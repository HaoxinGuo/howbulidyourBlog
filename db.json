{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/logo1.png","path":"medias/logo1.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/avatar1.jpg","path":"medias/avatars/avatar1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/babyq.png","path":"medias/avatars/babyq.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","path":"medias/avatars/cww97.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/fun4go.png","path":"medias/avatars/fun4go.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hael.jpg","path":"medias/avatars/hael.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","path":"medias/avatars/huaji.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","path":"medias/avatars/hzwer.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","path":"medias/avatars/ids2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","path":"medias/avatars/kewlgrl.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","path":"medias/avatars/ldy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","path":"medias/avatars/liyucheng.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/michael.jpg","path":"medias/avatars/michael.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mpy634.png","path":"medias/avatars/mpy634.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","path":"medias/avatars/qiqiang.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","path":"medias/avatars/taowei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","path":"medias/avatars/zhaokangzhe.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","path":"medias/avatars/antnlp.ico","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","path":"medias/avatars/duyupei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","path":"medias/avatars/gsy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","path":"medias/avatars/lijiaqian.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","path":"medias/avatars/liyangzone.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","path":"medias/avatars/mouse.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","path":"medias/avatars/qiandongwei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/spacesac.png","path":"medias/avatars/spacesac.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","path":"medias/avatars/sunchangzhi.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","path":"medias/avatars/xuzhongyou.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","path":"medias/avatars/zhangting.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","path":"medias/avatars/zzw.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/0xbird.png","path":"medias/avatars/0xbird.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","path":"medias/avatars/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","path":"medias/avatars/mizunashi.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qianqian.png","path":"medias/avatars/qianqian.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/nideyiyi.jpg","path":"medias/music/avatars/nideyiyi.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","path":"medias/music/avatars/yequ.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","path":"medias/music/avatars/yiluxiangbei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","path":"medias/music/avatars/tiantangdemogui.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","path":"medias/avatars/jitao.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","path":"medias/avatars/lyn-draw.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lzh.png","path":"medias/avatars/lzh.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","path":"medias/avatars/mashiro.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","path":"medias/avatars/milyyy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","path":"medias/avatars/zhangyi.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/27.jpg","path":"medias/featureimages/27.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","path":"medias/music/avatars/daoshu.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","path":"medias/avatars/jingjing.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/25.jpg","path":"medias/featureimages/25.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/26.jpg","path":"medias/featureimages/26.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/24.jpg","path":"medias/featureimages/24.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/nideyiyi.mp3","path":"medias/music/nideyiyi.mp3","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/guangnianzhiwai.mp3","path":"medias/music/guangnianzhiwai.mp3","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/yiluxiangbei.mp3","path":"medias/music/yiluxiangbei.mp3","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"d97f69ff63501de89cfd341c68e4d6ed5c8a5b3a","modified":1569677643097},{"_id":"source/CNAME","hash":"26ed9849d6c02c5892c04295277e15ebb5eb71ea","modified":1569745520056},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1569677643108},{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1569677643108},{"_id":"themes/matery/README.md","hash":"7ef16198a2c5ff580f006582286354caf160c7fe","modified":1569677643108},{"_id":"themes/matery/README_CN.md","hash":"a94324950e0299bcfcbc106cf2ca65c93e1fe843","modified":1569677643109},{"_id":"themes/matery/_config.yml","hash":"23b96d99b4f891ad8d2a01ca231682a142f2030f","modified":1569823825738},{"_id":"source/_posts/2019-AIPM.md","hash":"34121c0a2f7e22b8a50446589f48961b6c29e47d","modified":1569833854820},{"_id":"source/_posts/2019-BIM-Glodon.md","hash":"a8370a22023a2691e0124f752eadf8f2f18408fc","modified":1569833380825},{"_id":"source/_posts/2019-NASM.md","hash":"df258670268b7a890002f13a8a6643b0c6dd46fe","modified":1569812625133},{"_id":"source/_posts/2019-Opensees.md","hash":"d6fa7465acb6704533c340abdcb8f5e27578f8de","modified":1569836840210},{"_id":"source/_posts/2019-PM-APPSO.md","hash":"924e4c1b0c2ae05043475e6c2147cc4719d0775e","modified":1570090656121},{"_id":"source/_posts/2019-PM-AppSo-origin.md","hash":"a248e21f4db73f65e3207365d45cbc413b408647","modified":1570091107559},{"_id":"source/_posts/2019-PM-dedao.md","hash":"26e6a9ceae0eda4f2258579a6f054f127838a6f2","modified":1570085294541},{"_id":"source/_posts/2019-PM-demand-analysis.md","hash":"411b9b5d4489aaad8771427feee961d09905d8b5","modified":1570083865233},{"_id":"source/_posts/2019-PM-meiyou.md","hash":"2f7b3163818d17b0fc7a9384e0ab7e2f6489eaef","modified":1570085981129},{"_id":"source/_posts/2019-PM-music163.md","hash":"bcd694483e11c5cd98ab2916061821ac1eb3e01d","modified":1570083322116},{"_id":"source/_posts/2019-The-Elements-of-user-experience.md","hash":"eda3d5be0f99c32f7a3a705ed70cab02adf85c39","modified":1569834064348},{"_id":"source/_posts/2019-dot2pdf.md","hash":"7ee7697a822bab8201d9b229c50fb7f3b148ccae","modified":1569833009622},{"_id":"source/_posts/2019-first-post.md","hash":"f6aa8e2f8680436f29e3457196a2b7940ae6ab94","modified":1569741658829},{"_id":"source/_posts/2019-hooked.md","hash":"0ae6e1f105ffc5ba5813bff7072c5c72fb85fc76","modified":1569807586008},{"_id":"source/_posts/2019-how-to-build-your-Blog.md","hash":"61ca5e47808d0dd67ea180cf25bc460386f7f110","modified":1570119187122},{"_id":"source/_posts/2019-how-to-fix-connection-rest-by-port.md","hash":"ff9adeebcf607be35d894500d48dffc63b4238f5","modified":1570092875996},{"_id":"source/_posts/2019-inspired.md","hash":"99ae635c128aae17ee141debb146b39452459d21","modified":1569807519648},{"_id":"source/_posts/2019-interview-all.md","hash":"a89c866dbd54523d0d3de8b3a3b774e12335b722","modified":1570083888932},{"_id":"source/_posts/2019-maandword.md","hash":"8aa18cd67dd9a7d6d5575270b3049f9e6603cea6","modified":1569838080039},{"_id":"source/_posts/2019-matlab-to-deliver.md","hash":"606f3865669f2df7e46d339b5e45cc61b3790492","modified":1569807179081},{"_id":"source/_posts/2019-operation.md","hash":"621cca285d105f16fea2f9cbbe83fd3971973f7b","modified":1569833562140},{"_id":"source/_posts/2019-python.md","hash":"9ff274469f65e87e1b6db74fde59a2c3240aae1f","modified":1569754650391},{"_id":"source/_posts/2019-second-interview.md","hash":"12a54c9069731347a7cdb5e08c50e96d8f91587d","modified":1569753903669},{"_id":"source/_posts/2019-third-interview.md","hash":"ca5cf519c6742c885bc62b6559047a4b9a8f75eb","modified":1569753889101},{"_id":"source/about/index.md","hash":"7aab8c3f920f608643ff6aef4a4d6e6dc261b379","modified":1569823892407},{"_id":"source/_data/friends.json","hash":"eba3cadb9038901a0eb15f1358b3bcb9507b4afc","modified":1569842223467},{"_id":"source/_data/musics.json","hash":"0af6133d8778b114e52070b8eef63d3886cdd97a","modified":1569741009563},{"_id":"source/archives/index.md","hash":"a62b7d9b8a8bdf966ec5c823e71581d2b185156e","modified":1569677643104},{"_id":"source/categories/index.md","hash":"76889deb16e0d61d5c585f26a0e69f01de6cab74","modified":1569677643105},{"_id":"source/contact/index.md","hash":"fc7bc29e979ad0f183478c9afbee79558ec34378","modified":1569832558252},{"_id":"source/download/index.md","hash":"0a8cd9e387368c81eb47b9a5acd2ab21d3b75206","modified":1569834495327},{"_id":"source/tags/index.md","hash":"98697833897097a5c65521ea02baa1c6f85948d8","modified":1569677643107},{"_id":"source/friends/index.md","hash":"10c7e8c0aef7bb180a550717cc023556c7d365a6","modified":1569832622803},{"_id":"themes/matery/languages/default.yml","hash":"596b15f43b0961cbe338d3bba7873b890a43bb99","modified":1569822558273},{"_id":"themes/matery/languages/zh-CN.yml","hash":"3925d5cf0fef098c2cb1743db63707c3a7a0719d","modified":1569822577617},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1569677643111},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1569677643126},{"_id":"themes/matery/layout/archive.ejs","hash":"1b5023571894404d75caffa28128fc9c49f9095d","modified":1569677643126},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1569677643127},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1569677643127},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1569677643127},{"_id":"themes/matery/layout/download.ejs","hash":"fafe0b2c8771310af3f9fba04d20781c85c7ceeb","modified":1569822597474},{"_id":"themes/matery/layout/friends.ejs","hash":"b9b75ff45324da5b4ddbb6e16ea1ecd239dbc310","modified":1569677643128},{"_id":"themes/matery/layout/index.ejs","hash":"7fc5a6c4f0229c0be43b7d1315524c468346fbb8","modified":1569677643128},{"_id":"themes/matery/layout/layout.ejs","hash":"2ba4110dc596424b1220a259c8e594da774e7f59","modified":1569677643129},{"_id":"themes/matery/layout/post.ejs","hash":"9ecae79690293cacdccc172118f1fe481705b1f2","modified":1569677643129},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1569677643129},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1569677643129},{"_id":"source/_posts/2019-CProgramming.md","hash":"847f8d1a355378a94393c102a8f1f367da02f199","modified":1569842986030},{"_id":"source/_posts/2019-CProgramming/二维数组存储.jpg","hash":"3707ca5d921345d2506b97e16295b0b7d69ef27e","modified":1558152059959},{"_id":"source/_posts/2019-CProgramming/字符串存储.jpg","hash":"8bfefd779860b7859c3f6aed78b1f48833c1f607","modified":1558152059961},{"_id":"source/_posts/2019-CProgramming/宏定义和类型定义.png","hash":"9df1553c04f83712a21d83dda342e94394dcee0e","modified":1558152059962},{"_id":"source/_posts/2019-CProgramming/联合和结构的存储.jpg","hash":"2dd7d7bcf61842f874a4e7b0ab0dda401e944b88","modified":1558152059962},{"_id":"source/_posts/2019-NASM/BludgModel.jpg","hash":"1aebf639903e611b4fb8d802963cc36646d879b0","modified":1569818638224},{"_id":"source/_posts/2019-NASM/TrilinearModel.jpg","hash":"3254265a789074c7bdea5c1e0a473b291f7e0992","modified":1569818638232},{"_id":"source/_posts/2019-NASM/bilinear.jpg","hash":"3d83b3bdacec3d8652b180b1ba1edf7f06a2f3a5","modified":1569818638221},{"_id":"source/_posts/2019-NASM/linear.jpg","hash":"e4d78d747c1b1c499cc2c625ef5ef716cbfe6226","modified":1569818638228},{"_id":"source/_posts/2019-Opensees/114b5d55abb9b8a74bb18b1bcb0a2dca.png","hash":"365ba3ef8470b1861ad7df2e2c814ccd97bd9ec2","modified":1569835364489},{"_id":"source/_posts/2019-Opensees/3a471a82ccc457c44eba5125317e883a.png","hash":"f799fb9ab4080f49d23b393063914739aa8ef801","modified":1569835364535},{"_id":"source/_posts/2019-Opensees/3b1adcfc091178afbb2f106514eed312.png","hash":"08f2f3f0da87a2a58d047b44a0ab8ca888259ae9","modified":1569835364523},{"_id":"source/_posts/2019-PM-dedao/fenxi.png","hash":"90cb8122ac890a5e98dafb0825a3cb10fef20595","modified":1570084913360},{"_id":"source/_posts/2019-PM-demand-analysis/kaifanandu.png","hash":"75997701ddda7e0e72ce8a9ddf18af453359b6c4","modified":1570083601224},{"_id":"source/_posts/2019-PM-demand-analysis/sixiangxian.png","hash":"1cace425cf4c6fb4d1127c41ae5680e789e8241f","modified":1570083556616},{"_id":"source/_posts/2019-PM-demand-analysis/xuqiu.png","hash":"3d47e07058a5c982b0724bf7d6b6a6a819b90662","modified":1570083489441},{"_id":"source/_posts/2019-PM-meiyou/shiyongliucheng.png","hash":"0c739aca5a3eadd1653f6ed6a39023e7384550c9","modified":1570085578568},{"_id":"source/_posts/2019-PM-meiyou/shiyong.png","hash":"7dd48481d39b173ba316f2f1088441da630cd7a5","modified":1570085694367},{"_id":"source/_posts/2019-PM-meiyou/xingbie.png","hash":"edd85db5ce42459ad1440b4a5ff4abbdab776b98","modified":1570085426471},{"_id":"source/_posts/2019-PM-meiyou/xingbie3.jpg","hash":"ef53f2d5f8f6ba0f4a111d1e2e6c626c259b33c1","modified":1570085456933},{"_id":"source/_posts/2019-PM-meiyou/xingbie2.png","hash":"f11e992911397177cec128f26ad2e90c42adf8f8","modified":1570085439247},{"_id":"source/_posts/2019-The-Elements-of-user-experience/User.jpg","hash":"20fb17c901b9fd9dc7cb18d583a79817f8ba14df","modified":1559452227102},{"_id":"source/_posts/2019-how-to-build-your-Blog/RA.png","hash":"9f4a22cf90c33b2a94d713307043821873a7a461","modified":1570118068838},{"_id":"source/_posts/2019-how-to-build-your-Blog/NewSSH.png","hash":"ca2b9e4353df9402c2c64e5c14323f5872c9f119","modified":1570117943309},{"_id":"source/_posts/2019-how-to-build-your-Blog/chenggong.png","hash":"c0c9c7f0bdc4b1bb583b8bb2cbbcff1020506e04","modified":1570118236811},{"_id":"source/_posts/2019-how-to-build-your-Blog/chushihua.png","hash":"9bbd6afc41b50b6c2ddcb33aa8baf09eeb00d288","modified":1570113513916},{"_id":"source/_posts/2019-how-to-build-your-Blog/hexo.png","hash":"027956e60333dca487a6c079f2fbe12dfed5285e","modified":1570117595312},{"_id":"source/_posts/2019-how-to-build-your-Blog/npmshili.png","hash":"6145a6c77e7de0cd9df6f0d10551464b62839da7","modified":1570112957074},{"_id":"source/_posts/2019-how-to-build-your-Blog/xiazaishili.png","hash":"c087ca29cb340d6cb2153e21d93b5a31c1f8db4a","modified":1570112869950},{"_id":"source/_posts/2019-how-to-fix-connection-rest-by-port/shili.png","hash":"5bec631d54a9d1a6b03b0b72665dba32307ab64e","modified":1570096237149},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1569677643112},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"6bf708dbd705b486bc464e9be8e8834bbd692850","modified":1569677643112},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1569677643113},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1569677643112},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"35edf7ede07f4261d1d80b26daf2ca32736d7676","modified":1569831381795},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"a3a140e6aeeb6f289e4b821a577ef548267f3de1","modified":1569677643113},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1569677643114},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1569677643114},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"47fb9b0e25dff624f14430ad1c7e21ec23fee376","modified":1569746992124},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1569677643114},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1569677643115},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1569677643115},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1569677643116},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"e761f0104fbf431671bbe6bebc91ca82f737f4d2","modified":1569677643116},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"7ccf0586e537077863bd27d1fecc6b9d9dc87d40","modified":1569822671931},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1569677643117},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1569677643117},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1569677643118},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1569677643118},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1569677643118},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1569677643119},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1569677643119},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1569677643120},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1569677643120},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1569677643121},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"55272fab7a3303e94f1839ebd7ca6cf9965fb328","modified":1569677643121},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"c3039180ddb2eb17e724b8441e5f93e79859aef7","modified":1569677643121},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1569677643122},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1569677643122},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"2af85ddef6e61a44cbe10e8f6272a8324681ee3f","modified":1569677643122},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1569677643123},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1569677643123},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1569677643123},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1569677643124},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1569677643124},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1569677643125},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1569677643125},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1569677643125},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1569677643125},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1569677643126},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1569677643132},{"_id":"themes/matery/source/css/matery.css","hash":"b92bd5093424c4cc62f37175f1b0a54c4611a802","modified":1569677643132},{"_id":"themes/matery/source/favicon.png","hash":"412ae5f5b220e99b4ad10211a46b517cde8238c2","modified":1560772723039},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1569677643133},{"_id":"themes/matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1569677643133},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1569677643134},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1569677643134},{"_id":"themes/matery/source/medias/logo1.png","hash":"245bf683033c88588e6b0e74bde5398866731652","modified":1569677643275},{"_id":"source/_posts/2019-CProgramming/共享函数原型.png","hash":"839a2978c54fac6b15bfbd02761139c1ff691853","modified":1558152059960},{"_id":"source/_posts/2019-Opensees/3a04b2f3ba77e09e1d4a195a723210b2.png","hash":"8d37d4879e478c9e4fd1b2851e51e3fe6f8c5e37","modified":1569835364503},{"_id":"source/_posts/2019-Opensees/46afa9afcf5fa20bf42a6c9a6f73d79e.png","hash":"cc5e96539e9ee32347db699ae70b4f8018f2023b","modified":1569835364515},{"_id":"source/_posts/2019-Opensees/df03b2f5e7ca2bcccbbfaa784be671c3.png","hash":"8a19a93446bb75c94c392fda68ba59c3d616c9a2","modified":1569835364547},{"_id":"source/_posts/2019-PM-APPSO/yewu.png","hash":"35b845f8a8f37078a9bbe7f367b543aa62700696","modified":1570090455571},{"_id":"source/_posts/2019-PM-dedao/baokuan.jpg","hash":"e3877ddd0a032570c079bd735625de6bc7369d49","modified":1570084692370},{"_id":"source/_posts/2019-PM-dedao/kuangjia.png","hash":"e8571696b781de1b725c52a78c3810a20e2b2409","modified":1570084419872},{"_id":"source/_posts/2019-PM-dedao/shouru.png","hash":"daf96e0799c0fbc32c7d3f893dd154d2799d2dac","modified":1570084808675},{"_id":"source/_posts/2019-PM-dedao/yemian2.png","hash":"8292e3522d6624988538344c2eac0604501df6f5","modified":1570084538843},{"_id":"source/_posts/2019-PM-dedao/yemian4.png","hash":"81091629e597008e163f4d302d4123cc593582c9","modified":1570084579896},{"_id":"source/_posts/2019-PM-meiyou/gongnengjiegou.png","hash":"d905627814ddaf1f98f3b3ec5f9a1d7843ce25e8","modified":1570085657965},{"_id":"source/_posts/2019-PM-music163/wangyiyun.png","hash":"bf24e6f5a60a9888445a43f4cba0eae9e07b4c77","modified":1570083037420},{"_id":"source/_posts/2019-cPlusPlusproblemset/readme.jpg","hash":"ea10d58d231719c007459a057fbd461b42b4e53a","modified":1569828299886},{"_id":"source/_posts/2019-cPlusPlusproblemset.md","hash":"e19123fbf968b1f8eb664040b761064f291b37e3","modified":1569832672974},{"_id":"source/_posts/2019-how-to-build-your-Blog/SSH.png","hash":"15f68bcdc651a8008aab82f98fa84d0b52e93c9c","modified":1570117879814},{"_id":"source/_posts/2019-how-to-build-your-Blog/gitxiazai.png","hash":"6ad17d5a2f19fc94dbdd9232bd86917f65437c26","modified":1570113132417},{"_id":"source/_posts/2019-how-to-build-your-Blog/setting.png","hash":"437bc47a283e0d70eec288eae8372a081046ed7a","modified":1570117832993},{"_id":"source/_posts/2019-PM-dedao/jiazhi.jpg","hash":"664fbe515aa3213eae479dd211eb469347ddcca0","modified":1570084756679},{"_id":"source/_posts/2019-PM-dedao/yemian3.jpg","hash":"664fbe515aa3213eae479dd211eb469347ddcca0","modified":1570084551528},{"_id":"source/_posts/2019-how-to-build-your-Blog/newrepository.png","hash":"4b779e40ffe9adad0856e741e9083f652aa3d461","modified":1570113374837},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1569677643136},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1569677643135},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1569677643136},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1569677643137},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1569677643150},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1569677643155},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1569677643158},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1569677643158},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1569677643157},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1569677643163},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1569677643166},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1569677643166},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"5b76fa72a85cfb27d54b00128393ece773d65386","modified":1569677643166},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"e9c74f2dd3953d4d8dec44e9977574d00702e84d","modified":1569677643167},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1569677643167},{"_id":"themes/matery/source/libs/others/text.js","hash":"fdf18f65977e4bc358dfb5fb0b7c98492ae72efd","modified":1569677643167},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1569677643168},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1569677643171},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1569677643172},{"_id":"themes/matery/source/medias/avatars/avatar1.jpg","hash":"6850c3643f81caf79c8be7c454a501f0d3962e14","modified":1569677643176},{"_id":"themes/matery/source/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1569677643176},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1569677643176},{"_id":"themes/matery/source/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1569677643178},{"_id":"themes/matery/source/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1569677643179},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1569677643179},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1569677643180},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1569677643180},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1569677643183},{"_id":"themes/matery/source/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1569677643183},{"_id":"themes/matery/source/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1569677643185},{"_id":"themes/matery/source/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1569677643189},{"_id":"themes/matery/source/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1569677643191},{"_id":"themes/matery/source/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1569677643194},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1569677643195},{"_id":"themes/matery/source/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1569677643198},{"_id":"themes/matery/source/medias/logo.png","hash":"0ea58581750b44ffdbe7482a2efb3d9b44bbf6c2","modified":1568988139745},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"278a93d64ca4037ddf7adddd3a6942e0ce5b6759","modified":1569741417501},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"72e14682d19080bcbe86e16da60ec43db8fc7177","modified":1569741434660},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1569677643158},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1569677643159},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"f1558f12d96a352e490166d543a8e821dd3bb2bc","modified":1569677643172},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1569677643175},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1569677643177},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1569677643179},{"_id":"themes/matery/source/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1569677643184},{"_id":"themes/matery/source/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1569677643185},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1569677643191},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1569677643192},{"_id":"themes/matery/source/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1569677643194},{"_id":"themes/matery/source/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1569677643195},{"_id":"themes/matery/source/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1569677643196},{"_id":"themes/matery/source/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1569677643197},{"_id":"themes/matery/source/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1569677643199},{"_id":"source/_posts/2019-PM-APPSO/yewu2.jpg","hash":"1f2bee9175ce52efb9923fe94ec946bde80bbad7","modified":1570090472209},{"_id":"source/_posts/2019-PM-dedao/yemian1.png","hash":"7407f7e9b1c0ef35db0ebef6628e19a615fca4a6","modified":1570084477846},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1569677643137},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1569677643138},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1569677643149},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1569677643160},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1569677643160},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1569677643161},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1569677643161},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1569677643161},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1569677643162},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1569677643162},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1569677643162},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1569677643162},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1569677643164},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1569677643168},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1569677643169},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1569677643169},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1569677643170},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1569677643170},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1569677643171},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1569677643170},{"_id":"themes/matery/source/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1569677643175},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","hash":"412ae5f5b220e99b4ad10211a46b517cde8238c2","modified":1560772723039},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1569677643191},{"_id":"themes/matery/source/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1569677643193},{"_id":"themes/matery/source/medias/music/avatars/nideyiyi.jpg","hash":"8f145cc03666f33be703d7ba2efcdf55650a90dd","modified":1569740603743},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1569677643277},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1569677643278},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1569677643277},{"_id":"source/_posts/2019-PM-dedao/yemian5.png","hash":"245995d4a33a58222cbe0508e00c9bc2d93cf9ed","modified":1570084617854},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1569677643147},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1569677643148},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1569677643150},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"f63c7c489524ccb5d95e74fcd6618116c58fb305","modified":1569677643156},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1569677643163},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1569677643173},{"_id":"themes/matery/source/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1569677643183},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1569677643186},{"_id":"themes/matery/source/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1569677643187},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1569677643188},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1569677643190},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"4ca3850de064acc71055b1a14ad58bd7460f1074","modified":1569842475830},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"981df44315015ab76bf7760b3014a28cd1a17e63","modified":1569817208770},{"_id":"source/_posts/2019-PM-dedao/tuijian.png","hash":"1ec06f7a7114d681debb1e3154c175874428e272","modified":1570084869431},{"_id":"source/_posts/2019-PM-demand-analysis/siweidaotu.png","hash":"e887b762871a2cf73263898fb67662761d05123f","modified":1570083474455},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1569677643147},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1569677643165},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1569677643142},{"_id":"themes/matery/source/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1569677643198},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"90305d703c84d1f6f42bd26c8d99255079defa69","modified":1569751877511},{"_id":"themes/matery/source/medias/featureimages/27.jpg","hash":"704831ae9e8c59ffca7debcf5f9f08bc721e21fc","modified":1569817435889},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"64234598d86a55e33a0c354a9b61b8b956d25f1f","modified":1569751838873},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"b2c5748f39036b566e3dfe0aa78dff903aff36cd","modified":1569752000141},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1569677643140},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"764fd3b289fedea48c0a1f91723072548dfe299f","modified":1569752057374},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"16070b2847a9605d7ae5d77766cb0d1c777873f6","modified":1569817105641},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1569677643277},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1569677643182},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"b5ed9ed938259f39e2de4b16a9602089ac62fbf2","modified":1569752014186},{"_id":"source/_posts/2019-PM-AppSo-origin/yewu2.jpg","hash":"eff4637a662451b7a6454ffe8e9eb3c8b6558e16","modified":1570090774310},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"c2980f75f2c047d0957e3c8227b3f8d84e67f752","modified":1569677643206},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"66715c1dd857e6ceb4b99a3dc792c62d429e2d84","modified":1569752095132},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"7b1496b1cc2866d2eb6974e7cf4613d3c45864cb","modified":1569817086170},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"7836ff5bb53a2bcbf6b5932a4250bd2548413fc4","modified":1569751976329},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"1a3b2f42ed0c0da32abf740aa582918ac4c43f9c","modified":1569751942885},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"dc63b451549508268b49f4031a7262edfe4a4532","modified":1569752078367},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"3c9abfbe8cc2b082aa064bac3d2516db58cca639","modified":1569751907143},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"254489d7f99cafabf7cdff550098f6fd0a445c40","modified":1569817156279},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"b545453a93db71b65f5df87c96c38314cc43b36f","modified":1569751923582},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"7e30c4e30d383864c7501a6382a3b50bdd34d60e","modified":1569752037859},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1569677643145},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"14c66463fa5535ba607980951b69276c010126c3","modified":1569816951729},{"_id":"themes/matery/source/medias/featureimages/25.jpg","hash":"433bb293c83b6cbcaea3bbf5375c66dba3beb5ca","modified":1569817253026},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"769c0df9d615f6a79a99833819a3dec682dd5e0a","modified":1569817130996},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"e07786efa56e0da21efa95a6d763b8cfe1b6d4b0","modified":1569817179939},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"a2b2aa37c4bb1a921afe0803069a9aaf24311e8b","modified":1569817194648},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"7199ce0f67ca6177c1fcc429ef58629fde07667c","modified":1569817017286},{"_id":"source/_posts/2019-PM-AppSo-origin/yewu1.jpg","hash":"ee7dc9574e273bd3de3dede394edd544726c62c6","modified":1570090761478},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1569677643155},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"c299c416bb36e5b9e932499981564b1736dd76c3","modified":1569751890754},{"_id":"themes/matery/source/medias/featureimages/26.jpg","hash":"0368bb94e556c5e8c7f816ac1336dd1f35bb4693","modified":1569817387123},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"04e4902eb0e21f07979ca64b98247d520244f766","modified":1569817060023},{"_id":"themes/matery/source/medias/featureimages/24.jpg","hash":"ac87c1048a35683299da3019beac12a2c48c758b","modified":1569817238489},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"ca3e3d8e30fcec76e128f3afb8c494c59e51d23d","modified":1569750681840},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"431841084af68db40ac7dc727ee7a99acaabc641","modified":1569817001565},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"2812799b7e00bff4f265b8db3ab4e31604630faf","modified":1569750590875},{"_id":"themes/matery/source/medias/music/nideyiyi.mp3","hash":"7fabade8177cd4346b3136556783afdf5ff51372","modified":1569740567105},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"183c377d442c1d4bf506c8b52fd71918979dcaaf","modified":1569750415809},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"77ff367e639adfa56b2e7e85d0fc16201f6b5c13","modified":1569750498217},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"bcb850685e52d46bd68a309245493897ebfcf93e","modified":1569750543947},{"_id":"themes/matery/source/medias/music/guangnianzhiwai.mp3","hash":"59b826f58833b4e727363ed864a2bc2c2252491c","modified":1569740831049},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"a33699f102a09ac65e9ecd71727354c6cbb26108","modified":1569750611001},{"_id":"themes/matery/source/medias/music/yiluxiangbei.mp3","hash":"e0fea7418b4947779f0af05b2b2b703bdf7e6aec","modified":1569740787047},{"_id":"public/baidu_urls.txt","hash":"c1582e05cb86c0364b72c492945321c41a5d8dec","modified":1570119264664},{"_id":"public/search.xml","hash":"71ebc75b67677abdf4c89c7c3bf338d9d914279b","modified":1570119264665},{"_id":"public/baidusitemap.xml","hash":"b05f41fd6ccfe02347dc781d075b4b3c8a7e84ab","modified":1570119265463},{"_id":"public/atom.xml","hash":"04d99f694bae01cb691cd590ae37e63e6773a7e3","modified":1570119265556},{"_id":"public/sitemap.xml","hash":"0363c1908b92a813ced0d51ef2b05871bb64bb83","modified":1570119265557},{"_id":"public/404.html","hash":"75526ecc6d2aabd99532495718dea49d9b512da2","modified":1570119265688},{"_id":"public/about/index.html","hash":"4486d09b074431af84c9b7c54d5bf0f835b71332","modified":1570119265689},{"_id":"public/archives/index.html","hash":"20524c65337ec74afd417654a544023fe267e5aa","modified":1570119266183},{"_id":"public/categories/index.html","hash":"8ed3afdb367949eac91c15f512c4b559e3cb3f1f","modified":1570119266209},{"_id":"public/contact/index.html","hash":"0b513f8e24c27eacd35195262447f6f0053104ac","modified":1570119266209},{"_id":"public/tags/index.html","hash":"3db32ae2f5cfeb7fcf34a5bbc9609a688193d73b","modified":1570119266210},{"_id":"public/friends/index.html","hash":"7c74eceef5e766e1f790b187f9e18251902cce2c","modified":1570119266213},{"_id":"public/download/index.html","hash":"5c32b2a93c45f853d23bb3fcff850c752453a39a","modified":1570119266213},{"_id":"public/2019/10/03/2019-how-to-fix-connection-rest-by-port/index.html","hash":"e475321a6f15cd75633b0480473a851234e564d0","modified":1570119266213},{"_id":"public/2019/10/03/2019-pm-appso-origin/index.html","hash":"c9bf592edb032776565b65fc19f0f238d1cef395","modified":1570119266213},{"_id":"public/2019/10/03/2019-pm-appso/index.html","hash":"447593ce83815d4d503b0ac5f1c94053ec530b72","modified":1570119266213},{"_id":"public/2019/10/03/2019-pm-meiyou/index.html","hash":"56c5e9d1c9e709a8399eb33ceec69fedc75b61fe","modified":1570119266213},{"_id":"public/2019/10/03/2019-pm-demand-analysis/index.html","hash":"ea906fd4ef67c3b28519f9230e99fc93e2ee5b42","modified":1570119266213},{"_id":"public/2019/10/03/2019-pm-music163/index.html","hash":"da3aab30181de1b726f14513e33b2b8bfeda91bc","modified":1570119266213},{"_id":"public/2019/09/30/2019-cprogramming/index.html","hash":"226a3f03b16db43e978c4247f668248657481d35","modified":1570119266213},{"_id":"public/2019/09/30/2019-maandword/index.html","hash":"eba9fdb81376b70795c093df2dc4a654b799809f","modified":1570119266214},{"_id":"public/2019/09/30/2019-opensees/index.html","hash":"095f4d51f41d90daf612e7048ac21e124232e52f","modified":1570119266214},{"_id":"public/2019/09/30/2019-aipm/index.html","hash":"e2213d22eedb24ae51732a464935ad9a1b0b1e81","modified":1570119266214},{"_id":"public/2019/10/03/2019-pm-dedao/index.html","hash":"cb76466cdcc903bd893b54aab0bffaff4840f734","modified":1570119266214},{"_id":"public/2019/09/30/2019-the-elements-of-user-experience/index.html","hash":"7681a04a9ac1de23700c6d39720661e43f81a9f4","modified":1570119266214},{"_id":"public/2019/09/30/2019-operation/index.html","hash":"34b44865acab5cce28f2adf129b51bdd51d566ed","modified":1570119266214},{"_id":"public/2019/09/30/2019-dot2pdf/index.html","hash":"e6393f16acffff5cbd0a7bf2fee6c9e6cec7d566","modified":1570119266214},{"_id":"public/2019/09/30/2019-cplusplusproblemset/index.html","hash":"32fdaa1f26c4ea95b22d2c25d31a4c250d97dfa7","modified":1570119266214},{"_id":"public/2019/09/30/2019-inspired/index.html","hash":"1030c6ab7c04cd8a1d06fd3dbcd08f8a891dca19","modified":1570119266214},{"_id":"public/2019/09/30/2019-hooked/index.html","hash":"9047db9ffcf23df5d96773926a044c89a347d602","modified":1570119266214},{"_id":"public/2019/09/30/2019-matlab-to-deliver/index.html","hash":"c263cc6e05d8f24775050e296c62235144ba503c","modified":1570119266214},{"_id":"public/2019/09/30/2019-nasm/index.html","hash":"25419ec8ef53589c744738bab744ebeb0cd0ce46","modified":1570119266214},{"_id":"public/2019/09/29/2019-interview-all/index.html","hash":"0e6371615addc4e1744dbc97e53591a4cb441618","modified":1570119266214},{"_id":"public/2019/09/29/2019-python/index.html","hash":"183e24573ef42ae26be05b49fbbf619e97a151dd","modified":1570119266214},{"_id":"public/2019/09/29/2019-third-interview/index.html","hash":"949263657d079d8097512833b67aa136ff4a7098","modified":1570119266214},{"_id":"public/2019/09/29/2019-second-interview/index.html","hash":"693faa28b5c6086bebe0152adb9e0cfa834d3a4f","modified":1570119266215},{"_id":"public/2019/09/29/2019-first-post/index.html","hash":"b339df928b215af732b0aafd4638de1ddf03848d","modified":1570119266215},{"_id":"public/2019/08/30/2019-bim-glodon/index.html","hash":"23289a0434ae368aff35330f51825751726dd85f","modified":1570119266215},{"_id":"public/categories/读书笔记/index.html","hash":"203a4aff42784cc3e4a79cea76959d51b0afb7e5","modified":1570119266215},{"_id":"public/categories/行业了解/index.html","hash":"563b99c0299521e201cfc77500fec8dce96639c6","modified":1570119266215},{"_id":"public/categories/PM/index.html","hash":"bb8f14a93e26ecfd72da2ba1b2989c100ceffbd3","modified":1570119266215},{"_id":"public/categories/软件/index.html","hash":"dcd1a9c1039fa4a38851a37c03e1c4e4ebbf4537","modified":1570119266215},{"_id":"public/categories/Linux/index.html","hash":"66b2176f6a0331a2d412f761a015a0badcc1e688","modified":1570119266215},{"_id":"public/categories/Matlab/index.html","hash":"4bdcc7eaa3285c6dfe922d0ba650443216309e66","modified":1570119266215},{"_id":"public/categories/面试/index.html","hash":"c3ccb4a708efd141f141222ea2070e84335677a8","modified":1570119266215},{"_id":"public/categories/python/index.html","hash":"cb2e080eb4b0aff7eb7b5e3ebc206a22991b7afc","modified":1570119266215},{"_id":"public/categories/C语言/index.html","hash":"81d059e6b00831cc2ba6fadd6d8a1291e5b54374","modified":1570119266215},{"_id":"public/categories/C/index.html","hash":"e638b3e5e04020da44237a2e994238060967db86","modified":1570119266215},{"_id":"public/archives/page/2/index.html","hash":"6184969108303b1fad621a1c48c96ef86066c843","modified":1570119266215},{"_id":"public/archives/page/3/index.html","hash":"e4843a15429a2a230de919e4838c8f60a61492d8","modified":1570119266215},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/index.html","hash":"f4c6dbd992a1332c5ad5b820c9169a6d5cbdd172","modified":1570119266239},{"_id":"public/archives/2019/index.html","hash":"2bd7a6853ac70527a4a403f13761675144db5ed5","modified":1570119266239},{"_id":"public/archives/2019/page/2/index.html","hash":"88911ec8dc997e4a1e0f015b71886f8bac11aedb","modified":1570119266240},{"_id":"public/archives/2019/page/3/index.html","hash":"02f97d507e008695686aac0464ce477126c30871","modified":1570119266240},{"_id":"public/archives/2019/09/index.html","hash":"48b0317bd58affa6b2d67ad52ef330c261d9e1de","modified":1570119266240},{"_id":"public/archives/2019/08/index.html","hash":"31db0f9a7c35f849b10ec5b490e18f23c0b44236","modified":1570119266240},{"_id":"public/archives/2019/10/index.html","hash":"d4d22f992ace9ef88e4946a6853e239ad5fb59fa","modified":1570119266240},{"_id":"public/archives/2019/09/page/2/index.html","hash":"15f03edc0ed33f3361bb5f07c2a614e7438291e1","modified":1570119266240},{"_id":"public/index.html","hash":"cbe054637ddedf9bff61b7a81410622d2a8c63aa","modified":1570119266240},{"_id":"public/page/2/index.html","hash":"0a8764a293f916e20acdce667bef4e61bac0a603","modified":1570119266241},{"_id":"public/page/3/index.html","hash":"343e2f6c1c3a1478a11cb5fc93cf857c901afd7c","modified":1570119266241},{"_id":"public/page/4/index.html","hash":"b739f09fff680a374252488e3d10753af502366e","modified":1570119266241},{"_id":"public/page/5/index.html","hash":"b50258c4557534177dd9a0bd17522d634263e350","modified":1570119266241},{"_id":"public/tags/PM-读书笔记/index.html","hash":"b9b6fad598a453ddfd63be7fc1ad3be629f7dfb0","modified":1570119266241},{"_id":"public/tags/Glodon-BIM/index.html","hash":"590e18a2831a87079616fb5dff93fcc5f140bfdc","modified":1570119266241},{"_id":"public/tags/PM/index.html","hash":"7462b0c7608dbf98e9c3bcb3f95742f3df9d484f","modified":1570119266241},{"_id":"public/tags/软件-Matlab/index.html","hash":"132fec8ba4d91f2924fcec289e17b746efc93d03","modified":1570119266241},{"_id":"public/tags/读书笔记-Opensees/index.html","hash":"a6d93dab770c243eb3e93d0b7f355593b10ed887","modified":1570119266241},{"_id":"public/tags/读书笔记-PM/index.html","hash":"7f0c217f971adfca6df61aded36b5476efc251d8","modified":1570119266241},{"_id":"public/tags/读书笔记/index.html","hash":"56c0b138ea44f7b97f6625874affbf6dd0b4aff9","modified":1570119266241},{"_id":"public/tags/Linux-批处理/index.html","hash":"54c2b983e8190da4da8eb393ee8c5957b8979002","modified":1570119266241},{"_id":"public/tags/软件-技巧-Markdown-Word/index.html","hash":"c27532230688ceda02611c06d3654743c5158361","modified":1570119266241},{"_id":"public/tags/自动检测图像-Matlab/index.html","hash":"e36f4816f23173ce191764c910e5212b0c96cc23","modified":1570119266241},{"_id":"public/tags/面试-PM/index.html","hash":"bfd827e731fa5b7cfbeb42ba9808177a2e1afc72","modified":1570119266242},{"_id":"public/tags/读书笔记-运营/index.html","hash":"9b98a7c2332fd2131d4b47ee042efbe95f84fc59","modified":1570119266242},{"_id":"public/tags/python/index.html","hash":"878516a35078090af0c3e38099e45a86bc0a4843","modified":1570119266242},{"_id":"public/tags/面试/index.html","hash":"d492b629f3e40b4b528bb1a89029ec47e1e0cd4b","modified":1570119266242},{"_id":"public/tags/C语言/index.html","hash":"1f026dc632f0a225f3a4e5b163e39eed233c2b10","modified":1570119266242},{"_id":"public/tags/C-读书笔记/index.html","hash":"1e80b34922a725d3a8eef0a0490c76167916ea04","modified":1570119266242},{"_id":"public/CNAME","hash":"26ed9849d6c02c5892c04295277e15ebb5eb71ea","modified":1570119266257},{"_id":"public/medias/logo1.png","hash":"245bf683033c88588e6b0e74bde5398866731652","modified":1570119266258},{"_id":"public/medias/avatars/avatar1.jpg","hash":"6850c3643f81caf79c8be7c454a501f0d3962e14","modified":1570119266258},{"_id":"public/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1570119266258},{"_id":"public/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1570119266258},{"_id":"public/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1570119266258},{"_id":"public/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1570119266258},{"_id":"public/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1570119266258},{"_id":"public/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1570119266258},{"_id":"public/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1570119266258},{"_id":"public/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1570119266258},{"_id":"public/medias/avatars/ldy.jpg","hash":"906ef214d1f2fe52a663738340ad5623f826bd82","modified":1570119266258},{"_id":"public/medias/avatars/liyucheng.jpg","hash":"12055a27fa667c87d2319475968056e1a8ad0f08","modified":1570119266258},{"_id":"public/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1570119266258},{"_id":"public/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1570119266258},{"_id":"public/medias/avatars/qiqiang.jpg","hash":"081459866f922d9558a88cd4d7155d91fa730322","modified":1570119266258},{"_id":"public/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1570119266258},{"_id":"public/medias/avatars/zhaokangzhe.jpg","hash":"c8242bd13f08a9ddb97e26f216bc729b12ed9058","modified":1570119266259},{"_id":"public/medias/reward/alipay.jpg","hash":"278a93d64ca4037ddf7adddd3a6942e0ce5b6759","modified":1570119266259},{"_id":"public/medias/reward/wechat.png","hash":"72e14682d19080bcbe86e16da60ec43db8fc7177","modified":1570119266259},{"_id":"public/medias/avatars/lijiaqian.png","hash":"9d96b3838acfae9a23b6e290fcfafceff0419c63","modified":1570119266259},{"_id":"public/medias/avatars/liyangzone.jpg","hash":"febab557e4c0d859ab4cc14b57d8106f5e3fccfb","modified":1570119266259},{"_id":"public/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1570119266262},{"_id":"public/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1570119266262},{"_id":"public/medias/avatars/sunchangzhi.jpg","hash":"bbe2a15fd474ab62dbd14fea72deb1113a4fb005","modified":1570119266262},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1570119266262},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1570119266262},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1570119266262},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1570119266262},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1570119266262},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1570119266262},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1570119266263},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1570119266263},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1570119266263},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1570119266263},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1570119266263},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1570119266263},{"_id":"public/medias/music/avatars/nideyiyi.jpg","hash":"8f145cc03666f33be703d7ba2efcdf55650a90dd","modified":1570119266263},{"_id":"public/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1570119266263},{"_id":"public/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1570119266263},{"_id":"public/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1570119266263},{"_id":"public/2019/09/30/2019-the-elements-of-user-experience/User.jpg","hash":"20fb17c901b9fd9dc7cb18d583a79817f8ba14df","modified":1570119266263},{"_id":"public/2019/10/03/2019-how-to-fix-connection-rest-by-port/shili.png","hash":"5bec631d54a9d1a6b03b0b72665dba32307ab64e","modified":1570119266263},{"_id":"public/2019/09/30/2019-nasm/BludgModel.jpg","hash":"1aebf639903e611b4fb8d802963cc36646d879b0","modified":1570119266263},{"_id":"public/2019/09/30/2019-nasm/TrilinearModel.jpg","hash":"3254265a789074c7bdea5c1e0a473b291f7e0992","modified":1570119266263},{"_id":"public/2019/09/30/2019-nasm/bilinear.jpg","hash":"3d83b3bdacec3d8652b180b1ba1edf7f06a2f3a5","modified":1570119266263},{"_id":"public/2019/09/30/2019-nasm/linear.jpg","hash":"e4d78d747c1b1c499cc2c625ef5ef716cbfe6226","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-demand-analysis/kaifanandu.png","hash":"75997701ddda7e0e72ce8a9ddf18af453359b6c4","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-demand-analysis/sixiangxian.png","hash":"1cace425cf4c6fb4d1127c41ae5680e789e8241f","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-demand-analysis/xuqiu.png","hash":"3d47e07058a5c982b0724bf7d6b6a6a819b90662","modified":1570119266264},{"_id":"public/2019/09/30/2019-opensees/114b5d55abb9b8a74bb18b1bcb0a2dca.png","hash":"365ba3ef8470b1861ad7df2e2c814ccd97bd9ec2","modified":1570119266264},{"_id":"public/2019/09/30/2019-opensees/3a471a82ccc457c44eba5125317e883a.png","hash":"f799fb9ab4080f49d23b393063914739aa8ef801","modified":1570119266264},{"_id":"public/2019/09/30/2019-opensees/3b1adcfc091178afbb2f106514eed312.png","hash":"08f2f3f0da87a2a58d047b44a0ab8ca888259ae9","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-meiyou/shiyong.png","hash":"7dd48481d39b173ba316f2f1088441da630cd7a5","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-meiyou/shiyongliucheng.png","hash":"0c739aca5a3eadd1653f6ed6a39023e7384550c9","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-meiyou/xingbie.png","hash":"edd85db5ce42459ad1440b4a5ff4abbdab776b98","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-meiyou/xingbie3.jpg","hash":"ef53f2d5f8f6ba0f4a111d1e2e6c626c259b33c1","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-meiyou/xingbie2.png","hash":"f11e992911397177cec128f26ad2e90c42adf8f8","modified":1570119266264},{"_id":"public/2019/10/03/2019-pm-dedao/fenxi.png","hash":"90cb8122ac890a5e98dafb0825a3cb10fef20595","modified":1570119266264},{"_id":"public/2019/09/30/2019-cprogramming/二维数组存储.jpg","hash":"3707ca5d921345d2506b97e16295b0b7d69ef27e","modified":1570119266264},{"_id":"public/2019/09/30/2019-cprogramming/字符串存储.jpg","hash":"8bfefd779860b7859c3f6aed78b1f48833c1f607","modified":1570119266264},{"_id":"public/2019/09/30/2019-cprogramming/宏定义和类型定义.png","hash":"9df1553c04f83712a21d83dda342e94394dcee0e","modified":1570119266265},{"_id":"public/2019/09/30/2019-cprogramming/联合和结构的存储.jpg","hash":"2dd7d7bcf61842f874a4e7b0ab0dda401e944b88","modified":1570119266265},{"_id":"public/css/prism-line-numbers.css","hash":"e0db113a99e4a09d2161a539b1652d96e4a22fac","modified":1570119266265},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1570119266265},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/NewSSH.png","hash":"ca2b9e4353df9402c2c64e5c14323f5872c9f119","modified":1570119266265},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/RA.png","hash":"9f4a22cf90c33b2a94d713307043821873a7a461","modified":1570119266265},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/chenggong.png","hash":"c0c9c7f0bdc4b1bb583b8bb2cbbcff1020506e04","modified":1570119266265},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/chushihua.png","hash":"9bbd6afc41b50b6c2ddcb33aa8baf09eeb00d288","modified":1570119266265},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/hexo.png","hash":"027956e60333dca487a6c079f2fbe12dfed5285e","modified":1570119266265},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/npmshili.png","hash":"6145a6c77e7de0cd9df6f0d10551464b62839da7","modified":1570119266265},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/xiazaishili.png","hash":"c087ca29cb340d6cb2153e21d93b5a31c1f8db4a","modified":1570119266265},{"_id":"public/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1570119266279},{"_id":"public/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1570119266281},{"_id":"public/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1570119266284},{"_id":"public/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1570119266284},{"_id":"public/medias/avatars/xuzhongyou.jpg","hash":"1db4dfaf23cf250f222a398326562d4170d3aaa1","modified":1570119266284},{"_id":"public/medias/avatars/zhangting.jpg","hash":"10ee25ae3531f046a8bd3696c1cc8a16f0f25e1b","modified":1570119266285},{"_id":"public/medias/avatars/zzw.jpg","hash":"5d385b5732644b07b937a4919abc83cb95e14513","modified":1570119266285},{"_id":"public/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1570119266285},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1570119266285},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1570119266285},{"_id":"public/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1570119266285},{"_id":"public/2019/10/03/2019-pm-music163/wangyiyun.png","hash":"bf24e6f5a60a9888445a43f4cba0eae9e07b4c77","modified":1570119266285},{"_id":"public/2019/10/03/2019-pm-appso/yewu.png","hash":"35b845f8a8f37078a9bbe7f367b543aa62700696","modified":1570119266285},{"_id":"public/2019/09/30/2019-opensees/3a04b2f3ba77e09e1d4a195a723210b2.png","hash":"8d37d4879e478c9e4fd1b2851e51e3fe6f8c5e37","modified":1570119266285},{"_id":"public/2019/09/30/2019-opensees/46afa9afcf5fa20bf42a6c9a6f73d79e.png","hash":"cc5e96539e9ee32347db699ae70b4f8018f2023b","modified":1570119266285},{"_id":"public/2019/09/30/2019-opensees/df03b2f5e7ca2bcccbbfaa784be671c3.png","hash":"8a19a93446bb75c94c392fda68ba59c3d616c9a2","modified":1570119266286},{"_id":"public/2019/10/03/2019-pm-meiyou/gongnengjiegou.png","hash":"d905627814ddaf1f98f3b3ec5f9a1d7843ce25e8","modified":1570119266286},{"_id":"public/2019/10/03/2019-pm-dedao/baokuan.jpg","hash":"e3877ddd0a032570c079bd735625de6bc7369d49","modified":1570119266286},{"_id":"public/2019/10/03/2019-pm-dedao/kuangjia.png","hash":"e8571696b781de1b725c52a78c3810a20e2b2409","modified":1570119266286},{"_id":"public/2019/10/03/2019-pm-dedao/shouru.png","hash":"daf96e0799c0fbc32c7d3f893dd154d2799d2dac","modified":1570119266286},{"_id":"public/2019/10/03/2019-pm-dedao/yemian2.png","hash":"8292e3522d6624988538344c2eac0604501df6f5","modified":1570119266286},{"_id":"public/2019/10/03/2019-pm-dedao/yemian4.png","hash":"81091629e597008e163f4d302d4123cc593582c9","modified":1570119266286},{"_id":"public/2019/09/30/2019-cprogramming/共享函数原型.png","hash":"839a2978c54fac6b15bfbd02761139c1ff691853","modified":1570119266286},{"_id":"public/2019/09/30/2019-cplusplusproblemset/readme.jpg","hash":"ea10d58d231719c007459a057fbd461b42b4e53a","modified":1570119266286},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/SSH.png","hash":"15f68bcdc651a8008aab82f98fa84d0b52e93c9c","modified":1570119266286},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/gitxiazai.png","hash":"6ad17d5a2f19fc94dbdd9232bd86917f65437c26","modified":1570119266286},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/setting.png","hash":"437bc47a283e0d70eec288eae8372a081046ed7a","modified":1570119266287},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1570119266306},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1570119266306},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1570119266309},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1570119266309},{"_id":"public/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1570119266309},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1570119266309},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1570119266309},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1570119266309},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1570119266309},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1570119266309},{"_id":"public/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1570119266309},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1570119266309},{"_id":"public/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1570119266309},{"_id":"public/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1570119266309},{"_id":"public/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1570119266309},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1570119266309},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1570119266310},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1570119266310},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1570119266310},{"_id":"public/css/matery.css","hash":"7a418c539884ff6432de099c85517a8b9f770d65","modified":1570119266310},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1570119266310},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1570119266310},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1570119266310},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1570119266310},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1570119266310},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1570119266310},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1570119266310},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1570119266310},{"_id":"public/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1570119266310},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1570119266310},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1570119266310},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1570119266310},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1570119266310},{"_id":"public/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1570119266310},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1570119266310},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1570119266310},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1570119266311},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"28bdb33c9eb609c2f30d431df1a4cf8ca70bf841","modified":1570119266311},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1570119266311},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1570119266311},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1570119266311},{"_id":"public/medias/avatars/avatar.jpg","hash":"412ae5f5b220e99b4ad10211a46b517cde8238c2","modified":1570119266311},{"_id":"public/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1570119266311},{"_id":"public/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1570119266311},{"_id":"public/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1570119266311},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1570119266311},{"_id":"public/medias/avatars/myzhihu.png","hash":"4ca3850de064acc71055b1a14ad58bd7460f1074","modified":1570119266311},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1570119266311},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1570119266311},{"_id":"public/2019/10/03/2019-pm-dedao/jiazhi.jpg","hash":"664fbe515aa3213eae479dd211eb469347ddcca0","modified":1570119266311},{"_id":"public/2019/10/03/2019-pm-dedao/yemian3.jpg","hash":"664fbe515aa3213eae479dd211eb469347ddcca0","modified":1570119266312},{"_id":"public/2019/10/04/2019-how-to-build-your-blog/newrepository.png","hash":"4b779e40ffe9adad0856e741e9083f652aa3d461","modified":1570119266312},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1570119266319},{"_id":"public/favicon.png","hash":"412ae5f5b220e99b4ad10211a46b517cde8238c2","modified":1570119266319},{"_id":"public/medias/logo.png","hash":"0ea58581750b44ffdbe7482a2efb3d9b44bbf6c2","modified":1570119266320},{"_id":"public/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1570119266320},{"_id":"public/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1570119266320},{"_id":"public/medias/avatars/zhangyi.jpg","hash":"c9130036aac9a7ac8d62e33550a9d64896cdc364","modified":1570119266320},{"_id":"public/2019/10/03/2019-pm-appso/yewu2.jpg","hash":"1f2bee9175ce52efb9923fe94ec946bde80bbad7","modified":1570119266320},{"_id":"public/2019/10/03/2019-pm-dedao/yemian1.png","hash":"7407f7e9b1c0ef35db0ebef6628e19a615fca4a6","modified":1570119266320},{"_id":"public/medias/avatars/jitao.jpg","hash":"5934b9baccebccbc2be2ead5d84ad32dd41f9559","modified":1570119266328},{"_id":"public/2019/10/03/2019-pm-demand-analysis/siweidaotu.png","hash":"e887b762871a2cf73263898fb67662761d05123f","modified":1570119266336},{"_id":"public/2019/10/03/2019-pm-dedao/yemian5.png","hash":"245995d4a33a58222cbe0508e00c9bc2d93cf9ed","modified":1570119266336},{"_id":"public/medias/featureimages/23.jpg","hash":"981df44315015ab76bf7760b3014a28cd1a17e63","modified":1570119266343},{"_id":"public/medias/featureimages/7.jpg","hash":"b2c5748f39036b566e3dfe0aa78dff903aff36cd","modified":1570119266343},{"_id":"public/medias/featureimages/27.jpg","hash":"704831ae9e8c59ffca7debcf5f9f08bc721e21fc","modified":1570119266343},{"_id":"public/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1570119266344},{"_id":"public/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1570119266344},{"_id":"public/medias/banner/2.jpg","hash":"c2980f75f2c047d0957e3c8227b3f8d84e67f752","modified":1570119266344},{"_id":"public/medias/featureimages/0.jpg","hash":"90305d703c84d1f6f42bd26c8d99255079defa69","modified":1570119266353},{"_id":"public/medias/featureimages/4.jpg","hash":"64234598d86a55e33a0c354a9b61b8b956d25f1f","modified":1570119266353},{"_id":"public/2019/10/03/2019-pm-dedao/tuijian.png","hash":"1ec06f7a7114d681debb1e3154c175874428e272","modified":1570119266354},{"_id":"public/medias/featureimages/18.jpg","hash":"16070b2847a9605d7ae5d77766cb0d1c777873f6","modified":1570119266358},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1570119266358},{"_id":"public/medias/featureimages/10.jpg","hash":"764fd3b289fedea48c0a1f91723072548dfe299f","modified":1570119266363},{"_id":"public/medias/featureimages/8.jpg","hash":"b5ed9ed938259f39e2de4b16a9602089ac62fbf2","modified":1570119266363},{"_id":"public/medias/featureimages/17.jpg","hash":"7b1496b1cc2866d2eb6974e7cf4613d3c45864cb","modified":1570119266364},{"_id":"public/medias/featureimages/6.jpg","hash":"7836ff5bb53a2bcbf6b5932a4250bd2548413fc4","modified":1570119266364},{"_id":"public/medias/featureimages/5.jpg","hash":"1a3b2f42ed0c0da32abf740aa582918ac4c43f9c","modified":1570119266364},{"_id":"public/medias/featureimages/11.jpg","hash":"dc63b451549508268b49f4031a7262edfe4a4532","modified":1570119266365},{"_id":"public/medias/featureimages/3.jpg","hash":"b545453a93db71b65f5df87c96c38314cc43b36f","modified":1570119266365},{"_id":"public/2019/10/03/2019-pm-appso-origin/yewu2.jpg","hash":"eff4637a662451b7a6454ffe8e9eb3c8b6558e16","modified":1570119266365},{"_id":"public/medias/featureimages/12.jpg","hash":"66715c1dd857e6ceb4b99a3dc792c62d429e2d84","modified":1570119266370},{"_id":"public/medias/featureimages/2.jpg","hash":"3c9abfbe8cc2b082aa064bac3d2516db58cca639","modified":1570119266370},{"_id":"public/medias/featureimages/20.jpg","hash":"254489d7f99cafabf7cdff550098f6fd0a445c40","modified":1570119266371},{"_id":"public/medias/featureimages/9.jpg","hash":"7e30c4e30d383864c7501a6382a3b50bdd34d60e","modified":1570119266371},{"_id":"public/medias/featureimages/25.jpg","hash":"433bb293c83b6cbcaea3bbf5375c66dba3beb5ca","modified":1570119266371},{"_id":"public/medias/featureimages/19.jpg","hash":"769c0df9d615f6a79a99833819a3dec682dd5e0a","modified":1570119266372},{"_id":"public/medias/featureimages/13.jpg","hash":"14c66463fa5535ba607980951b69276c010126c3","modified":1570119266377},{"_id":"public/medias/featureimages/22.jpg","hash":"a2b2aa37c4bb1a921afe0803069a9aaf24311e8b","modified":1570119266377},{"_id":"public/medias/featureimages/21.jpg","hash":"e07786efa56e0da21efa95a6d763b8cfe1b6d4b0","modified":1570119266378},{"_id":"public/2019/10/03/2019-pm-appso-origin/yewu1.jpg","hash":"ee7dc9574e273bd3de3dede394edd544726c62c6","modified":1570119266388},{"_id":"public/medias/featureimages/15.jpg","hash":"7199ce0f67ca6177c1fcc429ef58629fde07667c","modified":1570119266392},{"_id":"public/medias/featureimages/1.jpg","hash":"c299c416bb36e5b9e932499981564b1736dd76c3","modified":1570119266392},{"_id":"public/medias/featureimages/26.jpg","hash":"0368bb94e556c5e8c7f816ac1336dd1f35bb4693","modified":1570119266404},{"_id":"public/medias/featureimages/16.jpg","hash":"04e4902eb0e21f07979ca64b98247d520244f766","modified":1570119266404},{"_id":"public/medias/featureimages/24.jpg","hash":"ac87c1048a35683299da3019beac12a2c48c758b","modified":1570119266421},{"_id":"public/medias/banner/4.jpg","hash":"ca3e3d8e30fcec76e128f3afb8c494c59e51d23d","modified":1570119266424},{"_id":"public/medias/featureimages/14.jpg","hash":"431841084af68db40ac7dc727ee7a99acaabc641","modified":1570119266424},{"_id":"public/medias/banner/5.jpg","hash":"2812799b7e00bff4f265b8db3ab4e31604630faf","modified":1570119266437},{"_id":"public/medias/music/nideyiyi.mp3","hash":"7fabade8177cd4346b3136556783afdf5ff51372","modified":1570119266441},{"_id":"public/medias/banner/0.jpg","hash":"183c377d442c1d4bf506c8b52fd71918979dcaaf","modified":1570119266448},{"_id":"public/medias/banner/1.jpg","hash":"77ff367e639adfa56b2e7e85d0fc16201f6b5c13","modified":1570119266455},{"_id":"public/medias/banner/3.jpg","hash":"bcb850685e52d46bd68a309245493897ebfcf93e","modified":1570119266471},{"_id":"public/medias/music/guangnianzhiwai.mp3","hash":"59b826f58833b4e727363ed864a2bc2c2252491c","modified":1570119266475},{"_id":"public/medias/banner/6.jpg","hash":"a33699f102a09ac65e9ecd71727354c6cbb26108","modified":1570119266491},{"_id":"public/medias/music/yiluxiangbei.mp3","hash":"e0fea7418b4947779f0af05b2b2b703bdf7e6aec","modified":1570119266500}],"Category":[{"name":"读书笔记","_id":"ck1awgxah00052wvcjzmzvm59"},{"name":"行业了解","_id":"ck1awgxas000c2wvc0fm8mgqs"},{"name":"PM","_id":"ck1awgxay000l2wvc1besn7v7"},{"name":"软件","_id":"ck1awgxb3000s2wvc98chr42v"},{"name":"Linux","_id":"ck1awgxbf001f2wvc5bxy7lro"},{"name":"Matlab","_id":"ck1awgxbn001v2wvczzpjts04"},{"name":"面试","_id":"ck1awgxbr00232wvcmeyo6fcu"},{"name":"python","_id":"ck1awgxbu002a2wvccdno21u7"},{"name":"C语言","_id":"ck1awgxdc002z2wvcgtjtqsyu"},{"name":"C++","_id":"ck1awgxeo00342wvcucdo055t"}],"Data":[{"_id":"friends","data":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}]},{"_id":"musics","data":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}],"Page":[{"title":"404","date":"2019-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2019-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2019-09-28T13:34:03.097Z","path":"404.html","comments":1,"_id":"ck1awgx8t00002wvczvf68g0w","content":"","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":""},{"title":"about","date":"2019-07-19T08:41:10.000Z","type":"about","layout":"about","_content":"\n\n# 教育经历\n* <b>硕士 建筑与土木工程</b>\n同济大学\n2019/06 - 现在\n* <b>本科 土木工程（路桥）</b>\n吉林大学\n2013/09 - 2017/06\n<b>综合排名专业第二</b>\n\n# 获得荣誉\n\n- 国家奖学金 2014\n- 国家励志奖学金 2015 \n- 校优秀学生 2014 \n- 校优秀学生 2015\n- 吉林省大学生数学建模二等奖\n\n# 联系方式\n* <b>电子邮箱</b>\n1210188858@qq.com\nguohaoxin@hotmail.com\n* <b>地址</b>\n上海市杨浦区四平路同济大学桥梁馆804室 200092\n* <b>微信</b>\nguo1210188858\n* <b>QQ</b>\n1210188858","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-07-19 16:41:10\ntype: \"about\"\nlayout: \"about\"\n---\n\n\n# 教育经历\n* <b>硕士 建筑与土木工程</b>\n同济大学\n2019/06 - 现在\n* <b>本科 土木工程（路桥）</b>\n吉林大学\n2013/09 - 2017/06\n<b>综合排名专业第二</b>\n\n# 获得荣誉\n\n- 国家奖学金 2014\n- 国家励志奖学金 2015 \n- 校优秀学生 2014 \n- 校优秀学生 2015\n- 吉林省大学生数学建模二等奖\n\n# 联系方式\n* <b>电子邮箱</b>\n1210188858@qq.com\nguohaoxin@hotmail.com\n* <b>地址</b>\n上海市杨浦区四平路同济大学桥梁馆804室 200092\n* <b>微信</b>\nguo1210188858\n* <b>QQ</b>\n1210188858","updated":"2019-09-30T06:11:32.407Z","path":"about/index.html","comments":1,"_id":"ck1awgxad00022wvc2o4o56fy","content":"<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><ul>\n<li><b>硕士 建筑与土木工程</b><br>同济大学<br>2019/06 - 现在</li>\n<li><b>本科 土木工程（路桥）</b><br>吉林大学<br>2013/09 - 2017/06<br><b>综合排名专业第二</b></li>\n</ul>\n<h1 id=\"获得荣誉\"><a href=\"#获得荣誉\" class=\"headerlink\" title=\"获得荣誉\"></a>获得荣誉</h1><ul>\n<li>国家奖学金 2014</li>\n<li>国家励志奖学金 2015 </li>\n<li>校优秀学生 2014 </li>\n<li>校优秀学生 2015</li>\n<li>吉林省大学生数学建模二等奖</li>\n</ul>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:1210188858@qq.com\" target=\"_blank\" rel=\"noopener\">1210188858@qq.com</a><br><a href=\"mailto:guohaoxin@hotmail.com\" target=\"_blank\" rel=\"noopener\">guohaoxin@hotmail.com</a></li>\n<li><b>地址</b><br>上海市杨浦区四平路同济大学桥梁馆804室 200092</li>\n<li><b>微信</b><br>guo1210188858</li>\n<li><b>QQ</b><br>1210188858</li>\n</ul>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h1><ul>\n<li><b>硕士 建筑与土木工程</b><br>同济大学<br>2019/06 - 现在</li>\n<li><b>本科 土木工程（路桥）</b><br>吉林大学<br>2013/09 - 2017/06<br><b>综合排名专业第二</b></li>\n</ul>\n<h1 id=\"获得荣誉\"><a href=\"#获得荣誉\" class=\"headerlink\" title=\"获得荣誉\"></a>获得荣誉</h1><ul>\n<li>国家奖学金 2014</li>\n<li>国家励志奖学金 2015 </li>\n<li>校优秀学生 2014 </li>\n<li>校优秀学生 2015</li>\n<li>吉林省大学生数学建模二等奖</li>\n</ul>\n<h1 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h1><ul>\n<li><b>电子邮箱</b><br><a href=\"mailto:1210188858@qq.com\" target=\"_blank\" rel=\"noopener\">1210188858@qq.com</a><br><a href=\"mailto:guohaoxin@hotmail.com\" target=\"_blank\" rel=\"noopener\">guohaoxin@hotmail.com</a></li>\n<li><b>地址</b><br>上海市杨浦区四平路同济大学桥梁馆804室 200092</li>\n<li><b>微信</b><br>guo1210188858</li>\n<li><b>QQ</b><br>1210188858</li>\n</ul>\n"},{"title":"archives","date":"2019-07-19T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2019-07-19 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2019-09-28T13:34:03.104Z","path":"archives/index.html","comments":1,"_id":"ck1awgxag00042wvcoti7za5n","content":"","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":""},{"title":"categories","date":"2019-07-19T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-07-19 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2019-09-28T13:34:03.105Z","path":"categories/index.html","comments":1,"_id":"ck1awgxak00082wvc520gxwig","content":"","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":""},{"title":"contact","date":"2019-07-26T09:17:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加我联系方式：\n* QQ：**1210188858**\n* 微信：**guo1210188858**","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2019-07-26 17:17:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加我联系方式：\n* QQ：**1210188858**\n* 微信：**guo1210188858**","updated":"2019-09-30T08:35:58.252Z","path":"contact/index.html","comments":1,"_id":"ck1awgxao000a2wvclp3exc80","content":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加我联系方式：</p>\n<ul>\n<li>QQ：<strong>1210188858</strong></li>\n<li>微信：<strong>guo1210188858</strong></li>\n</ul>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加我联系方式：</p>\n<ul>\n<li>QQ：<strong>1210188858</strong></li>\n<li>微信：<strong>guo1210188858</strong></li>\n</ul>\n"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-07-19 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2019-09-28T13:34:03.107Z","path":"tags/index.html","comments":1,"_id":"ck1awgxat000e2wvch8bz71xy","content":"","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":""},{"title":"friends","date":"2019-07-19T08:42:10.000Z","type":"friends","layout":"friends","_content":"\n# 赞赏名单\n\n# 友链交换\n* **名称：** HaoxinGuo\n* **地址：** http://guohaoxin.top\n* **简介：** PMer & Bridger & Coder\n例如我的博客友链，大家可以加到自己博客里哦：\n\n# 常用网站\n## 同济大学\n- [同济大学](tongji.edu.cn)\n- [同济大学图书馆](https://www.lib.tongji.edu.cn/)\n- [同济大学土木工程学院](http://civileng.tongji.edu.cn/)\n- [同济大学研究生院](https://gs.tongji.edu.cn/)\n- [同济大学研究生系统](yjsxt.tongji.edu.cn)\n## 其他\n\n- [学生会议云](http://www.allconfs.org/meeting_type.asp)\n- [鸠摩搜索-搜书](https://www.jiumodiary.com/)\n- [浙江大学google地址](https://zju.tools/google/) 答案：心灵之约\n- [Sci-Hub 最新可用网址](http://wap.sciencenet.cn/home.php?mod=space&mobile=1&do=blog&id=993173&id=993173)","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2019-07-19 16:42:10\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n# 赞赏名单\n\n# 友链交换\n* **名称：** HaoxinGuo\n* **地址：** http://guohaoxin.top\n* **简介：** PMer & Bridger & Coder\n例如我的博客友链，大家可以加到自己博客里哦：\n\n# 常用网站\n## 同济大学\n- [同济大学](tongji.edu.cn)\n- [同济大学图书馆](https://www.lib.tongji.edu.cn/)\n- [同济大学土木工程学院](http://civileng.tongji.edu.cn/)\n- [同济大学研究生院](https://gs.tongji.edu.cn/)\n- [同济大学研究生系统](yjsxt.tongji.edu.cn)\n## 其他\n\n- [学生会议云](http://www.allconfs.org/meeting_type.asp)\n- [鸠摩搜索-搜书](https://www.jiumodiary.com/)\n- [浙江大学google地址](https://zju.tools/google/) 答案：心灵之约\n- [Sci-Hub 最新可用网址](http://wap.sciencenet.cn/home.php?mod=space&mobile=1&do=blog&id=993173&id=993173)","updated":"2019-09-30T08:37:02.803Z","path":"friends/index.html","comments":1,"_id":"ck1awgxaw000h2wvcrovny4ei","content":"<h1 id=\"赞赏名单\"><a href=\"#赞赏名单\" class=\"headerlink\" title=\"赞赏名单\"></a>赞赏名单</h1><h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><ul>\n<li><strong>名称：</strong> HaoxinGuo</li>\n<li><strong>地址：</strong> <a href=\"http://guohaoxin.top\">http://guohaoxin.top</a></li>\n<li><strong>简介：</strong> PMer &amp; Bridger &amp; Coder<br>例如我的博客友链，大家可以加到自己博客里哦：</li>\n</ul>\n<h1 id=\"常用网站\"><a href=\"#常用网站\" class=\"headerlink\" title=\"常用网站\"></a>常用网站</h1><h2 id=\"同济大学\"><a href=\"#同济大学\" class=\"headerlink\" title=\"同济大学\"></a>同济大学</h2><ul>\n<li><p><a href=\"tongji.edu.cn\">同济大学</a></p>\n</li>\n<li><p><a href=\"https://www.lib.tongji.edu.cn/\" target=\"_blank\" rel=\"noopener\">同济大学图书馆</a></p>\n</li>\n<li><p><a href=\"http://civileng.tongji.edu.cn/\" target=\"_blank\" rel=\"noopener\">同济大学土木工程学院</a></p>\n</li>\n<li><p><a href=\"https://gs.tongji.edu.cn/\" target=\"_blank\" rel=\"noopener\">同济大学研究生院</a></p>\n</li>\n<li><p><a href=\"yjsxt.tongji.edu.cn\">同济大学研究生系统</a></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2></li>\n<li><p><a href=\"http://www.allconfs.org/meeting_type.asp\" target=\"_blank\" rel=\"noopener\">学生会议云</a></p>\n</li>\n<li><p><a href=\"https://www.jiumodiary.com/\" target=\"_blank\" rel=\"noopener\">鸠摩搜索-搜书</a></p>\n</li>\n<li><p><a href=\"https://zju.tools/google/\" target=\"_blank\" rel=\"noopener\">浙江大学google地址</a> 答案：心灵之约</p>\n</li>\n<li><p><a href=\"http://wap.sciencenet.cn/home.php?mod=space&mobile=1&do=blog&id=993173&id=993173\" target=\"_blank\" rel=\"noopener\">Sci-Hub 最新可用网址</a></p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"赞赏名单\"><a href=\"#赞赏名单\" class=\"headerlink\" title=\"赞赏名单\"></a>赞赏名单</h1><h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><ul>\n<li><strong>名称：</strong> HaoxinGuo</li>\n<li><strong>地址：</strong> <a href=\"http://guohaoxin.top\">http://guohaoxin.top</a></li>\n<li><strong>简介：</strong> PMer &amp; Bridger &amp; Coder<br>例如我的博客友链，大家可以加到自己博客里哦：</li>\n</ul>\n<h1 id=\"常用网站\"><a href=\"#常用网站\" class=\"headerlink\" title=\"常用网站\"></a>常用网站</h1><h2 id=\"同济大学\"><a href=\"#同济大学\" class=\"headerlink\" title=\"同济大学\"></a>同济大学</h2><ul>\n<li><p><a href=\"tongji.edu.cn\">同济大学</a></p>\n</li>\n<li><p><a href=\"https://www.lib.tongji.edu.cn/\" target=\"_blank\" rel=\"noopener\">同济大学图书馆</a></p>\n</li>\n<li><p><a href=\"http://civileng.tongji.edu.cn/\" target=\"_blank\" rel=\"noopener\">同济大学土木工程学院</a></p>\n</li>\n<li><p><a href=\"https://gs.tongji.edu.cn/\" target=\"_blank\" rel=\"noopener\">同济大学研究生院</a></p>\n</li>\n<li><p><a href=\"yjsxt.tongji.edu.cn\">同济大学研究生系统</a></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2></li>\n<li><p><a href=\"http://www.allconfs.org/meeting_type.asp\" target=\"_blank\" rel=\"noopener\">学生会议云</a></p>\n</li>\n<li><p><a href=\"https://www.jiumodiary.com/\" target=\"_blank\" rel=\"noopener\">鸠摩搜索-搜书</a></p>\n</li>\n<li><p><a href=\"https://zju.tools/google/\" target=\"_blank\" rel=\"noopener\">浙江大学google地址</a> 答案：心灵之约</p>\n</li>\n<li><p><a href=\"http://wap.sciencenet.cn/home.php?mod=space&mobile=1&do=blog&id=993173&id=993173\" target=\"_blank\" rel=\"noopener\">Sci-Hub 最新可用网址</a></p>\n</li>\n</ul>\n"},{"title":"download","date":"2019-07-26T09:17:02.000Z","type":"download","layout":"download","_content":"# 说明\n\n主要整理了在学习生活中常用到的软件和网站。\n\n# OpenSees\n[官方网站](http://opensees.berkeley.edu/index.php)\n[程序下载地址](http://opensees.berkeley.edu/OpenSees/user/download.php)\n[源码下载地址](https://github.com/OpenSees/OpenSees)\n[编译说明](https://www.youtube.com/watch?v=cOsAYr6zVwM)\n\n# NASM\n\n[下载地址](https://github.com/HaoxinGuo/NASM)\n\n# 书籍\n- [www.java1234.com]淘宝技术这十年 完整版\n- 梁宁.产品思维30讲\n- YES！产品经理\n- 产品经理手册  第3版\n- 产品经理修炼之道\n- 从点子到产品_产品经理的价值观与方法论\n- 点石成金\n- 电商产品经理宝典\n- 黑客与画家(中文版)\n- 结网-互联网产品经理改变世界-第二版\n- 破茧成蝶\n- 启示录-打造用户喜爱的产品（中文版）\n- 神一样的产品经理——基于移动与互联网产品\n- 谁说菜鸟不会数据分析\n- 淘宝技术这十年\n- 乌合之众\n- 写给大家看的设计书\n- 引爆点\n- 用户体验要素：以用户为中心的产品设计\n**大家可以加我微信，找我领取书籍。**\n","source":"download/index.md","raw":"---\ntitle: download\ndate: 2019-07-26 17:17:02\ntype: \"download\"\nlayout: \"download\"\n---\n# 说明\n\n主要整理了在学习生活中常用到的软件和网站。\n\n# OpenSees\n[官方网站](http://opensees.berkeley.edu/index.php)\n[程序下载地址](http://opensees.berkeley.edu/OpenSees/user/download.php)\n[源码下载地址](https://github.com/OpenSees/OpenSees)\n[编译说明](https://www.youtube.com/watch?v=cOsAYr6zVwM)\n\n# NASM\n\n[下载地址](https://github.com/HaoxinGuo/NASM)\n\n# 书籍\n- [www.java1234.com]淘宝技术这十年 完整版\n- 梁宁.产品思维30讲\n- YES！产品经理\n- 产品经理手册  第3版\n- 产品经理修炼之道\n- 从点子到产品_产品经理的价值观与方法论\n- 点石成金\n- 电商产品经理宝典\n- 黑客与画家(中文版)\n- 结网-互联网产品经理改变世界-第二版\n- 破茧成蝶\n- 启示录-打造用户喜爱的产品（中文版）\n- 神一样的产品经理——基于移动与互联网产品\n- 谁说菜鸟不会数据分析\n- 淘宝技术这十年\n- 乌合之众\n- 写给大家看的设计书\n- 引爆点\n- 用户体验要素：以用户为中心的产品设计\n**大家可以加我微信，找我领取书籍。**\n","updated":"2019-09-30T09:08:15.327Z","path":"download/index.html","comments":1,"_id":"ck1awgxay000k2wvcsnn9aer9","content":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>主要整理了在学习生活中常用到的软件和网站。</p>\n<h1 id=\"OpenSees\"><a href=\"#OpenSees\" class=\"headerlink\" title=\"OpenSees\"></a>OpenSees</h1><p><a href=\"http://opensees.berkeley.edu/index.php\" target=\"_blank\" rel=\"noopener\">官方网站</a><br><a href=\"http://opensees.berkeley.edu/OpenSees/user/download.php\" target=\"_blank\" rel=\"noopener\">程序下载地址</a><br><a href=\"https://github.com/OpenSees/OpenSees\" target=\"_blank\" rel=\"noopener\">源码下载地址</a><br><a href=\"https://www.youtube.com/watch?v=cOsAYr6zVwM\" target=\"_blank\" rel=\"noopener\">编译说明</a></p>\n<h1 id=\"NASM\"><a href=\"#NASM\" class=\"headerlink\" title=\"NASM\"></a>NASM</h1><p><a href=\"https://github.com/HaoxinGuo/NASM\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<h1 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h1><ul>\n<li>[<a href=\"http://www.java1234.com]淘宝技术这十年\" target=\"_blank\" rel=\"noopener\">www.java1234.com]淘宝技术这十年</a> 完整版</li>\n<li>梁宁.产品思维30讲</li>\n<li>YES！产品经理</li>\n<li>产品经理手册  第3版</li>\n<li>产品经理修炼之道</li>\n<li>从点子到产品_产品经理的价值观与方法论</li>\n<li>点石成金</li>\n<li>电商产品经理宝典</li>\n<li>黑客与画家(中文版)</li>\n<li>结网-互联网产品经理改变世界-第二版</li>\n<li>破茧成蝶</li>\n<li>启示录-打造用户喜爱的产品（中文版）</li>\n<li>神一样的产品经理——基于移动与互联网产品</li>\n<li>谁说菜鸟不会数据分析</li>\n<li>淘宝技术这十年</li>\n<li>乌合之众</li>\n<li>写给大家看的设计书</li>\n<li>引爆点</li>\n<li>用户体验要素：以用户为中心的产品设计</li>\n</ul>\n<p><strong>大家可以加我微信，找我领取书籍。</strong></p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>主要整理了在学习生活中常用到的软件和网站。</p>\n<h1 id=\"OpenSees\"><a href=\"#OpenSees\" class=\"headerlink\" title=\"OpenSees\"></a>OpenSees</h1><p><a href=\"http://opensees.berkeley.edu/index.php\" target=\"_blank\" rel=\"noopener\">官方网站</a><br><a href=\"http://opensees.berkeley.edu/OpenSees/user/download.php\" target=\"_blank\" rel=\"noopener\">程序下载地址</a><br><a href=\"https://github.com/OpenSees/OpenSees\" target=\"_blank\" rel=\"noopener\">源码下载地址</a><br><a href=\"https://www.youtube.com/watch?v=cOsAYr6zVwM\" target=\"_blank\" rel=\"noopener\">编译说明</a></p>\n<h1 id=\"NASM\"><a href=\"#NASM\" class=\"headerlink\" title=\"NASM\"></a>NASM</h1><p><a href=\"https://github.com/HaoxinGuo/NASM\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<h1 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h1><ul>\n<li>[<a href=\"http://www.java1234.com]淘宝技术这十年\" target=\"_blank\" rel=\"noopener\">www.java1234.com]淘宝技术这十年</a> 完整版</li>\n<li>梁宁.产品思维30讲</li>\n<li>YES！产品经理</li>\n<li>产品经理手册  第3版</li>\n<li>产品经理修炼之道</li>\n<li>从点子到产品_产品经理的价值观与方法论</li>\n<li>点石成金</li>\n<li>电商产品经理宝典</li>\n<li>黑客与画家(中文版)</li>\n<li>结网-互联网产品经理改变世界-第二版</li>\n<li>破茧成蝶</li>\n<li>启示录-打造用户喜爱的产品（中文版）</li>\n<li>神一样的产品经理——基于移动与互联网产品</li>\n<li>谁说菜鸟不会数据分析</li>\n<li>淘宝技术这十年</li>\n<li>乌合之众</li>\n<li>写给大家看的设计书</li>\n<li>引爆点</li>\n<li>用户体验要素：以用户为中心的产品设计</li>\n</ul>\n<p><strong>大家可以加我微信，找我领取书籍。</strong></p>\n"}],"Post":[{"title":"智能产品经理","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T08:56:41.000Z","password":null,"summary":null,"_content":"\nAI PM \n\n1. 传统PM和AIPM的区别和练习：\n\n# AI产品经理能力模型\n\n## 概述\n\n从现在的招聘市场来看，产品经理岗位已经出现大量细分，如数据产品经理，支付产品经理，ERP产品经理，CRM产品经，供应量产品经理，POP产品经理等，AI产品经理可能将成未来的一个主流细分岗位，而且因为AI对应的领域不同，AI产品经理下面将衍生出大量的细分行业AI产品经理。在讨论AI产品经理之前，我们来看看，非AI产品在公司中需要面对哪些角色，而面对这些角色需要的能力模型是什么，在这个基础上我们再来讨论AI产品经理的能力模型。\n\n产品经理需要每天与工程师，设计，老板，运营，市场，用户/客户，测试等部门同事沟通，AI产品经理从对接人上来看，\n**增加了AI科学家或者AI工程师，为了可以顺畅沟通，产品经理的知识结构必然需要增加相应的知识，以提升沟通效率，清楚产品设计边界**\n，同时，因为AI产品与客户的业务结合更加的密切，所以需要对所设计产品的行业有纵深的全流程理解能力。在这个基础上，我们来尝试搭建AI产品经理能力模型。\n\n产品能力模型可以从人，事，知识三个角度搭建，通过上文的分析，我们可以看到，在人和事上产品经理的能力几乎没有太大变化，但是在知识层面需要进行基础储备，以提高与AI科学家和AI工程师的沟通效率。人工智能技术正处于高速发展时期，充满了不确定性，所以产品经理的认知极限一定程度上影响了产品的未来，本文将总结人工智能领域的一些基本概念，认知极限需要靠阅读最前沿的paper和团队的AI科学家/工程师多交流，行业纵深的理解需要真实的参与到业务的整个过程中学习，这就为一些非互联网领域的，有着多年细分行业工作经验的，清楚全业务流程痛点的非互联网人提供了转型机会，后面会详细论述。\n\n清楚这些技术的实现框架就可以了，只要可以清楚的描述客户需求场景，深刻理解客户诉求，并将其清晰的描述给AI科学家，并能听懂AI科学家的话就可以了，至于他们使用了什么模型，什么算法并不需要你去操心。\n\n3、非互联网行业转型的新机会\n\n传统行业中的从业者可以利用其多年经验为AI团队提供认知价值\n\n二、人工智能发展史\n\n\n5、从应用场景来看\n\n互联网和移动互联网应用：搜索引擎、精准营销、用户画像、反欺诈\n\n智能交通：自动驾驶、共享出行、自动物流\n\n智能金融：银行业、保险业、证券投资（风控、反欺诈、投资决策）\n\n智能医疗：辅助诊断、手术机器人、智能制药、辅助器官、外骨骼\n\n智能农业：智慧农业管理系统、智慧农业设备\n\n智能写作：写稿机器人、收集资料机器人\n\n机器翻译：文字翻译、声音翻译、图像翻译\n\n机器仿生：动物仿生、器官仿生\n\n智能助理：律师助理、时间管理助理\n\n创作艺术：编曲、写歌、写小说、绘画","source":"_posts/2019-AIPM.md","raw":"---\ntitle: 智能产品经理\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 16:56:41\npassword:\nsummary:\ntags:\n- PM 读书笔记\ncategories:\n- 读书笔记\n---\n\nAI PM \n\n1. 传统PM和AIPM的区别和练习：\n\n# AI产品经理能力模型\n\n## 概述\n\n从现在的招聘市场来看，产品经理岗位已经出现大量细分，如数据产品经理，支付产品经理，ERP产品经理，CRM产品经，供应量产品经理，POP产品经理等，AI产品经理可能将成未来的一个主流细分岗位，而且因为AI对应的领域不同，AI产品经理下面将衍生出大量的细分行业AI产品经理。在讨论AI产品经理之前，我们来看看，非AI产品在公司中需要面对哪些角色，而面对这些角色需要的能力模型是什么，在这个基础上我们再来讨论AI产品经理的能力模型。\n\n产品经理需要每天与工程师，设计，老板，运营，市场，用户/客户，测试等部门同事沟通，AI产品经理从对接人上来看，\n**增加了AI科学家或者AI工程师，为了可以顺畅沟通，产品经理的知识结构必然需要增加相应的知识，以提升沟通效率，清楚产品设计边界**\n，同时，因为AI产品与客户的业务结合更加的密切，所以需要对所设计产品的行业有纵深的全流程理解能力。在这个基础上，我们来尝试搭建AI产品经理能力模型。\n\n产品能力模型可以从人，事，知识三个角度搭建，通过上文的分析，我们可以看到，在人和事上产品经理的能力几乎没有太大变化，但是在知识层面需要进行基础储备，以提高与AI科学家和AI工程师的沟通效率。人工智能技术正处于高速发展时期，充满了不确定性，所以产品经理的认知极限一定程度上影响了产品的未来，本文将总结人工智能领域的一些基本概念，认知极限需要靠阅读最前沿的paper和团队的AI科学家/工程师多交流，行业纵深的理解需要真实的参与到业务的整个过程中学习，这就为一些非互联网领域的，有着多年细分行业工作经验的，清楚全业务流程痛点的非互联网人提供了转型机会，后面会详细论述。\n\n清楚这些技术的实现框架就可以了，只要可以清楚的描述客户需求场景，深刻理解客户诉求，并将其清晰的描述给AI科学家，并能听懂AI科学家的话就可以了，至于他们使用了什么模型，什么算法并不需要你去操心。\n\n3、非互联网行业转型的新机会\n\n传统行业中的从业者可以利用其多年经验为AI团队提供认知价值\n\n二、人工智能发展史\n\n\n5、从应用场景来看\n\n互联网和移动互联网应用：搜索引擎、精准营销、用户画像、反欺诈\n\n智能交通：自动驾驶、共享出行、自动物流\n\n智能金融：银行业、保险业、证券投资（风控、反欺诈、投资决策）\n\n智能医疗：辅助诊断、手术机器人、智能制药、辅助器官、外骨骼\n\n智能农业：智慧农业管理系统、智慧农业设备\n\n智能写作：写稿机器人、收集资料机器人\n\n机器翻译：文字翻译、声音翻译、图像翻译\n\n机器仿生：动物仿生、器官仿生\n\n智能助理：律师助理、时间管理助理\n\n创作艺术：编曲、写歌、写小说、绘画","slug":"2019-AIPM","published":1,"updated":"2019-09-30T08:57:34.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxa900012wvcz0hrrhm3","content":"<p>AI PM </p>\n<ol>\n<li>传统PM和AIPM的区别和练习：</li>\n</ol>\n<h1 id=\"AI产品经理能力模型\"><a href=\"#AI产品经理能力模型\" class=\"headerlink\" title=\"AI产品经理能力模型\"></a>AI产品经理能力模型</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>从现在的招聘市场来看，产品经理岗位已经出现大量细分，如数据产品经理，支付产品经理，ERP产品经理，CRM产品经，供应量产品经理，POP产品经理等，AI产品经理可能将成未来的一个主流细分岗位，而且因为AI对应的领域不同，AI产品经理下面将衍生出大量的细分行业AI产品经理。在讨论AI产品经理之前，我们来看看，非AI产品在公司中需要面对哪些角色，而面对这些角色需要的能力模型是什么，在这个基础上我们再来讨论AI产品经理的能力模型。</p>\n<p>产品经理需要每天与工程师，设计，老板，运营，市场，用户/客户，测试等部门同事沟通，AI产品经理从对接人上来看，<br><strong>增加了AI科学家或者AI工程师，为了可以顺畅沟通，产品经理的知识结构必然需要增加相应的知识，以提升沟通效率，清楚产品设计边界</strong><br>，同时，因为AI产品与客户的业务结合更加的密切，所以需要对所设计产品的行业有纵深的全流程理解能力。在这个基础上，我们来尝试搭建AI产品经理能力模型。</p>\n<p>产品能力模型可以从人，事，知识三个角度搭建，通过上文的分析，我们可以看到，在人和事上产品经理的能力几乎没有太大变化，但是在知识层面需要进行基础储备，以提高与AI科学家和AI工程师的沟通效率。人工智能技术正处于高速发展时期，充满了不确定性，所以产品经理的认知极限一定程度上影响了产品的未来，本文将总结人工智能领域的一些基本概念，认知极限需要靠阅读最前沿的paper和团队的AI科学家/工程师多交流，行业纵深的理解需要真实的参与到业务的整个过程中学习，这就为一些非互联网领域的，有着多年细分行业工作经验的，清楚全业务流程痛点的非互联网人提供了转型机会，后面会详细论述。</p>\n<p>清楚这些技术的实现框架就可以了，只要可以清楚的描述客户需求场景，深刻理解客户诉求，并将其清晰的描述给AI科学家，并能听懂AI科学家的话就可以了，至于他们使用了什么模型，什么算法并不需要你去操心。</p>\n<p>3、非互联网行业转型的新机会</p>\n<p>传统行业中的从业者可以利用其多年经验为AI团队提供认知价值</p>\n<p>二、人工智能发展史</p>\n<p>5、从应用场景来看</p>\n<p>互联网和移动互联网应用：搜索引擎、精准营销、用户画像、反欺诈</p>\n<p>智能交通：自动驾驶、共享出行、自动物流</p>\n<p>智能金融：银行业、保险业、证券投资（风控、反欺诈、投资决策）</p>\n<p>智能医疗：辅助诊断、手术机器人、智能制药、辅助器官、外骨骼</p>\n<p>智能农业：智慧农业管理系统、智慧农业设备</p>\n<p>智能写作：写稿机器人、收集资料机器人</p>\n<p>机器翻译：文字翻译、声音翻译、图像翻译</p>\n<p>机器仿生：动物仿生、器官仿生</p>\n<p>智能助理：律师助理、时间管理助理</p>\n<p>创作艺术：编曲、写歌、写小说、绘画</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<p>AI PM </p>\n<ol>\n<li>传统PM和AIPM的区别和练习：</li>\n</ol>\n<h1 id=\"AI产品经理能力模型\"><a href=\"#AI产品经理能力模型\" class=\"headerlink\" title=\"AI产品经理能力模型\"></a>AI产品经理能力模型</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>从现在的招聘市场来看，产品经理岗位已经出现大量细分，如数据产品经理，支付产品经理，ERP产品经理，CRM产品经，供应量产品经理，POP产品经理等，AI产品经理可能将成未来的一个主流细分岗位，而且因为AI对应的领域不同，AI产品经理下面将衍生出大量的细分行业AI产品经理。在讨论AI产品经理之前，我们来看看，非AI产品在公司中需要面对哪些角色，而面对这些角色需要的能力模型是什么，在这个基础上我们再来讨论AI产品经理的能力模型。</p>\n<p>产品经理需要每天与工程师，设计，老板，运营，市场，用户/客户，测试等部门同事沟通，AI产品经理从对接人上来看，<br><strong>增加了AI科学家或者AI工程师，为了可以顺畅沟通，产品经理的知识结构必然需要增加相应的知识，以提升沟通效率，清楚产品设计边界</strong><br>，同时，因为AI产品与客户的业务结合更加的密切，所以需要对所设计产品的行业有纵深的全流程理解能力。在这个基础上，我们来尝试搭建AI产品经理能力模型。</p>\n<p>产品能力模型可以从人，事，知识三个角度搭建，通过上文的分析，我们可以看到，在人和事上产品经理的能力几乎没有太大变化，但是在知识层面需要进行基础储备，以提高与AI科学家和AI工程师的沟通效率。人工智能技术正处于高速发展时期，充满了不确定性，所以产品经理的认知极限一定程度上影响了产品的未来，本文将总结人工智能领域的一些基本概念，认知极限需要靠阅读最前沿的paper和团队的AI科学家/工程师多交流，行业纵深的理解需要真实的参与到业务的整个过程中学习，这就为一些非互联网领域的，有着多年细分行业工作经验的，清楚全业务流程痛点的非互联网人提供了转型机会，后面会详细论述。</p>\n<p>清楚这些技术的实现框架就可以了，只要可以清楚的描述客户需求场景，深刻理解客户诉求，并将其清晰的描述给AI科学家，并能听懂AI科学家的话就可以了，至于他们使用了什么模型，什么算法并不需要你去操心。</p>\n<p>3、非互联网行业转型的新机会</p>\n<p>传统行业中的从业者可以利用其多年经验为AI团队提供认知价值</p>\n<p>二、人工智能发展史</p>\n<p>5、从应用场景来看</p>\n<p>互联网和移动互联网应用：搜索引擎、精准营销、用户画像、反欺诈</p>\n<p>智能交通：自动驾驶、共享出行、自动物流</p>\n<p>智能金融：银行业、保险业、证券投资（风控、反欺诈、投资决策）</p>\n<p>智能医疗：辅助诊断、手术机器人、智能制药、辅助器官、外骨骼</p>\n<p>智能农业：智慧农业管理系统、智慧农业设备</p>\n<p>智能写作：写稿机器人、收集资料机器人</p>\n<p>机器翻译：文字翻译、声音翻译、图像翻译</p>\n<p>机器仿生：动物仿生、器官仿生</p>\n<p>智能助理：律师助理、时间管理助理</p>\n<p>创作艺术：编曲、写歌、写小说、绘画</p>\n"},{"title":"对BIM&Glodon的一些了解","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-08-30T08:47:08.000Z","password":null,"summary":"BIM的核心技术包括专业建模软件、专业分析软件、专业出图软件、专业加工设备、专业测量设备、专业管理平台，而不同BIM专业软件之间的数据共享和交换技术是核心中的核心。","_content":"\n# BIM \n\nBIM的核心技术包括专业建模软件、专业分析软件、专业出图软件、专业加工设备、专业测量设备、专业管理平台，而不同BIM专业软件之间的数据共享和交换技术是核心中的核心。\n\nBIM正向设计的主要矛盾为单一软件难以满足设计人员要求，而多种BIM专业软件虽能满足专业设计人员要求，但数据不兼容，难以进行协同设计。基于这个主要矛盾，邓雪原提出要采取“各施所长、信息共享”的多专业协同模式，并提出各专业BIM应用标准、三维协同设计、各专业数据共享、标准化数据管理的BIM技术路线。\n\nBIM致力于实现。装配式建筑应用、城市市政工程建设、建筑环境与能耗分析以及智慧城市建筑数据的建设与管理。\n\nRevit、ArchiCAD、PKPM、YJK、Tekla、MagiCAD、Rebro、Bentley、CATIA、AllPlan等多款BIM软件。\n\n# 广联达\n\n## 公司介绍\n\n作为**建筑产业互联网平台服务商**，广联达始终以专业精神锁定行业，期望通过互联网带来的自由、平等、开拓与创新精神，以开放、互联、共享、协同的平台化理念共同打造产业链新生态.\n\n广联达立足建筑产业，围绕建设工程项目的全生命周期，是提供以建设工程领域专业应用为核心基础支撑，以产业大数据、产业征信、产业金融等为增值服务的平台服务商。经过近二十年的发展，公司以BIM、云计算，国际化业务为战略支撑，产品从单一的预算软件扩展到包含工程造价、工程施工、工程信息、工程教育、项目管理、电子政务、电子商务，产业金融及投资并购等九大业务，近百款产品。为十七万企业用户、百万专业工程技术和管理人员提供了专业应用软件，用信息技术帮助建筑业内从业人员完成了工程造价、工程施工、工程项目管理等专业工作，大大提升工作效率，降低工程成本，促进行业技术与管理进步，增加企业效益，提高企业核心竞争力。同时广联达也在不断以创新互联网思维重构商业、运营和管理模式。\n\n## 业务介绍\n\n广联达立足建筑产业，围绕建设工程项目的全生命周期，是提供以建设工程领域专业应用为核心基础支撑，以产业大数据、产业征信、产业金融等为增值服务的平台服务商.\n\n专业应用：PC端应用:70余款产品，其中企业用户17万余家，工具类产品直接使用者60余万，管理类产品直接使用者100余万.\n\n移动端APP:20余款，互联网产品直接使用者300余万.\n\n硬件端应用:覆盖3000余个项目部，产品直接使用者3万余人.\n\n云空间: 已建立5000余项目空间.\n\n大数据服务：积累近2000个实际工程的指标数据，涵盖96个项目类型；\n\n积累形成了在工料机标准下的3000万条材料价格信息，1万条现场材料字典库；\n\n积累了建筑产业18万条专有词库及42万条行业关系库；\n\n芬兰PROGRAM公司MAGICAD产品中现已积累200多万BIM机电构件库；\n\n服务覆盖了20个省、3个直辖市和4个自治区；\n\n在美国硅谷建立大数据研究中心，在用户行为数据分析方面取得阶段性成果；\n\n“建筑工程信息数据服务整体解决方案”荣获中国信息技术服务产业2014-2015年度“中国大数据应用优秀创新实践奖”。\n\n电子商务：旺材电商为会员提供70多个品类、300个品种直供服务，超过1万类部品构件信息向会员企业免费开放。\n\n产业金融：业务涵盖：小贷、保理、保函等，两家互联网小贷子公司、一家商业保理子公司已经正式运营。全年累计发放贷款过1亿元，拨备覆盖率100%。\n\n国际化：2009年起开始国际化进程，美国、新加坡、香港、马来西亚、芬兰、英国分别设立子公司，带动东南亚、美洲、 欧洲区域市场。\n\n## 计量产品\n\n### 土建计量GTJ2018\n\n帮助工程造价企业和从业者解决土建专业估概算、招投标预算、施工进度变更、竣工结算全过程各阶段算量、提量、检查、审核全流程业务，实现一站式的BIM土建计量。\n\n### 钢筋算量GGJ2013\n\n### 土建算量GTJ2013\n\n### BIM安装/装饰计量2019\n\n广联达BIM安装计量软件是针对民用建筑安装全专业研发的一款工程量计算软件。GQI2019支持全专业BIM三维模式算量和手算模式算量，适用于所有电算化水平的安装造价和技术人员使用，兼容市场上所有电子版图纸的导入，包括CAD图纸、REVIT模型、PDF图纸、图片等。通过智能化识别，可视化三维显示、专业化计算规则、灵活化的工程量统计、无缝化的计价导入，全面解决安装专业各阶段手工计算效率低、难度大等问题。\n\n\n### BIM装饰设计2019\n\n### 市政算量GMA2018\n\n### 公路工程计价软甲GHW\n\n新一代的公路工程计价产品GHW V2.0以公路行业造价业务为主线，围绕公路、桥梁、隧道等公路项目，以公路工程设计概算、施工图预算、招投标清单的编制和审核为核心，采用丰富的云应用+大数据体验，随时随地快速编制。\n\n1. 云数据\n\n2. 保存所有组价方案\n\n3. 智能组价\n\n\n### BIM钢结构算量\n\n广联达BIM钢结构算量是基于BIM技术的全新应用，从三维算量的角度突破性解决了钢结构复杂、多变的节点问题，提供复杂构件的参数化建模，真正做到建模快、算量巧、报表全。\n\n1. 可视化\n\n2. 建模快\n\n3. 报表全\n\n\n## 计价产品\n\n### 云计价GCCP5\n\n广联达云计价平台GCCP5.0是迎合数字建筑平台服务商战略转型，为计价客户群，提供概算、预算、结算阶段的数据编制、审核、积累、分析和挖掘再利用的平台产品，于2015年研发完成并投放市场。平台基于大数据、云计算等信息技术，实现计价全业务一体化，全流程覆盖，从而使造价工作更高效、更智能。\n\n## 产品分类 \n\n造价管理  BIM建造  智慧工地  数字企业  信息服务  国际业务  企业协同  \n\n## 产品标签\n\nBIM  建模  算量  计价  预结算  招投标  施工 云服务  市政交通  能源资源 大型建设\n\n# BIM\n\nBIM技术从单纯的建模和管线综合等初级应用上升为规划，设计建造和运营等各个阶段的应用。它带来不仅仅是技术，也将带来新的工作流程，行业标准和规划。\n\n1. 建设方\n\n2. 设计机构\n\n3. 施工机构\n\n4. 运营机构\n\n运营机构对BIM技术的应用有如下几点：\n\n1）运用可视化的建筑模型，能够实现对物业管理以及设备的基本信息，能够依据设备的运行状况及时的安排设备的维修与保养或者更换设备。\n\n２）能够记录设备维护与保养的过程，可以规范设备保养的步骤与过程。\n\n３）利用BIM模型辅助培训新员工，防止因人员的流动而造成工作效率与水平下降。\n\n４）BIM设备维护管理系统有了一定的信息数据之后，就可以对其进行统计分析，为决策提供各类统计报表。\n\n５）当某设备发生故障时，在BIM设备维护系统中查看应急处理手册，做出第一步的快速应急处理．\n\n６）可查看维护保养的步骤和流程，使用说明，维护保养记录等信息，以帮助确定故障设备的维修或更换方案，提高效率。\n\n７）可实时漫游，观察维修设备周围环境，以帮助确定维修工作面是否能够展开，维修工具是否能使用。\n\n5. 造价咨询机构\n\n6. 软件行业\n\n使国内的传统软件公司如**广联达、鲁班、天正、PKPM**等纷纷开发自己的BIM软件，但它们的功能和体验都有待改进。\n\n7. 教育机构\n\n## BIM的特点\n\n1. 可视化\n\n2. 关联性\n\n3. 互用性\n\n4. 协调性\n\n5. 模拟性\n\n6. 优化性\n\n7. 可出图性\n\n## BIM的维度\n\n1. 二维模型（平面）\n\n2. 三维模型:增加了Z方向和尺寸\n\n3. 四维模型：增加了时间的维度\n\n4. 五维模型：增加了成本的维度\n\n5. 六维/七维模型：六维指的是全生命周期、设施和能量的管理构件，七维模型则包括建筑的安全使用问题。","source":"_posts/2019-BIM-Glodon.md","raw":"---\ntitle: 对BIM&Glodon的一些了解\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-08-30 16:47:08\npassword:\nsummary: BIM的核心技术包括专业建模软件、专业分析软件、专业出图软件、专业加工设备、专业测量设备、专业管理平台，而不同BIM专业软件之间的数据共享和交换技术是核心中的核心。\ntags:\n- Glodon BIM\ncategories:\n- 行业了解\n---\n\n# BIM \n\nBIM的核心技术包括专业建模软件、专业分析软件、专业出图软件、专业加工设备、专业测量设备、专业管理平台，而不同BIM专业软件之间的数据共享和交换技术是核心中的核心。\n\nBIM正向设计的主要矛盾为单一软件难以满足设计人员要求，而多种BIM专业软件虽能满足专业设计人员要求，但数据不兼容，难以进行协同设计。基于这个主要矛盾，邓雪原提出要采取“各施所长、信息共享”的多专业协同模式，并提出各专业BIM应用标准、三维协同设计、各专业数据共享、标准化数据管理的BIM技术路线。\n\nBIM致力于实现。装配式建筑应用、城市市政工程建设、建筑环境与能耗分析以及智慧城市建筑数据的建设与管理。\n\nRevit、ArchiCAD、PKPM、YJK、Tekla、MagiCAD、Rebro、Bentley、CATIA、AllPlan等多款BIM软件。\n\n# 广联达\n\n## 公司介绍\n\n作为**建筑产业互联网平台服务商**，广联达始终以专业精神锁定行业，期望通过互联网带来的自由、平等、开拓与创新精神，以开放、互联、共享、协同的平台化理念共同打造产业链新生态.\n\n广联达立足建筑产业，围绕建设工程项目的全生命周期，是提供以建设工程领域专业应用为核心基础支撑，以产业大数据、产业征信、产业金融等为增值服务的平台服务商。经过近二十年的发展，公司以BIM、云计算，国际化业务为战略支撑，产品从单一的预算软件扩展到包含工程造价、工程施工、工程信息、工程教育、项目管理、电子政务、电子商务，产业金融及投资并购等九大业务，近百款产品。为十七万企业用户、百万专业工程技术和管理人员提供了专业应用软件，用信息技术帮助建筑业内从业人员完成了工程造价、工程施工、工程项目管理等专业工作，大大提升工作效率，降低工程成本，促进行业技术与管理进步，增加企业效益，提高企业核心竞争力。同时广联达也在不断以创新互联网思维重构商业、运营和管理模式。\n\n## 业务介绍\n\n广联达立足建筑产业，围绕建设工程项目的全生命周期，是提供以建设工程领域专业应用为核心基础支撑，以产业大数据、产业征信、产业金融等为增值服务的平台服务商.\n\n专业应用：PC端应用:70余款产品，其中企业用户17万余家，工具类产品直接使用者60余万，管理类产品直接使用者100余万.\n\n移动端APP:20余款，互联网产品直接使用者300余万.\n\n硬件端应用:覆盖3000余个项目部，产品直接使用者3万余人.\n\n云空间: 已建立5000余项目空间.\n\n大数据服务：积累近2000个实际工程的指标数据，涵盖96个项目类型；\n\n积累形成了在工料机标准下的3000万条材料价格信息，1万条现场材料字典库；\n\n积累了建筑产业18万条专有词库及42万条行业关系库；\n\n芬兰PROGRAM公司MAGICAD产品中现已积累200多万BIM机电构件库；\n\n服务覆盖了20个省、3个直辖市和4个自治区；\n\n在美国硅谷建立大数据研究中心，在用户行为数据分析方面取得阶段性成果；\n\n“建筑工程信息数据服务整体解决方案”荣获中国信息技术服务产业2014-2015年度“中国大数据应用优秀创新实践奖”。\n\n电子商务：旺材电商为会员提供70多个品类、300个品种直供服务，超过1万类部品构件信息向会员企业免费开放。\n\n产业金融：业务涵盖：小贷、保理、保函等，两家互联网小贷子公司、一家商业保理子公司已经正式运营。全年累计发放贷款过1亿元，拨备覆盖率100%。\n\n国际化：2009年起开始国际化进程，美国、新加坡、香港、马来西亚、芬兰、英国分别设立子公司，带动东南亚、美洲、 欧洲区域市场。\n\n## 计量产品\n\n### 土建计量GTJ2018\n\n帮助工程造价企业和从业者解决土建专业估概算、招投标预算、施工进度变更、竣工结算全过程各阶段算量、提量、检查、审核全流程业务，实现一站式的BIM土建计量。\n\n### 钢筋算量GGJ2013\n\n### 土建算量GTJ2013\n\n### BIM安装/装饰计量2019\n\n广联达BIM安装计量软件是针对民用建筑安装全专业研发的一款工程量计算软件。GQI2019支持全专业BIM三维模式算量和手算模式算量，适用于所有电算化水平的安装造价和技术人员使用，兼容市场上所有电子版图纸的导入，包括CAD图纸、REVIT模型、PDF图纸、图片等。通过智能化识别，可视化三维显示、专业化计算规则、灵活化的工程量统计、无缝化的计价导入，全面解决安装专业各阶段手工计算效率低、难度大等问题。\n\n\n### BIM装饰设计2019\n\n### 市政算量GMA2018\n\n### 公路工程计价软甲GHW\n\n新一代的公路工程计价产品GHW V2.0以公路行业造价业务为主线，围绕公路、桥梁、隧道等公路项目，以公路工程设计概算、施工图预算、招投标清单的编制和审核为核心，采用丰富的云应用+大数据体验，随时随地快速编制。\n\n1. 云数据\n\n2. 保存所有组价方案\n\n3. 智能组价\n\n\n### BIM钢结构算量\n\n广联达BIM钢结构算量是基于BIM技术的全新应用，从三维算量的角度突破性解决了钢结构复杂、多变的节点问题，提供复杂构件的参数化建模，真正做到建模快、算量巧、报表全。\n\n1. 可视化\n\n2. 建模快\n\n3. 报表全\n\n\n## 计价产品\n\n### 云计价GCCP5\n\n广联达云计价平台GCCP5.0是迎合数字建筑平台服务商战略转型，为计价客户群，提供概算、预算、结算阶段的数据编制、审核、积累、分析和挖掘再利用的平台产品，于2015年研发完成并投放市场。平台基于大数据、云计算等信息技术，实现计价全业务一体化，全流程覆盖，从而使造价工作更高效、更智能。\n\n## 产品分类 \n\n造价管理  BIM建造  智慧工地  数字企业  信息服务  国际业务  企业协同  \n\n## 产品标签\n\nBIM  建模  算量  计价  预结算  招投标  施工 云服务  市政交通  能源资源 大型建设\n\n# BIM\n\nBIM技术从单纯的建模和管线综合等初级应用上升为规划，设计建造和运营等各个阶段的应用。它带来不仅仅是技术，也将带来新的工作流程，行业标准和规划。\n\n1. 建设方\n\n2. 设计机构\n\n3. 施工机构\n\n4. 运营机构\n\n运营机构对BIM技术的应用有如下几点：\n\n1）运用可视化的建筑模型，能够实现对物业管理以及设备的基本信息，能够依据设备的运行状况及时的安排设备的维修与保养或者更换设备。\n\n２）能够记录设备维护与保养的过程，可以规范设备保养的步骤与过程。\n\n３）利用BIM模型辅助培训新员工，防止因人员的流动而造成工作效率与水平下降。\n\n４）BIM设备维护管理系统有了一定的信息数据之后，就可以对其进行统计分析，为决策提供各类统计报表。\n\n５）当某设备发生故障时，在BIM设备维护系统中查看应急处理手册，做出第一步的快速应急处理．\n\n６）可查看维护保养的步骤和流程，使用说明，维护保养记录等信息，以帮助确定故障设备的维修或更换方案，提高效率。\n\n７）可实时漫游，观察维修设备周围环境，以帮助确定维修工作面是否能够展开，维修工具是否能使用。\n\n5. 造价咨询机构\n\n6. 软件行业\n\n使国内的传统软件公司如**广联达、鲁班、天正、PKPM**等纷纷开发自己的BIM软件，但它们的功能和体验都有待改进。\n\n7. 教育机构\n\n## BIM的特点\n\n1. 可视化\n\n2. 关联性\n\n3. 互用性\n\n4. 协调性\n\n5. 模拟性\n\n6. 优化性\n\n7. 可出图性\n\n## BIM的维度\n\n1. 二维模型（平面）\n\n2. 三维模型:增加了Z方向和尺寸\n\n3. 四维模型：增加了时间的维度\n\n4. 五维模型：增加了成本的维度\n\n5. 六维/七维模型：六维指的是全生命周期、设施和能量的管理构件，七维模型则包括建筑的安全使用问题。","slug":"2019-BIM-Glodon","published":1,"updated":"2019-09-30T08:49:40.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxae00032wvcg1la6pz7","content":"<h1 id=\"BIM\"><a href=\"#BIM\" class=\"headerlink\" title=\"BIM\"></a>BIM</h1><p>BIM的核心技术包括专业建模软件、专业分析软件、专业出图软件、专业加工设备、专业测量设备、专业管理平台，而不同BIM专业软件之间的数据共享和交换技术是核心中的核心。</p>\n<p>BIM正向设计的主要矛盾为单一软件难以满足设计人员要求，而多种BIM专业软件虽能满足专业设计人员要求，但数据不兼容，难以进行协同设计。基于这个主要矛盾，邓雪原提出要采取“各施所长、信息共享”的多专业协同模式，并提出各专业BIM应用标准、三维协同设计、各专业数据共享、标准化数据管理的BIM技术路线。</p>\n<p>BIM致力于实现。装配式建筑应用、城市市政工程建设、建筑环境与能耗分析以及智慧城市建筑数据的建设与管理。</p>\n<p>Revit、ArchiCAD、PKPM、YJK、Tekla、MagiCAD、Rebro、Bentley、CATIA、AllPlan等多款BIM软件。</p>\n<h1 id=\"广联达\"><a href=\"#广联达\" class=\"headerlink\" title=\"广联达\"></a>广联达</h1><h2 id=\"公司介绍\"><a href=\"#公司介绍\" class=\"headerlink\" title=\"公司介绍\"></a>公司介绍</h2><p>作为<strong>建筑产业互联网平台服务商</strong>，广联达始终以专业精神锁定行业，期望通过互联网带来的自由、平等、开拓与创新精神，以开放、互联、共享、协同的平台化理念共同打造产业链新生态.</p>\n<p>广联达立足建筑产业，围绕建设工程项目的全生命周期，是提供以建设工程领域专业应用为核心基础支撑，以产业大数据、产业征信、产业金融等为增值服务的平台服务商。经过近二十年的发展，公司以BIM、云计算，国际化业务为战略支撑，产品从单一的预算软件扩展到包含工程造价、工程施工、工程信息、工程教育、项目管理、电子政务、电子商务，产业金融及投资并购等九大业务，近百款产品。为十七万企业用户、百万专业工程技术和管理人员提供了专业应用软件，用信息技术帮助建筑业内从业人员完成了工程造价、工程施工、工程项目管理等专业工作，大大提升工作效率，降低工程成本，促进行业技术与管理进步，增加企业效益，提高企业核心竞争力。同时广联达也在不断以创新互联网思维重构商业、运营和管理模式。</p>\n<h2 id=\"业务介绍\"><a href=\"#业务介绍\" class=\"headerlink\" title=\"业务介绍\"></a>业务介绍</h2><p>广联达立足建筑产业，围绕建设工程项目的全生命周期，是提供以建设工程领域专业应用为核心基础支撑，以产业大数据、产业征信、产业金融等为增值服务的平台服务商.</p>\n<p>专业应用：PC端应用:70余款产品，其中企业用户17万余家，工具类产品直接使用者60余万，管理类产品直接使用者100余万.</p>\n<p>移动端APP:20余款，互联网产品直接使用者300余万.</p>\n<p>硬件端应用:覆盖3000余个项目部，产品直接使用者3万余人.</p>\n<p>云空间: 已建立5000余项目空间.</p>\n<p>大数据服务：积累近2000个实际工程的指标数据，涵盖96个项目类型；</p>\n<p>积累形成了在工料机标准下的3000万条材料价格信息，1万条现场材料字典库；</p>\n<p>积累了建筑产业18万条专有词库及42万条行业关系库；</p>\n<p>芬兰PROGRAM公司MAGICAD产品中现已积累200多万BIM机电构件库；</p>\n<p>服务覆盖了20个省、3个直辖市和4个自治区；</p>\n<p>在美国硅谷建立大数据研究中心，在用户行为数据分析方面取得阶段性成果；</p>\n<p>“建筑工程信息数据服务整体解决方案”荣获中国信息技术服务产业2014-2015年度“中国大数据应用优秀创新实践奖”。</p>\n<p>电子商务：旺材电商为会员提供70多个品类、300个品种直供服务，超过1万类部品构件信息向会员企业免费开放。</p>\n<p>产业金融：业务涵盖：小贷、保理、保函等，两家互联网小贷子公司、一家商业保理子公司已经正式运营。全年累计发放贷款过1亿元，拨备覆盖率100%。</p>\n<p>国际化：2009年起开始国际化进程，美国、新加坡、香港、马来西亚、芬兰、英国分别设立子公司，带动东南亚、美洲、 欧洲区域市场。</p>\n<h2 id=\"计量产品\"><a href=\"#计量产品\" class=\"headerlink\" title=\"计量产品\"></a>计量产品</h2><h3 id=\"土建计量GTJ2018\"><a href=\"#土建计量GTJ2018\" class=\"headerlink\" title=\"土建计量GTJ2018\"></a>土建计量GTJ2018</h3><p>帮助工程造价企业和从业者解决土建专业估概算、招投标预算、施工进度变更、竣工结算全过程各阶段算量、提量、检查、审核全流程业务，实现一站式的BIM土建计量。</p>\n<h3 id=\"钢筋算量GGJ2013\"><a href=\"#钢筋算量GGJ2013\" class=\"headerlink\" title=\"钢筋算量GGJ2013\"></a>钢筋算量GGJ2013</h3><h3 id=\"土建算量GTJ2013\"><a href=\"#土建算量GTJ2013\" class=\"headerlink\" title=\"土建算量GTJ2013\"></a>土建算量GTJ2013</h3><h3 id=\"BIM安装-装饰计量2019\"><a href=\"#BIM安装-装饰计量2019\" class=\"headerlink\" title=\"BIM安装/装饰计量2019\"></a>BIM安装/装饰计量2019</h3><p>广联达BIM安装计量软件是针对民用建筑安装全专业研发的一款工程量计算软件。GQI2019支持全专业BIM三维模式算量和手算模式算量，适用于所有电算化水平的安装造价和技术人员使用，兼容市场上所有电子版图纸的导入，包括CAD图纸、REVIT模型、PDF图纸、图片等。通过智能化识别，可视化三维显示、专业化计算规则、灵活化的工程量统计、无缝化的计价导入，全面解决安装专业各阶段手工计算效率低、难度大等问题。</p>\n<h3 id=\"BIM装饰设计2019\"><a href=\"#BIM装饰设计2019\" class=\"headerlink\" title=\"BIM装饰设计2019\"></a>BIM装饰设计2019</h3><h3 id=\"市政算量GMA2018\"><a href=\"#市政算量GMA2018\" class=\"headerlink\" title=\"市政算量GMA2018\"></a>市政算量GMA2018</h3><h3 id=\"公路工程计价软甲GHW\"><a href=\"#公路工程计价软甲GHW\" class=\"headerlink\" title=\"公路工程计价软甲GHW\"></a>公路工程计价软甲GHW</h3><p>新一代的公路工程计价产品GHW V2.0以公路行业造价业务为主线，围绕公路、桥梁、隧道等公路项目，以公路工程设计概算、施工图预算、招投标清单的编制和审核为核心，采用丰富的云应用+大数据体验，随时随地快速编制。</p>\n<ol>\n<li><p>云数据</p>\n</li>\n<li><p>保存所有组价方案</p>\n</li>\n<li><p>智能组价</p>\n</li>\n</ol>\n<h3 id=\"BIM钢结构算量\"><a href=\"#BIM钢结构算量\" class=\"headerlink\" title=\"BIM钢结构算量\"></a>BIM钢结构算量</h3><p>广联达BIM钢结构算量是基于BIM技术的全新应用，从三维算量的角度突破性解决了钢结构复杂、多变的节点问题，提供复杂构件的参数化建模，真正做到建模快、算量巧、报表全。</p>\n<ol>\n<li><p>可视化</p>\n</li>\n<li><p>建模快</p>\n</li>\n<li><p>报表全</p>\n</li>\n</ol>\n<h2 id=\"计价产品\"><a href=\"#计价产品\" class=\"headerlink\" title=\"计价产品\"></a>计价产品</h2><h3 id=\"云计价GCCP5\"><a href=\"#云计价GCCP5\" class=\"headerlink\" title=\"云计价GCCP5\"></a>云计价GCCP5</h3><p>广联达云计价平台GCCP5.0是迎合数字建筑平台服务商战略转型，为计价客户群，提供概算、预算、结算阶段的数据编制、审核、积累、分析和挖掘再利用的平台产品，于2015年研发完成并投放市场。平台基于大数据、云计算等信息技术，实现计价全业务一体化，全流程覆盖，从而使造价工作更高效、更智能。</p>\n<h2 id=\"产品分类\"><a href=\"#产品分类\" class=\"headerlink\" title=\"产品分类\"></a>产品分类</h2><p>造价管理  BIM建造  智慧工地  数字企业  信息服务  国际业务  企业协同  </p>\n<h2 id=\"产品标签\"><a href=\"#产品标签\" class=\"headerlink\" title=\"产品标签\"></a>产品标签</h2><p>BIM  建模  算量  计价  预结算  招投标  施工 云服务  市政交通  能源资源 大型建设</p>\n<h1 id=\"BIM-1\"><a href=\"#BIM-1\" class=\"headerlink\" title=\"BIM\"></a>BIM</h1><p>BIM技术从单纯的建模和管线综合等初级应用上升为规划，设计建造和运营等各个阶段的应用。它带来不仅仅是技术，也将带来新的工作流程，行业标准和规划。</p>\n<ol>\n<li><p>建设方</p>\n</li>\n<li><p>设计机构</p>\n</li>\n<li><p>施工机构</p>\n</li>\n<li><p>运营机构</p>\n</li>\n</ol>\n<p>运营机构对BIM技术的应用有如下几点：</p>\n<p>1）运用可视化的建筑模型，能够实现对物业管理以及设备的基本信息，能够依据设备的运行状况及时的安排设备的维修与保养或者更换设备。<br><br>２）能够记录设备维护与保养的过程，可以规范设备保养的步骤与过程。</p>\n<p>３）利用BIM模型辅助培训新员工，防止因人员的流动而造成工作效率与水平下降。<br><br>４）BIM设备维护管理系统有了一定的信息数据之后，就可以对其进行统计分析，为决策提供各类统计报表。</p>\n<p>５）当某设备发生故障时，在BIM设备维护系统中查看应急处理手册，做出第一步的快速应急处理．<br><br>６）可查看维护保养的步骤和流程，使用说明，维护保养记录等信息，以帮助确定故障设备的维修或更换方案，提高效率。</p>\n<p>７）可实时漫游，观察维修设备周围环境，以帮助确定维修工作面是否能够展开，维修工具是否能使用。</p>\n<ol start=\"5\">\n<li><p>造价咨询机构</p>\n</li>\n<li><p>软件行业</p>\n</li>\n</ol>\n<p>使国内的传统软件公司如<strong>广联达、鲁班、天正、PKPM</strong>等纷纷开发自己的BIM软件，但它们的功能和体验都有待改进。</p>\n<ol start=\"7\">\n<li>教育机构</li>\n</ol>\n<h2 id=\"BIM的特点\"><a href=\"#BIM的特点\" class=\"headerlink\" title=\"BIM的特点\"></a>BIM的特点</h2><ol>\n<li><p>可视化</p>\n</li>\n<li><p>关联性</p>\n</li>\n<li><p>互用性</p>\n</li>\n<li><p>协调性</p>\n</li>\n<li><p>模拟性</p>\n</li>\n<li><p>优化性</p>\n</li>\n<li><p>可出图性</p>\n</li>\n</ol>\n<h2 id=\"BIM的维度\"><a href=\"#BIM的维度\" class=\"headerlink\" title=\"BIM的维度\"></a>BIM的维度</h2><ol>\n<li><p>二维模型（平面）</p>\n</li>\n<li><p>三维模型:增加了Z方向和尺寸</p>\n</li>\n<li><p>四维模型：增加了时间的维度</p>\n</li>\n<li><p>五维模型：增加了成本的维度</p>\n</li>\n<li><p>六维/七维模型：六维指的是全生命周期、设施和能量的管理构件，七维模型则包括建筑的安全使用问题。</p>\n</li>\n</ol>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"BIM\"><a href=\"#BIM\" class=\"headerlink\" title=\"BIM\"></a>BIM</h1><p>BIM的核心技术包括专业建模软件、专业分析软件、专业出图软件、专业加工设备、专业测量设备、专业管理平台，而不同BIM专业软件之间的数据共享和交换技术是核心中的核心。</p>\n<p>BIM正向设计的主要矛盾为单一软件难以满足设计人员要求，而多种BIM专业软件虽能满足专业设计人员要求，但数据不兼容，难以进行协同设计。基于这个主要矛盾，邓雪原提出要采取“各施所长、信息共享”的多专业协同模式，并提出各专业BIM应用标准、三维协同设计、各专业数据共享、标准化数据管理的BIM技术路线。</p>\n<p>BIM致力于实现。装配式建筑应用、城市市政工程建设、建筑环境与能耗分析以及智慧城市建筑数据的建设与管理。</p>\n<p>Revit、ArchiCAD、PKPM、YJK、Tekla、MagiCAD、Rebro、Bentley、CATIA、AllPlan等多款BIM软件。</p>\n<h1 id=\"广联达\"><a href=\"#广联达\" class=\"headerlink\" title=\"广联达\"></a>广联达</h1><h2 id=\"公司介绍\"><a href=\"#公司介绍\" class=\"headerlink\" title=\"公司介绍\"></a>公司介绍</h2><p>作为<strong>建筑产业互联网平台服务商</strong>，广联达始终以专业精神锁定行业，期望通过互联网带来的自由、平等、开拓与创新精神，以开放、互联、共享、协同的平台化理念共同打造产业链新生态.</p>\n<p>广联达立足建筑产业，围绕建设工程项目的全生命周期，是提供以建设工程领域专业应用为核心基础支撑，以产业大数据、产业征信、产业金融等为增值服务的平台服务商。经过近二十年的发展，公司以BIM、云计算，国际化业务为战略支撑，产品从单一的预算软件扩展到包含工程造价、工程施工、工程信息、工程教育、项目管理、电子政务、电子商务，产业金融及投资并购等九大业务，近百款产品。为十七万企业用户、百万专业工程技术和管理人员提供了专业应用软件，用信息技术帮助建筑业内从业人员完成了工程造价、工程施工、工程项目管理等专业工作，大大提升工作效率，降低工程成本，促进行业技术与管理进步，增加企业效益，提高企业核心竞争力。同时广联达也在不断以创新互联网思维重构商业、运营和管理模式。</p>\n<h2 id=\"业务介绍\"><a href=\"#业务介绍\" class=\"headerlink\" title=\"业务介绍\"></a>业务介绍</h2><p>广联达立足建筑产业，围绕建设工程项目的全生命周期，是提供以建设工程领域专业应用为核心基础支撑，以产业大数据、产业征信、产业金融等为增值服务的平台服务商.</p>\n<p>专业应用：PC端应用:70余款产品，其中企业用户17万余家，工具类产品直接使用者60余万，管理类产品直接使用者100余万.</p>\n<p>移动端APP:20余款，互联网产品直接使用者300余万.</p>\n<p>硬件端应用:覆盖3000余个项目部，产品直接使用者3万余人.</p>\n<p>云空间: 已建立5000余项目空间.</p>\n<p>大数据服务：积累近2000个实际工程的指标数据，涵盖96个项目类型；</p>\n<p>积累形成了在工料机标准下的3000万条材料价格信息，1万条现场材料字典库；</p>\n<p>积累了建筑产业18万条专有词库及42万条行业关系库；</p>\n<p>芬兰PROGRAM公司MAGICAD产品中现已积累200多万BIM机电构件库；</p>\n<p>服务覆盖了20个省、3个直辖市和4个自治区；</p>\n<p>在美国硅谷建立大数据研究中心，在用户行为数据分析方面取得阶段性成果；</p>\n<p>“建筑工程信息数据服务整体解决方案”荣获中国信息技术服务产业2014-2015年度“中国大数据应用优秀创新实践奖”。</p>\n<p>电子商务：旺材电商为会员提供70多个品类、300个品种直供服务，超过1万类部品构件信息向会员企业免费开放。</p>\n<p>产业金融：业务涵盖：小贷、保理、保函等，两家互联网小贷子公司、一家商业保理子公司已经正式运营。全年累计发放贷款过1亿元，拨备覆盖率100%。</p>\n<p>国际化：2009年起开始国际化进程，美国、新加坡、香港、马来西亚、芬兰、英国分别设立子公司，带动东南亚、美洲、 欧洲区域市场。</p>\n<h2 id=\"计量产品\"><a href=\"#计量产品\" class=\"headerlink\" title=\"计量产品\"></a>计量产品</h2><h3 id=\"土建计量GTJ2018\"><a href=\"#土建计量GTJ2018\" class=\"headerlink\" title=\"土建计量GTJ2018\"></a>土建计量GTJ2018</h3><p>帮助工程造价企业和从业者解决土建专业估概算、招投标预算、施工进度变更、竣工结算全过程各阶段算量、提量、检查、审核全流程业务，实现一站式的BIM土建计量。</p>\n<h3 id=\"钢筋算量GGJ2013\"><a href=\"#钢筋算量GGJ2013\" class=\"headerlink\" title=\"钢筋算量GGJ2013\"></a>钢筋算量GGJ2013</h3><h3 id=\"土建算量GTJ2013\"><a href=\"#土建算量GTJ2013\" class=\"headerlink\" title=\"土建算量GTJ2013\"></a>土建算量GTJ2013</h3><h3 id=\"BIM安装-装饰计量2019\"><a href=\"#BIM安装-装饰计量2019\" class=\"headerlink\" title=\"BIM安装/装饰计量2019\"></a>BIM安装/装饰计量2019</h3><p>广联达BIM安装计量软件是针对民用建筑安装全专业研发的一款工程量计算软件。GQI2019支持全专业BIM三维模式算量和手算模式算量，适用于所有电算化水平的安装造价和技术人员使用，兼容市场上所有电子版图纸的导入，包括CAD图纸、REVIT模型、PDF图纸、图片等。通过智能化识别，可视化三维显示、专业化计算规则、灵活化的工程量统计、无缝化的计价导入，全面解决安装专业各阶段手工计算效率低、难度大等问题。</p>\n<h3 id=\"BIM装饰设计2019\"><a href=\"#BIM装饰设计2019\" class=\"headerlink\" title=\"BIM装饰设计2019\"></a>BIM装饰设计2019</h3><h3 id=\"市政算量GMA2018\"><a href=\"#市政算量GMA2018\" class=\"headerlink\" title=\"市政算量GMA2018\"></a>市政算量GMA2018</h3><h3 id=\"公路工程计价软甲GHW\"><a href=\"#公路工程计价软甲GHW\" class=\"headerlink\" title=\"公路工程计价软甲GHW\"></a>公路工程计价软甲GHW</h3><p>新一代的公路工程计价产品GHW V2.0以公路行业造价业务为主线，围绕公路、桥梁、隧道等公路项目，以公路工程设计概算、施工图预算、招投标清单的编制和审核为核心，采用丰富的云应用+大数据体验，随时随地快速编制。</p>\n<ol>\n<li><p>云数据</p>\n</li>\n<li><p>保存所有组价方案</p>\n</li>\n<li><p>智能组价</p>\n</li>\n</ol>\n<h3 id=\"BIM钢结构算量\"><a href=\"#BIM钢结构算量\" class=\"headerlink\" title=\"BIM钢结构算量\"></a>BIM钢结构算量</h3><p>广联达BIM钢结构算量是基于BIM技术的全新应用，从三维算量的角度突破性解决了钢结构复杂、多变的节点问题，提供复杂构件的参数化建模，真正做到建模快、算量巧、报表全。</p>\n<ol>\n<li><p>可视化</p>\n</li>\n<li><p>建模快</p>\n</li>\n<li><p>报表全</p>\n</li>\n</ol>\n<h2 id=\"计价产品\"><a href=\"#计价产品\" class=\"headerlink\" title=\"计价产品\"></a>计价产品</h2><h3 id=\"云计价GCCP5\"><a href=\"#云计价GCCP5\" class=\"headerlink\" title=\"云计价GCCP5\"></a>云计价GCCP5</h3><p>广联达云计价平台GCCP5.0是迎合数字建筑平台服务商战略转型，为计价客户群，提供概算、预算、结算阶段的数据编制、审核、积累、分析和挖掘再利用的平台产品，于2015年研发完成并投放市场。平台基于大数据、云计算等信息技术，实现计价全业务一体化，全流程覆盖，从而使造价工作更高效、更智能。</p>\n<h2 id=\"产品分类\"><a href=\"#产品分类\" class=\"headerlink\" title=\"产品分类\"></a>产品分类</h2><p>造价管理  BIM建造  智慧工地  数字企业  信息服务  国际业务  企业协同  </p>\n<h2 id=\"产品标签\"><a href=\"#产品标签\" class=\"headerlink\" title=\"产品标签\"></a>产品标签</h2><p>BIM  建模  算量  计价  预结算  招投标  施工 云服务  市政交通  能源资源 大型建设</p>\n<h1 id=\"BIM-1\"><a href=\"#BIM-1\" class=\"headerlink\" title=\"BIM\"></a>BIM</h1><p>BIM技术从单纯的建模和管线综合等初级应用上升为规划，设计建造和运营等各个阶段的应用。它带来不仅仅是技术，也将带来新的工作流程，行业标准和规划。</p>\n<ol>\n<li><p>建设方</p>\n</li>\n<li><p>设计机构</p>\n</li>\n<li><p>施工机构</p>\n</li>\n<li><p>运营机构</p>\n</li>\n</ol>\n<p>运营机构对BIM技术的应用有如下几点：</p>\n<p>1）运用可视化的建筑模型，能够实现对物业管理以及设备的基本信息，能够依据设备的运行状况及时的安排设备的维修与保养或者更换设备。<br><br>２）能够记录设备维护与保养的过程，可以规范设备保养的步骤与过程。</p>\n<p>３）利用BIM模型辅助培训新员工，防止因人员的流动而造成工作效率与水平下降。<br><br>４）BIM设备维护管理系统有了一定的信息数据之后，就可以对其进行统计分析，为决策提供各类统计报表。</p>\n<p>５）当某设备发生故障时，在BIM设备维护系统中查看应急处理手册，做出第一步的快速应急处理．<br><br>６）可查看维护保养的步骤和流程，使用说明，维护保养记录等信息，以帮助确定故障设备的维修或更换方案，提高效率。</p>\n<p>７）可实时漫游，观察维修设备周围环境，以帮助确定维修工作面是否能够展开，维修工具是否能使用。</p>\n<ol start=\"5\">\n<li><p>造价咨询机构</p>\n</li>\n<li><p>软件行业</p>\n</li>\n</ol>\n<p>使国内的传统软件公司如<strong>广联达、鲁班、天正、PKPM</strong>等纷纷开发自己的BIM软件，但它们的功能和体验都有待改进。</p>\n<ol start=\"7\">\n<li>教育机构</li>\n</ol>\n<h2 id=\"BIM的特点\"><a href=\"#BIM的特点\" class=\"headerlink\" title=\"BIM的特点\"></a>BIM的特点</h2><ol>\n<li><p>可视化</p>\n</li>\n<li><p>关联性</p>\n</li>\n<li><p>互用性</p>\n</li>\n<li><p>协调性</p>\n</li>\n<li><p>模拟性</p>\n</li>\n<li><p>优化性</p>\n</li>\n<li><p>可出图性</p>\n</li>\n</ol>\n<h2 id=\"BIM的维度\"><a href=\"#BIM的维度\" class=\"headerlink\" title=\"BIM的维度\"></a>BIM的维度</h2><ol>\n<li><p>二维模型（平面）</p>\n</li>\n<li><p>三维模型:增加了Z方向和尺寸</p>\n</li>\n<li><p>四维模型：增加了时间的维度</p>\n</li>\n<li><p>五维模型：增加了成本的维度</p>\n</li>\n<li><p>六维/七维模型：六维指的是全生命周期、设施和能量的管理构件，七维模型则包括建筑的安全使用问题。</p>\n</li>\n</ol>\n"},{"title":"「AppSo」页面流程还原","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-10-03T08:16:34.000Z","password":null,"summary":"AppSo 是一个让手机更好用的数字生活社区。","_content":"\n# 问题：「AppSo」页面流程还原\n在手机应用商店搜索「AppSo」，下载并体验，按以下要求完成作业：\n体验发布产品到「AppWall」的功能：体验整个功能逻辑：点击发布——搜索app——编写内容——等待审核——发布成功\n要求：梳理整个体验的页面流程\ntips：\n1. 区分页面层级\n\n2. 注意流程线流向，尽可能不交叉\n\n3. 梳理出页面跳转的触发点，提醒内容一并梳理出来\n\n4. 页面流程不是页面，不要贴页面上来~\n\n# 产品说明\nAppSo 是一个让手机更好用的数字生活社区。\n它让所有人轻松发现优秀（颜值高、功能好）的移动互联网产品，你还能了解到有关智能手机、个人电脑等科技产品的使用技巧，从此拥抱更有品质的数字生活。\n不管你是数码玩家、产品经理、创业者或是科技小白，我们都能让你成为优雅的数字生活家。\n\n# 使用环境\n产品名称：AppSo\n\n体验设备：iPhoneXs max\n\n系统版本：IOS 12\n\n# AppSo发布产品到AppWall的业务流程图\n![业务流程图](yewu.png)\n# AppSo发布产品到AppWall的页面流程\n![页面流程](yewu2.png)","source":"_posts/2019-PM-APPSO.md","raw":"---\ntitle: 「AppSo」页面流程还原\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-10-03 16:16:34\npassword:\nsummary: AppSo 是一个让手机更好用的数字生活社区。\ntags:\n- PM\ncategories:\n- PM\n---\n\n# 问题：「AppSo」页面流程还原\n在手机应用商店搜索「AppSo」，下载并体验，按以下要求完成作业：\n体验发布产品到「AppWall」的功能：体验整个功能逻辑：点击发布——搜索app——编写内容——等待审核——发布成功\n要求：梳理整个体验的页面流程\ntips：\n1. 区分页面层级\n\n2. 注意流程线流向，尽可能不交叉\n\n3. 梳理出页面跳转的触发点，提醒内容一并梳理出来\n\n4. 页面流程不是页面，不要贴页面上来~\n\n# 产品说明\nAppSo 是一个让手机更好用的数字生活社区。\n它让所有人轻松发现优秀（颜值高、功能好）的移动互联网产品，你还能了解到有关智能手机、个人电脑等科技产品的使用技巧，从此拥抱更有品质的数字生活。\n不管你是数码玩家、产品经理、创业者或是科技小白，我们都能让你成为优雅的数字生活家。\n\n# 使用环境\n产品名称：AppSo\n\n体验设备：iPhoneXs max\n\n系统版本：IOS 12\n\n# AppSo发布产品到AppWall的业务流程图\n![业务流程图](yewu.png)\n# AppSo发布产品到AppWall的页面流程\n![页面流程](yewu2.png)","slug":"2019-PM-APPSO","published":1,"updated":"2019-10-03T08:17:36.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxaj00072wvc0v9aouvh","content":"<h1 id=\"问题：「AppSo」页面流程还原\"><a href=\"#问题：「AppSo」页面流程还原\" class=\"headerlink\" title=\"问题：「AppSo」页面流程还原\"></a>问题：「AppSo」页面流程还原</h1><p>在手机应用商店搜索「AppSo」，下载并体验，按以下要求完成作业：<br>体验发布产品到「AppWall」的功能：体验整个功能逻辑：点击发布——搜索app——编写内容——等待审核——发布成功<br>要求：梳理整个体验的页面流程<br>tips：</p>\n<ol>\n<li><p>区分页面层级</p>\n</li>\n<li><p>注意流程线流向，尽可能不交叉</p>\n</li>\n<li><p>梳理出页面跳转的触发点，提醒内容一并梳理出来</p>\n</li>\n<li><p>页面流程不是页面，不要贴页面上来~</p>\n</li>\n</ol>\n<h1 id=\"产品说明\"><a href=\"#产品说明\" class=\"headerlink\" title=\"产品说明\"></a>产品说明</h1><p>AppSo 是一个让手机更好用的数字生活社区。<br>它让所有人轻松发现优秀（颜值高、功能好）的移动互联网产品，你还能了解到有关智能手机、个人电脑等科技产品的使用技巧，从此拥抱更有品质的数字生活。<br>不管你是数码玩家、产品经理、创业者或是科技小白，我们都能让你成为优雅的数字生活家。</p>\n<h1 id=\"使用环境\"><a href=\"#使用环境\" class=\"headerlink\" title=\"使用环境\"></a>使用环境</h1><p>产品名称：AppSo</p>\n<p>体验设备：iPhoneXs max</p>\n<p>系统版本：IOS 12</p>\n<h1 id=\"AppSo发布产品到AppWall的业务流程图\"><a href=\"#AppSo发布产品到AppWall的业务流程图\" class=\"headerlink\" title=\"AppSo发布产品到AppWall的业务流程图\"></a>AppSo发布产品到AppWall的业务流程图</h1><p><img src=\"yewu.png\" alt=\"业务流程图\"></p>\n<h1 id=\"AppSo发布产品到AppWall的页面流程\"><a href=\"#AppSo发布产品到AppWall的页面流程\" class=\"headerlink\" title=\"AppSo发布产品到AppWall的页面流程\"></a>AppSo发布产品到AppWall的页面流程</h1><p><img src=\"yewu2.png\" alt=\"页面流程\"></p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"问题：「AppSo」页面流程还原\"><a href=\"#问题：「AppSo」页面流程还原\" class=\"headerlink\" title=\"问题：「AppSo」页面流程还原\"></a>问题：「AppSo」页面流程还原</h1><p>在手机应用商店搜索「AppSo」，下载并体验，按以下要求完成作业：<br>体验发布产品到「AppWall」的功能：体验整个功能逻辑：点击发布——搜索app——编写内容——等待审核——发布成功<br>要求：梳理整个体验的页面流程<br>tips：</p>\n<ol>\n<li><p>区分页面层级</p>\n</li>\n<li><p>注意流程线流向，尽可能不交叉</p>\n</li>\n<li><p>梳理出页面跳转的触发点，提醒内容一并梳理出来</p>\n</li>\n<li><p>页面流程不是页面，不要贴页面上来~</p>\n</li>\n</ol>\n<h1 id=\"产品说明\"><a href=\"#产品说明\" class=\"headerlink\" title=\"产品说明\"></a>产品说明</h1><p>AppSo 是一个让手机更好用的数字生活社区。<br>它让所有人轻松发现优秀（颜值高、功能好）的移动互联网产品，你还能了解到有关智能手机、个人电脑等科技产品的使用技巧，从此拥抱更有品质的数字生活。<br>不管你是数码玩家、产品经理、创业者或是科技小白，我们都能让你成为优雅的数字生活家。</p>\n<h1 id=\"使用环境\"><a href=\"#使用环境\" class=\"headerlink\" title=\"使用环境\"></a>使用环境</h1><p>产品名称：AppSo</p>\n<p>体验设备：iPhoneXs max</p>\n<p>系统版本：IOS 12</p>\n<h1 id=\"AppSo发布产品到AppWall的业务流程图\"><a href=\"#AppSo发布产品到AppWall的业务流程图\" class=\"headerlink\" title=\"AppSo发布产品到AppWall的业务流程图\"></a>AppSo发布产品到AppWall的业务流程图</h1><p><img src=\"yewu.png\" alt=\"业务流程图\"></p>\n<h1 id=\"AppSo发布产品到AppWall的页面流程\"><a href=\"#AppSo发布产品到AppWall的页面流程\" class=\"headerlink\" title=\"AppSo发布产品到AppWall的页面流程\"></a>AppSo发布产品到AppWall的页面流程</h1><p><img src=\"yewu2.png\" alt=\"页面流程\"></p>\n"},{"title":"NASM-多自由度系统的非线性时程分析软件","top":true,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T01:25:08.000Z","password":null,"summary":"多自由度系统的非线性时程分析：NASM。","_content":"\n# 多自由度系统的非线性时程分析：NASM\nNASM 是用于执行多自由度（MDOF）系统的非线性时间时程分析的非商业性Matlab GUI。求解算法是Newmark常加速度法，EHHT法、KR-α、中心差分法（CDM），FFAST,Gui-λ、SEE-α法，采用Newton-Raphson迭代（Chopra第4版，表16.3.3）进行求解。\n# 简化模型\n## 本构模型输入\n本构模型可以有三种方式可供选择：线弹性模型，双线性模型，三线性模型，可以包括P-$\\Delta$效应。模型的本构关系如图1-3所示。  \n<div align=center> <img src=\"linear.JPG\" width=\"300\" title=\"图1：linear model\"/></div>   \n\n<div align=center> <img src=\"bilinear.JPG\" width=\"300\" title=\"图2：bilinear model\"/></div>   \n\n<div align=center> <img src=\"TrilinearModel.jpg\" width=\"300\" title=\"图3：Trilinear model\"/></div>   \n\n\n## 结构模型输入\nNASM 使用MDOF系统的剪切集中质量模型，其质量集中在端点（我们常说的糖葫芦串模型）。  \n用户通过.csv文件输入模型信息。  \n用户可以通过示例文件Model.csv进行模拟输入。   \n\n<div align=center> <img src=\"BludgModel.JPG\" width=\"200\" title=\"图4：Shear-building lumped-mass model\"/> </div>\n\n## 地震动输入\n用户通过.csv文件输入要分析的地面运动记录及其比例因子。提供了此文件的示例以供参考。每个地面运动的名称在第一行，第二行输入计算的点数，第三行的时间步长（$\\Delta t$），第四行的比例因子和加速时间序列（以[g为单位] ]）是从第五行到结尾。  \n如果第四行中指定的点数大于时间系列中的加速点数，则在记录末尾填充零以匹配指定的点数。例如，这对于正确估计残余变形特别有用。另一方面，如果第四行中指定的点数低于时间序列中的加速点数，则修改记录以匹配指定的点数。  \nNASM为用户提供两种选择：  \n1.按指定的比例因子分析每个地面运动；  \n2.缩放每个地面运动以获得导致崩溃的比例因子（在此选项中，忽略输入文件中指定的比例因子）。  \n## GUI界面输入\nNASM需要用户输入：  \n1.BuildingInformation 选取结构信息文件.csv；  \n2.Ground Motions 选择地震动信息文件.csv；  \n3.选取本构模型信息：包括linear、bilinear、trilinear三种本构模型，可以考虑P-Δ 效应；  \n4.选取合适的分析方法：AAM、CDM、EHHT、FFAST、MK-α、Gui-λ、SEE-α法，一共七种方法，接下来会更新更多的新方法，请期待后续......  \n5.选取振型阻尼比，阻尼采用瑞雷阻尼，请用户选取合适的振型及对应的阻尼比。  \n# 输出\n - 可视化输出\n \n NASM 提供了几种响应的可视化。它还能够在给定的地面运动下产生结构响应（Dis-time，ResForce-Dis）的视频。\n \n\n\n - 数据输出\n 用户可以从NASM导出不同的输出：\n\t* 每个地面运动中每个楼层的位移，层间位移，层间位移比（IDR），残余层间位移，Residual IDR，绝对速度，层间速度，总加速度和层间恢复力的最大值和最小值数据\n\t* 绝对位移、层间位移、IDR和层间恢复力的时程数据\n\t* 导致崩溃的比例因子\n\t* 每种方法计算的时间。\n所有的计算结果均以.xlsx文件导出。\n\n# 其他信息\n\nMATLAB版本采用MATLABR2018B教育版。\n\n# 第二次更新\n\n为NASM程序添加了启动页面，运行NASM.m文件即可进行进入界面。欢迎各位提建议和对图标以及启动界面进行设计。\n\n# 独立应用版本\n\nstandalone 版本更新完成。\n\n# Python脚本\n\n开发中\n\n# 参考文献\nNewmark常加速度法:NEWMARK N M. A method of computation for structural dynamics[J]. Journal of th engineering mechanics division, 1959, 85(3): 67–69  \n\nEHHT-$\\alpha$:本人基于HHT方法开发的一种新的双显示积分算法  \n\nKR-α:KOLAY C, RICLES J M. Development of a family of unconditionally stable explicit direc integration algorithms with controllable numerical energy dissipation[J]. Earthquak Engineering & Structural Dynamics, 2014, 43(9): 1361–1380.  \n\n中心差分法（CDM）:Subbaraj K, Dokainish M. A survey of direct time-integration methods in computationa structural dynamics—II. Implicit methods. Computers & Structures, 1989, 32(6):1387–1401.  \n\nFFAST:Zheng M, Yuan Z, Tong Q, et al. A novel unconditionally stable explicit integration metho for finite element method. The Visual Computer, 2018, 34(5):721–733.  \n\nGui-λ:桂耀. 一族双显式算法及其在实时耦联动力试验中的应用[Doctor Thesis]. 2014.  \n\nSEE-α法:Kolay C. Parametrically dissipative explicit direct integration algorithms for computationa and experimental structural dynamics. 2016.    \n\n****\n|Author|郭豪鑫|\n|---|---|\n|E-mail|guohaoxin@hotmail.com|\n","source":"_posts/2019-NASM.md","raw":"---\ntitle: NASM-多自由度系统的非线性时程分析软件\ntop: true\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 09:25:08\npassword:\nsummary: 多自由度系统的非线性时程分析：NASM。\ntags:\n- 软件 Matlab\ncategories:\n- 软件 \n---\n\n# 多自由度系统的非线性时程分析：NASM\nNASM 是用于执行多自由度（MDOF）系统的非线性时间时程分析的非商业性Matlab GUI。求解算法是Newmark常加速度法，EHHT法、KR-α、中心差分法（CDM），FFAST,Gui-λ、SEE-α法，采用Newton-Raphson迭代（Chopra第4版，表16.3.3）进行求解。\n# 简化模型\n## 本构模型输入\n本构模型可以有三种方式可供选择：线弹性模型，双线性模型，三线性模型，可以包括P-$\\Delta$效应。模型的本构关系如图1-3所示。  \n<div align=center> <img src=\"linear.JPG\" width=\"300\" title=\"图1：linear model\"/></div>   \n\n<div align=center> <img src=\"bilinear.JPG\" width=\"300\" title=\"图2：bilinear model\"/></div>   \n\n<div align=center> <img src=\"TrilinearModel.jpg\" width=\"300\" title=\"图3：Trilinear model\"/></div>   \n\n\n## 结构模型输入\nNASM 使用MDOF系统的剪切集中质量模型，其质量集中在端点（我们常说的糖葫芦串模型）。  \n用户通过.csv文件输入模型信息。  \n用户可以通过示例文件Model.csv进行模拟输入。   \n\n<div align=center> <img src=\"BludgModel.JPG\" width=\"200\" title=\"图4：Shear-building lumped-mass model\"/> </div>\n\n## 地震动输入\n用户通过.csv文件输入要分析的地面运动记录及其比例因子。提供了此文件的示例以供参考。每个地面运动的名称在第一行，第二行输入计算的点数，第三行的时间步长（$\\Delta t$），第四行的比例因子和加速时间序列（以[g为单位] ]）是从第五行到结尾。  \n如果第四行中指定的点数大于时间系列中的加速点数，则在记录末尾填充零以匹配指定的点数。例如，这对于正确估计残余变形特别有用。另一方面，如果第四行中指定的点数低于时间序列中的加速点数，则修改记录以匹配指定的点数。  \nNASM为用户提供两种选择：  \n1.按指定的比例因子分析每个地面运动；  \n2.缩放每个地面运动以获得导致崩溃的比例因子（在此选项中，忽略输入文件中指定的比例因子）。  \n## GUI界面输入\nNASM需要用户输入：  \n1.BuildingInformation 选取结构信息文件.csv；  \n2.Ground Motions 选择地震动信息文件.csv；  \n3.选取本构模型信息：包括linear、bilinear、trilinear三种本构模型，可以考虑P-Δ 效应；  \n4.选取合适的分析方法：AAM、CDM、EHHT、FFAST、MK-α、Gui-λ、SEE-α法，一共七种方法，接下来会更新更多的新方法，请期待后续......  \n5.选取振型阻尼比，阻尼采用瑞雷阻尼，请用户选取合适的振型及对应的阻尼比。  \n# 输出\n - 可视化输出\n \n NASM 提供了几种响应的可视化。它还能够在给定的地面运动下产生结构响应（Dis-time，ResForce-Dis）的视频。\n \n\n\n - 数据输出\n 用户可以从NASM导出不同的输出：\n\t* 每个地面运动中每个楼层的位移，层间位移，层间位移比（IDR），残余层间位移，Residual IDR，绝对速度，层间速度，总加速度和层间恢复力的最大值和最小值数据\n\t* 绝对位移、层间位移、IDR和层间恢复力的时程数据\n\t* 导致崩溃的比例因子\n\t* 每种方法计算的时间。\n所有的计算结果均以.xlsx文件导出。\n\n# 其他信息\n\nMATLAB版本采用MATLABR2018B教育版。\n\n# 第二次更新\n\n为NASM程序添加了启动页面，运行NASM.m文件即可进行进入界面。欢迎各位提建议和对图标以及启动界面进行设计。\n\n# 独立应用版本\n\nstandalone 版本更新完成。\n\n# Python脚本\n\n开发中\n\n# 参考文献\nNewmark常加速度法:NEWMARK N M. A method of computation for structural dynamics[J]. Journal of th engineering mechanics division, 1959, 85(3): 67–69  \n\nEHHT-$\\alpha$:本人基于HHT方法开发的一种新的双显示积分算法  \n\nKR-α:KOLAY C, RICLES J M. Development of a family of unconditionally stable explicit direc integration algorithms with controllable numerical energy dissipation[J]. Earthquak Engineering & Structural Dynamics, 2014, 43(9): 1361–1380.  \n\n中心差分法（CDM）:Subbaraj K, Dokainish M. A survey of direct time-integration methods in computationa structural dynamics—II. Implicit methods. Computers & Structures, 1989, 32(6):1387–1401.  \n\nFFAST:Zheng M, Yuan Z, Tong Q, et al. A novel unconditionally stable explicit integration metho for finite element method. The Visual Computer, 2018, 34(5):721–733.  \n\nGui-λ:桂耀. 一族双显式算法及其在实时耦联动力试验中的应用[Doctor Thesis]. 2014.  \n\nSEE-α法:Kolay C. Parametrically dissipative explicit direct integration algorithms for computationa and experimental structural dynamics. 2016.    \n\n****\n|Author|郭豪鑫|\n|---|---|\n|E-mail|guohaoxin@hotmail.com|\n","slug":"2019-NASM","published":1,"updated":"2019-09-30T03:03:45.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxam00092wvclhz7z0t7","content":"<h1 id=\"多自由度系统的非线性时程分析：NASM\"><a href=\"#多自由度系统的非线性时程分析：NASM\" class=\"headerlink\" title=\"多自由度系统的非线性时程分析：NASM\"></a>多自由度系统的非线性时程分析：NASM</h1><p>NASM 是用于执行多自由度（MDOF）系统的非线性时间时程分析的非商业性Matlab GUI。求解算法是Newmark常加速度法，EHHT法、KR-α、中心差分法（CDM），FFAST,Gui-λ、SEE-α法，采用Newton-Raphson迭代（Chopra第4版，表16.3.3）进行求解。</p>\n<h1 id=\"简化模型\"><a href=\"#简化模型\" class=\"headerlink\" title=\"简化模型\"></a>简化模型</h1><h2 id=\"本构模型输入\"><a href=\"#本构模型输入\" class=\"headerlink\" title=\"本构模型输入\"></a>本构模型输入</h2><p>本构模型可以有三种方式可供选择：线弹性模型，双线性模型，三线性模型，可以包括P-$\\Delta$效应。模型的本构关系如图1-3所示。  </p>\n<div align=\"center\"> <img src=\"linear.JPG\" width=\"300\" title=\"图1：linear model\"></div>   \n\n<div align=\"center\"> <img src=\"bilinear.JPG\" width=\"300\" title=\"图2：bilinear model\"></div>   \n\n<div align=\"center\"> <img src=\"TrilinearModel.jpg\" width=\"300\" title=\"图3：Trilinear model\"></div>   \n\n\n<h2 id=\"结构模型输入\"><a href=\"#结构模型输入\" class=\"headerlink\" title=\"结构模型输入\"></a>结构模型输入</h2><p>NASM 使用MDOF系统的剪切集中质量模型，其质量集中在端点（我们常说的糖葫芦串模型）。<br>用户通过.csv文件输入模型信息。<br>用户可以通过示例文件Model.csv进行模拟输入。   </p>\n<div align=\"center\"> <img src=\"BludgModel.JPG\" width=\"200\" title=\"图4：Shear-building lumped-mass model\"> </div>\n\n<h2 id=\"地震动输入\"><a href=\"#地震动输入\" class=\"headerlink\" title=\"地震动输入\"></a>地震动输入</h2><p>用户通过.csv文件输入要分析的地面运动记录及其比例因子。提供了此文件的示例以供参考。每个地面运动的名称在第一行，第二行输入计算的点数，第三行的时间步长（$\\Delta t$），第四行的比例因子和加速时间序列（以[g为单位] ]）是从第五行到结尾。<br>如果第四行中指定的点数大于时间系列中的加速点数，则在记录末尾填充零以匹配指定的点数。例如，这对于正确估计残余变形特别有用。另一方面，如果第四行中指定的点数低于时间序列中的加速点数，则修改记录以匹配指定的点数。<br>NASM为用户提供两种选择：<br>1.按指定的比例因子分析每个地面运动；<br>2.缩放每个地面运动以获得导致崩溃的比例因子（在此选项中，忽略输入文件中指定的比例因子）。  </p>\n<h2 id=\"GUI界面输入\"><a href=\"#GUI界面输入\" class=\"headerlink\" title=\"GUI界面输入\"></a>GUI界面输入</h2><p>NASM需要用户输入：<br>1.BuildingInformation 选取结构信息文件.csv；<br>2.Ground Motions 选择地震动信息文件.csv；<br>3.选取本构模型信息：包括linear、bilinear、trilinear三种本构模型，可以考虑P-Δ 效应；<br>4.选取合适的分析方法：AAM、CDM、EHHT、FFAST、MK-α、Gui-λ、SEE-α法，一共七种方法，接下来会更新更多的新方法，请期待后续……<br>5.选取振型阻尼比，阻尼采用瑞雷阻尼，请用户选取合适的振型及对应的阻尼比。  </p>\n<h1 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h1><ul>\n<li><p>可视化输出</p>\n<p>NASM 提供了几种响应的可视化。它还能够在给定的地面运动下产生结构响应（Dis-time，ResForce-Dis）的视频。</p>\n</li>\n</ul>\n<ul>\n<li>数据输出<br>用户可以从NASM导出不同的输出：<ul>\n<li>每个地面运动中每个楼层的位移，层间位移，层间位移比（IDR），残余层间位移，Residual IDR，绝对速度，层间速度，总加速度和层间恢复力的最大值和最小值数据</li>\n<li>绝对位移、层间位移、IDR和层间恢复力的时程数据</li>\n<li>导致崩溃的比例因子</li>\n<li>每种方法计算的时间。<br>所有的计算结果均以.xlsx文件导出。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"其他信息\"><a href=\"#其他信息\" class=\"headerlink\" title=\"其他信息\"></a>其他信息</h1><p>MATLAB版本采用MATLABR2018B教育版。</p>\n<h1 id=\"第二次更新\"><a href=\"#第二次更新\" class=\"headerlink\" title=\"第二次更新\"></a>第二次更新</h1><p>为NASM程序添加了启动页面，运行NASM.m文件即可进行进入界面。欢迎各位提建议和对图标以及启动界面进行设计。</p>\n<h1 id=\"独立应用版本\"><a href=\"#独立应用版本\" class=\"headerlink\" title=\"独立应用版本\"></a>独立应用版本</h1><p>standalone 版本更新完成。</p>\n<h1 id=\"Python脚本\"><a href=\"#Python脚本\" class=\"headerlink\" title=\"Python脚本\"></a>Python脚本</h1><p>开发中</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>Newmark常加速度法:NEWMARK N M. A method of computation for structural dynamics[J]. Journal of th engineering mechanics division, 1959, 85(3): 67–69  </p>\n<p>EHHT-$\\alpha$:本人基于HHT方法开发的一种新的双显示积分算法  </p>\n<p>KR-α:KOLAY C, RICLES J M. Development of a family of unconditionally stable explicit direc integration algorithms with controllable numerical energy dissipation[J]. Earthquak Engineering &amp; Structural Dynamics, 2014, 43(9): 1361–1380.  </p>\n<p>中心差分法（CDM）:Subbaraj K, Dokainish M. A survey of direct time-integration methods in computationa structural dynamics—II. Implicit methods. Computers &amp; Structures, 1989, 32(6):1387–1401.  </p>\n<p>FFAST:Zheng M, Yuan Z, Tong Q, et al. A novel unconditionally stable explicit integration metho for finite element method. The Visual Computer, 2018, 34(5):721–733.  </p>\n<p>Gui-λ:桂耀. 一族双显式算法及其在实时耦联动力试验中的应用[Doctor Thesis]. 2014.  </p>\n<p>SEE-α法:Kolay C. Parametrically dissipative explicit direct integration algorithms for computationa and experimental structural dynamics. 2016.    </p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>Author</th>\n<th>郭豪鑫</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>E-mail</td>\n<td><a href=\"mailto:guohaoxin@hotmail.com\" target=\"_blank\" rel=\"noopener\">guohaoxin@hotmail.com</a></td>\n</tr>\n</tbody></table>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"多自由度系统的非线性时程分析：NASM\"><a href=\"#多自由度系统的非线性时程分析：NASM\" class=\"headerlink\" title=\"多自由度系统的非线性时程分析：NASM\"></a>多自由度系统的非线性时程分析：NASM</h1><p>NASM 是用于执行多自由度（MDOF）系统的非线性时间时程分析的非商业性Matlab GUI。求解算法是Newmark常加速度法，EHHT法、KR-α、中心差分法（CDM），FFAST,Gui-λ、SEE-α法，采用Newton-Raphson迭代（Chopra第4版，表16.3.3）进行求解。</p>\n<h1 id=\"简化模型\"><a href=\"#简化模型\" class=\"headerlink\" title=\"简化模型\"></a>简化模型</h1><h2 id=\"本构模型输入\"><a href=\"#本构模型输入\" class=\"headerlink\" title=\"本构模型输入\"></a>本构模型输入</h2><p>本构模型可以有三种方式可供选择：线弹性模型，双线性模型，三线性模型，可以包括P-$\\Delta$效应。模型的本构关系如图1-3所示。  </p>\n<div align=\"center\"> <img src=\"linear.JPG\" width=\"300\" title=\"图1：linear model\"></div>   \n\n<div align=\"center\"> <img src=\"bilinear.JPG\" width=\"300\" title=\"图2：bilinear model\"></div>   \n\n<div align=\"center\"> <img src=\"TrilinearModel.jpg\" width=\"300\" title=\"图3：Trilinear model\"></div>   \n\n\n<h2 id=\"结构模型输入\"><a href=\"#结构模型输入\" class=\"headerlink\" title=\"结构模型输入\"></a>结构模型输入</h2><p>NASM 使用MDOF系统的剪切集中质量模型，其质量集中在端点（我们常说的糖葫芦串模型）。<br>用户通过.csv文件输入模型信息。<br>用户可以通过示例文件Model.csv进行模拟输入。   </p>\n<div align=\"center\"> <img src=\"BludgModel.JPG\" width=\"200\" title=\"图4：Shear-building lumped-mass model\"> </div>\n\n<h2 id=\"地震动输入\"><a href=\"#地震动输入\" class=\"headerlink\" title=\"地震动输入\"></a>地震动输入</h2><p>用户通过.csv文件输入要分析的地面运动记录及其比例因子。提供了此文件的示例以供参考。每个地面运动的名称在第一行，第二行输入计算的点数，第三行的时间步长（$\\Delta t$），第四行的比例因子和加速时间序列（以[g为单位] ]）是从第五行到结尾。<br>如果第四行中指定的点数大于时间系列中的加速点数，则在记录末尾填充零以匹配指定的点数。例如，这对于正确估计残余变形特别有用。另一方面，如果第四行中指定的点数低于时间序列中的加速点数，则修改记录以匹配指定的点数。<br>NASM为用户提供两种选择：<br>1.按指定的比例因子分析每个地面运动；<br>2.缩放每个地面运动以获得导致崩溃的比例因子（在此选项中，忽略输入文件中指定的比例因子）。  </p>\n<h2 id=\"GUI界面输入\"><a href=\"#GUI界面输入\" class=\"headerlink\" title=\"GUI界面输入\"></a>GUI界面输入</h2><p>NASM需要用户输入：<br>1.BuildingInformation 选取结构信息文件.csv；<br>2.Ground Motions 选择地震动信息文件.csv；<br>3.选取本构模型信息：包括linear、bilinear、trilinear三种本构模型，可以考虑P-Δ 效应；<br>4.选取合适的分析方法：AAM、CDM、EHHT、FFAST、MK-α、Gui-λ、SEE-α法，一共七种方法，接下来会更新更多的新方法，请期待后续……<br>5.选取振型阻尼比，阻尼采用瑞雷阻尼，请用户选取合适的振型及对应的阻尼比。  </p>\n<h1 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h1><ul>\n<li><p>可视化输出</p>\n<p>NASM 提供了几种响应的可视化。它还能够在给定的地面运动下产生结构响应（Dis-time，ResForce-Dis）的视频。</p>\n</li>\n</ul>\n<ul>\n<li>数据输出<br>用户可以从NASM导出不同的输出：<ul>\n<li>每个地面运动中每个楼层的位移，层间位移，层间位移比（IDR），残余层间位移，Residual IDR，绝对速度，层间速度，总加速度和层间恢复力的最大值和最小值数据</li>\n<li>绝对位移、层间位移、IDR和层间恢复力的时程数据</li>\n<li>导致崩溃的比例因子</li>\n<li>每种方法计算的时间。<br>所有的计算结果均以.xlsx文件导出。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"其他信息\"><a href=\"#其他信息\" class=\"headerlink\" title=\"其他信息\"></a>其他信息</h1><p>MATLAB版本采用MATLABR2018B教育版。</p>\n<h1 id=\"第二次更新\"><a href=\"#第二次更新\" class=\"headerlink\" title=\"第二次更新\"></a>第二次更新</h1><p>为NASM程序添加了启动页面，运行NASM.m文件即可进行进入界面。欢迎各位提建议和对图标以及启动界面进行设计。</p>\n<h1 id=\"独立应用版本\"><a href=\"#独立应用版本\" class=\"headerlink\" title=\"独立应用版本\"></a>独立应用版本</h1><p>standalone 版本更新完成。</p>\n<h1 id=\"Python脚本\"><a href=\"#Python脚本\" class=\"headerlink\" title=\"Python脚本\"></a>Python脚本</h1><p>开发中</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>Newmark常加速度法:NEWMARK N M. A method of computation for structural dynamics[J]. Journal of th engineering mechanics division, 1959, 85(3): 67–69  </p>\n<p>EHHT-$\\alpha$:本人基于HHT方法开发的一种新的双显示积分算法  </p>\n<p>KR-α:KOLAY C, RICLES J M. Development of a family of unconditionally stable explicit direc integration algorithms with controllable numerical energy dissipation[J]. Earthquak Engineering &amp; Structural Dynamics, 2014, 43(9): 1361–1380.  </p>\n<p>中心差分法（CDM）:Subbaraj K, Dokainish M. A survey of direct time-integration methods in computationa structural dynamics—II. Implicit methods. Computers &amp; Structures, 1989, 32(6):1387–1401.  </p>\n<p>FFAST:Zheng M, Yuan Z, Tong Q, et al. A novel unconditionally stable explicit integration metho for finite element method. The Visual Computer, 2018, 34(5):721–733.  </p>\n<p>Gui-λ:桂耀. 一族双显式算法及其在实时耦联动力试验中的应用[Doctor Thesis]. 2014.  </p>\n<p>SEE-α法:Kolay C. Parametrically dissipative explicit direct integration algorithms for computationa and experimental structural dynamics. 2016.    </p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>Author</th>\n<th>郭豪鑫</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>E-mail</td>\n<td><a href=\"mailto:guohaoxin@hotmail.com\" target=\"_blank\" rel=\"noopener\">guohaoxin@hotmail.com</a></td>\n</tr>\n</tbody></table>\n"},{"title":"Opensees介绍","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T09:39:25.000Z","password":null,"summary":"本文针对OpenSees在地震工程领域的独特优势，对软件结构整体进行详细分解和剖析，为OpenSees的学习和二次开发提供参考。","_content":"\n本文针对OpenSees在地震工程领域的独特优势，对软件结构整体进行详细分解和剖析，为OpenSees的学习和二次开发提供参考。\n# Opensees中的基本概念\n======================\nOpenSees全称是Open System for Earthquake Engineerting\nSimulation，是土木工程学术界广泛使用的有限元分析软件和地震工程模拟平台。\n作为新一代的有限元计算软件，OpenSees致力于强非线性分析，具有丰富的非线性单元、材料库和针对强非线性分析开发的算法，可用于分析非线性岩土和结构体系。\nOpenSees程序自1999年正式推出以来，已广泛用于太平洋地震工程研究中心和美国其它一些大学和科研机构的科研项目中，较好的模拟了包括钢筋混凝土结构、桥梁、岩土工程在内众多的实际工程和振动台试验项目，证明其具有较好的非线性数值模拟精度。该程序正在引起世界各国结构工程领域众多研究人员的关注和重视，而在国内也开始有少数学校开展了一些初步的学习和相关的研究工作。\n作为国外具有一定影响的分析程序和开发平台，\nOpenSees还具有以下一些突出特点：便于改进，易于协同开发，保持国际同步。OpenSees主要用于结构和岩土方面的地震反应模拟。可以实现的分析包括：简单的静力线弹性分析，静力非线性分析，截面分析，模态分析，Pushover拟动力分析，动力线弹性分析和复杂的动力非线性分析等；还可用于结构和岩土体系在地震作用下的可靠度及灵敏度的分析。自从1999年推出以来，该软件不断进行升级和提高，加入了许多新的材料和单元，引入了许多业已成熟的Fortran库文件为己所用(如FEAP、FEDEAS材料)，更新了高效实用的运算法则和判敛准则，允许多点输入地震波纪录，并不断提高运算中的内存管理水平和计算效率，允许用户在脚本层面上对分析进行更多控制。\nOpenSees的另一个优点就是使用面向对象的先进程序框架设计，基于C++的源代码公开有限元程序，方便使用者按照自己的需求进行二次开发。并且，基于此框架易于实现并行计算。它的主要特点归纳如下：\n（1）源码公开，学术界共同开发和共享代码，实现科研合作，持续集成最新科研成果；\n（2）OpenSees突出强非线性（土和结构非线性），针对强非线性开发的算法；\n（3）基于C++面向对象的先进程序框架设计以及基于此构架先进的并行计算方法；\n（4）敏感性可靠度和优化分析；\n（5）高性能云计算，比如Open Science Grid、TerraGrid;\n（6）通过OpenFresco等技术，实现和其他系统的集成以及混合实验等。\n# Tcl命令语言简介\n=================\n选择了Tcl脚本语言来支持OpenSees命令，这些命令用于定义问题几何，加载，配方和解决方案。这些命令是具有特定任务的单行命令。Tcl语言提供了有用的编程工具，如变量操作，数学表达式评估和控制结构。\nTcl是一个基于字符串的脚本语言，它允许以下内容：\n（1）变量和变量替换\n（2）数学表达评估\n（3）基本的控制结构(if , while, for, foreach)\n（4）程序\n（5）文件操作\n有关Tcl命令的更多信息可以在其网站上找到：Tcl / Tk\n[Primer](http://dev.scriptics.com/scripting/primer.html)\nTcl语言命令：\n*incr* - Increment the value of a variable（增加一个变量的值）:\n*set a 1*\n*incr a*\n参考:\nBrent Welch \\<welch\\@acm.org\\>, Ken Jones, and Jeff Hobbs: \n[Practical Programming in Tcl and Tk,](http://www.beedub.com/book/) \n[4th Edition ISBN:0-13-038560-3, June, 2003](http://www.beedub.com/book/)\n## Tcl命令格式\n---------------\nTcl脚本由用新行或分号（;）分隔的命令组成。\nTcl命令的基本语法是：\n*command \\$arg1 \\$arg2 ...*\ncommand? ：Tcl命令的名称或用户定义的过程\n\\$arg1 \\$arg2 ：命令参数\nTcl允许任何参数嵌套命令：\n*command [nested-command1] [nested-command2]*\n其中[]用于分隔嵌套的命令。Tcl解释器将首先评估嵌套命令，然后评估外部命令，并将结果嵌入到嵌套命令中。\nTcl中最基本的命令是set命令：\n*set variable \\$value*\n例如：\n*set a 5*\nTcl解释器认为一个以井号（＃）开始的命令是一个注释语句，所以它不会执行＃之后的任何内容。例如：\n*＃*这个命令给变量a赋值5\n*set a 5*\n英镑符号和分号可以一起用来将注释放在与命令相同的行上。例如：\n*set a 5*； ＃这个命令给变量a赋值5\nTcl命令示例，如下表所示。\n*set a*\n## Tcl命令示例\n---------------\n\n| Arithmetic       | procedure                                                                                                                                                                           | for& foreach functions                                                                                                                               |\n|------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *\\>set a 1 1 \\>set b a a \\>set b \\$a 1 \\>expr 2 + 3 5 \\>expr 2 + \\$a 3 \\>set b [expr 2 + \\$a] 3 \\>*                    | *\\>proc sum {a b} { return [expr \\$a + \\$b] } \\>sum 2 3 5 \\>set c [sum 2 3] 5 \\>*                                                                                                   | *for {set i 1} {\\$i \\< 10} {incr i 1} \n{ puts \"i equals \\$i\" } set sum 0 foreach value {1 2 3 4} { set sum [expr \\$sum + \\$value] } puts \\$sum 10 \\>* |\n| file manipulation                                                                                                      | procedure & if statement                                                                                                                                                            |                                                                                                                                                      |\n| *\\>set fileId [open tmp w] anumber \\>puts \\$fileId \"hello\" \\>close \\$fileID \\>type tmp hello \\> \\>source Example1.tcl* | *\\>proc guess {value} { global sum if {\\$value \\< \\$sum} { puts \"too low\" } else { if {\\$value \\> \\$sum} { puts \"too high\" } else { puts \"you got it!\"} } } \\> guess 9 too low \\>*  |                                                                                                                                                      |\n\n##  Tcl的其他资源\n-----------------\n<http://www.freeprogrammingresources.com/tcl.html>;\nhttp://www.tcl.tk/man/Tcl/Tkmanualpages;\n<http://www.mit.edu/afs/sipb/user/golem/doc/tcltk-iap2000/TclTk1.html>\n(通过在一个简短的程序中描述它们的实现来描述许多命令的教程);\n<http://www.beedub.com/book/>\n(一些来自Tcl和Tk的编程实例的章节，由Welch和Jones编写);\nhttp://philip.greenspun.com/tcl/;\n<http://www.tcl.tk/scripting/>;\n<http://hegel.ittc.ukans.edu/topics/tcltk/tutorial-noplugin/index.htm>\n（一个关于基本Tcl命令的简短教程，在下面的网站中也包含一个Tcl / Tk命令手册）\n## OpenSees编译器\n------------------\n\nOpenSees的主要抽象将使用OpenSees解释器进行解释。解释器是Tcl脚本语言的扩展。OpenSees解释器将命令添加到Tcl进行有限元分析。这些命令中的每一个都与提供的C\n++过程相关联。解释器调用这个过程来解析命令。在这个文档中，我们只概述那些被OpenSees添加到Tcl中的命令。\n\n对于OpenSees，我们向Tcl添加了有限元分析的命令：\n\n*Modeling* – create nodes, elements, loads and\nconstraints（创建节点，元素，载荷和约束）；\n\n*Analysis* – specify the analysis procedure（指定分析过程）\n\n*Output specification* – specify what it is you want to monitor during the\nanalysis（指定在分析过程中要监视的内容）\n\n# Opensees 基本概况\n===================\n\n# OpenSees概述\n----------------\n\nOpenSees的全称是Open System for Earthquake Engineering Simulation\n（地震工程模拟的开放体系）。它是由美国国家自然科学基金（NSF）资助、西部大学联盟“太平洋地震工程研究中心”（Pacific\nEarthquake Engineering Research\nCenter，简称PEER）主导、加州大学伯克利分校为主研发而成的、用于结构和岩土方面地震反应模拟的一个较为全面且不断发展的开放的程序软件体系。\n\n在Silvia Mazzoni, Frank McKenna, Michael H. Scott, Gregory L.\nFenves等人编写的OpenSEES的Users Manual (v2.0)开篇，是这样回答“What is\nOpenSees?”这个问题：\n\n（1）它是用有限元方法模拟地震工程应用的软件框架。 OpenSees不是一个代码；\n\n（2）在PEER，NEES及其以外的交流机制，交流和建立研究成果；\n\n（3）作为开源软件，它具有建立地震工程社区代码的潜力。\n\nOpenSees可以描述一个结构/模型。多个级别组件：\n\n![图1](114b5d55abb9b8a74bb18b1bcb0a2dca.png)\n\n![图2](3a04b2f3ba77e09e1d4a195a723210b2.png)\n\n传统的代码与OpenSees代码对比\n\n![图3](46afa9afcf5fa20bf42a6c9a6f73d79e.png)\n\n**Opensees计算仿真分区**\n\nOpenSees由一组模块组成，用于执行有限元模型的创建，分析过程的说明，分析过程中要监测的量的选择以及结果的输出。\n在每个有限元分析中，使用分析来构建4个主要类型的主题，如下图所示：\n\n![图4](3b1adcfc091178afbb2f106514eed312.png)\n\nDomain对象负责存储由ModelBuilder对象创建的对象，并提供对这些对象的分析和记录器对象的访问权限。\n\n![图6](3a471a82ccc457c44eba5125317e883a.png)\n\nAnalysis对象负责执行分析。分析将模型从t时刻的状态转移到t +\ndt时刻的状态。这可能会从简单的静态线性分析到瞬态非线性分析。在OpenSees中，每个Analysis对象由多个组件对象组成，这些组件对象定义了如何执行分析的分析类型。\n\n![图7](df03b2f5e7ca2bcccbbfaa784be671c3.png)\n\n3.2 OpenSees 特性\n-----------------\n\n为什么选择OpenSees？\n\n（1）材料，元素和分析命令库使得OpenSees成为非线性结构和岩土系统数值模拟的强大工具；\n\n（2）OpenSees组件库不断增长，处于数值模拟模型的前沿；\n\n（3）OpenSees界面基于命令驱动的脚本语言，使用户能够创建更多功能的输入文件；\n\n（4）OpenSees不是黑匣子，使其成为数值模拟的有用教育工具；\n\n（5）可以创建自己的材料，元素或分析工具，并将它们合并到OpenSees machine中；\n\n（6）NEES正在支持将OpenSees集成为实验室测试的模拟组件。\n\n模型：\n- 线性和非线性结构和岩土模型\n模拟：\n- static push-over analyses\n- static reversed-cyclic analyses\n- dynamic time-series analyses\n- uniform-support excitation\n- multi-support excitation\n","source":"_posts/2019-Opensees.md","raw":"---\ntitle: Opensees介绍\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 17:39:25\npassword:\nsummary: 本文针对OpenSees在地震工程领域的独特优势，对软件结构整体进行详细分解和剖析，为OpenSees的学习和二次开发提供参考。\ntags:\n- 读书笔记 Opensees\ncategories:\n- 读书笔记\n---\n\n本文针对OpenSees在地震工程领域的独特优势，对软件结构整体进行详细分解和剖析，为OpenSees的学习和二次开发提供参考。\n# Opensees中的基本概念\n======================\nOpenSees全称是Open System for Earthquake Engineerting\nSimulation，是土木工程学术界广泛使用的有限元分析软件和地震工程模拟平台。\n作为新一代的有限元计算软件，OpenSees致力于强非线性分析，具有丰富的非线性单元、材料库和针对强非线性分析开发的算法，可用于分析非线性岩土和结构体系。\nOpenSees程序自1999年正式推出以来，已广泛用于太平洋地震工程研究中心和美国其它一些大学和科研机构的科研项目中，较好的模拟了包括钢筋混凝土结构、桥梁、岩土工程在内众多的实际工程和振动台试验项目，证明其具有较好的非线性数值模拟精度。该程序正在引起世界各国结构工程领域众多研究人员的关注和重视，而在国内也开始有少数学校开展了一些初步的学习和相关的研究工作。\n作为国外具有一定影响的分析程序和开发平台，\nOpenSees还具有以下一些突出特点：便于改进，易于协同开发，保持国际同步。OpenSees主要用于结构和岩土方面的地震反应模拟。可以实现的分析包括：简单的静力线弹性分析，静力非线性分析，截面分析，模态分析，Pushover拟动力分析，动力线弹性分析和复杂的动力非线性分析等；还可用于结构和岩土体系在地震作用下的可靠度及灵敏度的分析。自从1999年推出以来，该软件不断进行升级和提高，加入了许多新的材料和单元，引入了许多业已成熟的Fortran库文件为己所用(如FEAP、FEDEAS材料)，更新了高效实用的运算法则和判敛准则，允许多点输入地震波纪录，并不断提高运算中的内存管理水平和计算效率，允许用户在脚本层面上对分析进行更多控制。\nOpenSees的另一个优点就是使用面向对象的先进程序框架设计，基于C++的源代码公开有限元程序，方便使用者按照自己的需求进行二次开发。并且，基于此框架易于实现并行计算。它的主要特点归纳如下：\n（1）源码公开，学术界共同开发和共享代码，实现科研合作，持续集成最新科研成果；\n（2）OpenSees突出强非线性（土和结构非线性），针对强非线性开发的算法；\n（3）基于C++面向对象的先进程序框架设计以及基于此构架先进的并行计算方法；\n（4）敏感性可靠度和优化分析；\n（5）高性能云计算，比如Open Science Grid、TerraGrid;\n（6）通过OpenFresco等技术，实现和其他系统的集成以及混合实验等。\n# Tcl命令语言简介\n=================\n选择了Tcl脚本语言来支持OpenSees命令，这些命令用于定义问题几何，加载，配方和解决方案。这些命令是具有特定任务的单行命令。Tcl语言提供了有用的编程工具，如变量操作，数学表达式评估和控制结构。\nTcl是一个基于字符串的脚本语言，它允许以下内容：\n（1）变量和变量替换\n（2）数学表达评估\n（3）基本的控制结构(if , while, for, foreach)\n（4）程序\n（5）文件操作\n有关Tcl命令的更多信息可以在其网站上找到：Tcl / Tk\n[Primer](http://dev.scriptics.com/scripting/primer.html)\nTcl语言命令：\n*incr* - Increment the value of a variable（增加一个变量的值）:\n*set a 1*\n*incr a*\n参考:\nBrent Welch \\<welch\\@acm.org\\>, Ken Jones, and Jeff Hobbs: \n[Practical Programming in Tcl and Tk,](http://www.beedub.com/book/) \n[4th Edition ISBN:0-13-038560-3, June, 2003](http://www.beedub.com/book/)\n## Tcl命令格式\n---------------\nTcl脚本由用新行或分号（;）分隔的命令组成。\nTcl命令的基本语法是：\n*command \\$arg1 \\$arg2 ...*\ncommand? ：Tcl命令的名称或用户定义的过程\n\\$arg1 \\$arg2 ：命令参数\nTcl允许任何参数嵌套命令：\n*command [nested-command1] [nested-command2]*\n其中[]用于分隔嵌套的命令。Tcl解释器将首先评估嵌套命令，然后评估外部命令，并将结果嵌入到嵌套命令中。\nTcl中最基本的命令是set命令：\n*set variable \\$value*\n例如：\n*set a 5*\nTcl解释器认为一个以井号（＃）开始的命令是一个注释语句，所以它不会执行＃之后的任何内容。例如：\n*＃*这个命令给变量a赋值5\n*set a 5*\n英镑符号和分号可以一起用来将注释放在与命令相同的行上。例如：\n*set a 5*； ＃这个命令给变量a赋值5\nTcl命令示例，如下表所示。\n*set a*\n## Tcl命令示例\n---------------\n\n| Arithmetic       | procedure                                                                                                                                                                           | for& foreach functions                                                                                                                               |\n|------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|\n| *\\>set a 1 1 \\>set b a a \\>set b \\$a 1 \\>expr 2 + 3 5 \\>expr 2 + \\$a 3 \\>set b [expr 2 + \\$a] 3 \\>*                    | *\\>proc sum {a b} { return [expr \\$a + \\$b] } \\>sum 2 3 5 \\>set c [sum 2 3] 5 \\>*                                                                                                   | *for {set i 1} {\\$i \\< 10} {incr i 1} \n{ puts \"i equals \\$i\" } set sum 0 foreach value {1 2 3 4} { set sum [expr \\$sum + \\$value] } puts \\$sum 10 \\>* |\n| file manipulation                                                                                                      | procedure & if statement                                                                                                                                                            |                                                                                                                                                      |\n| *\\>set fileId [open tmp w] anumber \\>puts \\$fileId \"hello\" \\>close \\$fileID \\>type tmp hello \\> \\>source Example1.tcl* | *\\>proc guess {value} { global sum if {\\$value \\< \\$sum} { puts \"too low\" } else { if {\\$value \\> \\$sum} { puts \"too high\" } else { puts \"you got it!\"} } } \\> guess 9 too low \\>*  |                                                                                                                                                      |\n\n##  Tcl的其他资源\n-----------------\n<http://www.freeprogrammingresources.com/tcl.html>;\nhttp://www.tcl.tk/man/Tcl/Tkmanualpages;\n<http://www.mit.edu/afs/sipb/user/golem/doc/tcltk-iap2000/TclTk1.html>\n(通过在一个简短的程序中描述它们的实现来描述许多命令的教程);\n<http://www.beedub.com/book/>\n(一些来自Tcl和Tk的编程实例的章节，由Welch和Jones编写);\nhttp://philip.greenspun.com/tcl/;\n<http://www.tcl.tk/scripting/>;\n<http://hegel.ittc.ukans.edu/topics/tcltk/tutorial-noplugin/index.htm>\n（一个关于基本Tcl命令的简短教程，在下面的网站中也包含一个Tcl / Tk命令手册）\n## OpenSees编译器\n------------------\n\nOpenSees的主要抽象将使用OpenSees解释器进行解释。解释器是Tcl脚本语言的扩展。OpenSees解释器将命令添加到Tcl进行有限元分析。这些命令中的每一个都与提供的C\n++过程相关联。解释器调用这个过程来解析命令。在这个文档中，我们只概述那些被OpenSees添加到Tcl中的命令。\n\n对于OpenSees，我们向Tcl添加了有限元分析的命令：\n\n*Modeling* – create nodes, elements, loads and\nconstraints（创建节点，元素，载荷和约束）；\n\n*Analysis* – specify the analysis procedure（指定分析过程）\n\n*Output specification* – specify what it is you want to monitor during the\nanalysis（指定在分析过程中要监视的内容）\n\n# Opensees 基本概况\n===================\n\n# OpenSees概述\n----------------\n\nOpenSees的全称是Open System for Earthquake Engineering Simulation\n（地震工程模拟的开放体系）。它是由美国国家自然科学基金（NSF）资助、西部大学联盟“太平洋地震工程研究中心”（Pacific\nEarthquake Engineering Research\nCenter，简称PEER）主导、加州大学伯克利分校为主研发而成的、用于结构和岩土方面地震反应模拟的一个较为全面且不断发展的开放的程序软件体系。\n\n在Silvia Mazzoni, Frank McKenna, Michael H. Scott, Gregory L.\nFenves等人编写的OpenSEES的Users Manual (v2.0)开篇，是这样回答“What is\nOpenSees?”这个问题：\n\n（1）它是用有限元方法模拟地震工程应用的软件框架。 OpenSees不是一个代码；\n\n（2）在PEER，NEES及其以外的交流机制，交流和建立研究成果；\n\n（3）作为开源软件，它具有建立地震工程社区代码的潜力。\n\nOpenSees可以描述一个结构/模型。多个级别组件：\n\n![图1](114b5d55abb9b8a74bb18b1bcb0a2dca.png)\n\n![图2](3a04b2f3ba77e09e1d4a195a723210b2.png)\n\n传统的代码与OpenSees代码对比\n\n![图3](46afa9afcf5fa20bf42a6c9a6f73d79e.png)\n\n**Opensees计算仿真分区**\n\nOpenSees由一组模块组成，用于执行有限元模型的创建，分析过程的说明，分析过程中要监测的量的选择以及结果的输出。\n在每个有限元分析中，使用分析来构建4个主要类型的主题，如下图所示：\n\n![图4](3b1adcfc091178afbb2f106514eed312.png)\n\nDomain对象负责存储由ModelBuilder对象创建的对象，并提供对这些对象的分析和记录器对象的访问权限。\n\n![图6](3a471a82ccc457c44eba5125317e883a.png)\n\nAnalysis对象负责执行分析。分析将模型从t时刻的状态转移到t +\ndt时刻的状态。这可能会从简单的静态线性分析到瞬态非线性分析。在OpenSees中，每个Analysis对象由多个组件对象组成，这些组件对象定义了如何执行分析的分析类型。\n\n![图7](df03b2f5e7ca2bcccbbfaa784be671c3.png)\n\n3.2 OpenSees 特性\n-----------------\n\n为什么选择OpenSees？\n\n（1）材料，元素和分析命令库使得OpenSees成为非线性结构和岩土系统数值模拟的强大工具；\n\n（2）OpenSees组件库不断增长，处于数值模拟模型的前沿；\n\n（3）OpenSees界面基于命令驱动的脚本语言，使用户能够创建更多功能的输入文件；\n\n（4）OpenSees不是黑匣子，使其成为数值模拟的有用教育工具；\n\n（5）可以创建自己的材料，元素或分析工具，并将它们合并到OpenSees machine中；\n\n（6）NEES正在支持将OpenSees集成为实验室测试的模拟组件。\n\n模型：\n- 线性和非线性结构和岩土模型\n模拟：\n- static push-over analyses\n- static reversed-cyclic analyses\n- dynamic time-series analyses\n- uniform-support excitation\n- multi-support excitation\n","slug":"2019-Opensees","published":1,"updated":"2019-09-30T09:47:20.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxar000b2wvcvus41ol0","content":"<p>本文针对OpenSees在地震工程领域的独特优势，对软件结构整体进行详细分解和剖析，为OpenSees的学习和二次开发提供参考。</p>\n<h1 id=\"Opensees中的基本概念\"><a href=\"#Opensees中的基本概念\" class=\"headerlink\" title=\"Opensees中的基本概念\"></a>Opensees中的基本概念</h1><p>======================<br>OpenSees全称是Open System for Earthquake Engineerting<br>Simulation，是土木工程学术界广泛使用的有限元分析软件和地震工程模拟平台。<br>作为新一代的有限元计算软件，OpenSees致力于强非线性分析，具有丰富的非线性单元、材料库和针对强非线性分析开发的算法，可用于分析非线性岩土和结构体系。<br>OpenSees程序自1999年正式推出以来，已广泛用于太平洋地震工程研究中心和美国其它一些大学和科研机构的科研项目中，较好的模拟了包括钢筋混凝土结构、桥梁、岩土工程在内众多的实际工程和振动台试验项目，证明其具有较好的非线性数值模拟精度。该程序正在引起世界各国结构工程领域众多研究人员的关注和重视，而在国内也开始有少数学校开展了一些初步的学习和相关的研究工作。<br>作为国外具有一定影响的分析程序和开发平台，<br>OpenSees还具有以下一些突出特点：便于改进，易于协同开发，保持国际同步。OpenSees主要用于结构和岩土方面的地震反应模拟。可以实现的分析包括：简单的静力线弹性分析，静力非线性分析，截面分析，模态分析，Pushover拟动力分析，动力线弹性分析和复杂的动力非线性分析等；还可用于结构和岩土体系在地震作用下的可靠度及灵敏度的分析。自从1999年推出以来，该软件不断进行升级和提高，加入了许多新的材料和单元，引入了许多业已成熟的Fortran库文件为己所用(如FEAP、FEDEAS材料)，更新了高效实用的运算法则和判敛准则，允许多点输入地震波纪录，并不断提高运算中的内存管理水平和计算效率，允许用户在脚本层面上对分析进行更多控制。<br>OpenSees的另一个优点就是使用面向对象的先进程序框架设计，基于C++的源代码公开有限元程序，方便使用者按照自己的需求进行二次开发。并且，基于此框架易于实现并行计算。它的主要特点归纳如下：<br>（1）源码公开，学术界共同开发和共享代码，实现科研合作，持续集成最新科研成果；<br>（2）OpenSees突出强非线性（土和结构非线性），针对强非线性开发的算法；<br>（3）基于C++面向对象的先进程序框架设计以及基于此构架先进的并行计算方法；<br>（4）敏感性可靠度和优化分析；<br>（5）高性能云计算，比如Open Science Grid、TerraGrid;<br>（6）通过OpenFresco等技术，实现和其他系统的集成以及混合实验等。</p>\n<h1 id=\"Tcl命令语言简介\"><a href=\"#Tcl命令语言简介\" class=\"headerlink\" title=\"Tcl命令语言简介\"></a>Tcl命令语言简介</h1><p>=================<br>选择了Tcl脚本语言来支持OpenSees命令，这些命令用于定义问题几何，加载，配方和解决方案。这些命令是具有特定任务的单行命令。Tcl语言提供了有用的编程工具，如变量操作，数学表达式评估和控制结构。<br>Tcl是一个基于字符串的脚本语言，它允许以下内容：<br>（1）变量和变量替换<br>（2）数学表达评估<br>（3）基本的控制结构(if , while, for, foreach)<br>（4）程序<br>（5）文件操作<br>有关Tcl命令的更多信息可以在其网站上找到：Tcl / Tk<br><a href=\"http://dev.scriptics.com/scripting/primer.html\" target=\"_blank\" rel=\"noopener\">Primer</a><br>Tcl语言命令：<br><em>incr</em> - Increment the value of a variable（增加一个变量的值）:<br><em>set a 1</em><br><em>incr a</em><br>参考:<br>Brent Welch \\&lt;welch\\@acm.org&gt;, Ken Jones, and Jeff Hobbs:<br><a href=\"http://www.beedub.com/book/\" target=\"_blank\" rel=\"noopener\">Practical Programming in Tcl and Tk,</a><br><a href=\"http://www.beedub.com/book/\" target=\"_blank\" rel=\"noopener\">4th Edition ISBN:0-13-038560-3, June, 2003</a></p>\n<h2 id=\"Tcl命令格式\"><a href=\"#Tcl命令格式\" class=\"headerlink\" title=\"Tcl命令格式\"></a>Tcl命令格式</h2><hr>\n<p>Tcl脚本由用新行或分号（;）分隔的命令组成。<br>Tcl命令的基本语法是：<br><em>command $arg1 $arg2 …</em><br>command? ：Tcl命令的名称或用户定义的过程<br>$arg1 $arg2 ：命令参数<br>Tcl允许任何参数嵌套命令：<br><em>command [nested-command1] [nested-command2]</em><br>其中[]用于分隔嵌套的命令。Tcl解释器将首先评估嵌套命令，然后评估外部命令，并将结果嵌入到嵌套命令中。<br>Tcl中最基本的命令是set命令：<br><em>set variable $value</em><br>例如：<br><em>set a 5</em><br>Tcl解释器认为一个以井号（＃）开始的命令是一个注释语句，所以它不会执行＃之后的任何内容。例如：<br><em>＃</em>这个命令给变量a赋值5<br><em>set a 5</em><br>英镑符号和分号可以一起用来将注释放在与命令相同的行上。例如：<br><em>set a 5</em>； ＃这个命令给变量a赋值5<br>Tcl命令示例，如下表所示。<br><em>set a</em></p>\n<h2 id=\"Tcl命令示例\"><a href=\"#Tcl命令示例\" class=\"headerlink\" title=\"Tcl命令示例\"></a>Tcl命令示例</h2><hr>\n<table>\n<thead>\n<tr>\n<th>Arithmetic</th>\n<th>procedure</th>\n<th>for&amp; foreach functions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>&gt;set a 1 1 &gt;set b a a &gt;set b $a 1 &gt;expr 2 + 3 5 &gt;expr 2 + $a 3 &gt;set b [expr 2 + $a] 3 &gt;</em></td>\n<td><em>&gt;proc sum {a b} { return [expr $a + $b] } &gt;sum 2 3 5 &gt;set c [sum 2 3] 5 &gt;</em></td>\n<td>*for {set i 1} {$i \\&lt; 10} {incr i 1}</td>\n</tr>\n<tr>\n<td>{ puts “i equals $i” } set sum 0 foreach value {1 2 3 4} { set sum [expr $sum + $value] } puts $sum 10 &gt;*</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>file manipulation</td>\n<td>procedure &amp; if statement</td>\n<td></td>\n</tr>\n<tr>\n<td><em>&gt;set fileId [open tmp w] anumber &gt;puts $fileId “hello” &gt;close $fileID &gt;type tmp hello &gt; &gt;source Example1.tcl</em></td>\n<td><em>&gt;proc guess {value} { global sum if {$value \\&lt; $sum} { puts “too low” } else { if {$value &gt; $sum} { puts “too high” } else { puts “you got it!”} } } &gt; guess 9 too low &gt;</em></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"Tcl的其他资源\"><a href=\"#Tcl的其他资源\" class=\"headerlink\" title=\"Tcl的其他资源\"></a>Tcl的其他资源</h2><hr>\n<p><a href=\"http://www.freeprogrammingresources.com/tcl.html\" target=\"_blank\" rel=\"noopener\">http://www.freeprogrammingresources.com/tcl.html</a>;<br><a href=\"http://www.tcl.tk/man/Tcl/Tkmanualpages\" target=\"_blank\" rel=\"noopener\">http://www.tcl.tk/man/Tcl/Tkmanualpages</a>;<br><a href=\"http://www.mit.edu/afs/sipb/user/golem/doc/tcltk-iap2000/TclTk1.html\" target=\"_blank\" rel=\"noopener\">http://www.mit.edu/afs/sipb/user/golem/doc/tcltk-iap2000/TclTk1.html</a><br>(通过在一个简短的程序中描述它们的实现来描述许多命令的教程);<br><a href=\"http://www.beedub.com/book/\" target=\"_blank\" rel=\"noopener\">http://www.beedub.com/book/</a><br>(一些来自Tcl和Tk的编程实例的章节，由Welch和Jones编写);<br><a href=\"http://philip.greenspun.com/tcl/\" target=\"_blank\" rel=\"noopener\">http://philip.greenspun.com/tcl/</a>;<br><a href=\"http://www.tcl.tk/scripting/\" target=\"_blank\" rel=\"noopener\">http://www.tcl.tk/scripting/</a>;<br><a href=\"http://hegel.ittc.ukans.edu/topics/tcltk/tutorial-noplugin/index.htm\" target=\"_blank\" rel=\"noopener\">http://hegel.ittc.ukans.edu/topics/tcltk/tutorial-noplugin/index.htm</a><br>（一个关于基本Tcl命令的简短教程，在下面的网站中也包含一个Tcl / Tk命令手册）</p>\n<h2 id=\"OpenSees编译器\"><a href=\"#OpenSees编译器\" class=\"headerlink\" title=\"OpenSees编译器\"></a>OpenSees编译器</h2><hr>\n<p>OpenSees的主要抽象将使用OpenSees解释器进行解释。解释器是Tcl脚本语言的扩展。OpenSees解释器将命令添加到Tcl进行有限元分析。这些命令中的每一个都与提供的C<br>++过程相关联。解释器调用这个过程来解析命令。在这个文档中，我们只概述那些被OpenSees添加到Tcl中的命令。</p>\n<p>对于OpenSees，我们向Tcl添加了有限元分析的命令：</p>\n<p><em>Modeling</em> – create nodes, elements, loads and<br>constraints（创建节点，元素，载荷和约束）；</p>\n<p><em>Analysis</em> – specify the analysis procedure（指定分析过程）</p>\n<p><em>Output specification</em> – specify what it is you want to monitor during the<br>analysis（指定在分析过程中要监视的内容）</p>\n<h1 id=\"Opensees-基本概况\"><a href=\"#Opensees-基本概况\" class=\"headerlink\" title=\"Opensees 基本概况\"></a>Opensees 基本概况</h1><p>===================</p>\n<h1 id=\"OpenSees概述\"><a href=\"#OpenSees概述\" class=\"headerlink\" title=\"OpenSees概述\"></a>OpenSees概述</h1><hr>\n<p>OpenSees的全称是Open System for Earthquake Engineering Simulation<br>（地震工程模拟的开放体系）。它是由美国国家自然科学基金（NSF）资助、西部大学联盟“太平洋地震工程研究中心”（Pacific<br>Earthquake Engineering Research<br>Center，简称PEER）主导、加州大学伯克利分校为主研发而成的、用于结构和岩土方面地震反应模拟的一个较为全面且不断发展的开放的程序软件体系。</p>\n<p>在Silvia Mazzoni, Frank McKenna, Michael H. Scott, Gregory L.<br>Fenves等人编写的OpenSEES的Users Manual (v2.0)开篇，是这样回答“What is<br>OpenSees?”这个问题：</p>\n<p>（1）它是用有限元方法模拟地震工程应用的软件框架。 OpenSees不是一个代码；</p>\n<p>（2）在PEER，NEES及其以外的交流机制，交流和建立研究成果；</p>\n<p>（3）作为开源软件，它具有建立地震工程社区代码的潜力。</p>\n<p>OpenSees可以描述一个结构/模型。多个级别组件：</p>\n<p><img src=\"114b5d55abb9b8a74bb18b1bcb0a2dca.png\" alt=\"图1\"></p>\n<p><img src=\"3a04b2f3ba77e09e1d4a195a723210b2.png\" alt=\"图2\"></p>\n<p>传统的代码与OpenSees代码对比</p>\n<p><img src=\"46afa9afcf5fa20bf42a6c9a6f73d79e.png\" alt=\"图3\"></p>\n<p><strong>Opensees计算仿真分区</strong></p>\n<p>OpenSees由一组模块组成，用于执行有限元模型的创建，分析过程的说明，分析过程中要监测的量的选择以及结果的输出。<br>在每个有限元分析中，使用分析来构建4个主要类型的主题，如下图所示：</p>\n<p><img src=\"3b1adcfc091178afbb2f106514eed312.png\" alt=\"图4\"></p>\n<p>Domain对象负责存储由ModelBuilder对象创建的对象，并提供对这些对象的分析和记录器对象的访问权限。</p>\n<p><img src=\"3a471a82ccc457c44eba5125317e883a.png\" alt=\"图6\"></p>\n<p>Analysis对象负责执行分析。分析将模型从t时刻的状态转移到t +<br>dt时刻的状态。这可能会从简单的静态线性分析到瞬态非线性分析。在OpenSees中，每个Analysis对象由多个组件对象组成，这些组件对象定义了如何执行分析的分析类型。</p>\n<p><img src=\"df03b2f5e7ca2bcccbbfaa784be671c3.png\" alt=\"图7\"></p>\n<h2 id=\"3-2-OpenSees-特性\"><a href=\"#3-2-OpenSees-特性\" class=\"headerlink\" title=\"3.2 OpenSees 特性\"></a>3.2 OpenSees 特性</h2><p>为什么选择OpenSees？</p>\n<p>（1）材料，元素和分析命令库使得OpenSees成为非线性结构和岩土系统数值模拟的强大工具；</p>\n<p>（2）OpenSees组件库不断增长，处于数值模拟模型的前沿；</p>\n<p>（3）OpenSees界面基于命令驱动的脚本语言，使用户能够创建更多功能的输入文件；</p>\n<p>（4）OpenSees不是黑匣子，使其成为数值模拟的有用教育工具；</p>\n<p>（5）可以创建自己的材料，元素或分析工具，并将它们合并到OpenSees machine中；</p>\n<p>（6）NEES正在支持将OpenSees集成为实验室测试的模拟组件。</p>\n<p>模型：</p>\n<ul>\n<li>线性和非线性结构和岩土模型<br>模拟：</li>\n<li>static push-over analyses</li>\n<li>static reversed-cyclic analyses</li>\n<li>dynamic time-series analyses</li>\n<li>uniform-support excitation</li>\n<li>multi-support excitation</li>\n</ul>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<p>本文针对OpenSees在地震工程领域的独特优势，对软件结构整体进行详细分解和剖析，为OpenSees的学习和二次开发提供参考。</p>\n<h1 id=\"Opensees中的基本概念\"><a href=\"#Opensees中的基本概念\" class=\"headerlink\" title=\"Opensees中的基本概念\"></a>Opensees中的基本概念</h1><p>======================<br>OpenSees全称是Open System for Earthquake Engineerting<br>Simulation，是土木工程学术界广泛使用的有限元分析软件和地震工程模拟平台。<br>作为新一代的有限元计算软件，OpenSees致力于强非线性分析，具有丰富的非线性单元、材料库和针对强非线性分析开发的算法，可用于分析非线性岩土和结构体系。<br>OpenSees程序自1999年正式推出以来，已广泛用于太平洋地震工程研究中心和美国其它一些大学和科研机构的科研项目中，较好的模拟了包括钢筋混凝土结构、桥梁、岩土工程在内众多的实际工程和振动台试验项目，证明其具有较好的非线性数值模拟精度。该程序正在引起世界各国结构工程领域众多研究人员的关注和重视，而在国内也开始有少数学校开展了一些初步的学习和相关的研究工作。<br>作为国外具有一定影响的分析程序和开发平台，<br>OpenSees还具有以下一些突出特点：便于改进，易于协同开发，保持国际同步。OpenSees主要用于结构和岩土方面的地震反应模拟。可以实现的分析包括：简单的静力线弹性分析，静力非线性分析，截面分析，模态分析，Pushover拟动力分析，动力线弹性分析和复杂的动力非线性分析等；还可用于结构和岩土体系在地震作用下的可靠度及灵敏度的分析。自从1999年推出以来，该软件不断进行升级和提高，加入了许多新的材料和单元，引入了许多业已成熟的Fortran库文件为己所用(如FEAP、FEDEAS材料)，更新了高效实用的运算法则和判敛准则，允许多点输入地震波纪录，并不断提高运算中的内存管理水平和计算效率，允许用户在脚本层面上对分析进行更多控制。<br>OpenSees的另一个优点就是使用面向对象的先进程序框架设计，基于C++的源代码公开有限元程序，方便使用者按照自己的需求进行二次开发。并且，基于此框架易于实现并行计算。它的主要特点归纳如下：<br>（1）源码公开，学术界共同开发和共享代码，实现科研合作，持续集成最新科研成果；<br>（2）OpenSees突出强非线性（土和结构非线性），针对强非线性开发的算法；<br>（3）基于C++面向对象的先进程序框架设计以及基于此构架先进的并行计算方法；<br>（4）敏感性可靠度和优化分析；<br>（5）高性能云计算，比如Open Science Grid、TerraGrid;<br>（6）通过OpenFresco等技术，实现和其他系统的集成以及混合实验等。</p>\n<h1 id=\"Tcl命令语言简介\"><a href=\"#Tcl命令语言简介\" class=\"headerlink\" title=\"Tcl命令语言简介\"></a>Tcl命令语言简介</h1><p>=================<br>选择了Tcl脚本语言来支持OpenSees命令，这些命令用于定义问题几何，加载，配方和解决方案。这些命令是具有特定任务的单行命令。Tcl语言提供了有用的编程工具，如变量操作，数学表达式评估和控制结构。<br>Tcl是一个基于字符串的脚本语言，它允许以下内容：<br>（1）变量和变量替换<br>（2）数学表达评估<br>（3）基本的控制结构(if , while, for, foreach)<br>（4）程序<br>（5）文件操作<br>有关Tcl命令的更多信息可以在其网站上找到：Tcl / Tk<br><a href=\"http://dev.scriptics.com/scripting/primer.html\" target=\"_blank\" rel=\"noopener\">Primer</a><br>Tcl语言命令：<br><em>incr</em> - Increment the value of a variable（增加一个变量的值）:<br><em>set a 1</em><br><em>incr a</em><br>参考:<br>Brent Welch \\&lt;welch\\@acm.org&gt;, Ken Jones, and Jeff Hobbs:<br><a href=\"http://www.beedub.com/book/\" target=\"_blank\" rel=\"noopener\">Practical Programming in Tcl and Tk,</a><br><a href=\"http://www.beedub.com/book/\" target=\"_blank\" rel=\"noopener\">4th Edition ISBN:0-13-038560-3, June, 2003</a></p>\n<h2 id=\"Tcl命令格式\"><a href=\"#Tcl命令格式\" class=\"headerlink\" title=\"Tcl命令格式\"></a>Tcl命令格式</h2><hr>\n<p>Tcl脚本由用新行或分号（;）分隔的命令组成。<br>Tcl命令的基本语法是：<br><em>command $arg1 $arg2 …</em><br>command? ：Tcl命令的名称或用户定义的过程<br>$arg1 $arg2 ：命令参数<br>Tcl允许任何参数嵌套命令：<br><em>command [nested-command1] [nested-command2]</em><br>其中[]用于分隔嵌套的命令。Tcl解释器将首先评估嵌套命令，然后评估外部命令，并将结果嵌入到嵌套命令中。<br>Tcl中最基本的命令是set命令：<br><em>set variable $value</em><br>例如：<br><em>set a 5</em><br>Tcl解释器认为一个以井号（＃）开始的命令是一个注释语句，所以它不会执行＃之后的任何内容。例如：<br><em>＃</em>这个命令给变量a赋值5<br><em>set a 5</em><br>英镑符号和分号可以一起用来将注释放在与命令相同的行上。例如：<br><em>set a 5</em>； ＃这个命令给变量a赋值5<br>Tcl命令示例，如下表所示。<br><em>set a</em></p>\n<h2 id=\"Tcl命令示例\"><a href=\"#Tcl命令示例\" class=\"headerlink\" title=\"Tcl命令示例\"></a>Tcl命令示例</h2><hr>\n<table>\n<thead>\n<tr>\n<th>Arithmetic</th>\n<th>procedure</th>\n<th>for&amp; foreach functions</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><em>&gt;set a 1 1 &gt;set b a a &gt;set b $a 1 &gt;expr 2 + 3 5 &gt;expr 2 + $a 3 &gt;set b [expr 2 + $a] 3 &gt;</em></td>\n<td><em>&gt;proc sum {a b} { return [expr $a + $b] } &gt;sum 2 3 5 &gt;set c [sum 2 3] 5 &gt;</em></td>\n<td>*for {set i 1} {$i \\&lt; 10} {incr i 1}</td>\n</tr>\n<tr>\n<td>{ puts “i equals $i” } set sum 0 foreach value {1 2 3 4} { set sum [expr $sum + $value] } puts $sum 10 &gt;*</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>file manipulation</td>\n<td>procedure &amp; if statement</td>\n<td></td>\n</tr>\n<tr>\n<td><em>&gt;set fileId [open tmp w] anumber &gt;puts $fileId “hello” &gt;close $fileID &gt;type tmp hello &gt; &gt;source Example1.tcl</em></td>\n<td><em>&gt;proc guess {value} { global sum if {$value \\&lt; $sum} { puts “too low” } else { if {$value &gt; $sum} { puts “too high” } else { puts “you got it!”} } } &gt; guess 9 too low &gt;</em></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"Tcl的其他资源\"><a href=\"#Tcl的其他资源\" class=\"headerlink\" title=\"Tcl的其他资源\"></a>Tcl的其他资源</h2><hr>\n<p><a href=\"http://www.freeprogrammingresources.com/tcl.html\" target=\"_blank\" rel=\"noopener\">http://www.freeprogrammingresources.com/tcl.html</a>;<br><a href=\"http://www.tcl.tk/man/Tcl/Tkmanualpages\" target=\"_blank\" rel=\"noopener\">http://www.tcl.tk/man/Tcl/Tkmanualpages</a>;<br><a href=\"http://www.mit.edu/afs/sipb/user/golem/doc/tcltk-iap2000/TclTk1.html\" target=\"_blank\" rel=\"noopener\">http://www.mit.edu/afs/sipb/user/golem/doc/tcltk-iap2000/TclTk1.html</a><br>(通过在一个简短的程序中描述它们的实现来描述许多命令的教程);<br><a href=\"http://www.beedub.com/book/\" target=\"_blank\" rel=\"noopener\">http://www.beedub.com/book/</a><br>(一些来自Tcl和Tk的编程实例的章节，由Welch和Jones编写);<br><a href=\"http://philip.greenspun.com/tcl/\" target=\"_blank\" rel=\"noopener\">http://philip.greenspun.com/tcl/</a>;<br><a href=\"http://www.tcl.tk/scripting/\" target=\"_blank\" rel=\"noopener\">http://www.tcl.tk/scripting/</a>;<br><a href=\"http://hegel.ittc.ukans.edu/topics/tcltk/tutorial-noplugin/index.htm\" target=\"_blank\" rel=\"noopener\">http://hegel.ittc.ukans.edu/topics/tcltk/tutorial-noplugin/index.htm</a><br>（一个关于基本Tcl命令的简短教程，在下面的网站中也包含一个Tcl / Tk命令手册）</p>\n<h2 id=\"OpenSees编译器\"><a href=\"#OpenSees编译器\" class=\"headerlink\" title=\"OpenSees编译器\"></a>OpenSees编译器</h2><hr>\n<p>OpenSees的主要抽象将使用OpenSees解释器进行解释。解释器是Tcl脚本语言的扩展。OpenSees解释器将命令添加到Tcl进行有限元分析。这些命令中的每一个都与提供的C<br>++过程相关联。解释器调用这个过程来解析命令。在这个文档中，我们只概述那些被OpenSees添加到Tcl中的命令。</p>\n<p>对于OpenSees，我们向Tcl添加了有限元分析的命令：</p>\n<p><em>Modeling</em> – create nodes, elements, loads and<br>constraints（创建节点，元素，载荷和约束）；</p>\n<p><em>Analysis</em> – specify the analysis procedure（指定分析过程）</p>\n<p><em>Output specification</em> – specify what it is you want to monitor during the<br>analysis（指定在分析过程中要监视的内容）</p>\n<h1 id=\"Opensees-基本概况\"><a href=\"#Opensees-基本概况\" class=\"headerlink\" title=\"Opensees 基本概况\"></a>Opensees 基本概况</h1><p>===================</p>\n<h1 id=\"OpenSees概述\"><a href=\"#OpenSees概述\" class=\"headerlink\" title=\"OpenSees概述\"></a>OpenSees概述</h1><hr>\n<p>OpenSees的全称是Open System for Earthquake Engineering Simulation<br>（地震工程模拟的开放体系）。它是由美国国家自然科学基金（NSF）资助、西部大学联盟“太平洋地震工程研究中心”（Pacific<br>Earthquake Engineering Research<br>Center，简称PEER）主导、加州大学伯克利分校为主研发而成的、用于结构和岩土方面地震反应模拟的一个较为全面且不断发展的开放的程序软件体系。</p>\n<p>在Silvia Mazzoni, Frank McKenna, Michael H. Scott, Gregory L.<br>Fenves等人编写的OpenSEES的Users Manual (v2.0)开篇，是这样回答“What is<br>OpenSees?”这个问题：</p>\n<p>（1）它是用有限元方法模拟地震工程应用的软件框架。 OpenSees不是一个代码；</p>\n<p>（2）在PEER，NEES及其以外的交流机制，交流和建立研究成果；</p>\n<p>（3）作为开源软件，它具有建立地震工程社区代码的潜力。</p>\n<p>OpenSees可以描述一个结构/模型。多个级别组件：</p>\n<p><img src=\"114b5d55abb9b8a74bb18b1bcb0a2dca.png\" alt=\"图1\"></p>\n<p><img src=\"3a04b2f3ba77e09e1d4a195a723210b2.png\" alt=\"图2\"></p>\n<p>传统的代码与OpenSees代码对比</p>\n<p><img src=\"46afa9afcf5fa20bf42a6c9a6f73d79e.png\" alt=\"图3\"></p>\n<p><strong>Opensees计算仿真分区</strong></p>\n<p>OpenSees由一组模块组成，用于执行有限元模型的创建，分析过程的说明，分析过程中要监测的量的选择以及结果的输出。<br>在每个有限元分析中，使用分析来构建4个主要类型的主题，如下图所示：</p>\n<p><img src=\"3b1adcfc091178afbb2f106514eed312.png\" alt=\"图4\"></p>\n<p>Domain对象负责存储由ModelBuilder对象创建的对象，并提供对这些对象的分析和记录器对象的访问权限。</p>\n<p><img src=\"3a471a82ccc457c44eba5125317e883a.png\" alt=\"图6\"></p>\n<p>Analysis对象负责执行分析。分析将模型从t时刻的状态转移到t +<br>dt时刻的状态。这可能会从简单的静态线性分析到瞬态非线性分析。在OpenSees中，每个Analysis对象由多个组件对象组成，这些组件对象定义了如何执行分析的分析类型。</p>\n<p><img src=\"df03b2f5e7ca2bcccbbfaa784be671c3.png\" alt=\"图7\"></p>\n<h2 id=\"3-2-OpenSees-特性\"><a href=\"#3-2-OpenSees-特性\" class=\"headerlink\" title=\"3.2 OpenSees 特性\"></a>3.2 OpenSees 特性</h2><p>为什么选择OpenSees？</p>\n<p>（1）材料，元素和分析命令库使得OpenSees成为非线性结构和岩土系统数值模拟的强大工具；</p>\n<p>（2）OpenSees组件库不断增长，处于数值模拟模型的前沿；</p>\n<p>（3）OpenSees界面基于命令驱动的脚本语言，使用户能够创建更多功能的输入文件；</p>\n<p>（4）OpenSees不是黑匣子，使其成为数值模拟的有用教育工具；</p>\n<p>（5）可以创建自己的材料，元素或分析工具，并将它们合并到OpenSees machine中；</p>\n<p>（6）NEES正在支持将OpenSees集成为实验室测试的模拟组件。</p>\n<p>模型：</p>\n<ul>\n<li>线性和非线性结构和岩土模型<br>模拟：</li>\n<li>static push-over analyses</li>\n<li>static reversed-cyclic analyses</li>\n<li>dynamic time-series analyses</li>\n<li>uniform-support excitation</li>\n<li>multi-support excitation</li>\n</ul>\n"},{"title":"「AppSo」页面原型还原","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-10-03T08:20:56.000Z","password":null,"summary":"「AppSo」页面原型还原","_content":"# 问题：「AppSo」页面原型还原\n在上题中，大家已经梳理出来「AppSo」的页面流程\n作业要求：本题要求还原上题中涉及到的页面\ntips：\n1. 还原页面的所有要素，要求元素必须完整，图片可以使用占位符\n2. 自己可以提前整理个元件库，为原型绘制时所需的icon做准备\n3. 在原型中要标注交互信息（即页面跳转的逻辑），若有数据信息也一并梳理出来\n4. 不要遗漏异常情况的提示/引导\n\n# AppSo提交审核阶段页面交互原型\n![审核阶段页面交互原型](yewu1.jpg)\n# AppSo——收录发表阶段页面交互原型\n![收录发表阶段页面交互原型](yewu2.jpg)\n","source":"_posts/2019-PM-AppSo-origin.md","raw":"---\ntitle: 「AppSo」页面原型还原\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-10-03 16:20:56\npassword:\nsummary: 「AppSo」页面原型还原\ntags:\n- PM\ncategories:\n- PM\n---\n# 问题：「AppSo」页面原型还原\n在上题中，大家已经梳理出来「AppSo」的页面流程\n作业要求：本题要求还原上题中涉及到的页面\ntips：\n1. 还原页面的所有要素，要求元素必须完整，图片可以使用占位符\n2. 自己可以提前整理个元件库，为原型绘制时所需的icon做准备\n3. 在原型中要标注交互信息（即页面跳转的逻辑），若有数据信息也一并梳理出来\n4. 不要遗漏异常情况的提示/引导\n\n# AppSo提交审核阶段页面交互原型\n![审核阶段页面交互原型](yewu1.jpg)\n# AppSo——收录发表阶段页面交互原型\n![收录发表阶段页面交互原型](yewu2.jpg)\n","slug":"2019-PM-AppSo-origin","published":1,"updated":"2019-10-03T08:25:07.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxav000g2wvcecp2qoy5","content":"<h1 id=\"问题：「AppSo」页面原型还原\"><a href=\"#问题：「AppSo」页面原型还原\" class=\"headerlink\" title=\"问题：「AppSo」页面原型还原\"></a>问题：「AppSo」页面原型还原</h1><p>在上题中，大家已经梳理出来「AppSo」的页面流程<br>作业要求：本题要求还原上题中涉及到的页面<br>tips：</p>\n<ol>\n<li>还原页面的所有要素，要求元素必须完整，图片可以使用占位符</li>\n<li>自己可以提前整理个元件库，为原型绘制时所需的icon做准备</li>\n<li>在原型中要标注交互信息（即页面跳转的逻辑），若有数据信息也一并梳理出来</li>\n<li>不要遗漏异常情况的提示/引导</li>\n</ol>\n<h1 id=\"AppSo提交审核阶段页面交互原型\"><a href=\"#AppSo提交审核阶段页面交互原型\" class=\"headerlink\" title=\"AppSo提交审核阶段页面交互原型\"></a>AppSo提交审核阶段页面交互原型</h1><p><img src=\"yewu1.jpg\" alt=\"审核阶段页面交互原型\"></p>\n<h1 id=\"AppSo——收录发表阶段页面交互原型\"><a href=\"#AppSo——收录发表阶段页面交互原型\" class=\"headerlink\" title=\"AppSo——收录发表阶段页面交互原型\"></a>AppSo——收录发表阶段页面交互原型</h1><p><img src=\"yewu2.jpg\" alt=\"收录发表阶段页面交互原型\"></p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"问题：「AppSo」页面原型还原\"><a href=\"#问题：「AppSo」页面原型还原\" class=\"headerlink\" title=\"问题：「AppSo」页面原型还原\"></a>问题：「AppSo」页面原型还原</h1><p>在上题中，大家已经梳理出来「AppSo」的页面流程<br>作业要求：本题要求还原上题中涉及到的页面<br>tips：</p>\n<ol>\n<li>还原页面的所有要素，要求元素必须完整，图片可以使用占位符</li>\n<li>自己可以提前整理个元件库，为原型绘制时所需的icon做准备</li>\n<li>在原型中要标注交互信息（即页面跳转的逻辑），若有数据信息也一并梳理出来</li>\n<li>不要遗漏异常情况的提示/引导</li>\n</ol>\n<h1 id=\"AppSo提交审核阶段页面交互原型\"><a href=\"#AppSo提交审核阶段页面交互原型\" class=\"headerlink\" title=\"AppSo提交审核阶段页面交互原型\"></a>AppSo提交审核阶段页面交互原型</h1><p><img src=\"yewu1.jpg\" alt=\"审核阶段页面交互原型\"></p>\n<h1 id=\"AppSo——收录发表阶段页面交互原型\"><a href=\"#AppSo——收录发表阶段页面交互原型\" class=\"headerlink\" title=\"AppSo——收录发表阶段页面交互原型\"></a>AppSo——收录发表阶段页面交互原型</h1><p><img src=\"yewu2.jpg\" alt=\"收录发表阶段页面交互原型\"></p>\n"},{"title":"体验「得到」","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-10-03T06:42:54.000Z","password":null,"summary":null,"_content":"\n# 问题：体验「得到」\n\n# 产品是什么？\n## 一句话描述产品\n得到，提供最省时间的知识服务，利用碎片时间获取高浓度知识。\n\n## 产品满足的需求\n利用零碎时间，帮助用户高效率阅读，专业的说书人为用户解读好书，搞懂一本书；\n帮助用户，迅速了解一个领域，包含声音、创业、健康…优化用户跟世界接触的每一面，各领域的高手引导用户；\n多领域满足客户需求，经济学、管理学、西方艺术、心理学、儿童教育等方面的独家知识专栏。\n## 产品亮点\n利用零碎时间，由专业成功人士为你解读专业知识，内容包含丰富，听书，看书，大咖云集，以课堂的形式参与，提升你的兴趣。\n\n# 目标用户与典型场景\n## 目标用户和典型场景案例1\n1. 目标用户\n18-22岁之间为了解其他专业知识，提升自己视野的学生群体\n2. 典型应用场景\n学生党刚进入大学，为了提升自己综合的素质和培养兴趣，提升自己的课外知识和学习视野，在课堂结束的课间，在食堂，在闲暇之余，他打开APP点开了“知识城邦”，选择自己喜欢的内容，带着耳机，随时随地听到自己想学习的内容。\n## 目标用户和典型场景案例2\n1. 目标用户\n23-35岁之间、每天想在工作之外进行充电学习的职场人士\n2. 典型应用场景\n刚进入职场年轻同学，面对新的环境和新的事情，逐渐感觉缺乏其他方面（例如：法律，经济，管理）的知识。在朋友的推荐下，下载了得到APP，打开自己的“学习计划”，每天上下班的地铁里，公交里，都会听书，看书。逐渐提升了自己的知识水平和视野，又打发了上下班路上无聊的时间。\n## 目标用户和典型场景案例3：\n1. 目标用户\n不满足现状，希望提升自己的工作人员\n2. 典型应用场景\n对于外卖小哥、快递人员，这种底层工作劳动者，他们希望提升自己的知识水平。下载得到APP，打开“发现”栏，选择自己喜欢的作家和文章，他们在送餐、送快递之余可以提升自己，取得进步。\n# 关键功能与描述\n## 产品框架\n【得到】app主要由【发现】，【学习计划】，【知识城邦】，【已购】，【我的】五个模块页面构成，整体框架梳理如下：\n![得到整体框架](kuangjia.png)\n## 描述关键功能名称及作用\n（1）每天听本书\n由专家精选好书进行解析拆读，然后以音频的形式供用户学习。用户可以选择自己喜欢类型的书，利用碎片化的时间，轻松的学习到其中的精华。此外，得到的课程人性化的地方在于你可以任选课程的5讲来试听，感兴趣的话在付费购买，这一点用户体验做得很好。\n![每天听本书页面详情](yemian1.png)\n（2）学习计划\n制定属于自己的学习计划，既起到了监督和提醒的作用，。又让用户有了归属感。\n![学习计划页面详情](yemian2.png)\n（3）知识城邦\n![知识城邦页面详情](yemian3.jpg)\n在知识城邦，用户可以发变自己的看法，提升了互动社交的特性，也可以在此反馈自己对课程的看法，可以促进课堂的改进。\n（4）已购\n![已购页面详情](yemian4.png)\n整理出用户已经购买的课程，方便用户快速找到自己的课程\n（5）听课\n![听课页面详情](yemian5.png)\n产品最核心的功能，用户选择喜欢的课程进行学习，可以自由调整定时，倍速，快进等功能，较为人性化。附带的划重点能够自动截取到正在听的一段话，并让用户辅助配上自己的心得，帮助用户更好的内化沉淀，以及输出知识。用户也可以在评论区和其他用户分享交流自己的学习体会，整个听课过程形成了选课，听课，吸收，输出的完整环节。\n# 运营方法\n## 2018运营事件梳理\n得到APP2018年运营事件梳理可见链接：https://mp.weixin.qq.com/s/FEEB1xxtQeoWTIiiDipLrw\n\n重点营销事件包括:赞助最强大脑，上线知识城邦，学习计划，六大学院，薛兆丰课程开启订阅以及跨年演讲，都带来了不错的收益。\n\n## AARRR模型梳理\n### acquisition 用户获取\n（1）渠道导流\n利用微博、微信对得到app的内容进行推广和曝光宣传。【得到】公总号对得到上的优秀内容再包装和二次传播，平均单篇推送阅读量破万。此外，通过【罗辑思维】公众号对得到app上的内容同样进行包装宣传，单篇阅读量均达10万+。此外，还通过知乎，授课讲师自身微博豆瓣等渠道进行推广传播。\n（2）品牌合作和大型活动\n《从时间的朋友》到《最强大脑》，从差异化晚会到深度内容合作，罗振宇的知识产品品牌效应正突破圈层，通过不同的媒介，被大家广泛认知。\n2018年7月，得到APP联合江苏卫视和爱奇艺出品《知识就是力量》这一大型知识类脱口秀节目，深圳卫视延后一天播出。江苏卫视35城首播收视率0.425，爱奇艺3天播放量接近200万，在知识类节目中排名领先。得到APP每周会围绕节目主题的观点进行“延展知识的征集”，引发了观众的广泛参与，实现了导流。\n（3）站内推荐\n通过app内推荐【得到】给好友，双方均可获得20元优惠券。\n通过周年庆活动，分享活动赠送优惠券。\n（4）创始人个人IP效应\n罗振宇通过《罗辑思维》已积累了大量忠实用户，这一批用户也是注入得到APP的首批种子用户。罗振宇的个人IP效应至今对得到APP的影响也不容小觑。\n（5）打造流量爆款\n![爆款示例](baokuan.jpg)\n得到APP上订阅人数最多的课程是《薛兆丰的经济学课》，已有将近30万人学习。这不难理解，经济学是非常大众的学科，每个人都应该了解一些经济学常识，同时薛兆丰北大讲师的身份使这门课更具有含金量。\n## activation 活跃\n（1）新人福利\n用户注册后可以领取新人知识礼包和优惠券，可以按感兴趣的内容挑选，还有详细的产品使用指导，降低使用门槛。\n（2）免费试听\n用户可以以0.1元购买听书VIP七天体验卡，同时有两门每天更新的免费课程”罗辑思维”和“李翔知识内参”面向所有用户。\n（2）定期举办站内活动\n2018.2.8举办【得到相亲大会】\n2018.2.15举办【和知识一起过春节】\n2018.5.26举办【两周年】庆祝活动\n2018.7.27开播【知识就是力量】\n以及一些不定期的诸如名家直播小活动\n## Retention 留存\n(1) 严格品控\n得到APP对音频严格控制在每秒4.5字（罗振宇是每秒4.2字），把控断句等细节，为用户带来最佳的收听感。\n品控还体现在为内容生产者（大佬主讲人们）赋能，创造金钱等条件让他们专心生产最优质的知识内容，同时也可以使他们的影响力更有含金量，实现平台、内容生产者及用户的“三赢”。\n(2)储存价值\n![价值](jiazhi.png)\n得到APP为用户构建了自己的“笔记”，“学习计划”直接为用户推荐学习时间计划，管理学习进度，“笔记”分为\"我的笔记\"和\"知识城邦\",鼓励用户留下对知识的反馈。\"我的笔记”可以查询总学习时长、收藏和历史纪录，“知识城邦”就相当于社区，可以查看、转发、评论、点赞其他人的笔记，虽说这样得到APP也还没有形成社群，但是记录笔记和关注他人优秀的笔记还是可以为用户带来宝贵的储存价值。\n(3)推送\n得到APP会通过APP弹窗提示、应用推送通知、、公众号、微博等，提醒用户有优惠券、新课程上线、直播预告等，既吸引新用户，又挽留老用户。\n(4)打造UGC社区\n通过构建知识城邦，帮助用户在平台上分享自己的所学和见解，提升个人成就感，同时促进优秀课程的二次曝光。\n## Revenue 收入\n![收入](shouru.png)\n得到APP是一款知识付费产品，因此自然是从付费知识服务中获得营收的。目前收费的板块有两部分，既课程和每天听本书。每天听本书可以按月度和年度收费开通，课程收费在19.9-199元不等，都必须先充值“得贝”，我觉得比较耐人寻味的是得贝金额是固定的几个选项，没有正好19.9、199之类的，所以你想订阅课程肯定会多充值，充值的得贝是不能退款或提现的，这就会使用户多买一些付费内容。\n2018年9月推出线上线下联动学习的得到大学，针对筛选过的优质学员，营收手段从线上逐步向线下精英学院形式深入。\n## Refer 传播推荐\n（1）优秀的内容分享：源自于得到内容本身的高质量，用户自发的分享课程内容和学习到的心得，但往往这类转发分享很少。\n（2）趣味h5分享：例如得到推出的：分享马伯庸免费资源，获得“仗义证”活动，也获得了很好的效果。\n（3）好友邀请：得到APP在好友邀请方面主要还是采用了补贴奖励，邀请成功双方可以获得优惠券。用户可以生成显示自己学习天数的海报，如果用户学习时间长可以”炫耀”，也会刺激用户分享。\n???![推荐](tuijian.png)\n# 竞品分析\n## 喜马拉雅FM VS 得到\n喜马拉雅是行业排名靠前的知识变现平台，作为移动音频领域的领跑者，拥有庞大的用户流量，在当前具有一定的典型性。得到起始于2016年，由罗辑思维推出，为了更好的达到竞品分析的目的，对喜马拉雅与得到在用户、定位、功能、设计、运营及公司策略这几个方面的分析，希望从中获得进一步迭代功能的灵感。\n![竞品分析](fenxi.png)\n**结论：得到试图寻找一种其他竞品没有尝试过的道路，一种不一样的玩法：**\n- 得到不断争取行业或者某领域专家来得到发音频节目。\n- 得到的核心内容深度介于知识分子专精的领域与付费成人教育机构之间，内容精良且深度平均，区别于喜马拉雅大而广的内容体系，强调通过优秀的音频内容去“学习”，掌握某领域的一些知识。喜马拉雅FM没有刻意营造出“学习”氛围，把选择权交给读者，从内容看偏向娱乐。两家公司战略有一定的重合，但更多的是不同，得到专而精，喜马拉雅大而广，目标人群也不一样。","source":"_posts/2019-PM-dedao.md","raw":"---\ntitle: 体验「得到」\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-10-03 14:42:54\npassword:\nsummary:\ntags:\n- PM\ncategories:\n- PM\n---\n\n# 问题：体验「得到」\n\n# 产品是什么？\n## 一句话描述产品\n得到，提供最省时间的知识服务，利用碎片时间获取高浓度知识。\n\n## 产品满足的需求\n利用零碎时间，帮助用户高效率阅读，专业的说书人为用户解读好书，搞懂一本书；\n帮助用户，迅速了解一个领域，包含声音、创业、健康…优化用户跟世界接触的每一面，各领域的高手引导用户；\n多领域满足客户需求，经济学、管理学、西方艺术、心理学、儿童教育等方面的独家知识专栏。\n## 产品亮点\n利用零碎时间，由专业成功人士为你解读专业知识，内容包含丰富，听书，看书，大咖云集，以课堂的形式参与，提升你的兴趣。\n\n# 目标用户与典型场景\n## 目标用户和典型场景案例1\n1. 目标用户\n18-22岁之间为了解其他专业知识，提升自己视野的学生群体\n2. 典型应用场景\n学生党刚进入大学，为了提升自己综合的素质和培养兴趣，提升自己的课外知识和学习视野，在课堂结束的课间，在食堂，在闲暇之余，他打开APP点开了“知识城邦”，选择自己喜欢的内容，带着耳机，随时随地听到自己想学习的内容。\n## 目标用户和典型场景案例2\n1. 目标用户\n23-35岁之间、每天想在工作之外进行充电学习的职场人士\n2. 典型应用场景\n刚进入职场年轻同学，面对新的环境和新的事情，逐渐感觉缺乏其他方面（例如：法律，经济，管理）的知识。在朋友的推荐下，下载了得到APP，打开自己的“学习计划”，每天上下班的地铁里，公交里，都会听书，看书。逐渐提升了自己的知识水平和视野，又打发了上下班路上无聊的时间。\n## 目标用户和典型场景案例3：\n1. 目标用户\n不满足现状，希望提升自己的工作人员\n2. 典型应用场景\n对于外卖小哥、快递人员，这种底层工作劳动者，他们希望提升自己的知识水平。下载得到APP，打开“发现”栏，选择自己喜欢的作家和文章，他们在送餐、送快递之余可以提升自己，取得进步。\n# 关键功能与描述\n## 产品框架\n【得到】app主要由【发现】，【学习计划】，【知识城邦】，【已购】，【我的】五个模块页面构成，整体框架梳理如下：\n![得到整体框架](kuangjia.png)\n## 描述关键功能名称及作用\n（1）每天听本书\n由专家精选好书进行解析拆读，然后以音频的形式供用户学习。用户可以选择自己喜欢类型的书，利用碎片化的时间，轻松的学习到其中的精华。此外，得到的课程人性化的地方在于你可以任选课程的5讲来试听，感兴趣的话在付费购买，这一点用户体验做得很好。\n![每天听本书页面详情](yemian1.png)\n（2）学习计划\n制定属于自己的学习计划，既起到了监督和提醒的作用，。又让用户有了归属感。\n![学习计划页面详情](yemian2.png)\n（3）知识城邦\n![知识城邦页面详情](yemian3.jpg)\n在知识城邦，用户可以发变自己的看法，提升了互动社交的特性，也可以在此反馈自己对课程的看法，可以促进课堂的改进。\n（4）已购\n![已购页面详情](yemian4.png)\n整理出用户已经购买的课程，方便用户快速找到自己的课程\n（5）听课\n![听课页面详情](yemian5.png)\n产品最核心的功能，用户选择喜欢的课程进行学习，可以自由调整定时，倍速，快进等功能，较为人性化。附带的划重点能够自动截取到正在听的一段话，并让用户辅助配上自己的心得，帮助用户更好的内化沉淀，以及输出知识。用户也可以在评论区和其他用户分享交流自己的学习体会，整个听课过程形成了选课，听课，吸收，输出的完整环节。\n# 运营方法\n## 2018运营事件梳理\n得到APP2018年运营事件梳理可见链接：https://mp.weixin.qq.com/s/FEEB1xxtQeoWTIiiDipLrw\n\n重点营销事件包括:赞助最强大脑，上线知识城邦，学习计划，六大学院，薛兆丰课程开启订阅以及跨年演讲，都带来了不错的收益。\n\n## AARRR模型梳理\n### acquisition 用户获取\n（1）渠道导流\n利用微博、微信对得到app的内容进行推广和曝光宣传。【得到】公总号对得到上的优秀内容再包装和二次传播，平均单篇推送阅读量破万。此外，通过【罗辑思维】公众号对得到app上的内容同样进行包装宣传，单篇阅读量均达10万+。此外，还通过知乎，授课讲师自身微博豆瓣等渠道进行推广传播。\n（2）品牌合作和大型活动\n《从时间的朋友》到《最强大脑》，从差异化晚会到深度内容合作，罗振宇的知识产品品牌效应正突破圈层，通过不同的媒介，被大家广泛认知。\n2018年7月，得到APP联合江苏卫视和爱奇艺出品《知识就是力量》这一大型知识类脱口秀节目，深圳卫视延后一天播出。江苏卫视35城首播收视率0.425，爱奇艺3天播放量接近200万，在知识类节目中排名领先。得到APP每周会围绕节目主题的观点进行“延展知识的征集”，引发了观众的广泛参与，实现了导流。\n（3）站内推荐\n通过app内推荐【得到】给好友，双方均可获得20元优惠券。\n通过周年庆活动，分享活动赠送优惠券。\n（4）创始人个人IP效应\n罗振宇通过《罗辑思维》已积累了大量忠实用户，这一批用户也是注入得到APP的首批种子用户。罗振宇的个人IP效应至今对得到APP的影响也不容小觑。\n（5）打造流量爆款\n![爆款示例](baokuan.jpg)\n得到APP上订阅人数最多的课程是《薛兆丰的经济学课》，已有将近30万人学习。这不难理解，经济学是非常大众的学科，每个人都应该了解一些经济学常识，同时薛兆丰北大讲师的身份使这门课更具有含金量。\n## activation 活跃\n（1）新人福利\n用户注册后可以领取新人知识礼包和优惠券，可以按感兴趣的内容挑选，还有详细的产品使用指导，降低使用门槛。\n（2）免费试听\n用户可以以0.1元购买听书VIP七天体验卡，同时有两门每天更新的免费课程”罗辑思维”和“李翔知识内参”面向所有用户。\n（2）定期举办站内活动\n2018.2.8举办【得到相亲大会】\n2018.2.15举办【和知识一起过春节】\n2018.5.26举办【两周年】庆祝活动\n2018.7.27开播【知识就是力量】\n以及一些不定期的诸如名家直播小活动\n## Retention 留存\n(1) 严格品控\n得到APP对音频严格控制在每秒4.5字（罗振宇是每秒4.2字），把控断句等细节，为用户带来最佳的收听感。\n品控还体现在为内容生产者（大佬主讲人们）赋能，创造金钱等条件让他们专心生产最优质的知识内容，同时也可以使他们的影响力更有含金量，实现平台、内容生产者及用户的“三赢”。\n(2)储存价值\n![价值](jiazhi.png)\n得到APP为用户构建了自己的“笔记”，“学习计划”直接为用户推荐学习时间计划，管理学习进度，“笔记”分为\"我的笔记\"和\"知识城邦\",鼓励用户留下对知识的反馈。\"我的笔记”可以查询总学习时长、收藏和历史纪录，“知识城邦”就相当于社区，可以查看、转发、评论、点赞其他人的笔记，虽说这样得到APP也还没有形成社群，但是记录笔记和关注他人优秀的笔记还是可以为用户带来宝贵的储存价值。\n(3)推送\n得到APP会通过APP弹窗提示、应用推送通知、、公众号、微博等，提醒用户有优惠券、新课程上线、直播预告等，既吸引新用户，又挽留老用户。\n(4)打造UGC社区\n通过构建知识城邦，帮助用户在平台上分享自己的所学和见解，提升个人成就感，同时促进优秀课程的二次曝光。\n## Revenue 收入\n![收入](shouru.png)\n得到APP是一款知识付费产品，因此自然是从付费知识服务中获得营收的。目前收费的板块有两部分，既课程和每天听本书。每天听本书可以按月度和年度收费开通，课程收费在19.9-199元不等，都必须先充值“得贝”，我觉得比较耐人寻味的是得贝金额是固定的几个选项，没有正好19.9、199之类的，所以你想订阅课程肯定会多充值，充值的得贝是不能退款或提现的，这就会使用户多买一些付费内容。\n2018年9月推出线上线下联动学习的得到大学，针对筛选过的优质学员，营收手段从线上逐步向线下精英学院形式深入。\n## Refer 传播推荐\n（1）优秀的内容分享：源自于得到内容本身的高质量，用户自发的分享课程内容和学习到的心得，但往往这类转发分享很少。\n（2）趣味h5分享：例如得到推出的：分享马伯庸免费资源，获得“仗义证”活动，也获得了很好的效果。\n（3）好友邀请：得到APP在好友邀请方面主要还是采用了补贴奖励，邀请成功双方可以获得优惠券。用户可以生成显示自己学习天数的海报，如果用户学习时间长可以”炫耀”，也会刺激用户分享。\n???![推荐](tuijian.png)\n# 竞品分析\n## 喜马拉雅FM VS 得到\n喜马拉雅是行业排名靠前的知识变现平台，作为移动音频领域的领跑者，拥有庞大的用户流量，在当前具有一定的典型性。得到起始于2016年，由罗辑思维推出，为了更好的达到竞品分析的目的，对喜马拉雅与得到在用户、定位、功能、设计、运营及公司策略这几个方面的分析，希望从中获得进一步迭代功能的灵感。\n![竞品分析](fenxi.png)\n**结论：得到试图寻找一种其他竞品没有尝试过的道路，一种不一样的玩法：**\n- 得到不断争取行业或者某领域专家来得到发音频节目。\n- 得到的核心内容深度介于知识分子专精的领域与付费成人教育机构之间，内容精良且深度平均，区别于喜马拉雅大而广的内容体系，强调通过优秀的音频内容去“学习”，掌握某领域的一些知识。喜马拉雅FM没有刻意营造出“学习”氛围，把选择权交给读者，从内容看偏向娱乐。两家公司战略有一定的重合，但更多的是不同，得到专而精，喜马拉雅大而广，目标人群也不一样。","slug":"2019-PM-dedao","published":1,"updated":"2019-10-03T06:48:14.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxax000i2wvclz11nepm","content":"<h1 id=\"问题：体验「得到」\"><a href=\"#问题：体验「得到」\" class=\"headerlink\" title=\"问题：体验「得到」\"></a>问题：体验「得到」</h1><h1 id=\"产品是什么？\"><a href=\"#产品是什么？\" class=\"headerlink\" title=\"产品是什么？\"></a>产品是什么？</h1><h2 id=\"一句话描述产品\"><a href=\"#一句话描述产品\" class=\"headerlink\" title=\"一句话描述产品\"></a>一句话描述产品</h2><p>得到，提供最省时间的知识服务，利用碎片时间获取高浓度知识。</p>\n<h2 id=\"产品满足的需求\"><a href=\"#产品满足的需求\" class=\"headerlink\" title=\"产品满足的需求\"></a>产品满足的需求</h2><p>利用零碎时间，帮助用户高效率阅读，专业的说书人为用户解读好书，搞懂一本书；<br>帮助用户，迅速了解一个领域，包含声音、创业、健康…优化用户跟世界接触的每一面，各领域的高手引导用户；<br>多领域满足客户需求，经济学、管理学、西方艺术、心理学、儿童教育等方面的独家知识专栏。</p>\n<h2 id=\"产品亮点\"><a href=\"#产品亮点\" class=\"headerlink\" title=\"产品亮点\"></a>产品亮点</h2><p>利用零碎时间，由专业成功人士为你解读专业知识，内容包含丰富，听书，看书，大咖云集，以课堂的形式参与，提升你的兴趣。</p>\n<h1 id=\"目标用户与典型场景\"><a href=\"#目标用户与典型场景\" class=\"headerlink\" title=\"目标用户与典型场景\"></a>目标用户与典型场景</h1><h2 id=\"目标用户和典型场景案例1\"><a href=\"#目标用户和典型场景案例1\" class=\"headerlink\" title=\"目标用户和典型场景案例1\"></a>目标用户和典型场景案例1</h2><ol>\n<li>目标用户<br>18-22岁之间为了解其他专业知识，提升自己视野的学生群体</li>\n<li>典型应用场景<br>学生党刚进入大学，为了提升自己综合的素质和培养兴趣，提升自己的课外知识和学习视野，在课堂结束的课间，在食堂，在闲暇之余，他打开APP点开了“知识城邦”，选择自己喜欢的内容，带着耳机，随时随地听到自己想学习的内容。<h2 id=\"目标用户和典型场景案例2\"><a href=\"#目标用户和典型场景案例2\" class=\"headerlink\" title=\"目标用户和典型场景案例2\"></a>目标用户和典型场景案例2</h2></li>\n<li>目标用户<br>23-35岁之间、每天想在工作之外进行充电学习的职场人士</li>\n<li>典型应用场景<br>刚进入职场年轻同学，面对新的环境和新的事情，逐渐感觉缺乏其他方面（例如：法律，经济，管理）的知识。在朋友的推荐下，下载了得到APP，打开自己的“学习计划”，每天上下班的地铁里，公交里，都会听书，看书。逐渐提升了自己的知识水平和视野，又打发了上下班路上无聊的时间。<h2 id=\"目标用户和典型场景案例3：\"><a href=\"#目标用户和典型场景案例3：\" class=\"headerlink\" title=\"目标用户和典型场景案例3：\"></a>目标用户和典型场景案例3：</h2></li>\n<li>目标用户<br>不满足现状，希望提升自己的工作人员</li>\n<li>典型应用场景<br>对于外卖小哥、快递人员，这种底层工作劳动者，他们希望提升自己的知识水平。下载得到APP，打开“发现”栏，选择自己喜欢的作家和文章，他们在送餐、送快递之余可以提升自己，取得进步。<h1 id=\"关键功能与描述\"><a href=\"#关键功能与描述\" class=\"headerlink\" title=\"关键功能与描述\"></a>关键功能与描述</h1><h2 id=\"产品框架\"><a href=\"#产品框架\" class=\"headerlink\" title=\"产品框架\"></a>产品框架</h2>【得到】app主要由【发现】，【学习计划】，【知识城邦】，【已购】，【我的】五个模块页面构成，整体框架梳理如下：<br><img src=\"kuangjia.png\" alt=\"得到整体框架\"><h2 id=\"描述关键功能名称及作用\"><a href=\"#描述关键功能名称及作用\" class=\"headerlink\" title=\"描述关键功能名称及作用\"></a>描述关键功能名称及作用</h2>（1）每天听本书<br>由专家精选好书进行解析拆读，然后以音频的形式供用户学习。用户可以选择自己喜欢类型的书，利用碎片化的时间，轻松的学习到其中的精华。此外，得到的课程人性化的地方在于你可以任选课程的5讲来试听，感兴趣的话在付费购买，这一点用户体验做得很好。<br><img src=\"yemian1.png\" alt=\"每天听本书页面详情\"><br>（2）学习计划<br>制定属于自己的学习计划，既起到了监督和提醒的作用，。又让用户有了归属感。<br><img src=\"yemian2.png\" alt=\"学习计划页面详情\"><br>（3）知识城邦<br><img src=\"yemian3.jpg\" alt=\"知识城邦页面详情\"><br>在知识城邦，用户可以发变自己的看法，提升了互动社交的特性，也可以在此反馈自己对课程的看法，可以促进课堂的改进。<br>（4）已购<br><img src=\"yemian4.png\" alt=\"已购页面详情\"><br>整理出用户已经购买的课程，方便用户快速找到自己的课程<br>（5）听课<br><img src=\"yemian5.png\" alt=\"听课页面详情\"><br>产品最核心的功能，用户选择喜欢的课程进行学习，可以自由调整定时，倍速，快进等功能，较为人性化。附带的划重点能够自动截取到正在听的一段话，并让用户辅助配上自己的心得，帮助用户更好的内化沉淀，以及输出知识。用户也可以在评论区和其他用户分享交流自己的学习体会，整个听课过程形成了选课，听课，吸收，输出的完整环节。<h1 id=\"运营方法\"><a href=\"#运营方法\" class=\"headerlink\" title=\"运营方法\"></a>运营方法</h1><h2 id=\"2018运营事件梳理\"><a href=\"#2018运营事件梳理\" class=\"headerlink\" title=\"2018运营事件梳理\"></a>2018运营事件梳理</h2>得到APP2018年运营事件梳理可见链接：<a href=\"https://mp.weixin.qq.com/s/FEEB1xxtQeoWTIiiDipLrw\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/FEEB1xxtQeoWTIiiDipLrw</a></li>\n</ol>\n<p>重点营销事件包括:赞助最强大脑，上线知识城邦，学习计划，六大学院，薛兆丰课程开启订阅以及跨年演讲，都带来了不错的收益。</p>\n<h2 id=\"AARRR模型梳理\"><a href=\"#AARRR模型梳理\" class=\"headerlink\" title=\"AARRR模型梳理\"></a>AARRR模型梳理</h2><h3 id=\"acquisition-用户获取\"><a href=\"#acquisition-用户获取\" class=\"headerlink\" title=\"acquisition 用户获取\"></a>acquisition 用户获取</h3><p>（1）渠道导流<br>利用微博、微信对得到app的内容进行推广和曝光宣传。【得到】公总号对得到上的优秀内容再包装和二次传播，平均单篇推送阅读量破万。此外，通过【罗辑思维】公众号对得到app上的内容同样进行包装宣传，单篇阅读量均达10万+。此外，还通过知乎，授课讲师自身微博豆瓣等渠道进行推广传播。<br>（2）品牌合作和大型活动<br>《从时间的朋友》到《最强大脑》，从差异化晚会到深度内容合作，罗振宇的知识产品品牌效应正突破圈层，通过不同的媒介，被大家广泛认知。<br>2018年7月，得到APP联合江苏卫视和爱奇艺出品《知识就是力量》这一大型知识类脱口秀节目，深圳卫视延后一天播出。江苏卫视35城首播收视率0.425，爱奇艺3天播放量接近200万，在知识类节目中排名领先。得到APP每周会围绕节目主题的观点进行“延展知识的征集”，引发了观众的广泛参与，实现了导流。<br>（3）站内推荐<br>通过app内推荐【得到】给好友，双方均可获得20元优惠券。<br>通过周年庆活动，分享活动赠送优惠券。<br>（4）创始人个人IP效应<br>罗振宇通过《罗辑思维》已积累了大量忠实用户，这一批用户也是注入得到APP的首批种子用户。罗振宇的个人IP效应至今对得到APP的影响也不容小觑。<br>（5）打造流量爆款<br><img src=\"baokuan.jpg\" alt=\"爆款示例\"><br>得到APP上订阅人数最多的课程是《薛兆丰的经济学课》，已有将近30万人学习。这不难理解，经济学是非常大众的学科，每个人都应该了解一些经济学常识，同时薛兆丰北大讲师的身份使这门课更具有含金量。</p>\n<h2 id=\"activation-活跃\"><a href=\"#activation-活跃\" class=\"headerlink\" title=\"activation 活跃\"></a>activation 活跃</h2><p>（1）新人福利<br>用户注册后可以领取新人知识礼包和优惠券，可以按感兴趣的内容挑选，还有详细的产品使用指导，降低使用门槛。<br>（2）免费试听<br>用户可以以0.1元购买听书VIP七天体验卡，同时有两门每天更新的免费课程”罗辑思维”和“李翔知识内参”面向所有用户。<br>（2）定期举办站内活动<br>2018.2.8举办【得到相亲大会】<br>2018.2.15举办【和知识一起过春节】<br>2018.5.26举办【两周年】庆祝活动<br>2018.7.27开播【知识就是力量】<br>以及一些不定期的诸如名家直播小活动</p>\n<h2 id=\"Retention-留存\"><a href=\"#Retention-留存\" class=\"headerlink\" title=\"Retention 留存\"></a>Retention 留存</h2><p>(1) 严格品控<br>得到APP对音频严格控制在每秒4.5字（罗振宇是每秒4.2字），把控断句等细节，为用户带来最佳的收听感。<br>品控还体现在为内容生产者（大佬主讲人们）赋能，创造金钱等条件让他们专心生产最优质的知识内容，同时也可以使他们的影响力更有含金量，实现平台、内容生产者及用户的“三赢”。<br>(2)储存价值<br><img src=\"jiazhi.png\" alt=\"价值\"><br>得到APP为用户构建了自己的“笔记”，“学习计划”直接为用户推荐学习时间计划，管理学习进度，“笔记”分为”我的笔记”和”知识城邦”,鼓励用户留下对知识的反馈。”我的笔记”可以查询总学习时长、收藏和历史纪录，“知识城邦”就相当于社区，可以查看、转发、评论、点赞其他人的笔记，虽说这样得到APP也还没有形成社群，但是记录笔记和关注他人优秀的笔记还是可以为用户带来宝贵的储存价值。<br>(3)推送<br>得到APP会通过APP弹窗提示、应用推送通知、、公众号、微博等，提醒用户有优惠券、新课程上线、直播预告等，既吸引新用户，又挽留老用户。<br>(4)打造UGC社区<br>通过构建知识城邦，帮助用户在平台上分享自己的所学和见解，提升个人成就感，同时促进优秀课程的二次曝光。</p>\n<h2 id=\"Revenue-收入\"><a href=\"#Revenue-收入\" class=\"headerlink\" title=\"Revenue 收入\"></a>Revenue 收入</h2><p><img src=\"shouru.png\" alt=\"收入\"><br>得到APP是一款知识付费产品，因此自然是从付费知识服务中获得营收的。目前收费的板块有两部分，既课程和每天听本书。每天听本书可以按月度和年度收费开通，课程收费在19.9-199元不等，都必须先充值“得贝”，我觉得比较耐人寻味的是得贝金额是固定的几个选项，没有正好19.9、199之类的，所以你想订阅课程肯定会多充值，充值的得贝是不能退款或提现的，这就会使用户多买一些付费内容。<br>2018年9月推出线上线下联动学习的得到大学，针对筛选过的优质学员，营收手段从线上逐步向线下精英学院形式深入。</p>\n<h2 id=\"Refer-传播推荐\"><a href=\"#Refer-传播推荐\" class=\"headerlink\" title=\"Refer 传播推荐\"></a>Refer 传播推荐</h2><p>（1）优秀的内容分享：源自于得到内容本身的高质量，用户自发的分享课程内容和学习到的心得，但往往这类转发分享很少。<br>（2）趣味h5分享：例如得到推出的：分享马伯庸免费资源，获得“仗义证”活动，也获得了很好的效果。<br>（3）好友邀请：得到APP在好友邀请方面主要还是采用了补贴奖励，邀请成功双方可以获得优惠券。用户可以生成显示自己学习天数的海报，如果用户学习时间长可以”炫耀”，也会刺激用户分享。<br>???<img src=\"tuijian.png\" alt=\"推荐\"></p>\n<h1 id=\"竞品分析\"><a href=\"#竞品分析\" class=\"headerlink\" title=\"竞品分析\"></a>竞品分析</h1><h2 id=\"喜马拉雅FM-VS-得到\"><a href=\"#喜马拉雅FM-VS-得到\" class=\"headerlink\" title=\"喜马拉雅FM VS 得到\"></a>喜马拉雅FM VS 得到</h2><p>喜马拉雅是行业排名靠前的知识变现平台，作为移动音频领域的领跑者，拥有庞大的用户流量，在当前具有一定的典型性。得到起始于2016年，由罗辑思维推出，为了更好的达到竞品分析的目的，对喜马拉雅与得到在用户、定位、功能、设计、运营及公司策略这几个方面的分析，希望从中获得进一步迭代功能的灵感。<br><img src=\"fenxi.png\" alt=\"竞品分析\"><br><strong>结论：得到试图寻找一种其他竞品没有尝试过的道路，一种不一样的玩法：</strong></p>\n<ul>\n<li>得到不断争取行业或者某领域专家来得到发音频节目。</li>\n<li>得到的核心内容深度介于知识分子专精的领域与付费成人教育机构之间，内容精良且深度平均，区别于喜马拉雅大而广的内容体系，强调通过优秀的音频内容去“学习”，掌握某领域的一些知识。喜马拉雅FM没有刻意营造出“学习”氛围，把选择权交给读者，从内容看偏向娱乐。两家公司战略有一定的重合，但更多的是不同，得到专而精，喜马拉雅大而广，目标人群也不一样。</li>\n</ul>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"问题：体验「得到」\"><a href=\"#问题：体验「得到」\" class=\"headerlink\" title=\"问题：体验「得到」\"></a>问题：体验「得到」</h1><h1 id=\"产品是什么？\"><a href=\"#产品是什么？\" class=\"headerlink\" title=\"产品是什么？\"></a>产品是什么？</h1><h2 id=\"一句话描述产品\"><a href=\"#一句话描述产品\" class=\"headerlink\" title=\"一句话描述产品\"></a>一句话描述产品</h2><p>得到，提供最省时间的知识服务，利用碎片时间获取高浓度知识。</p>\n<h2 id=\"产品满足的需求\"><a href=\"#产品满足的需求\" class=\"headerlink\" title=\"产品满足的需求\"></a>产品满足的需求</h2><p>利用零碎时间，帮助用户高效率阅读，专业的说书人为用户解读好书，搞懂一本书；<br>帮助用户，迅速了解一个领域，包含声音、创业、健康…优化用户跟世界接触的每一面，各领域的高手引导用户；<br>多领域满足客户需求，经济学、管理学、西方艺术、心理学、儿童教育等方面的独家知识专栏。</p>\n<h2 id=\"产品亮点\"><a href=\"#产品亮点\" class=\"headerlink\" title=\"产品亮点\"></a>产品亮点</h2><p>利用零碎时间，由专业成功人士为你解读专业知识，内容包含丰富，听书，看书，大咖云集，以课堂的形式参与，提升你的兴趣。</p>\n<h1 id=\"目标用户与典型场景\"><a href=\"#目标用户与典型场景\" class=\"headerlink\" title=\"目标用户与典型场景\"></a>目标用户与典型场景</h1><h2 id=\"目标用户和典型场景案例1\"><a href=\"#目标用户和典型场景案例1\" class=\"headerlink\" title=\"目标用户和典型场景案例1\"></a>目标用户和典型场景案例1</h2><ol>\n<li>目标用户<br>18-22岁之间为了解其他专业知识，提升自己视野的学生群体</li>\n<li>典型应用场景<br>学生党刚进入大学，为了提升自己综合的素质和培养兴趣，提升自己的课外知识和学习视野，在课堂结束的课间，在食堂，在闲暇之余，他打开APP点开了“知识城邦”，选择自己喜欢的内容，带着耳机，随时随地听到自己想学习的内容。<h2 id=\"目标用户和典型场景案例2\"><a href=\"#目标用户和典型场景案例2\" class=\"headerlink\" title=\"目标用户和典型场景案例2\"></a>目标用户和典型场景案例2</h2></li>\n<li>目标用户<br>23-35岁之间、每天想在工作之外进行充电学习的职场人士</li>\n<li>典型应用场景<br>刚进入职场年轻同学，面对新的环境和新的事情，逐渐感觉缺乏其他方面（例如：法律，经济，管理）的知识。在朋友的推荐下，下载了得到APP，打开自己的“学习计划”，每天上下班的地铁里，公交里，都会听书，看书。逐渐提升了自己的知识水平和视野，又打发了上下班路上无聊的时间。<h2 id=\"目标用户和典型场景案例3：\"><a href=\"#目标用户和典型场景案例3：\" class=\"headerlink\" title=\"目标用户和典型场景案例3：\"></a>目标用户和典型场景案例3：</h2></li>\n<li>目标用户<br>不满足现状，希望提升自己的工作人员</li>\n<li>典型应用场景<br>对于外卖小哥、快递人员，这种底层工作劳动者，他们希望提升自己的知识水平。下载得到APP，打开“发现”栏，选择自己喜欢的作家和文章，他们在送餐、送快递之余可以提升自己，取得进步。<h1 id=\"关键功能与描述\"><a href=\"#关键功能与描述\" class=\"headerlink\" title=\"关键功能与描述\"></a>关键功能与描述</h1><h2 id=\"产品框架\"><a href=\"#产品框架\" class=\"headerlink\" title=\"产品框架\"></a>产品框架</h2>【得到】app主要由【发现】，【学习计划】，【知识城邦】，【已购】，【我的】五个模块页面构成，整体框架梳理如下：<br><img src=\"kuangjia.png\" alt=\"得到整体框架\"><h2 id=\"描述关键功能名称及作用\"><a href=\"#描述关键功能名称及作用\" class=\"headerlink\" title=\"描述关键功能名称及作用\"></a>描述关键功能名称及作用</h2>（1）每天听本书<br>由专家精选好书进行解析拆读，然后以音频的形式供用户学习。用户可以选择自己喜欢类型的书，利用碎片化的时间，轻松的学习到其中的精华。此外，得到的课程人性化的地方在于你可以任选课程的5讲来试听，感兴趣的话在付费购买，这一点用户体验做得很好。<br><img src=\"yemian1.png\" alt=\"每天听本书页面详情\"><br>（2）学习计划<br>制定属于自己的学习计划，既起到了监督和提醒的作用，。又让用户有了归属感。<br><img src=\"yemian2.png\" alt=\"学习计划页面详情\"><br>（3）知识城邦<br><img src=\"yemian3.jpg\" alt=\"知识城邦页面详情\"><br>在知识城邦，用户可以发变自己的看法，提升了互动社交的特性，也可以在此反馈自己对课程的看法，可以促进课堂的改进。<br>（4）已购<br><img src=\"yemian4.png\" alt=\"已购页面详情\"><br>整理出用户已经购买的课程，方便用户快速找到自己的课程<br>（5）听课<br><img src=\"yemian5.png\" alt=\"听课页面详情\"><br>产品最核心的功能，用户选择喜欢的课程进行学习，可以自由调整定时，倍速，快进等功能，较为人性化。附带的划重点能够自动截取到正在听的一段话，并让用户辅助配上自己的心得，帮助用户更好的内化沉淀，以及输出知识。用户也可以在评论区和其他用户分享交流自己的学习体会，整个听课过程形成了选课，听课，吸收，输出的完整环节。<h1 id=\"运营方法\"><a href=\"#运营方法\" class=\"headerlink\" title=\"运营方法\"></a>运营方法</h1><h2 id=\"2018运营事件梳理\"><a href=\"#2018运营事件梳理\" class=\"headerlink\" title=\"2018运营事件梳理\"></a>2018运营事件梳理</h2>得到APP2018年运营事件梳理可见链接：<a href=\"https://mp.weixin.qq.com/s/FEEB1xxtQeoWTIiiDipLrw\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/FEEB1xxtQeoWTIiiDipLrw</a></li>\n</ol>\n<p>重点营销事件包括:赞助最强大脑，上线知识城邦，学习计划，六大学院，薛兆丰课程开启订阅以及跨年演讲，都带来了不错的收益。</p>\n<h2 id=\"AARRR模型梳理\"><a href=\"#AARRR模型梳理\" class=\"headerlink\" title=\"AARRR模型梳理\"></a>AARRR模型梳理</h2><h3 id=\"acquisition-用户获取\"><a href=\"#acquisition-用户获取\" class=\"headerlink\" title=\"acquisition 用户获取\"></a>acquisition 用户获取</h3><p>（1）渠道导流<br>利用微博、微信对得到app的内容进行推广和曝光宣传。【得到】公总号对得到上的优秀内容再包装和二次传播，平均单篇推送阅读量破万。此外，通过【罗辑思维】公众号对得到app上的内容同样进行包装宣传，单篇阅读量均达10万+。此外，还通过知乎，授课讲师自身微博豆瓣等渠道进行推广传播。<br>（2）品牌合作和大型活动<br>《从时间的朋友》到《最强大脑》，从差异化晚会到深度内容合作，罗振宇的知识产品品牌效应正突破圈层，通过不同的媒介，被大家广泛认知。<br>2018年7月，得到APP联合江苏卫视和爱奇艺出品《知识就是力量》这一大型知识类脱口秀节目，深圳卫视延后一天播出。江苏卫视35城首播收视率0.425，爱奇艺3天播放量接近200万，在知识类节目中排名领先。得到APP每周会围绕节目主题的观点进行“延展知识的征集”，引发了观众的广泛参与，实现了导流。<br>（3）站内推荐<br>通过app内推荐【得到】给好友，双方均可获得20元优惠券。<br>通过周年庆活动，分享活动赠送优惠券。<br>（4）创始人个人IP效应<br>罗振宇通过《罗辑思维》已积累了大量忠实用户，这一批用户也是注入得到APP的首批种子用户。罗振宇的个人IP效应至今对得到APP的影响也不容小觑。<br>（5）打造流量爆款<br><img src=\"baokuan.jpg\" alt=\"爆款示例\"><br>得到APP上订阅人数最多的课程是《薛兆丰的经济学课》，已有将近30万人学习。这不难理解，经济学是非常大众的学科，每个人都应该了解一些经济学常识，同时薛兆丰北大讲师的身份使这门课更具有含金量。</p>\n<h2 id=\"activation-活跃\"><a href=\"#activation-活跃\" class=\"headerlink\" title=\"activation 活跃\"></a>activation 活跃</h2><p>（1）新人福利<br>用户注册后可以领取新人知识礼包和优惠券，可以按感兴趣的内容挑选，还有详细的产品使用指导，降低使用门槛。<br>（2）免费试听<br>用户可以以0.1元购买听书VIP七天体验卡，同时有两门每天更新的免费课程”罗辑思维”和“李翔知识内参”面向所有用户。<br>（2）定期举办站内活动<br>2018.2.8举办【得到相亲大会】<br>2018.2.15举办【和知识一起过春节】<br>2018.5.26举办【两周年】庆祝活动<br>2018.7.27开播【知识就是力量】<br>以及一些不定期的诸如名家直播小活动</p>\n<h2 id=\"Retention-留存\"><a href=\"#Retention-留存\" class=\"headerlink\" title=\"Retention 留存\"></a>Retention 留存</h2><p>(1) 严格品控<br>得到APP对音频严格控制在每秒4.5字（罗振宇是每秒4.2字），把控断句等细节，为用户带来最佳的收听感。<br>品控还体现在为内容生产者（大佬主讲人们）赋能，创造金钱等条件让他们专心生产最优质的知识内容，同时也可以使他们的影响力更有含金量，实现平台、内容生产者及用户的“三赢”。<br>(2)储存价值<br><img src=\"jiazhi.png\" alt=\"价值\"><br>得到APP为用户构建了自己的“笔记”，“学习计划”直接为用户推荐学习时间计划，管理学习进度，“笔记”分为”我的笔记”和”知识城邦”,鼓励用户留下对知识的反馈。”我的笔记”可以查询总学习时长、收藏和历史纪录，“知识城邦”就相当于社区，可以查看、转发、评论、点赞其他人的笔记，虽说这样得到APP也还没有形成社群，但是记录笔记和关注他人优秀的笔记还是可以为用户带来宝贵的储存价值。<br>(3)推送<br>得到APP会通过APP弹窗提示、应用推送通知、、公众号、微博等，提醒用户有优惠券、新课程上线、直播预告等，既吸引新用户，又挽留老用户。<br>(4)打造UGC社区<br>通过构建知识城邦，帮助用户在平台上分享自己的所学和见解，提升个人成就感，同时促进优秀课程的二次曝光。</p>\n<h2 id=\"Revenue-收入\"><a href=\"#Revenue-收入\" class=\"headerlink\" title=\"Revenue 收入\"></a>Revenue 收入</h2><p><img src=\"shouru.png\" alt=\"收入\"><br>得到APP是一款知识付费产品，因此自然是从付费知识服务中获得营收的。目前收费的板块有两部分，既课程和每天听本书。每天听本书可以按月度和年度收费开通，课程收费在19.9-199元不等，都必须先充值“得贝”，我觉得比较耐人寻味的是得贝金额是固定的几个选项，没有正好19.9、199之类的，所以你想订阅课程肯定会多充值，充值的得贝是不能退款或提现的，这就会使用户多买一些付费内容。<br>2018年9月推出线上线下联动学习的得到大学，针对筛选过的优质学员，营收手段从线上逐步向线下精英学院形式深入。</p>\n<h2 id=\"Refer-传播推荐\"><a href=\"#Refer-传播推荐\" class=\"headerlink\" title=\"Refer 传播推荐\"></a>Refer 传播推荐</h2><p>（1）优秀的内容分享：源自于得到内容本身的高质量，用户自发的分享课程内容和学习到的心得，但往往这类转发分享很少。<br>（2）趣味h5分享：例如得到推出的：分享马伯庸免费资源，获得“仗义证”活动，也获得了很好的效果。<br>（3）好友邀请：得到APP在好友邀请方面主要还是采用了补贴奖励，邀请成功双方可以获得优惠券。用户可以生成显示自己学习天数的海报，如果用户学习时间长可以”炫耀”，也会刺激用户分享。<br>???<img src=\"tuijian.png\" alt=\"推荐\"></p>\n<h1 id=\"竞品分析\"><a href=\"#竞品分析\" class=\"headerlink\" title=\"竞品分析\"></a>竞品分析</h1><h2 id=\"喜马拉雅FM-VS-得到\"><a href=\"#喜马拉雅FM-VS-得到\" class=\"headerlink\" title=\"喜马拉雅FM VS 得到\"></a>喜马拉雅FM VS 得到</h2><p>喜马拉雅是行业排名靠前的知识变现平台，作为移动音频领域的领跑者，拥有庞大的用户流量，在当前具有一定的典型性。得到起始于2016年，由罗辑思维推出，为了更好的达到竞品分析的目的，对喜马拉雅与得到在用户、定位、功能、设计、运营及公司策略这几个方面的分析，希望从中获得进一步迭代功能的灵感。<br><img src=\"fenxi.png\" alt=\"竞品分析\"><br><strong>结论：得到试图寻找一种其他竞品没有尝试过的道路，一种不一样的玩法：</strong></p>\n<ul>\n<li>得到不断争取行业或者某领域专家来得到发音频节目。</li>\n<li>得到的核心内容深度介于知识分子专精的领域与付费成人教育机构之间，内容精良且深度平均，区别于喜马拉雅大而广的内容体系，强调通过优秀的音频内容去“学习”，掌握某领域的一些知识。喜马拉雅FM没有刻意营造出“学习”氛围，把选择权交给读者，从内容看偏向娱乐。两家公司战略有一定的重合，但更多的是不同，得到专而精，喜马拉雅大而广，目标人群也不一样。</li>\n</ul>\n"},{"title":"需求分析及优先级排序","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-10-03T06:22:26.000Z","password":null,"summary":null,"_content":"\n# 问题：需求分析及优先级排序\n假设你是好豆新入职的产品助理。在经过多次团队讨论后，为了满足用户更丰富的需求，提升使用体验，你的leader想要在APP里加入【直播】功能。但是具体应该怎么做，肯定需要先分析一下用户的需求。现在领导把这个任务交给了你，让你根据调研用户情况，撰写一份需求分析报告。\n\n\n# 产品简介\n好豆，拥有过百万道新鲜时尚的美食做法，近千万条品质生活的美食资讯，上亿种一日三餐的搭配，是一款超过 1 亿用户选择的美食 App。\n\n# 用户反馈\n为满足用户更丰富的需求，提升使用体验，计划在好豆中加入直播功能。\n\n通过【用户—场景—问题—解决方案】的方法对直播需求进行了分析，主要涉及的潜在用户大体上可以分为以下六大类：\n\n- 想学做菜的用户：直播学习更有趣，更高效。\n- 想挖掘新菜谱的用户：直播可以和其他用户交流，节省挑菜谱的时间。\n- 分享菜谱的用户：直播相比写菜谱更高效省时，更容易得到用户的认可。\n- 想获得收益和影响力的美食机构、美食博主：通过直播可以提升知名度，用户点赞获得收益。\n- 运营人员：通过拉新、促活获取和存留用户，最后推动用户转化变现。\n- 老板：想和大V或明星合作，提升产品知名度，拓展收入渠道来源。\n# 用户需求和产品需求\n通过【用户-场景-问题-现有解决方案】思维导图梳理，得出以下五大用户需求，并将其转化为产品需求。\n![思维导图](siweidaotu.png)\n![产品需求](xuqiu.png)\n# 产品需求优先级排序\n1. 看用户和发生频率\n用户量和发生频率四象限分析：\n![用户量和发生频率](sixiangxian.png)\n\n2. 开发难度和效果\n![开发难度和效果](kaifanandu.png)\n\n3. 看产品价值\n- 迫切程度：基础直播功能 > 评论弹幕功能 > 点赞功能 > 打赏功能 > 滤镜功能 >直播回看功能；\n- 付费意愿：基础直播功能 >评论弹幕功能 > 打赏功能 > 滤镜功能 >直播回看功能 > 点赞功能。\n4. 对目标群体熟悉程度\n- 场景1\n目标群体：美食生产者\n25~40岁左右，生活水平和质量较高的中产阶级，有充裕的时间练习厨艺或从事厨艺工作，生活之余愿意花费较多的时间和精力于创作菜谱，录制直播视频，享受因为创作带来的认可，同时也希望自己的创作能带来额外的收入。\n- 场景2\n目标群体：内容消费者\n20~40岁左右，想提升厨艺或学习新菜谱的大学生、都市白领，希望通过观看做菜直播、和菜友直播弹屏或社区互动的同时，不需要花费太多的思考时间去研习菜谱做法，轻松愉快的有人带领自己学习做菜，假若菜谱里的食材和厨具能一键采购，也是可以考虑尝试购买。\n- 场景3\n目标群体：运营人员\n“好豆菜谱”产品的运营人员，希望通过直播功能邀请一些大V或者明星坐镇，通过其影响力能为产品带来大量的流量和新用户，积累用户之后再通过各种活动和优质的内容留存用户，为后期用户转化变现储备力量。\n- 场景4\n目标群体：老板。\n想通过直播功能与大V或明星合作，打响产品的知名度，获得更多的用户群，拓展收入渠道来源，增加产品营收。\n# 优先级排序总结\n- 基础直播功能\n- 点赞评论弹幕功能\n- 滤镜功能\n- 打赏功能\n- 直播回看功能\n# 总结\n1. 用户：直播功能的推出，第一批核心用户应该是平台内容的消费者，他们既是平台活跃率的来源，同时也是平台转化变现的主体。\n2. 场景：内容消费者，在工作日下班后，或双休日期间，想学习下新的菜式时，打开“好豆菜谱”app，通过直播宣传栏目，看到直播的内容或直播的大V是自己喜欢的情况下，会点击使用直播此功能。\n3. 问题：直播打开率的最大痛点是直播内容和大V用户对用户的吸引力度，需要寻找知名度高用户喜欢的明星或大V参与直播录制，但投入费用高，用户对app的使用场景较窄，进行直播时打开率不一定高。\n4. 对比：在app没有推出直播功能方案的前提下，用户的解决方案是——选择有视频录播教程的同类软件，如“下厨房”的学习模块，这样就容易出现本产品用户向竞品流失的问题，如果直播/回放功能的上线，用户需求得到了解决，平台的忠实用户需求得到满足，产品的留存率便会提高，后期转化变现的可能性将变大。\n ","source":"_posts/2019-PM-demand-analysis.md","raw":"---\ntitle: 需求分析及优先级排序\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-10-03 14:22:26\npassword:\nsummary:\ntags:\n- PM\ncategories:\n- PM\n---\n\n# 问题：需求分析及优先级排序\n假设你是好豆新入职的产品助理。在经过多次团队讨论后，为了满足用户更丰富的需求，提升使用体验，你的leader想要在APP里加入【直播】功能。但是具体应该怎么做，肯定需要先分析一下用户的需求。现在领导把这个任务交给了你，让你根据调研用户情况，撰写一份需求分析报告。\n\n\n# 产品简介\n好豆，拥有过百万道新鲜时尚的美食做法，近千万条品质生活的美食资讯，上亿种一日三餐的搭配，是一款超过 1 亿用户选择的美食 App。\n\n# 用户反馈\n为满足用户更丰富的需求，提升使用体验，计划在好豆中加入直播功能。\n\n通过【用户—场景—问题—解决方案】的方法对直播需求进行了分析，主要涉及的潜在用户大体上可以分为以下六大类：\n\n- 想学做菜的用户：直播学习更有趣，更高效。\n- 想挖掘新菜谱的用户：直播可以和其他用户交流，节省挑菜谱的时间。\n- 分享菜谱的用户：直播相比写菜谱更高效省时，更容易得到用户的认可。\n- 想获得收益和影响力的美食机构、美食博主：通过直播可以提升知名度，用户点赞获得收益。\n- 运营人员：通过拉新、促活获取和存留用户，最后推动用户转化变现。\n- 老板：想和大V或明星合作，提升产品知名度，拓展收入渠道来源。\n# 用户需求和产品需求\n通过【用户-场景-问题-现有解决方案】思维导图梳理，得出以下五大用户需求，并将其转化为产品需求。\n![思维导图](siweidaotu.png)\n![产品需求](xuqiu.png)\n# 产品需求优先级排序\n1. 看用户和发生频率\n用户量和发生频率四象限分析：\n![用户量和发生频率](sixiangxian.png)\n\n2. 开发难度和效果\n![开发难度和效果](kaifanandu.png)\n\n3. 看产品价值\n- 迫切程度：基础直播功能 > 评论弹幕功能 > 点赞功能 > 打赏功能 > 滤镜功能 >直播回看功能；\n- 付费意愿：基础直播功能 >评论弹幕功能 > 打赏功能 > 滤镜功能 >直播回看功能 > 点赞功能。\n4. 对目标群体熟悉程度\n- 场景1\n目标群体：美食生产者\n25~40岁左右，生活水平和质量较高的中产阶级，有充裕的时间练习厨艺或从事厨艺工作，生活之余愿意花费较多的时间和精力于创作菜谱，录制直播视频，享受因为创作带来的认可，同时也希望自己的创作能带来额外的收入。\n- 场景2\n目标群体：内容消费者\n20~40岁左右，想提升厨艺或学习新菜谱的大学生、都市白领，希望通过观看做菜直播、和菜友直播弹屏或社区互动的同时，不需要花费太多的思考时间去研习菜谱做法，轻松愉快的有人带领自己学习做菜，假若菜谱里的食材和厨具能一键采购，也是可以考虑尝试购买。\n- 场景3\n目标群体：运营人员\n“好豆菜谱”产品的运营人员，希望通过直播功能邀请一些大V或者明星坐镇，通过其影响力能为产品带来大量的流量和新用户，积累用户之后再通过各种活动和优质的内容留存用户，为后期用户转化变现储备力量。\n- 场景4\n目标群体：老板。\n想通过直播功能与大V或明星合作，打响产品的知名度，获得更多的用户群，拓展收入渠道来源，增加产品营收。\n# 优先级排序总结\n- 基础直播功能\n- 点赞评论弹幕功能\n- 滤镜功能\n- 打赏功能\n- 直播回看功能\n# 总结\n1. 用户：直播功能的推出，第一批核心用户应该是平台内容的消费者，他们既是平台活跃率的来源，同时也是平台转化变现的主体。\n2. 场景：内容消费者，在工作日下班后，或双休日期间，想学习下新的菜式时，打开“好豆菜谱”app，通过直播宣传栏目，看到直播的内容或直播的大V是自己喜欢的情况下，会点击使用直播此功能。\n3. 问题：直播打开率的最大痛点是直播内容和大V用户对用户的吸引力度，需要寻找知名度高用户喜欢的明星或大V参与直播录制，但投入费用高，用户对app的使用场景较窄，进行直播时打开率不一定高。\n4. 对比：在app没有推出直播功能方案的前提下，用户的解决方案是——选择有视频录播教程的同类软件，如“下厨房”的学习模块，这样就容易出现本产品用户向竞品流失的问题，如果直播/回放功能的上线，用户需求得到了解决，平台的忠实用户需求得到满足，产品的留存率便会提高，后期转化变现的可能性将变大。\n ","slug":"2019-PM-demand-analysis","published":1,"updated":"2019-10-03T06:24:25.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxb0000n2wvc2vjd5yi5","content":"<h1 id=\"问题：需求分析及优先级排序\"><a href=\"#问题：需求分析及优先级排序\" class=\"headerlink\" title=\"问题：需求分析及优先级排序\"></a>问题：需求分析及优先级排序</h1><p>假设你是好豆新入职的产品助理。在经过多次团队讨论后，为了满足用户更丰富的需求，提升使用体验，你的leader想要在APP里加入【直播】功能。但是具体应该怎么做，肯定需要先分析一下用户的需求。现在领导把这个任务交给了你，让你根据调研用户情况，撰写一份需求分析报告。</p>\n<h1 id=\"产品简介\"><a href=\"#产品简介\" class=\"headerlink\" title=\"产品简介\"></a>产品简介</h1><p>好豆，拥有过百万道新鲜时尚的美食做法，近千万条品质生活的美食资讯，上亿种一日三餐的搭配，是一款超过 1 亿用户选择的美食 App。</p>\n<h1 id=\"用户反馈\"><a href=\"#用户反馈\" class=\"headerlink\" title=\"用户反馈\"></a>用户反馈</h1><p>为满足用户更丰富的需求，提升使用体验，计划在好豆中加入直播功能。</p>\n<p>通过【用户—场景—问题—解决方案】的方法对直播需求进行了分析，主要涉及的潜在用户大体上可以分为以下六大类：</p>\n<ul>\n<li>想学做菜的用户：直播学习更有趣，更高效。</li>\n<li>想挖掘新菜谱的用户：直播可以和其他用户交流，节省挑菜谱的时间。</li>\n<li>分享菜谱的用户：直播相比写菜谱更高效省时，更容易得到用户的认可。</li>\n<li>想获得收益和影响力的美食机构、美食博主：通过直播可以提升知名度，用户点赞获得收益。</li>\n<li>运营人员：通过拉新、促活获取和存留用户，最后推动用户转化变现。</li>\n<li>老板：想和大V或明星合作，提升产品知名度，拓展收入渠道来源。<h1 id=\"用户需求和产品需求\"><a href=\"#用户需求和产品需求\" class=\"headerlink\" title=\"用户需求和产品需求\"></a>用户需求和产品需求</h1>通过【用户-场景-问题-现有解决方案】思维导图梳理，得出以下五大用户需求，并将其转化为产品需求。<br><img src=\"siweidaotu.png\" alt=\"思维导图\"><br><img src=\"xuqiu.png\" alt=\"产品需求\"><h1 id=\"产品需求优先级排序\"><a href=\"#产品需求优先级排序\" class=\"headerlink\" title=\"产品需求优先级排序\"></a>产品需求优先级排序</h1></li>\n</ul>\n<ol>\n<li><p>看用户和发生频率<br>用户量和发生频率四象限分析：<br><img src=\"sixiangxian.png\" alt=\"用户量和发生频率\"></p>\n</li>\n<li><p>开发难度和效果<br><img src=\"kaifanandu.png\" alt=\"开发难度和效果\"></p>\n</li>\n<li><p>看产品价值</p>\n</li>\n</ol>\n<ul>\n<li>迫切程度：基础直播功能 &gt; 评论弹幕功能 &gt; 点赞功能 &gt; 打赏功能 &gt; 滤镜功能 &gt;直播回看功能；</li>\n<li>付费意愿：基础直播功能 &gt;评论弹幕功能 &gt; 打赏功能 &gt; 滤镜功能 &gt;直播回看功能 &gt; 点赞功能。</li>\n</ul>\n<ol start=\"4\">\n<li>对目标群体熟悉程度</li>\n</ol>\n<ul>\n<li>场景1<br>目标群体：美食生产者<br>25~40岁左右，生活水平和质量较高的中产阶级，有充裕的时间练习厨艺或从事厨艺工作，生活之余愿意花费较多的时间和精力于创作菜谱，录制直播视频，享受因为创作带来的认可，同时也希望自己的创作能带来额外的收入。</li>\n<li>场景2<br>目标群体：内容消费者<br>20~40岁左右，想提升厨艺或学习新菜谱的大学生、都市白领，希望通过观看做菜直播、和菜友直播弹屏或社区互动的同时，不需要花费太多的思考时间去研习菜谱做法，轻松愉快的有人带领自己学习做菜，假若菜谱里的食材和厨具能一键采购，也是可以考虑尝试购买。</li>\n<li>场景3<br>目标群体：运营人员<br>“好豆菜谱”产品的运营人员，希望通过直播功能邀请一些大V或者明星坐镇，通过其影响力能为产品带来大量的流量和新用户，积累用户之后再通过各种活动和优质的内容留存用户，为后期用户转化变现储备力量。</li>\n<li>场景4<br>目标群体：老板。<br>想通过直播功能与大V或明星合作，打响产品的知名度，获得更多的用户群，拓展收入渠道来源，增加产品营收。<h1 id=\"优先级排序总结\"><a href=\"#优先级排序总结\" class=\"headerlink\" title=\"优先级排序总结\"></a>优先级排序总结</h1></li>\n<li>基础直播功能</li>\n<li>点赞评论弹幕功能</li>\n<li>滤镜功能</li>\n<li>打赏功能</li>\n<li>直播回看功能<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1></li>\n</ul>\n<ol>\n<li>用户：直播功能的推出，第一批核心用户应该是平台内容的消费者，他们既是平台活跃率的来源，同时也是平台转化变现的主体。</li>\n<li>场景：内容消费者，在工作日下班后，或双休日期间，想学习下新的菜式时，打开“好豆菜谱”app，通过直播宣传栏目，看到直播的内容或直播的大V是自己喜欢的情况下，会点击使用直播此功能。</li>\n<li>问题：直播打开率的最大痛点是直播内容和大V用户对用户的吸引力度，需要寻找知名度高用户喜欢的明星或大V参与直播录制，但投入费用高，用户对app的使用场景较窄，进行直播时打开率不一定高。</li>\n<li>对比：在app没有推出直播功能方案的前提下，用户的解决方案是——选择有视频录播教程的同类软件，如“下厨房”的学习模块，这样就容易出现本产品用户向竞品流失的问题，如果直播/回放功能的上线，用户需求得到了解决，平台的忠实用户需求得到满足，产品的留存率便会提高，后期转化变现的可能性将变大。</li>\n</ol>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"问题：需求分析及优先级排序\"><a href=\"#问题：需求分析及优先级排序\" class=\"headerlink\" title=\"问题：需求分析及优先级排序\"></a>问题：需求分析及优先级排序</h1><p>假设你是好豆新入职的产品助理。在经过多次团队讨论后，为了满足用户更丰富的需求，提升使用体验，你的leader想要在APP里加入【直播】功能。但是具体应该怎么做，肯定需要先分析一下用户的需求。现在领导把这个任务交给了你，让你根据调研用户情况，撰写一份需求分析报告。</p>\n<h1 id=\"产品简介\"><a href=\"#产品简介\" class=\"headerlink\" title=\"产品简介\"></a>产品简介</h1><p>好豆，拥有过百万道新鲜时尚的美食做法，近千万条品质生活的美食资讯，上亿种一日三餐的搭配，是一款超过 1 亿用户选择的美食 App。</p>\n<h1 id=\"用户反馈\"><a href=\"#用户反馈\" class=\"headerlink\" title=\"用户反馈\"></a>用户反馈</h1><p>为满足用户更丰富的需求，提升使用体验，计划在好豆中加入直播功能。</p>\n<p>通过【用户—场景—问题—解决方案】的方法对直播需求进行了分析，主要涉及的潜在用户大体上可以分为以下六大类：</p>\n<ul>\n<li>想学做菜的用户：直播学习更有趣，更高效。</li>\n<li>想挖掘新菜谱的用户：直播可以和其他用户交流，节省挑菜谱的时间。</li>\n<li>分享菜谱的用户：直播相比写菜谱更高效省时，更容易得到用户的认可。</li>\n<li>想获得收益和影响力的美食机构、美食博主：通过直播可以提升知名度，用户点赞获得收益。</li>\n<li>运营人员：通过拉新、促活获取和存留用户，最后推动用户转化变现。</li>\n<li>老板：想和大V或明星合作，提升产品知名度，拓展收入渠道来源。<h1 id=\"用户需求和产品需求\"><a href=\"#用户需求和产品需求\" class=\"headerlink\" title=\"用户需求和产品需求\"></a>用户需求和产品需求</h1>通过【用户-场景-问题-现有解决方案】思维导图梳理，得出以下五大用户需求，并将其转化为产品需求。<br><img src=\"siweidaotu.png\" alt=\"思维导图\"><br><img src=\"xuqiu.png\" alt=\"产品需求\"><h1 id=\"产品需求优先级排序\"><a href=\"#产品需求优先级排序\" class=\"headerlink\" title=\"产品需求优先级排序\"></a>产品需求优先级排序</h1></li>\n</ul>\n<ol>\n<li><p>看用户和发生频率<br>用户量和发生频率四象限分析：<br><img src=\"sixiangxian.png\" alt=\"用户量和发生频率\"></p>\n</li>\n<li><p>开发难度和效果<br><img src=\"kaifanandu.png\" alt=\"开发难度和效果\"></p>\n</li>\n<li><p>看产品价值</p>\n</li>\n</ol>\n<ul>\n<li>迫切程度：基础直播功能 &gt; 评论弹幕功能 &gt; 点赞功能 &gt; 打赏功能 &gt; 滤镜功能 &gt;直播回看功能；</li>\n<li>付费意愿：基础直播功能 &gt;评论弹幕功能 &gt; 打赏功能 &gt; 滤镜功能 &gt;直播回看功能 &gt; 点赞功能。</li>\n</ul>\n<ol start=\"4\">\n<li>对目标群体熟悉程度</li>\n</ol>\n<ul>\n<li>场景1<br>目标群体：美食生产者<br>25~40岁左右，生活水平和质量较高的中产阶级，有充裕的时间练习厨艺或从事厨艺工作，生活之余愿意花费较多的时间和精力于创作菜谱，录制直播视频，享受因为创作带来的认可，同时也希望自己的创作能带来额外的收入。</li>\n<li>场景2<br>目标群体：内容消费者<br>20~40岁左右，想提升厨艺或学习新菜谱的大学生、都市白领，希望通过观看做菜直播、和菜友直播弹屏或社区互动的同时，不需要花费太多的思考时间去研习菜谱做法，轻松愉快的有人带领自己学习做菜，假若菜谱里的食材和厨具能一键采购，也是可以考虑尝试购买。</li>\n<li>场景3<br>目标群体：运营人员<br>“好豆菜谱”产品的运营人员，希望通过直播功能邀请一些大V或者明星坐镇，通过其影响力能为产品带来大量的流量和新用户，积累用户之后再通过各种活动和优质的内容留存用户，为后期用户转化变现储备力量。</li>\n<li>场景4<br>目标群体：老板。<br>想通过直播功能与大V或明星合作，打响产品的知名度，获得更多的用户群，拓展收入渠道来源，增加产品营收。<h1 id=\"优先级排序总结\"><a href=\"#优先级排序总结\" class=\"headerlink\" title=\"优先级排序总结\"></a>优先级排序总结</h1></li>\n<li>基础直播功能</li>\n<li>点赞评论弹幕功能</li>\n<li>滤镜功能</li>\n<li>打赏功能</li>\n<li>直播回看功能<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1></li>\n</ul>\n<ol>\n<li>用户：直播功能的推出，第一批核心用户应该是平台内容的消费者，他们既是平台活跃率的来源，同时也是平台转化变现的主体。</li>\n<li>场景：内容消费者，在工作日下班后，或双休日期间，想学习下新的菜式时，打开“好豆菜谱”app，通过直播宣传栏目，看到直播的内容或直播的大V是自己喜欢的情况下，会点击使用直播此功能。</li>\n<li>问题：直播打开率的最大痛点是直播内容和大V用户对用户的吸引力度，需要寻找知名度高用户喜欢的明星或大V参与直播录制，但投入费用高，用户对app的使用场景较窄，进行直播时打开率不一定高。</li>\n<li>对比：在app没有推出直播功能方案的前提下，用户的解决方案是——选择有视频录播教程的同类软件，如“下厨房”的学习模块，这样就容易出现本产品用户向竞品流失的问题，如果直播/回放功能的上线，用户需求得到了解决，平台的忠实用户需求得到满足，产品的留存率便会提高，后期转化变现的可能性将变大。</li>\n</ol>\n"},{"title":"体验「美柚」","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-10-03T06:57:02.000Z","password":null,"summary":null,"_content":"# 问题：体验「美柚」\n\n你是美柚的用户，美柚的产品经理邀请你来做做访谈，问了你如下几个问题：\n\n1. 你平时有使用软件记录或者管理经期吗？（男生版：你平时有使用软件记录女友/老婆的经期，以适时送上关怀吗）/（男生单身狗版：你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？）\n2. 在使用软件时，你是如何做记录的，会用哪些功能？\n3. 产品的视觉上是怎样的？给你的感受/印象如何？\n4. 产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\n5. 使用产品中，最让你惊喜的是哪一点？\n6. 使用产品中，最难以忍受的是哪一点？\n7. 你会向朋友去传播这个产品吗？为什么？\n\n# 你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？\n\n本人听说过该APP，之前并没有使用或者体验过。根据艾瑞数据上美柚的数据显示，可以详细了解到美柚的用户群（如下图，数据来源：https://index.iresearch.com.cn/app/detail?id=150&Tid=73  ）。根据用户群年龄占比我们可知，美柚用户主要是排除月经初潮前的小女孩和绝经后的老年女性以外的其他女性群体，男性用户占所有用户的1.52%，这部分用户是帮女朋友、老婆记录经期的。下面我们根据已有的用户画像来简单梳理用户需求和场景。\n![性别比例](xingbie.png)\n![年龄比例](xingbie2.png)\n![用户场景](xingbie3.jpg)\n## 产品定位\n一款记录女性生理周期的工具。\n## 产品介绍\n美柚app于2013年4月上线，为年轻女性用户提供管理健康、解决问题、寻找闺蜜、娱乐交流等综合服务。目前，用户数超过1亿，日活跃用户数近千万。它拥有160多个高活跃女性话题圈，社区日均互动量超500万，日均浏览量超1.6亿次。\n## 产品的成长路径\n最初美柚只是一款记录女性生理周期的工具，满足了女性用户无法准确估计生理周期的痛点需求。随着产品版本的多次迭代，美柚逐渐从工具向平台演进\n## 产品特点：\n贴心预测，及时提醒月经期\n不同模式，给你不同阶段的关爱\n吃饭睡觉聊八卦，一起扎堆她她圈\n柚子街，手机上的女人街\n\n# 在使用软件时，你是如何做记录的，会用哪些功能？\n\n“记录”作为美柚的核心功能模块。美柚会根据用户所处的不同人生阶段（经期、备孕、怀孕、育儿），结合上一次姨妈开始和结束时间、经期长度、周期、体重、体温、心情，习惯、是否爱爱等参数，综合预测下一次姨妈来的时间、安全期和排卵期，并通过“分析”功能为用户展示在经期、备孕、孕期、宝贝的健康状态，辅以大数据算法提高预测准确率。关于记录功能的使用流程如下：\n![使用流程](shiyongliucheng.png)\n# 产品的视觉上是怎样的？给你的感受/印象如何？\n## 关于页面\n美柚的页面主要采用粉色+橙色系，图标偏可爱风格，与美柚LOGO的主色和产品定位相同。整体的视觉表现为活泼、可爱，容易被目标用户接受和喜爱。\n\n## 关于交互\n \n柚的内容以记录为主，但是进入的默认界面却为一些推广，重点不突出，不容易让用户迅速找到核心功能进行使用。\n\n## 关于内容\n\n1. 美柚推广内容推送质量参差不齐，较为“低端”，产品定位需要提升???，因而美柚反而给我一种商业化优先于用户体验的感觉；\n2. “我的”信息页面设计有点混乱。个人设计页面的中间部分，是我的主页，收藏，关注，小提醒，订单，购物车，柚子测评以及小工具。这其中，订单、收藏和柚子测评是电商相关的部分，消息、关注和我的主页是社区功能的内容，小工具则是部分属于记录，部分属于第三方，这些内容放到一起十分混乱。对此，我有两种方案建议，第一，将电商的部分合并到电商页面里面，社区的部分合并到社区，每个功能相关的全部放到各个功能下面去，而个人信息的页面只单纯放信息设置以及第三方广告；第二，将中间这部分内容拆分开，电商相关的归属到一排，上面标注上对应的分类名，同理，社区的内容也一样，单独列一排。\n\n# 产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\n美柚有“发现、记录、她她圈、柚子街、我”五大模块和众多功能。产品的功能结构如下：\n\n![功能结构](gongnengjiegou.png)\n\n从用户和企业的角度分别说明一下这些模块和功能的作用：\n\n![功能作用](shiyong.png)\n\n# 使用产品中，最让你惊喜的是哪一点？\n\n产品根据用户选择不同的人生阶段会有不同的内容展示，在美柚、记录和她她圈几个模块中都有体现。\n设置模块里有些从用户需求出发的产品小模块，比如每日提醒帮助用户养成好的习惯、生命时钟提醒人们要珍惜时间、卡路里计算器便于计算每日卡路里消耗、能不能吃更是符合年轻人对养生健康的内心需求，可谓是一本宝典。这些小工具能够从背后体会产品对女性的关爱，还是比较难能可贵的。而上述这些暖心小工具，其竞品大姨妈是没有的。\n\n# 使用产品中，最难以忍受的是哪一点？\n\n产品最难以忍受的是首页推荐的内容，内容太多太杂，而且其中掺杂大量隐藏的广告，有些点进去才发现是广告，而在外面单看标题却根本看不出来。在商业化和用户间需要找到一个平衡。可以通过提升推荐的内容品质做起，完善内容，提升品质。\n\n# 你会向朋友去传播这个产品吗？为什么？\n我个人应该不会去传播。这一款APP虽然可以记录和预测经期，但同时有两个页面在做社区，一个页面做购买平台，社区我个人用不上，而购买我可以直接淘宝，而且柚子街的功能有专门的APP，所以个人认为美柚在功能上不够专一。\n\n ","source":"_posts/2019-PM-meiyou.md","raw":"---\ntitle: 体验「美柚」\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-10-03 14:57:02\npassword:\nsummary:\ntags:\n- PM\ncategories:\n- PM\n---\n# 问题：体验「美柚」\n\n你是美柚的用户，美柚的产品经理邀请你来做做访谈，问了你如下几个问题：\n\n1. 你平时有使用软件记录或者管理经期吗？（男生版：你平时有使用软件记录女友/老婆的经期，以适时送上关怀吗）/（男生单身狗版：你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？）\n2. 在使用软件时，你是如何做记录的，会用哪些功能？\n3. 产品的视觉上是怎样的？给你的感受/印象如何？\n4. 产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\n5. 使用产品中，最让你惊喜的是哪一点？\n6. 使用产品中，最难以忍受的是哪一点？\n7. 你会向朋友去传播这个产品吗？为什么？\n\n# 你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？\n\n本人听说过该APP，之前并没有使用或者体验过。根据艾瑞数据上美柚的数据显示，可以详细了解到美柚的用户群（如下图，数据来源：https://index.iresearch.com.cn/app/detail?id=150&Tid=73  ）。根据用户群年龄占比我们可知，美柚用户主要是排除月经初潮前的小女孩和绝经后的老年女性以外的其他女性群体，男性用户占所有用户的1.52%，这部分用户是帮女朋友、老婆记录经期的。下面我们根据已有的用户画像来简单梳理用户需求和场景。\n![性别比例](xingbie.png)\n![年龄比例](xingbie2.png)\n![用户场景](xingbie3.jpg)\n## 产品定位\n一款记录女性生理周期的工具。\n## 产品介绍\n美柚app于2013年4月上线，为年轻女性用户提供管理健康、解决问题、寻找闺蜜、娱乐交流等综合服务。目前，用户数超过1亿，日活跃用户数近千万。它拥有160多个高活跃女性话题圈，社区日均互动量超500万，日均浏览量超1.6亿次。\n## 产品的成长路径\n最初美柚只是一款记录女性生理周期的工具，满足了女性用户无法准确估计生理周期的痛点需求。随着产品版本的多次迭代，美柚逐渐从工具向平台演进\n## 产品特点：\n贴心预测，及时提醒月经期\n不同模式，给你不同阶段的关爱\n吃饭睡觉聊八卦，一起扎堆她她圈\n柚子街，手机上的女人街\n\n# 在使用软件时，你是如何做记录的，会用哪些功能？\n\n“记录”作为美柚的核心功能模块。美柚会根据用户所处的不同人生阶段（经期、备孕、怀孕、育儿），结合上一次姨妈开始和结束时间、经期长度、周期、体重、体温、心情，习惯、是否爱爱等参数，综合预测下一次姨妈来的时间、安全期和排卵期，并通过“分析”功能为用户展示在经期、备孕、孕期、宝贝的健康状态，辅以大数据算法提高预测准确率。关于记录功能的使用流程如下：\n![使用流程](shiyongliucheng.png)\n# 产品的视觉上是怎样的？给你的感受/印象如何？\n## 关于页面\n美柚的页面主要采用粉色+橙色系，图标偏可爱风格，与美柚LOGO的主色和产品定位相同。整体的视觉表现为活泼、可爱，容易被目标用户接受和喜爱。\n\n## 关于交互\n \n柚的内容以记录为主，但是进入的默认界面却为一些推广，重点不突出，不容易让用户迅速找到核心功能进行使用。\n\n## 关于内容\n\n1. 美柚推广内容推送质量参差不齐，较为“低端”，产品定位需要提升???，因而美柚反而给我一种商业化优先于用户体验的感觉；\n2. “我的”信息页面设计有点混乱。个人设计页面的中间部分，是我的主页，收藏，关注，小提醒，订单，购物车，柚子测评以及小工具。这其中，订单、收藏和柚子测评是电商相关的部分，消息、关注和我的主页是社区功能的内容，小工具则是部分属于记录，部分属于第三方，这些内容放到一起十分混乱。对此，我有两种方案建议，第一，将电商的部分合并到电商页面里面，社区的部分合并到社区，每个功能相关的全部放到各个功能下面去，而个人信息的页面只单纯放信息设置以及第三方广告；第二，将中间这部分内容拆分开，电商相关的归属到一排，上面标注上对应的分类名，同理，社区的内容也一样，单独列一排。\n\n# 产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\n美柚有“发现、记录、她她圈、柚子街、我”五大模块和众多功能。产品的功能结构如下：\n\n![功能结构](gongnengjiegou.png)\n\n从用户和企业的角度分别说明一下这些模块和功能的作用：\n\n![功能作用](shiyong.png)\n\n# 使用产品中，最让你惊喜的是哪一点？\n\n产品根据用户选择不同的人生阶段会有不同的内容展示，在美柚、记录和她她圈几个模块中都有体现。\n设置模块里有些从用户需求出发的产品小模块，比如每日提醒帮助用户养成好的习惯、生命时钟提醒人们要珍惜时间、卡路里计算器便于计算每日卡路里消耗、能不能吃更是符合年轻人对养生健康的内心需求，可谓是一本宝典。这些小工具能够从背后体会产品对女性的关爱，还是比较难能可贵的。而上述这些暖心小工具，其竞品大姨妈是没有的。\n\n# 使用产品中，最难以忍受的是哪一点？\n\n产品最难以忍受的是首页推荐的内容，内容太多太杂，而且其中掺杂大量隐藏的广告，有些点进去才发现是广告，而在外面单看标题却根本看不出来。在商业化和用户间需要找到一个平衡。可以通过提升推荐的内容品质做起，完善内容，提升品质。\n\n# 你会向朋友去传播这个产品吗？为什么？\n我个人应该不会去传播。这一款APP虽然可以记录和预测经期，但同时有两个页面在做社区，一个页面做购买平台，社区我个人用不上，而购买我可以直接淘宝，而且柚子街的功能有专门的APP，所以个人认为美柚在功能上不够专一。\n\n ","slug":"2019-PM-meiyou","published":1,"updated":"2019-10-03T06:59:41.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxb2000q2wvc9jbho8za","content":"<h1 id=\"问题：体验「美柚」\"><a href=\"#问题：体验「美柚」\" class=\"headerlink\" title=\"问题：体验「美柚」\"></a>问题：体验「美柚」</h1><p>你是美柚的用户，美柚的产品经理邀请你来做做访谈，问了你如下几个问题：</p>\n<ol>\n<li>你平时有使用软件记录或者管理经期吗？（男生版：你平时有使用软件记录女友/老婆的经期，以适时送上关怀吗）/（男生单身狗版：你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？）</li>\n<li>在使用软件时，你是如何做记录的，会用哪些功能？</li>\n<li>产品的视觉上是怎样的？给你的感受/印象如何？</li>\n<li>产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？</li>\n<li>使用产品中，最让你惊喜的是哪一点？</li>\n<li>使用产品中，最难以忍受的是哪一点？</li>\n<li>你会向朋友去传播这个产品吗？为什么？</li>\n</ol>\n<h1 id=\"你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？\"><a href=\"#你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？\" class=\"headerlink\" title=\"你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？\"></a>你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？</h1><p>本人听说过该APP，之前并没有使用或者体验过。根据艾瑞数据上美柚的数据显示，可以详细了解到美柚的用户群（如下图，数据来源：<a href=\"https://index.iresearch.com.cn/app/detail?id=150&amp;Tid=73\" target=\"_blank\" rel=\"noopener\">https://index.iresearch.com.cn/app/detail?id=150&amp;Tid=73</a>  ）。根据用户群年龄占比我们可知，美柚用户主要是排除月经初潮前的小女孩和绝经后的老年女性以外的其他女性群体，男性用户占所有用户的1.52%，这部分用户是帮女朋友、老婆记录经期的。下面我们根据已有的用户画像来简单梳理用户需求和场景。<br><img src=\"xingbie.png\" alt=\"性别比例\"><br><img src=\"xingbie2.png\" alt=\"年龄比例\"><br><img src=\"xingbie3.jpg\" alt=\"用户场景\"></p>\n<h2 id=\"产品定位\"><a href=\"#产品定位\" class=\"headerlink\" title=\"产品定位\"></a>产品定位</h2><p>一款记录女性生理周期的工具。</p>\n<h2 id=\"产品介绍\"><a href=\"#产品介绍\" class=\"headerlink\" title=\"产品介绍\"></a>产品介绍</h2><p>美柚app于2013年4月上线，为年轻女性用户提供管理健康、解决问题、寻找闺蜜、娱乐交流等综合服务。目前，用户数超过1亿，日活跃用户数近千万。它拥有160多个高活跃女性话题圈，社区日均互动量超500万，日均浏览量超1.6亿次。</p>\n<h2 id=\"产品的成长路径\"><a href=\"#产品的成长路径\" class=\"headerlink\" title=\"产品的成长路径\"></a>产品的成长路径</h2><p>最初美柚只是一款记录女性生理周期的工具，满足了女性用户无法准确估计生理周期的痛点需求。随着产品版本的多次迭代，美柚逐渐从工具向平台演进</p>\n<h2 id=\"产品特点：\"><a href=\"#产品特点：\" class=\"headerlink\" title=\"产品特点：\"></a>产品特点：</h2><p>贴心预测，及时提醒月经期<br>不同模式，给你不同阶段的关爱<br>吃饭睡觉聊八卦，一起扎堆她她圈<br>柚子街，手机上的女人街</p>\n<h1 id=\"在使用软件时，你是如何做记录的，会用哪些功能？\"><a href=\"#在使用软件时，你是如何做记录的，会用哪些功能？\" class=\"headerlink\" title=\"在使用软件时，你是如何做记录的，会用哪些功能？\"></a>在使用软件时，你是如何做记录的，会用哪些功能？</h1><p>“记录”作为美柚的核心功能模块。美柚会根据用户所处的不同人生阶段（经期、备孕、怀孕、育儿），结合上一次姨妈开始和结束时间、经期长度、周期、体重、体温、心情，习惯、是否爱爱等参数，综合预测下一次姨妈来的时间、安全期和排卵期，并通过“分析”功能为用户展示在经期、备孕、孕期、宝贝的健康状态，辅以大数据算法提高预测准确率。关于记录功能的使用流程如下：<br><img src=\"shiyongliucheng.png\" alt=\"使用流程\"></p>\n<h1 id=\"产品的视觉上是怎样的？给你的感受-印象如何？\"><a href=\"#产品的视觉上是怎样的？给你的感受-印象如何？\" class=\"headerlink\" title=\"产品的视觉上是怎样的？给你的感受/印象如何？\"></a>产品的视觉上是怎样的？给你的感受/印象如何？</h1><h2 id=\"关于页面\"><a href=\"#关于页面\" class=\"headerlink\" title=\"关于页面\"></a>关于页面</h2><p>美柚的页面主要采用粉色+橙色系，图标偏可爱风格，与美柚LOGO的主色和产品定位相同。整体的视觉表现为活泼、可爱，容易被目标用户接受和喜爱。</p>\n<h2 id=\"关于交互\"><a href=\"#关于交互\" class=\"headerlink\" title=\"关于交互\"></a>关于交互</h2><p>柚的内容以记录为主，但是进入的默认界面却为一些推广，重点不突出，不容易让用户迅速找到核心功能进行使用。</p>\n<h2 id=\"关于内容\"><a href=\"#关于内容\" class=\"headerlink\" title=\"关于内容\"></a>关于内容</h2><ol>\n<li>美柚推广内容推送质量参差不齐，较为“低端”，产品定位需要提升???，因而美柚反而给我一种商业化优先于用户体验的感觉；</li>\n<li>“我的”信息页面设计有点混乱。个人设计页面的中间部分，是我的主页，收藏，关注，小提醒，订单，购物车，柚子测评以及小工具。这其中，订单、收藏和柚子测评是电商相关的部分，消息、关注和我的主页是社区功能的内容，小工具则是部分属于记录，部分属于第三方，这些内容放到一起十分混乱。对此，我有两种方案建议，第一，将电商的部分合并到电商页面里面，社区的部分合并到社区，每个功能相关的全部放到各个功能下面去，而个人信息的页面只单纯放信息设置以及第三方广告；第二，将中间这部分内容拆分开，电商相关的归属到一排，上面标注上对应的分类名，同理，社区的内容也一样，单独列一排。</li>\n</ol>\n<h1 id=\"产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\"><a href=\"#产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\" class=\"headerlink\" title=\"产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\"></a>产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？</h1><p>美柚有“发现、记录、她她圈、柚子街、我”五大模块和众多功能。产品的功能结构如下：</p>\n<p><img src=\"gongnengjiegou.png\" alt=\"功能结构\"></p>\n<p>从用户和企业的角度分别说明一下这些模块和功能的作用：</p>\n<p><img src=\"shiyong.png\" alt=\"功能作用\"></p>\n<h1 id=\"使用产品中，最让你惊喜的是哪一点？\"><a href=\"#使用产品中，最让你惊喜的是哪一点？\" class=\"headerlink\" title=\"使用产品中，最让你惊喜的是哪一点？\"></a>使用产品中，最让你惊喜的是哪一点？</h1><p>产品根据用户选择不同的人生阶段会有不同的内容展示，在美柚、记录和她她圈几个模块中都有体现。<br>设置模块里有些从用户需求出发的产品小模块，比如每日提醒帮助用户养成好的习惯、生命时钟提醒人们要珍惜时间、卡路里计算器便于计算每日卡路里消耗、能不能吃更是符合年轻人对养生健康的内心需求，可谓是一本宝典。这些小工具能够从背后体会产品对女性的关爱，还是比较难能可贵的。而上述这些暖心小工具，其竞品大姨妈是没有的。</p>\n<h1 id=\"使用产品中，最难以忍受的是哪一点？\"><a href=\"#使用产品中，最难以忍受的是哪一点？\" class=\"headerlink\" title=\"使用产品中，最难以忍受的是哪一点？\"></a>使用产品中，最难以忍受的是哪一点？</h1><p>产品最难以忍受的是首页推荐的内容，内容太多太杂，而且其中掺杂大量隐藏的广告，有些点进去才发现是广告，而在外面单看标题却根本看不出来。在商业化和用户间需要找到一个平衡。可以通过提升推荐的内容品质做起，完善内容，提升品质。</p>\n<h1 id=\"你会向朋友去传播这个产品吗？为什么？\"><a href=\"#你会向朋友去传播这个产品吗？为什么？\" class=\"headerlink\" title=\"你会向朋友去传播这个产品吗？为什么？\"></a>你会向朋友去传播这个产品吗？为什么？</h1><p>我个人应该不会去传播。这一款APP虽然可以记录和预测经期，但同时有两个页面在做社区，一个页面做购买平台，社区我个人用不上，而购买我可以直接淘宝，而且柚子街的功能有专门的APP，所以个人认为美柚在功能上不够专一。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"问题：体验「美柚」\"><a href=\"#问题：体验「美柚」\" class=\"headerlink\" title=\"问题：体验「美柚」\"></a>问题：体验「美柚」</h1><p>你是美柚的用户，美柚的产品经理邀请你来做做访谈，问了你如下几个问题：</p>\n<ol>\n<li>你平时有使用软件记录或者管理经期吗？（男生版：你平时有使用软件记录女友/老婆的经期，以适时送上关怀吗）/（男生单身狗版：你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？）</li>\n<li>在使用软件时，你是如何做记录的，会用哪些功能？</li>\n<li>产品的视觉上是怎样的？给你的感受/印象如何？</li>\n<li>产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？</li>\n<li>使用产品中，最让你惊喜的是哪一点？</li>\n<li>使用产品中，最难以忍受的是哪一点？</li>\n<li>你会向朋友去传播这个产品吗？为什么？</li>\n</ol>\n<h1 id=\"你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？\"><a href=\"#你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？\" class=\"headerlink\" title=\"你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？\"></a>你知道有「美柚」、「大姨妈」此类产品吗？他们是用来干嘛的？</h1><p>本人听说过该APP，之前并没有使用或者体验过。根据艾瑞数据上美柚的数据显示，可以详细了解到美柚的用户群（如下图，数据来源：<a href=\"https://index.iresearch.com.cn/app/detail?id=150&amp;Tid=73\" target=\"_blank\" rel=\"noopener\">https://index.iresearch.com.cn/app/detail?id=150&amp;Tid=73</a>  ）。根据用户群年龄占比我们可知，美柚用户主要是排除月经初潮前的小女孩和绝经后的老年女性以外的其他女性群体，男性用户占所有用户的1.52%，这部分用户是帮女朋友、老婆记录经期的。下面我们根据已有的用户画像来简单梳理用户需求和场景。<br><img src=\"xingbie.png\" alt=\"性别比例\"><br><img src=\"xingbie2.png\" alt=\"年龄比例\"><br><img src=\"xingbie3.jpg\" alt=\"用户场景\"></p>\n<h2 id=\"产品定位\"><a href=\"#产品定位\" class=\"headerlink\" title=\"产品定位\"></a>产品定位</h2><p>一款记录女性生理周期的工具。</p>\n<h2 id=\"产品介绍\"><a href=\"#产品介绍\" class=\"headerlink\" title=\"产品介绍\"></a>产品介绍</h2><p>美柚app于2013年4月上线，为年轻女性用户提供管理健康、解决问题、寻找闺蜜、娱乐交流等综合服务。目前，用户数超过1亿，日活跃用户数近千万。它拥有160多个高活跃女性话题圈，社区日均互动量超500万，日均浏览量超1.6亿次。</p>\n<h2 id=\"产品的成长路径\"><a href=\"#产品的成长路径\" class=\"headerlink\" title=\"产品的成长路径\"></a>产品的成长路径</h2><p>最初美柚只是一款记录女性生理周期的工具，满足了女性用户无法准确估计生理周期的痛点需求。随着产品版本的多次迭代，美柚逐渐从工具向平台演进</p>\n<h2 id=\"产品特点：\"><a href=\"#产品特点：\" class=\"headerlink\" title=\"产品特点：\"></a>产品特点：</h2><p>贴心预测，及时提醒月经期<br>不同模式，给你不同阶段的关爱<br>吃饭睡觉聊八卦，一起扎堆她她圈<br>柚子街，手机上的女人街</p>\n<h1 id=\"在使用软件时，你是如何做记录的，会用哪些功能？\"><a href=\"#在使用软件时，你是如何做记录的，会用哪些功能？\" class=\"headerlink\" title=\"在使用软件时，你是如何做记录的，会用哪些功能？\"></a>在使用软件时，你是如何做记录的，会用哪些功能？</h1><p>“记录”作为美柚的核心功能模块。美柚会根据用户所处的不同人生阶段（经期、备孕、怀孕、育儿），结合上一次姨妈开始和结束时间、经期长度、周期、体重、体温、心情，习惯、是否爱爱等参数，综合预测下一次姨妈来的时间、安全期和排卵期，并通过“分析”功能为用户展示在经期、备孕、孕期、宝贝的健康状态，辅以大数据算法提高预测准确率。关于记录功能的使用流程如下：<br><img src=\"shiyongliucheng.png\" alt=\"使用流程\"></p>\n<h1 id=\"产品的视觉上是怎样的？给你的感受-印象如何？\"><a href=\"#产品的视觉上是怎样的？给你的感受-印象如何？\" class=\"headerlink\" title=\"产品的视觉上是怎样的？给你的感受/印象如何？\"></a>产品的视觉上是怎样的？给你的感受/印象如何？</h1><h2 id=\"关于页面\"><a href=\"#关于页面\" class=\"headerlink\" title=\"关于页面\"></a>关于页面</h2><p>美柚的页面主要采用粉色+橙色系，图标偏可爱风格，与美柚LOGO的主色和产品定位相同。整体的视觉表现为活泼、可爱，容易被目标用户接受和喜爱。</p>\n<h2 id=\"关于交互\"><a href=\"#关于交互\" class=\"headerlink\" title=\"关于交互\"></a>关于交互</h2><p>柚的内容以记录为主，但是进入的默认界面却为一些推广，重点不突出，不容易让用户迅速找到核心功能进行使用。</p>\n<h2 id=\"关于内容\"><a href=\"#关于内容\" class=\"headerlink\" title=\"关于内容\"></a>关于内容</h2><ol>\n<li>美柚推广内容推送质量参差不齐，较为“低端”，产品定位需要提升???，因而美柚反而给我一种商业化优先于用户体验的感觉；</li>\n<li>“我的”信息页面设计有点混乱。个人设计页面的中间部分，是我的主页，收藏，关注，小提醒，订单，购物车，柚子测评以及小工具。这其中，订单、收藏和柚子测评是电商相关的部分，消息、关注和我的主页是社区功能的内容，小工具则是部分属于记录，部分属于第三方，这些内容放到一起十分混乱。对此，我有两种方案建议，第一，将电商的部分合并到电商页面里面，社区的部分合并到社区，每个功能相关的全部放到各个功能下面去，而个人信息的页面只单纯放信息设置以及第三方广告；第二，将中间这部分内容拆分开，电商相关的归属到一排，上面标注上对应的分类名，同理，社区的内容也一样，单独列一排。</li>\n</ol>\n<h1 id=\"产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\"><a href=\"#产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\" class=\"headerlink\" title=\"产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？\"></a>产品还有哪些「模块」或「功能」，你如何理解这些「模块」或「功能」的作用？</h1><p>美柚有“发现、记录、她她圈、柚子街、我”五大模块和众多功能。产品的功能结构如下：</p>\n<p><img src=\"gongnengjiegou.png\" alt=\"功能结构\"></p>\n<p>从用户和企业的角度分别说明一下这些模块和功能的作用：</p>\n<p><img src=\"shiyong.png\" alt=\"功能作用\"></p>\n<h1 id=\"使用产品中，最让你惊喜的是哪一点？\"><a href=\"#使用产品中，最让你惊喜的是哪一点？\" class=\"headerlink\" title=\"使用产品中，最让你惊喜的是哪一点？\"></a>使用产品中，最让你惊喜的是哪一点？</h1><p>产品根据用户选择不同的人生阶段会有不同的内容展示，在美柚、记录和她她圈几个模块中都有体现。<br>设置模块里有些从用户需求出发的产品小模块，比如每日提醒帮助用户养成好的习惯、生命时钟提醒人们要珍惜时间、卡路里计算器便于计算每日卡路里消耗、能不能吃更是符合年轻人对养生健康的内心需求，可谓是一本宝典。这些小工具能够从背后体会产品对女性的关爱，还是比较难能可贵的。而上述这些暖心小工具，其竞品大姨妈是没有的。</p>\n<h1 id=\"使用产品中，最难以忍受的是哪一点？\"><a href=\"#使用产品中，最难以忍受的是哪一点？\" class=\"headerlink\" title=\"使用产品中，最难以忍受的是哪一点？\"></a>使用产品中，最难以忍受的是哪一点？</h1><p>产品最难以忍受的是首页推荐的内容，内容太多太杂，而且其中掺杂大量隐藏的广告，有些点进去才发现是广告，而在外面单看标题却根本看不出来。在商业化和用户间需要找到一个平衡。可以通过提升推荐的内容品质做起，完善内容，提升品质。</p>\n<h1 id=\"你会向朋友去传播这个产品吗？为什么？\"><a href=\"#你会向朋友去传播这个产品吗？为什么？\" class=\"headerlink\" title=\"你会向朋友去传播这个产品吗？为什么？\"></a>你会向朋友去传播这个产品吗？为什么？</h1><p>我个人应该不会去传播。这一款APP虽然可以记录和预测经期，但同时有两个页面在做社区，一个页面做购买平台，社区我个人用不上，而购买我可以直接淘宝，而且柚子街的功能有专门的APP，所以个人认为美柚在功能上不够专一。</p>\n"},{"title":"「网易云音乐」登录流程还原","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-10-03T06:12:35.000Z","password":null,"summary":"登录流程是比较基础的流程之一，很常见，看起来也很简单，但很多时候，这种基础流程的体验往往也最容易被忽略。所以希望大家从基础着手，关注细节体验，为后续产品设计打好基础。","_content":"\n# 产品介绍\n网易云音乐主打社交分享，歌单推荐，乐评特色，通过社交分享帮助更多的人发现好音乐。目前，网易云音乐拥有国内最大，最优质的“歌单”库。它是国内首个以“歌单”作为核心架构的音乐APP，强化“歌单”的概念，让用户批量发现好音乐更简单，弱化了“单曲”的概念。\n\n# 网易云音乐登陆流程图\n![网易云音乐登陆流程图](wangyiyun.png)\n# 登录流程的暴力测试：\n## 对手机号填写进行暴力测试\n空出不填写的时候会提示：请填写手机号。\n\n当手机号不满11位数字的时候提示：请输入11位数字的手机号。\n\n当手机号的第一位数字不为“1”的时候会提示：服务器发生错误[code:500]。\n\n对手机号的判断机制是首位数字为“1”的11位数字，无论是否是手机号，都会进入下一步的判断。\n\n## 对密码的判断\n空出不填的时候提示：请输入密码。\n\n密码不足6位时会提示：请输入6位或以上的密码。\n\n值得一提的是，云音乐对密码的长度限制没有上限（一定程度下，笔者尝试输入了300位左右的数字，依旧可以设置成功）\n\n## 验证码的判断\n只有一种错误提示：验证码有误。\n\n## 昵称的判断\n空填的时候会提示：请输入昵称。\n\n昵称字数限制是15个汉字或30个字符，超出会提示：字数超出限制。\n\n昵称输入之后会进行检索比对，如果有数据库中有相同的昵称会提示：该昵称已经被占用。\n\n## 断网测试\n每一个页面进行点击交互的时候客户端都会判断是否联网，如没联网，则提示：当前无网络连接，请稍后再试。","source":"_posts/2019-PM-music163.md","raw":"---\ntitle: 「网易云音乐」登录流程还原\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-10-03 14:12:35\npassword:\nsummary: 登录流程是比较基础的流程之一，很常见，看起来也很简单，但很多时候，这种基础流程的体验往往也最容易被忽略。所以希望大家从基础着手，关注细节体验，为后续产品设计打好基础。\ntags:\n- PM\ncategories:\n- PM\n---\n\n# 产品介绍\n网易云音乐主打社交分享，歌单推荐，乐评特色，通过社交分享帮助更多的人发现好音乐。目前，网易云音乐拥有国内最大，最优质的“歌单”库。它是国内首个以“歌单”作为核心架构的音乐APP，强化“歌单”的概念，让用户批量发现好音乐更简单，弱化了“单曲”的概念。\n\n# 网易云音乐登陆流程图\n![网易云音乐登陆流程图](wangyiyun.png)\n# 登录流程的暴力测试：\n## 对手机号填写进行暴力测试\n空出不填写的时候会提示：请填写手机号。\n\n当手机号不满11位数字的时候提示：请输入11位数字的手机号。\n\n当手机号的第一位数字不为“1”的时候会提示：服务器发生错误[code:500]。\n\n对手机号的判断机制是首位数字为“1”的11位数字，无论是否是手机号，都会进入下一步的判断。\n\n## 对密码的判断\n空出不填的时候提示：请输入密码。\n\n密码不足6位时会提示：请输入6位或以上的密码。\n\n值得一提的是，云音乐对密码的长度限制没有上限（一定程度下，笔者尝试输入了300位左右的数字，依旧可以设置成功）\n\n## 验证码的判断\n只有一种错误提示：验证码有误。\n\n## 昵称的判断\n空填的时候会提示：请输入昵称。\n\n昵称字数限制是15个汉字或30个字符，超出会提示：字数超出限制。\n\n昵称输入之后会进行检索比对，如果有数据库中有相同的昵称会提示：该昵称已经被占用。\n\n## 断网测试\n每一个页面进行点击交互的时候客户端都会判断是否联网，如没联网，则提示：当前无网络连接，请稍后再试。","slug":"2019-PM-music163","published":1,"updated":"2019-10-03T06:15:22.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxb4000v2wvcp82wtyg3","content":"<h1 id=\"产品介绍\"><a href=\"#产品介绍\" class=\"headerlink\" title=\"产品介绍\"></a>产品介绍</h1><p>网易云音乐主打社交分享，歌单推荐，乐评特色，通过社交分享帮助更多的人发现好音乐。目前，网易云音乐拥有国内最大，最优质的“歌单”库。它是国内首个以“歌单”作为核心架构的音乐APP，强化“歌单”的概念，让用户批量发现好音乐更简单，弱化了“单曲”的概念。</p>\n<h1 id=\"网易云音乐登陆流程图\"><a href=\"#网易云音乐登陆流程图\" class=\"headerlink\" title=\"网易云音乐登陆流程图\"></a>网易云音乐登陆流程图</h1><p><img src=\"wangyiyun.png\" alt=\"网易云音乐登陆流程图\"></p>\n<h1 id=\"登录流程的暴力测试：\"><a href=\"#登录流程的暴力测试：\" class=\"headerlink\" title=\"登录流程的暴力测试：\"></a>登录流程的暴力测试：</h1><h2 id=\"对手机号填写进行暴力测试\"><a href=\"#对手机号填写进行暴力测试\" class=\"headerlink\" title=\"对手机号填写进行暴力测试\"></a>对手机号填写进行暴力测试</h2><p>空出不填写的时候会提示：请填写手机号。</p>\n<p>当手机号不满11位数字的时候提示：请输入11位数字的手机号。</p>\n<p>当手机号的第一位数字不为“1”的时候会提示：服务器发生错误[code:500]。</p>\n<p>对手机号的判断机制是首位数字为“1”的11位数字，无论是否是手机号，都会进入下一步的判断。</p>\n<h2 id=\"对密码的判断\"><a href=\"#对密码的判断\" class=\"headerlink\" title=\"对密码的判断\"></a>对密码的判断</h2><p>空出不填的时候提示：请输入密码。</p>\n<p>密码不足6位时会提示：请输入6位或以上的密码。</p>\n<p>值得一提的是，云音乐对密码的长度限制没有上限（一定程度下，笔者尝试输入了300位左右的数字，依旧可以设置成功）</p>\n<h2 id=\"验证码的判断\"><a href=\"#验证码的判断\" class=\"headerlink\" title=\"验证码的判断\"></a>验证码的判断</h2><p>只有一种错误提示：验证码有误。</p>\n<h2 id=\"昵称的判断\"><a href=\"#昵称的判断\" class=\"headerlink\" title=\"昵称的判断\"></a>昵称的判断</h2><p>空填的时候会提示：请输入昵称。</p>\n<p>昵称字数限制是15个汉字或30个字符，超出会提示：字数超出限制。</p>\n<p>昵称输入之后会进行检索比对，如果有数据库中有相同的昵称会提示：该昵称已经被占用。</p>\n<h2 id=\"断网测试\"><a href=\"#断网测试\" class=\"headerlink\" title=\"断网测试\"></a>断网测试</h2><p>每一个页面进行点击交互的时候客户端都会判断是否联网，如没联网，则提示：当前无网络连接，请稍后再试。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"产品介绍\"><a href=\"#产品介绍\" class=\"headerlink\" title=\"产品介绍\"></a>产品介绍</h1><p>网易云音乐主打社交分享，歌单推荐，乐评特色，通过社交分享帮助更多的人发现好音乐。目前，网易云音乐拥有国内最大，最优质的“歌单”库。它是国内首个以“歌单”作为核心架构的音乐APP，强化“歌单”的概念，让用户批量发现好音乐更简单，弱化了“单曲”的概念。</p>\n<h1 id=\"网易云音乐登陆流程图\"><a href=\"#网易云音乐登陆流程图\" class=\"headerlink\" title=\"网易云音乐登陆流程图\"></a>网易云音乐登陆流程图</h1><p><img src=\"wangyiyun.png\" alt=\"网易云音乐登陆流程图\"></p>\n<h1 id=\"登录流程的暴力测试：\"><a href=\"#登录流程的暴力测试：\" class=\"headerlink\" title=\"登录流程的暴力测试：\"></a>登录流程的暴力测试：</h1><h2 id=\"对手机号填写进行暴力测试\"><a href=\"#对手机号填写进行暴力测试\" class=\"headerlink\" title=\"对手机号填写进行暴力测试\"></a>对手机号填写进行暴力测试</h2><p>空出不填写的时候会提示：请填写手机号。</p>\n<p>当手机号不满11位数字的时候提示：请输入11位数字的手机号。</p>\n<p>当手机号的第一位数字不为“1”的时候会提示：服务器发生错误[code:500]。</p>\n<p>对手机号的判断机制是首位数字为“1”的11位数字，无论是否是手机号，都会进入下一步的判断。</p>\n<h2 id=\"对密码的判断\"><a href=\"#对密码的判断\" class=\"headerlink\" title=\"对密码的判断\"></a>对密码的判断</h2><p>空出不填的时候提示：请输入密码。</p>\n<p>密码不足6位时会提示：请输入6位或以上的密码。</p>\n<p>值得一提的是，云音乐对密码的长度限制没有上限（一定程度下，笔者尝试输入了300位左右的数字，依旧可以设置成功）</p>\n<h2 id=\"验证码的判断\"><a href=\"#验证码的判断\" class=\"headerlink\" title=\"验证码的判断\"></a>验证码的判断</h2><p>只有一种错误提示：验证码有误。</p>\n<h2 id=\"昵称的判断\"><a href=\"#昵称的判断\" class=\"headerlink\" title=\"昵称的判断\"></a>昵称的判断</h2><p>空填的时候会提示：请输入昵称。</p>\n<p>昵称字数限制是15个汉字或30个字符，超出会提示：字数超出限制。</p>\n<p>昵称输入之后会进行检索比对，如果有数据库中有相同的昵称会提示：该昵称已经被占用。</p>\n<h2 id=\"断网测试\"><a href=\"#断网测试\" class=\"headerlink\" title=\"断网测试\"></a>断网测试</h2><p>每一个页面进行点击交互的时候客户端都会判断是否联网，如没联网，则提示：当前无网络连接，请稍后再试。</p>\n"},{"title":"《用户体验要素》","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T08:55:23.000Z","password":null,"summary":null,"_content":"\n# 用户体验要素\n\n包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。\n----\n# 用户体验为什么那么重要\n\n用户体验并不是指一件产品本身是如何工作的，用户体验是指“产品如何与外界发生联系并发挥作用”，也就是人们如何“接触”和“使用”它。当人们询问你某个产品或服务时，他们问的是使用的体验。它用起来难不难？是不是很容易学会？使用起来感觉如何？\n\n# 认识这些要素\n\n## 五个层面\n\n1. 表现层：感知设计（UI）\n\n2. 框架层：信息设计，界面设计，导航设计（页面原型）\n\n3. 结构层：交互设计和信息架构（业务流程和功能流程）\n\n4. 范围层：内容需求和功能规格（PRD文档）\n\n5. 战略层：用户需求和产品目标\n\n# 战略层\n\n1. 我们要从这个产品得到什么？\n\n2. 我们的用户可以从这个产品得到什么？\n\n# 范围层\n\n功能需求和内容需求。\n\n当我们把用户需求和产品目标转换成产品应该给用户提供什么功能和内容时，战略就变成了范围。\n\n产出物：PRD文档\n\n帮助我们知道该建设什么不该建设什么，在范围层我们讨论战略层面的抽象问题----“我们为什么要开发这个产品？”----转而面对一个新的问题：“我们要开发的是什么?”\n\n## 结构层\n\n在我们定义好用户需求并排列好优先级顺序之后，我们对于最终产品将会包括什么特性已经有了清楚的图像。然而，这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上一层：结构层。\n\n## 框架层\n\n## 表现层\n\n视觉、听觉、触觉、嗅觉和味觉\n\n\n\n# 用户体验要素\n<img src=\"User.jpg\" width=\"50%\" height=\"50%\" alt=\"需求工程师产品设计流程\">\n\n## 战略层\n\n无论是功能性产品还是信息型产品，在战略层上关心的内容是一样的：“我们为什么要开发这个这个产品？”，可以分解为两个问题：\n\n1. 用户需求（产品给用户带来了什么？）\n\n常见的用研方法有：问卷调查、用户访谈、焦点小组等，最适合用于收集用户的普遍观点与需求。其他研究工具（如用户测试或体验旅程图）则更适用于理解用户具体行为及用户和产品交互时的表现。\n\n\n\n2. 产品目标（产品给企业带来什么？）\n\n包括产品的商业逻辑、商业价值、商业壁垒、品牌传播等。\n\n需要注意的是，战略层面虽然是整个产品的根基，但不意味着在项目开始之前你的战略要完全确定下来，也可以在过程中逐步完善，因为通过产品逐渐发展、成熟，会随着商业市场发生变化。\n\n3. 阶段性目标\n\n复盘，检验设计结果，数据验证，用户使用时间，登陆次数......\n\n## 范围层\n\n带着*“产品给用户带来了什么”、“企业通过产品得到什么”*的明确认识，我们才能搞清楚如何去满足这些战略目标。当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。这里也是产品经理需要重点专注的层面。\n\n\n1. 你正在设计什么？\n\n工作中我们要考虑三个维度：\n\n-. 自己的工作流程\n\n-. 产品的迭代流程\n\n-. 团队的工作流程\n\n2. 你不需要设计什么？\n\n因此需要明确产品范围边界，梳理得到核心功能。C端产品通常只有一个核心功能解决个人用户的一个核心问题，而B端产品则有多个核心功能来满足企业用户多个使用场景。被解决的问题即是需求，需求从何而来？\n\n需求来源：需求来源一般来说分为内部和外部，内部大多是职能部门的一些业务性需求或受到战略上的决策影响，而外部可能是和竞品、用户反馈的需求，无论是哪些需求，一定是站在战略性角度去看，既：这些需求能否满足用户或企业价值来，更接地气的说，这个需求能否起到实际作用，还是伪需求，或者不紧急的。\n\n*《PRD文档》范围层面的产出物*，文档是起到定义功能的作用，他不需要包含产品的每一个细节（不像交互文档那样细致），只需要包含在设计或开发过程中出现有可能混淆的功能定义即可。\n\n## 结构层\n\n定义好功能范围并排列好优先级之后，我们对最终的产品模型包含什么特性会有一个清晰的认识，然后这些需求并没有说明如何将这些分散的片段组成一个整体。这就是在范围层之上的结构层：为产品创建一个功能架构，设计用户如何到达某个页面，并且要思考他们完成事情之后能够去哪里，也就是确定页面各种特性和功能最适合的组合方式，并在流程上形成一个闭环。从这里往后就是我们交互设计师该重点专注的层面了：将抽象的需求逐渐整理成一个具象的产品原型。\n\n对结构是否有质量的的评判标准是：\n\n1. 以各种方式将产品信息合理并有意义地呈现给用户，让用户更容易找到最有用的信息；\n\n2. 不是整个过程需要多少步完成，而是用户是否认为每个步骤都是合理的；\n\n3. 一个高效结构的优点具备“可包容”和“可扩展”的能力。\n\n*产出物*：功能流程图，业务流程图（泳道图），页面流程图，\n\n## 框架层\n\n将功能和流程梳理清楚之后，我们就要开始设计功能点里的具体细节，也就是让广大设计师又爱又恨的原型图。在充满概念的结构层当中形成了大量的需求，这些需求都是来自战略目标的需求。在框架层里，我们要更进一步的提炼这些结构，输出详细的界面雏形、导航及信息设计，也就是将结构层的东西变得更加清晰、实在。“交互设计文档”就是在该阶段产生的。\n\n这个阶段需要注意：\n\n1. 让设计尽量符合用户的使用习惯\n\n2. 重点突出，让用户一眼看到核心内容\n\n3. 将产品信息呈现出来并让用户容易理解\n\n4. 在合适的地方权衡利弊，使用合适的组件。\n\n5. 理性的错误处理。\n\n*. 操作前，提醒放错\n\n*. 操作中，实时感知\n\n*. 操作后，及时反馈&友好引导\n\n\n## 表现层\n\n表现层在这五层模型的最顶端，也是用户会首先注意到的地方：感知设计。这里是将品牌、内容、功能和美学汇集到一起界面设计。在框架层，我们主要解决组件放置和元素布局的问题，表现层则要解决并弥补“产品框架层的逻辑排布”的感知呈现问题。通过视觉设计，我们决定这些内容在界面上应该如何呈现。\n\n**五大感知：视觉、听觉、触觉、嗅觉、味觉**\n\n## 总结\n\n实际上这五个层面，就是我们产品设计的工作流程和注意点：\n\n战略层——确定*产品目标和用户需求*，为产品将来的方向做市场调研、用户研究，这是产品经理设计产品的根源，也是做一个产品的开端；\n\n范围层——当我们获取到用户需求、明确好产品目标后，就要开始研究提供什么解决方案来满足用户的需求，这些解决方案对应的功能有哪些，内容由什么组成，这时一般会产出*《PRD文档》*、《功能规格说明书》来记录这些，一般包含：版本记录、产品规划图、功能清单、业务流程图、需求列表、开发资源、其他相关规范...\n\n结构层——功能和内容范围确定后，交互设计师开始根据产品的需求设计解决方案，通过*架构图和流程图*，将这些打散的需求串联起来，形成一个可以闭环的流程，并且罗列出功能架构：这些需求会有几个页面组成、每个页面包含什么东西。当然有些团队可能没有交互设计师的岗位，那就是PM和UI共同担任；\n\n框架层——有了架构图和流程图之后，就开始设计*具体界面雏形（原型图、线框图），具体到这些页面如何跳转、用什么组件、交互规则是怎么样的、页面元素怎么组合等，这时候通常会产出《交互设计文档》*，一般包含：版本记录、需求背景、流程图、架构图、页面原型、交互说明、页面demo...\n\n表现层——UI设计对功能设计进行支持的环节，基于原型图将产品呈现出来，颜色、元素、品牌、内容怎么通过视觉设计来定义，这都取决于UI设计师如何把控产品特性、功能理解及目标用户的调性，最后将设计稿（高保真）交付给开发工程师，并产出《UI、交互设计规范》和组件库，方便开发调用及后期复用。\n","source":"_posts/2019-The-Elements-of-user-experience.md","raw":"---\ntitle: 《用户体验要素》\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 16:55:23\npassword:\nsummary:\ntags:\n- 读书笔记 PM\ncategories:\n- 读书笔记\n---\n\n# 用户体验要素\n\n包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。\n----\n# 用户体验为什么那么重要\n\n用户体验并不是指一件产品本身是如何工作的，用户体验是指“产品如何与外界发生联系并发挥作用”，也就是人们如何“接触”和“使用”它。当人们询问你某个产品或服务时，他们问的是使用的体验。它用起来难不难？是不是很容易学会？使用起来感觉如何？\n\n# 认识这些要素\n\n## 五个层面\n\n1. 表现层：感知设计（UI）\n\n2. 框架层：信息设计，界面设计，导航设计（页面原型）\n\n3. 结构层：交互设计和信息架构（业务流程和功能流程）\n\n4. 范围层：内容需求和功能规格（PRD文档）\n\n5. 战略层：用户需求和产品目标\n\n# 战略层\n\n1. 我们要从这个产品得到什么？\n\n2. 我们的用户可以从这个产品得到什么？\n\n# 范围层\n\n功能需求和内容需求。\n\n当我们把用户需求和产品目标转换成产品应该给用户提供什么功能和内容时，战略就变成了范围。\n\n产出物：PRD文档\n\n帮助我们知道该建设什么不该建设什么，在范围层我们讨论战略层面的抽象问题----“我们为什么要开发这个产品？”----转而面对一个新的问题：“我们要开发的是什么?”\n\n## 结构层\n\n在我们定义好用户需求并排列好优先级顺序之后，我们对于最终产品将会包括什么特性已经有了清楚的图像。然而，这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上一层：结构层。\n\n## 框架层\n\n## 表现层\n\n视觉、听觉、触觉、嗅觉和味觉\n\n\n\n# 用户体验要素\n<img src=\"User.jpg\" width=\"50%\" height=\"50%\" alt=\"需求工程师产品设计流程\">\n\n## 战略层\n\n无论是功能性产品还是信息型产品，在战略层上关心的内容是一样的：“我们为什么要开发这个这个产品？”，可以分解为两个问题：\n\n1. 用户需求（产品给用户带来了什么？）\n\n常见的用研方法有：问卷调查、用户访谈、焦点小组等，最适合用于收集用户的普遍观点与需求。其他研究工具（如用户测试或体验旅程图）则更适用于理解用户具体行为及用户和产品交互时的表现。\n\n\n\n2. 产品目标（产品给企业带来什么？）\n\n包括产品的商业逻辑、商业价值、商业壁垒、品牌传播等。\n\n需要注意的是，战略层面虽然是整个产品的根基，但不意味着在项目开始之前你的战略要完全确定下来，也可以在过程中逐步完善，因为通过产品逐渐发展、成熟，会随着商业市场发生变化。\n\n3. 阶段性目标\n\n复盘，检验设计结果，数据验证，用户使用时间，登陆次数......\n\n## 范围层\n\n带着*“产品给用户带来了什么”、“企业通过产品得到什么”*的明确认识，我们才能搞清楚如何去满足这些战略目标。当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。这里也是产品经理需要重点专注的层面。\n\n\n1. 你正在设计什么？\n\n工作中我们要考虑三个维度：\n\n-. 自己的工作流程\n\n-. 产品的迭代流程\n\n-. 团队的工作流程\n\n2. 你不需要设计什么？\n\n因此需要明确产品范围边界，梳理得到核心功能。C端产品通常只有一个核心功能解决个人用户的一个核心问题，而B端产品则有多个核心功能来满足企业用户多个使用场景。被解决的问题即是需求，需求从何而来？\n\n需求来源：需求来源一般来说分为内部和外部，内部大多是职能部门的一些业务性需求或受到战略上的决策影响，而外部可能是和竞品、用户反馈的需求，无论是哪些需求，一定是站在战略性角度去看，既：这些需求能否满足用户或企业价值来，更接地气的说，这个需求能否起到实际作用，还是伪需求，或者不紧急的。\n\n*《PRD文档》范围层面的产出物*，文档是起到定义功能的作用，他不需要包含产品的每一个细节（不像交互文档那样细致），只需要包含在设计或开发过程中出现有可能混淆的功能定义即可。\n\n## 结构层\n\n定义好功能范围并排列好优先级之后，我们对最终的产品模型包含什么特性会有一个清晰的认识，然后这些需求并没有说明如何将这些分散的片段组成一个整体。这就是在范围层之上的结构层：为产品创建一个功能架构，设计用户如何到达某个页面，并且要思考他们完成事情之后能够去哪里，也就是确定页面各种特性和功能最适合的组合方式，并在流程上形成一个闭环。从这里往后就是我们交互设计师该重点专注的层面了：将抽象的需求逐渐整理成一个具象的产品原型。\n\n对结构是否有质量的的评判标准是：\n\n1. 以各种方式将产品信息合理并有意义地呈现给用户，让用户更容易找到最有用的信息；\n\n2. 不是整个过程需要多少步完成，而是用户是否认为每个步骤都是合理的；\n\n3. 一个高效结构的优点具备“可包容”和“可扩展”的能力。\n\n*产出物*：功能流程图，业务流程图（泳道图），页面流程图，\n\n## 框架层\n\n将功能和流程梳理清楚之后，我们就要开始设计功能点里的具体细节，也就是让广大设计师又爱又恨的原型图。在充满概念的结构层当中形成了大量的需求，这些需求都是来自战略目标的需求。在框架层里，我们要更进一步的提炼这些结构，输出详细的界面雏形、导航及信息设计，也就是将结构层的东西变得更加清晰、实在。“交互设计文档”就是在该阶段产生的。\n\n这个阶段需要注意：\n\n1. 让设计尽量符合用户的使用习惯\n\n2. 重点突出，让用户一眼看到核心内容\n\n3. 将产品信息呈现出来并让用户容易理解\n\n4. 在合适的地方权衡利弊，使用合适的组件。\n\n5. 理性的错误处理。\n\n*. 操作前，提醒放错\n\n*. 操作中，实时感知\n\n*. 操作后，及时反馈&友好引导\n\n\n## 表现层\n\n表现层在这五层模型的最顶端，也是用户会首先注意到的地方：感知设计。这里是将品牌、内容、功能和美学汇集到一起界面设计。在框架层，我们主要解决组件放置和元素布局的问题，表现层则要解决并弥补“产品框架层的逻辑排布”的感知呈现问题。通过视觉设计，我们决定这些内容在界面上应该如何呈现。\n\n**五大感知：视觉、听觉、触觉、嗅觉、味觉**\n\n## 总结\n\n实际上这五个层面，就是我们产品设计的工作流程和注意点：\n\n战略层——确定*产品目标和用户需求*，为产品将来的方向做市场调研、用户研究，这是产品经理设计产品的根源，也是做一个产品的开端；\n\n范围层——当我们获取到用户需求、明确好产品目标后，就要开始研究提供什么解决方案来满足用户的需求，这些解决方案对应的功能有哪些，内容由什么组成，这时一般会产出*《PRD文档》*、《功能规格说明书》来记录这些，一般包含：版本记录、产品规划图、功能清单、业务流程图、需求列表、开发资源、其他相关规范...\n\n结构层——功能和内容范围确定后，交互设计师开始根据产品的需求设计解决方案，通过*架构图和流程图*，将这些打散的需求串联起来，形成一个可以闭环的流程，并且罗列出功能架构：这些需求会有几个页面组成、每个页面包含什么东西。当然有些团队可能没有交互设计师的岗位，那就是PM和UI共同担任；\n\n框架层——有了架构图和流程图之后，就开始设计*具体界面雏形（原型图、线框图），具体到这些页面如何跳转、用什么组件、交互规则是怎么样的、页面元素怎么组合等，这时候通常会产出《交互设计文档》*，一般包含：版本记录、需求背景、流程图、架构图、页面原型、交互说明、页面demo...\n\n表现层——UI设计对功能设计进行支持的环节，基于原型图将产品呈现出来，颜色、元素、品牌、内容怎么通过视觉设计来定义，这都取决于UI设计师如何把控产品特性、功能理解及目标用户的调性，最后将设计稿（高保真）交付给开发工程师，并产出《UI、交互设计规范》和组件库，方便开发调用及后期复用。\n","slug":"2019-The-Elements-of-user-experience","published":1,"updated":"2019-09-30T09:01:04.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxb5000x2wvc7szt2ilj","content":"<h1 id=\"用户体验要素\"><a href=\"#用户体验要素\" class=\"headerlink\" title=\"用户体验要素\"></a>用户体验要素</h1><h2 id=\"包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。\"><a href=\"#包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。\" class=\"headerlink\" title=\"包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。\"></a>包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。</h2><h1 id=\"用户体验为什么那么重要\"><a href=\"#用户体验为什么那么重要\" class=\"headerlink\" title=\"用户体验为什么那么重要\"></a>用户体验为什么那么重要</h1><p>用户体验并不是指一件产品本身是如何工作的，用户体验是指“产品如何与外界发生联系并发挥作用”，也就是人们如何“接触”和“使用”它。当人们询问你某个产品或服务时，他们问的是使用的体验。它用起来难不难？是不是很容易学会？使用起来感觉如何？</p>\n<h1 id=\"认识这些要素\"><a href=\"#认识这些要素\" class=\"headerlink\" title=\"认识这些要素\"></a>认识这些要素</h1><h2 id=\"五个层面\"><a href=\"#五个层面\" class=\"headerlink\" title=\"五个层面\"></a>五个层面</h2><ol>\n<li><p>表现层：感知设计（UI）</p>\n</li>\n<li><p>框架层：信息设计，界面设计，导航设计（页面原型）</p>\n</li>\n<li><p>结构层：交互设计和信息架构（业务流程和功能流程）</p>\n</li>\n<li><p>范围层：内容需求和功能规格（PRD文档）</p>\n</li>\n<li><p>战略层：用户需求和产品目标</p>\n</li>\n</ol>\n<h1 id=\"战略层\"><a href=\"#战略层\" class=\"headerlink\" title=\"战略层\"></a>战略层</h1><ol>\n<li><p>我们要从这个产品得到什么？</p>\n</li>\n<li><p>我们的用户可以从这个产品得到什么？</p>\n</li>\n</ol>\n<h1 id=\"范围层\"><a href=\"#范围层\" class=\"headerlink\" title=\"范围层\"></a>范围层</h1><p>功能需求和内容需求。</p>\n<p>当我们把用户需求和产品目标转换成产品应该给用户提供什么功能和内容时，战略就变成了范围。</p>\n<p>产出物：PRD文档</p>\n<p>帮助我们知道该建设什么不该建设什么，在范围层我们讨论战略层面的抽象问题—-“我们为什么要开发这个产品？”—-转而面对一个新的问题：“我们要开发的是什么?”</p>\n<h2 id=\"结构层\"><a href=\"#结构层\" class=\"headerlink\" title=\"结构层\"></a>结构层</h2><p>在我们定义好用户需求并排列好优先级顺序之后，我们对于最终产品将会包括什么特性已经有了清楚的图像。然而，这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上一层：结构层。</p>\n<h2 id=\"框架层\"><a href=\"#框架层\" class=\"headerlink\" title=\"框架层\"></a>框架层</h2><h2 id=\"表现层\"><a href=\"#表现层\" class=\"headerlink\" title=\"表现层\"></a>表现层</h2><p>视觉、听觉、触觉、嗅觉和味觉</p>\n<h1 id=\"用户体验要素-1\"><a href=\"#用户体验要素-1\" class=\"headerlink\" title=\"用户体验要素\"></a>用户体验要素</h1><img src=\"User.jpg\" width=\"50%\" height=\"50%\" alt=\"需求工程师产品设计流程\">\n\n<h2 id=\"战略层-1\"><a href=\"#战略层-1\" class=\"headerlink\" title=\"战略层\"></a>战略层</h2><p>无论是功能性产品还是信息型产品，在战略层上关心的内容是一样的：“我们为什么要开发这个这个产品？”，可以分解为两个问题：</p>\n<ol>\n<li>用户需求（产品给用户带来了什么？）</li>\n</ol>\n<p>常见的用研方法有：问卷调查、用户访谈、焦点小组等，最适合用于收集用户的普遍观点与需求。其他研究工具（如用户测试或体验旅程图）则更适用于理解用户具体行为及用户和产品交互时的表现。</p>\n<ol start=\"2\">\n<li>产品目标（产品给企业带来什么？）</li>\n</ol>\n<p>包括产品的商业逻辑、商业价值、商业壁垒、品牌传播等。</p>\n<p>需要注意的是，战略层面虽然是整个产品的根基，但不意味着在项目开始之前你的战略要完全确定下来，也可以在过程中逐步完善，因为通过产品逐渐发展、成熟，会随着商业市场发生变化。</p>\n<ol start=\"3\">\n<li>阶段性目标</li>\n</ol>\n<p>复盘，检验设计结果，数据验证，用户使用时间，登陆次数……</p>\n<h2 id=\"范围层-1\"><a href=\"#范围层-1\" class=\"headerlink\" title=\"范围层\"></a>范围层</h2><p>带着<em>“产品给用户带来了什么”、“企业通过产品得到什么”</em>的明确认识，我们才能搞清楚如何去满足这些战略目标。当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。这里也是产品经理需要重点专注的层面。</p>\n<ol>\n<li>你正在设计什么？</li>\n</ol>\n<p>工作中我们要考虑三个维度：</p>\n<p>-. 自己的工作流程</p>\n<p>-. 产品的迭代流程</p>\n<p>-. 团队的工作流程</p>\n<ol start=\"2\">\n<li>你不需要设计什么？</li>\n</ol>\n<p>因此需要明确产品范围边界，梳理得到核心功能。C端产品通常只有一个核心功能解决个人用户的一个核心问题，而B端产品则有多个核心功能来满足企业用户多个使用场景。被解决的问题即是需求，需求从何而来？</p>\n<p>需求来源：需求来源一般来说分为内部和外部，内部大多是职能部门的一些业务性需求或受到战略上的决策影响，而外部可能是和竞品、用户反馈的需求，无论是哪些需求，一定是站在战略性角度去看，既：这些需求能否满足用户或企业价值来，更接地气的说，这个需求能否起到实际作用，还是伪需求，或者不紧急的。</p>\n<p><em>《PRD文档》范围层面的产出物</em>，文档是起到定义功能的作用，他不需要包含产品的每一个细节（不像交互文档那样细致），只需要包含在设计或开发过程中出现有可能混淆的功能定义即可。</p>\n<h2 id=\"结构层-1\"><a href=\"#结构层-1\" class=\"headerlink\" title=\"结构层\"></a>结构层</h2><p>定义好功能范围并排列好优先级之后，我们对最终的产品模型包含什么特性会有一个清晰的认识，然后这些需求并没有说明如何将这些分散的片段组成一个整体。这就是在范围层之上的结构层：为产品创建一个功能架构，设计用户如何到达某个页面，并且要思考他们完成事情之后能够去哪里，也就是确定页面各种特性和功能最适合的组合方式，并在流程上形成一个闭环。从这里往后就是我们交互设计师该重点专注的层面了：将抽象的需求逐渐整理成一个具象的产品原型。</p>\n<p>对结构是否有质量的的评判标准是：</p>\n<ol>\n<li><p>以各种方式将产品信息合理并有意义地呈现给用户，让用户更容易找到最有用的信息；</p>\n</li>\n<li><p>不是整个过程需要多少步完成，而是用户是否认为每个步骤都是合理的；</p>\n</li>\n<li><p>一个高效结构的优点具备“可包容”和“可扩展”的能力。</p>\n</li>\n</ol>\n<p><em>产出物</em>：功能流程图，业务流程图（泳道图），页面流程图，</p>\n<h2 id=\"框架层-1\"><a href=\"#框架层-1\" class=\"headerlink\" title=\"框架层\"></a>框架层</h2><p>将功能和流程梳理清楚之后，我们就要开始设计功能点里的具体细节，也就是让广大设计师又爱又恨的原型图。在充满概念的结构层当中形成了大量的需求，这些需求都是来自战略目标的需求。在框架层里，我们要更进一步的提炼这些结构，输出详细的界面雏形、导航及信息设计，也就是将结构层的东西变得更加清晰、实在。“交互设计文档”就是在该阶段产生的。</p>\n<p>这个阶段需要注意：</p>\n<ol>\n<li><p>让设计尽量符合用户的使用习惯</p>\n</li>\n<li><p>重点突出，让用户一眼看到核心内容</p>\n</li>\n<li><p>将产品信息呈现出来并让用户容易理解</p>\n</li>\n<li><p>在合适的地方权衡利弊，使用合适的组件。</p>\n</li>\n<li><p>理性的错误处理。</p>\n</li>\n</ol>\n<p>*. 操作前，提醒放错</p>\n<p>*. 操作中，实时感知</p>\n<p>*. 操作后，及时反馈&amp;友好引导</p>\n<h2 id=\"表现层-1\"><a href=\"#表现层-1\" class=\"headerlink\" title=\"表现层\"></a>表现层</h2><p>表现层在这五层模型的最顶端，也是用户会首先注意到的地方：感知设计。这里是将品牌、内容、功能和美学汇集到一起界面设计。在框架层，我们主要解决组件放置和元素布局的问题，表现层则要解决并弥补“产品框架层的逻辑排布”的感知呈现问题。通过视觉设计，我们决定这些内容在界面上应该如何呈现。</p>\n<p><strong>五大感知：视觉、听觉、触觉、嗅觉、味觉</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实际上这五个层面，就是我们产品设计的工作流程和注意点：</p>\n<p>战略层——确定<em>产品目标和用户需求</em>，为产品将来的方向做市场调研、用户研究，这是产品经理设计产品的根源，也是做一个产品的开端；</p>\n<p>范围层——当我们获取到用户需求、明确好产品目标后，就要开始研究提供什么解决方案来满足用户的需求，这些解决方案对应的功能有哪些，内容由什么组成，这时一般会产出<em>《PRD文档》</em>、《功能规格说明书》来记录这些，一般包含：版本记录、产品规划图、功能清单、业务流程图、需求列表、开发资源、其他相关规范…</p>\n<p>结构层——功能和内容范围确定后，交互设计师开始根据产品的需求设计解决方案，通过<em>架构图和流程图</em>，将这些打散的需求串联起来，形成一个可以闭环的流程，并且罗列出功能架构：这些需求会有几个页面组成、每个页面包含什么东西。当然有些团队可能没有交互设计师的岗位，那就是PM和UI共同担任；</p>\n<p>框架层——有了架构图和流程图之后，就开始设计<em>具体界面雏形（原型图、线框图），具体到这些页面如何跳转、用什么组件、交互规则是怎么样的、页面元素怎么组合等，这时候通常会产出《交互设计文档》</em>，一般包含：版本记录、需求背景、流程图、架构图、页面原型、交互说明、页面demo…</p>\n<p>表现层——UI设计对功能设计进行支持的环节，基于原型图将产品呈现出来，颜色、元素、品牌、内容怎么通过视觉设计来定义，这都取决于UI设计师如何把控产品特性、功能理解及目标用户的调性，最后将设计稿（高保真）交付给开发工程师，并产出《UI、交互设计规范》和组件库，方便开发调用及后期复用。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"用户体验要素\"><a href=\"#用户体验要素\" class=\"headerlink\" title=\"用户体验要素\"></a>用户体验要素</h1><h2 id=\"包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。\"><a href=\"#包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。\" class=\"headerlink\" title=\"包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。\"></a>包括五个层面（战略层、范围层、结构层、框架层、表现层），10个要素的模型。向我们讲述了“用户”、“商业”和“技术”之间的关系。</h2><h1 id=\"用户体验为什么那么重要\"><a href=\"#用户体验为什么那么重要\" class=\"headerlink\" title=\"用户体验为什么那么重要\"></a>用户体验为什么那么重要</h1><p>用户体验并不是指一件产品本身是如何工作的，用户体验是指“产品如何与外界发生联系并发挥作用”，也就是人们如何“接触”和“使用”它。当人们询问你某个产品或服务时，他们问的是使用的体验。它用起来难不难？是不是很容易学会？使用起来感觉如何？</p>\n<h1 id=\"认识这些要素\"><a href=\"#认识这些要素\" class=\"headerlink\" title=\"认识这些要素\"></a>认识这些要素</h1><h2 id=\"五个层面\"><a href=\"#五个层面\" class=\"headerlink\" title=\"五个层面\"></a>五个层面</h2><ol>\n<li><p>表现层：感知设计（UI）</p>\n</li>\n<li><p>框架层：信息设计，界面设计，导航设计（页面原型）</p>\n</li>\n<li><p>结构层：交互设计和信息架构（业务流程和功能流程）</p>\n</li>\n<li><p>范围层：内容需求和功能规格（PRD文档）</p>\n</li>\n<li><p>战略层：用户需求和产品目标</p>\n</li>\n</ol>\n<h1 id=\"战略层\"><a href=\"#战略层\" class=\"headerlink\" title=\"战略层\"></a>战略层</h1><ol>\n<li><p>我们要从这个产品得到什么？</p>\n</li>\n<li><p>我们的用户可以从这个产品得到什么？</p>\n</li>\n</ol>\n<h1 id=\"范围层\"><a href=\"#范围层\" class=\"headerlink\" title=\"范围层\"></a>范围层</h1><p>功能需求和内容需求。</p>\n<p>当我们把用户需求和产品目标转换成产品应该给用户提供什么功能和内容时，战略就变成了范围。</p>\n<p>产出物：PRD文档</p>\n<p>帮助我们知道该建设什么不该建设什么，在范围层我们讨论战略层面的抽象问题—-“我们为什么要开发这个产品？”—-转而面对一个新的问题：“我们要开发的是什么?”</p>\n<h2 id=\"结构层\"><a href=\"#结构层\" class=\"headerlink\" title=\"结构层\"></a>结构层</h2><p>在我们定义好用户需求并排列好优先级顺序之后，我们对于最终产品将会包括什么特性已经有了清楚的图像。然而，这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上一层：结构层。</p>\n<h2 id=\"框架层\"><a href=\"#框架层\" class=\"headerlink\" title=\"框架层\"></a>框架层</h2><h2 id=\"表现层\"><a href=\"#表现层\" class=\"headerlink\" title=\"表现层\"></a>表现层</h2><p>视觉、听觉、触觉、嗅觉和味觉</p>\n<h1 id=\"用户体验要素-1\"><a href=\"#用户体验要素-1\" class=\"headerlink\" title=\"用户体验要素\"></a>用户体验要素</h1><img src=\"User.jpg\" width=\"50%\" height=\"50%\" alt=\"需求工程师产品设计流程\">\n\n<h2 id=\"战略层-1\"><a href=\"#战略层-1\" class=\"headerlink\" title=\"战略层\"></a>战略层</h2><p>无论是功能性产品还是信息型产品，在战略层上关心的内容是一样的：“我们为什么要开发这个这个产品？”，可以分解为两个问题：</p>\n<ol>\n<li>用户需求（产品给用户带来了什么？）</li>\n</ol>\n<p>常见的用研方法有：问卷调查、用户访谈、焦点小组等，最适合用于收集用户的普遍观点与需求。其他研究工具（如用户测试或体验旅程图）则更适用于理解用户具体行为及用户和产品交互时的表现。</p>\n<ol start=\"2\">\n<li>产品目标（产品给企业带来什么？）</li>\n</ol>\n<p>包括产品的商业逻辑、商业价值、商业壁垒、品牌传播等。</p>\n<p>需要注意的是，战略层面虽然是整个产品的根基，但不意味着在项目开始之前你的战略要完全确定下来，也可以在过程中逐步完善，因为通过产品逐渐发展、成熟，会随着商业市场发生变化。</p>\n<ol start=\"3\">\n<li>阶段性目标</li>\n</ol>\n<p>复盘，检验设计结果，数据验证，用户使用时间，登陆次数……</p>\n<h2 id=\"范围层-1\"><a href=\"#范围层-1\" class=\"headerlink\" title=\"范围层\"></a>范围层</h2><p>带着<em>“产品给用户带来了什么”、“企业通过产品得到什么”</em>的明确认识，我们才能搞清楚如何去满足这些战略目标。当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。这里也是产品经理需要重点专注的层面。</p>\n<ol>\n<li>你正在设计什么？</li>\n</ol>\n<p>工作中我们要考虑三个维度：</p>\n<p>-. 自己的工作流程</p>\n<p>-. 产品的迭代流程</p>\n<p>-. 团队的工作流程</p>\n<ol start=\"2\">\n<li>你不需要设计什么？</li>\n</ol>\n<p>因此需要明确产品范围边界，梳理得到核心功能。C端产品通常只有一个核心功能解决个人用户的一个核心问题，而B端产品则有多个核心功能来满足企业用户多个使用场景。被解决的问题即是需求，需求从何而来？</p>\n<p>需求来源：需求来源一般来说分为内部和外部，内部大多是职能部门的一些业务性需求或受到战略上的决策影响，而外部可能是和竞品、用户反馈的需求，无论是哪些需求，一定是站在战略性角度去看，既：这些需求能否满足用户或企业价值来，更接地气的说，这个需求能否起到实际作用，还是伪需求，或者不紧急的。</p>\n<p><em>《PRD文档》范围层面的产出物</em>，文档是起到定义功能的作用，他不需要包含产品的每一个细节（不像交互文档那样细致），只需要包含在设计或开发过程中出现有可能混淆的功能定义即可。</p>\n<h2 id=\"结构层-1\"><a href=\"#结构层-1\" class=\"headerlink\" title=\"结构层\"></a>结构层</h2><p>定义好功能范围并排列好优先级之后，我们对最终的产品模型包含什么特性会有一个清晰的认识，然后这些需求并没有说明如何将这些分散的片段组成一个整体。这就是在范围层之上的结构层：为产品创建一个功能架构，设计用户如何到达某个页面，并且要思考他们完成事情之后能够去哪里，也就是确定页面各种特性和功能最适合的组合方式，并在流程上形成一个闭环。从这里往后就是我们交互设计师该重点专注的层面了：将抽象的需求逐渐整理成一个具象的产品原型。</p>\n<p>对结构是否有质量的的评判标准是：</p>\n<ol>\n<li><p>以各种方式将产品信息合理并有意义地呈现给用户，让用户更容易找到最有用的信息；</p>\n</li>\n<li><p>不是整个过程需要多少步完成，而是用户是否认为每个步骤都是合理的；</p>\n</li>\n<li><p>一个高效结构的优点具备“可包容”和“可扩展”的能力。</p>\n</li>\n</ol>\n<p><em>产出物</em>：功能流程图，业务流程图（泳道图），页面流程图，</p>\n<h2 id=\"框架层-1\"><a href=\"#框架层-1\" class=\"headerlink\" title=\"框架层\"></a>框架层</h2><p>将功能和流程梳理清楚之后，我们就要开始设计功能点里的具体细节，也就是让广大设计师又爱又恨的原型图。在充满概念的结构层当中形成了大量的需求，这些需求都是来自战略目标的需求。在框架层里，我们要更进一步的提炼这些结构，输出详细的界面雏形、导航及信息设计，也就是将结构层的东西变得更加清晰、实在。“交互设计文档”就是在该阶段产生的。</p>\n<p>这个阶段需要注意：</p>\n<ol>\n<li><p>让设计尽量符合用户的使用习惯</p>\n</li>\n<li><p>重点突出，让用户一眼看到核心内容</p>\n</li>\n<li><p>将产品信息呈现出来并让用户容易理解</p>\n</li>\n<li><p>在合适的地方权衡利弊，使用合适的组件。</p>\n</li>\n<li><p>理性的错误处理。</p>\n</li>\n</ol>\n<p>*. 操作前，提醒放错</p>\n<p>*. 操作中，实时感知</p>\n<p>*. 操作后，及时反馈&amp;友好引导</p>\n<h2 id=\"表现层-1\"><a href=\"#表现层-1\" class=\"headerlink\" title=\"表现层\"></a>表现层</h2><p>表现层在这五层模型的最顶端，也是用户会首先注意到的地方：感知设计。这里是将品牌、内容、功能和美学汇集到一起界面设计。在框架层，我们主要解决组件放置和元素布局的问题，表现层则要解决并弥补“产品框架层的逻辑排布”的感知呈现问题。通过视觉设计，我们决定这些内容在界面上应该如何呈现。</p>\n<p><strong>五大感知：视觉、听觉、触觉、嗅觉、味觉</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实际上这五个层面，就是我们产品设计的工作流程和注意点：</p>\n<p>战略层——确定<em>产品目标和用户需求</em>，为产品将来的方向做市场调研、用户研究，这是产品经理设计产品的根源，也是做一个产品的开端；</p>\n<p>范围层——当我们获取到用户需求、明确好产品目标后，就要开始研究提供什么解决方案来满足用户的需求，这些解决方案对应的功能有哪些，内容由什么组成，这时一般会产出<em>《PRD文档》</em>、《功能规格说明书》来记录这些，一般包含：版本记录、产品规划图、功能清单、业务流程图、需求列表、开发资源、其他相关规范…</p>\n<p>结构层——功能和内容范围确定后，交互设计师开始根据产品的需求设计解决方案，通过<em>架构图和流程图</em>，将这些打散的需求串联起来，形成一个可以闭环的流程，并且罗列出功能架构：这些需求会有几个页面组成、每个页面包含什么东西。当然有些团队可能没有交互设计师的岗位，那就是PM和UI共同担任；</p>\n<p>框架层——有了架构图和流程图之后，就开始设计<em>具体界面雏形（原型图、线框图），具体到这些页面如何跳转、用什么组件、交互规则是怎么样的、页面元素怎么组合等，这时候通常会产出《交互设计文档》</em>，一般包含：版本记录、需求背景、流程图、架构图、页面原型、交互说明、页面demo…</p>\n<p>表现层——UI设计对功能设计进行支持的环节，基于原型图将产品呈现出来，颜色、元素、品牌、内容怎么通过视觉设计来定义，这都取决于UI设计师如何把控产品特性、功能理解及目标用户的调性，最后将设计稿（高保真）交付给开发工程师，并产出《UI、交互设计规范》和组件库，方便开发调用及后期复用。</p>\n"},{"title":"幕后产品读书笔记","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-29T07:18:41.000Z","password":null,"summary":"这是我之前上传到CSDN上的一篇幕后产品读书笔记。","_content":"\n# 幕后产品\n\n## 执行层面\n\n### 产品经理的四个素质\n\n1. 创业心态\n\n互联网两三年翻天覆地，没创业心会掉队\n\n创业心态说得人多做到的人少，要知行合一\n\n与团队、上司、老板意见不合：仔细思考与他人的想法差异，找到分歧真正原因，选择对用户、产品最佳的方案\n\n优秀的产品经理则会不断地尝试通过自己的努力去影响他人解决问题、完成目标，而非坐看这个产品烂掉。\n\n做产品先想想失败了会怎样，遇到困难怎么办\n\n2. 求知\n\n市场 用户 心理学 运营 产品 设计 美学 商业 技术都要了解。\n\n3. 联想\n\n产品经理工作本质是解决问题\n\n洞察-归纳-联想\n\n洞察：顶级产品经理在生活方方面面观察入微，比如坐公交思考看到大屏手机双手操作而不便，会思考如何如何改进手势设计；\n\n归纳：用户为了作品上首页争吵，知乎用户认真作答而成就慢慢，朋友圈晒照片或赞，都可以加载对用户虚荣心的理解\n\n联想：把洞察和归纳的结论运用到产品中\n\n4. 闪断\n\n易云音乐导入歌单功能，在可能得罪对手、影响品牌形象与非常利于用户及产品之间，诗沐老师选择了后者\n\n产品功能影响远大于交互设计\n\n如果没有同时满足多方面的方案，则需要快速决策，推进\n\n有实验意识\n\n### 用户调研\n\n1. 亲力亲为\n\n2. 用研方法：深入访谈 焦点小组 问卷调查 可用性测试 留置研究\n\n3. 用研三要素：用户是否是典型的目标用户 信息是否真实 研究结论怎么样运用到产品设计中 \n\n4. 洞察心理和人性：共鸣 爱现 群体用户心理 \n\n5. 如何了解这么多的用户：同理心 设身处地想，创造性想法往往不会直接来自用户 发展多方面的兴趣，多出门食人间烟火 玩 RPG 网游，段时间体验人生\n\n### 需求\n\n**老板提出了一个不靠谱的需求，如何说服他？** \n\n分析需求背后动机，比如老板想通过这功能获取更多用户\n\n从长短期情况考虑，在这个获取用户这目标上是否一致？是否当前最重要的？\n\n用老板的方法实现这个目标有何优缺点？\n\n有没有更好的方法实现这个目标\n\n### 产品基本功 \n\n1. 数据分析\n\n2. 定位和架构层面\n\n3. UI设计\n\n4. 编程能力\n\n5. 审美能力\n\n## 产品定位\n\n定位决定了：\n\n你的产品能否活下来\n\n今后发展的天花板\n\n健康产品的平均数据\n\n日活/总用户数 = 5%\n\n周活/总用户数 = 10%\n\n月活/总用户数 = 20%\n\n次日留存 40%\n\n7日留存 20%\n\n30日留存 10%\n\n## 思维方式\n\n往重点、本质、上层、不同思考\n\n## 架构能力\n\n## 产品负责人的三个能力\n\n1. 商业嗅觉及推理能力\n\n2. 业务架构及创新能力\n\n3. 善于沟通及领导能力","source":"_posts/2019-first-post.md","raw":"---\ntitle: 幕后产品读书笔记\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-29 15:18:41\npassword:\nsummary: 这是我之前上传到CSDN上的一篇幕后产品读书笔记。\ntags:\n- 读书笔记\ncategories:\n- 读书笔记\n---\n\n# 幕后产品\n\n## 执行层面\n\n### 产品经理的四个素质\n\n1. 创业心态\n\n互联网两三年翻天覆地，没创业心会掉队\n\n创业心态说得人多做到的人少，要知行合一\n\n与团队、上司、老板意见不合：仔细思考与他人的想法差异，找到分歧真正原因，选择对用户、产品最佳的方案\n\n优秀的产品经理则会不断地尝试通过自己的努力去影响他人解决问题、完成目标，而非坐看这个产品烂掉。\n\n做产品先想想失败了会怎样，遇到困难怎么办\n\n2. 求知\n\n市场 用户 心理学 运营 产品 设计 美学 商业 技术都要了解。\n\n3. 联想\n\n产品经理工作本质是解决问题\n\n洞察-归纳-联想\n\n洞察：顶级产品经理在生活方方面面观察入微，比如坐公交思考看到大屏手机双手操作而不便，会思考如何如何改进手势设计；\n\n归纳：用户为了作品上首页争吵，知乎用户认真作答而成就慢慢，朋友圈晒照片或赞，都可以加载对用户虚荣心的理解\n\n联想：把洞察和归纳的结论运用到产品中\n\n4. 闪断\n\n易云音乐导入歌单功能，在可能得罪对手、影响品牌形象与非常利于用户及产品之间，诗沐老师选择了后者\n\n产品功能影响远大于交互设计\n\n如果没有同时满足多方面的方案，则需要快速决策，推进\n\n有实验意识\n\n### 用户调研\n\n1. 亲力亲为\n\n2. 用研方法：深入访谈 焦点小组 问卷调查 可用性测试 留置研究\n\n3. 用研三要素：用户是否是典型的目标用户 信息是否真实 研究结论怎么样运用到产品设计中 \n\n4. 洞察心理和人性：共鸣 爱现 群体用户心理 \n\n5. 如何了解这么多的用户：同理心 设身处地想，创造性想法往往不会直接来自用户 发展多方面的兴趣，多出门食人间烟火 玩 RPG 网游，段时间体验人生\n\n### 需求\n\n**老板提出了一个不靠谱的需求，如何说服他？** \n\n分析需求背后动机，比如老板想通过这功能获取更多用户\n\n从长短期情况考虑，在这个获取用户这目标上是否一致？是否当前最重要的？\n\n用老板的方法实现这个目标有何优缺点？\n\n有没有更好的方法实现这个目标\n\n### 产品基本功 \n\n1. 数据分析\n\n2. 定位和架构层面\n\n3. UI设计\n\n4. 编程能力\n\n5. 审美能力\n\n## 产品定位\n\n定位决定了：\n\n你的产品能否活下来\n\n今后发展的天花板\n\n健康产品的平均数据\n\n日活/总用户数 = 5%\n\n周活/总用户数 = 10%\n\n月活/总用户数 = 20%\n\n次日留存 40%\n\n7日留存 20%\n\n30日留存 10%\n\n## 思维方式\n\n往重点、本质、上层、不同思考\n\n## 架构能力\n\n## 产品负责人的三个能力\n\n1. 商业嗅觉及推理能力\n\n2. 业务架构及创新能力\n\n3. 善于沟通及领导能力","slug":"2019-first-post","published":1,"updated":"2019-09-29T07:20:58.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxb700122wvcafu6cmvf","content":"<h1 id=\"幕后产品\"><a href=\"#幕后产品\" class=\"headerlink\" title=\"幕后产品\"></a>幕后产品</h1><h2 id=\"执行层面\"><a href=\"#执行层面\" class=\"headerlink\" title=\"执行层面\"></a>执行层面</h2><h3 id=\"产品经理的四个素质\"><a href=\"#产品经理的四个素质\" class=\"headerlink\" title=\"产品经理的四个素质\"></a>产品经理的四个素质</h3><ol>\n<li>创业心态</li>\n</ol>\n<p>互联网两三年翻天覆地，没创业心会掉队</p>\n<p>创业心态说得人多做到的人少，要知行合一</p>\n<p>与团队、上司、老板意见不合：仔细思考与他人的想法差异，找到分歧真正原因，选择对用户、产品最佳的方案</p>\n<p>优秀的产品经理则会不断地尝试通过自己的努力去影响他人解决问题、完成目标，而非坐看这个产品烂掉。</p>\n<p>做产品先想想失败了会怎样，遇到困难怎么办</p>\n<ol start=\"2\">\n<li>求知</li>\n</ol>\n<p>市场 用户 心理学 运营 产品 设计 美学 商业 技术都要了解。</p>\n<ol start=\"3\">\n<li>联想</li>\n</ol>\n<p>产品经理工作本质是解决问题</p>\n<p>洞察-归纳-联想</p>\n<p>洞察：顶级产品经理在生活方方面面观察入微，比如坐公交思考看到大屏手机双手操作而不便，会思考如何如何改进手势设计；</p>\n<p>归纳：用户为了作品上首页争吵，知乎用户认真作答而成就慢慢，朋友圈晒照片或赞，都可以加载对用户虚荣心的理解</p>\n<p>联想：把洞察和归纳的结论运用到产品中</p>\n<ol start=\"4\">\n<li>闪断</li>\n</ol>\n<p>易云音乐导入歌单功能，在可能得罪对手、影响品牌形象与非常利于用户及产品之间，诗沐老师选择了后者</p>\n<p>产品功能影响远大于交互设计</p>\n<p>如果没有同时满足多方面的方案，则需要快速决策，推进</p>\n<p>有实验意识</p>\n<h3 id=\"用户调研\"><a href=\"#用户调研\" class=\"headerlink\" title=\"用户调研\"></a>用户调研</h3><ol>\n<li><p>亲力亲为</p>\n</li>\n<li><p>用研方法：深入访谈 焦点小组 问卷调查 可用性测试 留置研究</p>\n</li>\n<li><p>用研三要素：用户是否是典型的目标用户 信息是否真实 研究结论怎么样运用到产品设计中 </p>\n</li>\n<li><p>洞察心理和人性：共鸣 爱现 群体用户心理 </p>\n</li>\n<li><p>如何了解这么多的用户：同理心 设身处地想，创造性想法往往不会直接来自用户 发展多方面的兴趣，多出门食人间烟火 玩 RPG 网游，段时间体验人生</p>\n</li>\n</ol>\n<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p><strong>老板提出了一个不靠谱的需求，如何说服他？</strong> </p>\n<p>分析需求背后动机，比如老板想通过这功能获取更多用户</p>\n<p>从长短期情况考虑，在这个获取用户这目标上是否一致？是否当前最重要的？</p>\n<p>用老板的方法实现这个目标有何优缺点？</p>\n<p>有没有更好的方法实现这个目标</p>\n<h3 id=\"产品基本功\"><a href=\"#产品基本功\" class=\"headerlink\" title=\"产品基本功\"></a>产品基本功</h3><ol>\n<li><p>数据分析</p>\n</li>\n<li><p>定位和架构层面</p>\n</li>\n<li><p>UI设计</p>\n</li>\n<li><p>编程能力</p>\n</li>\n<li><p>审美能力</p>\n</li>\n</ol>\n<h2 id=\"产品定位\"><a href=\"#产品定位\" class=\"headerlink\" title=\"产品定位\"></a>产品定位</h2><p>定位决定了：</p>\n<p>你的产品能否活下来</p>\n<p>今后发展的天花板</p>\n<p>健康产品的平均数据</p>\n<p>日活/总用户数 = 5%</p>\n<p>周活/总用户数 = 10%</p>\n<p>月活/总用户数 = 20%</p>\n<p>次日留存 40%</p>\n<p>7日留存 20%</p>\n<p>30日留存 10%</p>\n<h2 id=\"思维方式\"><a href=\"#思维方式\" class=\"headerlink\" title=\"思维方式\"></a>思维方式</h2><p>往重点、本质、上层、不同思考</p>\n<h2 id=\"架构能力\"><a href=\"#架构能力\" class=\"headerlink\" title=\"架构能力\"></a>架构能力</h2><h2 id=\"产品负责人的三个能力\"><a href=\"#产品负责人的三个能力\" class=\"headerlink\" title=\"产品负责人的三个能力\"></a>产品负责人的三个能力</h2><ol>\n<li><p>商业嗅觉及推理能力</p>\n</li>\n<li><p>业务架构及创新能力</p>\n</li>\n<li><p>善于沟通及领导能力</p>\n</li>\n</ol>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"幕后产品\"><a href=\"#幕后产品\" class=\"headerlink\" title=\"幕后产品\"></a>幕后产品</h1><h2 id=\"执行层面\"><a href=\"#执行层面\" class=\"headerlink\" title=\"执行层面\"></a>执行层面</h2><h3 id=\"产品经理的四个素质\"><a href=\"#产品经理的四个素质\" class=\"headerlink\" title=\"产品经理的四个素质\"></a>产品经理的四个素质</h3><ol>\n<li>创业心态</li>\n</ol>\n<p>互联网两三年翻天覆地，没创业心会掉队</p>\n<p>创业心态说得人多做到的人少，要知行合一</p>\n<p>与团队、上司、老板意见不合：仔细思考与他人的想法差异，找到分歧真正原因，选择对用户、产品最佳的方案</p>\n<p>优秀的产品经理则会不断地尝试通过自己的努力去影响他人解决问题、完成目标，而非坐看这个产品烂掉。</p>\n<p>做产品先想想失败了会怎样，遇到困难怎么办</p>\n<ol start=\"2\">\n<li>求知</li>\n</ol>\n<p>市场 用户 心理学 运营 产品 设计 美学 商业 技术都要了解。</p>\n<ol start=\"3\">\n<li>联想</li>\n</ol>\n<p>产品经理工作本质是解决问题</p>\n<p>洞察-归纳-联想</p>\n<p>洞察：顶级产品经理在生活方方面面观察入微，比如坐公交思考看到大屏手机双手操作而不便，会思考如何如何改进手势设计；</p>\n<p>归纳：用户为了作品上首页争吵，知乎用户认真作答而成就慢慢，朋友圈晒照片或赞，都可以加载对用户虚荣心的理解</p>\n<p>联想：把洞察和归纳的结论运用到产品中</p>\n<ol start=\"4\">\n<li>闪断</li>\n</ol>\n<p>易云音乐导入歌单功能，在可能得罪对手、影响品牌形象与非常利于用户及产品之间，诗沐老师选择了后者</p>\n<p>产品功能影响远大于交互设计</p>\n<p>如果没有同时满足多方面的方案，则需要快速决策，推进</p>\n<p>有实验意识</p>\n<h3 id=\"用户调研\"><a href=\"#用户调研\" class=\"headerlink\" title=\"用户调研\"></a>用户调研</h3><ol>\n<li><p>亲力亲为</p>\n</li>\n<li><p>用研方法：深入访谈 焦点小组 问卷调查 可用性测试 留置研究</p>\n</li>\n<li><p>用研三要素：用户是否是典型的目标用户 信息是否真实 研究结论怎么样运用到产品设计中 </p>\n</li>\n<li><p>洞察心理和人性：共鸣 爱现 群体用户心理 </p>\n</li>\n<li><p>如何了解这么多的用户：同理心 设身处地想，创造性想法往往不会直接来自用户 发展多方面的兴趣，多出门食人间烟火 玩 RPG 网游，段时间体验人生</p>\n</li>\n</ol>\n<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p><strong>老板提出了一个不靠谱的需求，如何说服他？</strong> </p>\n<p>分析需求背后动机，比如老板想通过这功能获取更多用户</p>\n<p>从长短期情况考虑，在这个获取用户这目标上是否一致？是否当前最重要的？</p>\n<p>用老板的方法实现这个目标有何优缺点？</p>\n<p>有没有更好的方法实现这个目标</p>\n<h3 id=\"产品基本功\"><a href=\"#产品基本功\" class=\"headerlink\" title=\"产品基本功\"></a>产品基本功</h3><ol>\n<li><p>数据分析</p>\n</li>\n<li><p>定位和架构层面</p>\n</li>\n<li><p>UI设计</p>\n</li>\n<li><p>编程能力</p>\n</li>\n<li><p>审美能力</p>\n</li>\n</ol>\n<h2 id=\"产品定位\"><a href=\"#产品定位\" class=\"headerlink\" title=\"产品定位\"></a>产品定位</h2><p>定位决定了：</p>\n<p>你的产品能否活下来</p>\n<p>今后发展的天花板</p>\n<p>健康产品的平均数据</p>\n<p>日活/总用户数 = 5%</p>\n<p>周活/总用户数 = 10%</p>\n<p>月活/总用户数 = 20%</p>\n<p>次日留存 40%</p>\n<p>7日留存 20%</p>\n<p>30日留存 10%</p>\n<h2 id=\"思维方式\"><a href=\"#思维方式\" class=\"headerlink\" title=\"思维方式\"></a>思维方式</h2><p>往重点、本质、上层、不同思考</p>\n<h2 id=\"架构能力\"><a href=\"#架构能力\" class=\"headerlink\" title=\"架构能力\"></a>架构能力</h2><h2 id=\"产品负责人的三个能力\"><a href=\"#产品负责人的三个能力\" class=\"headerlink\" title=\"产品负责人的三个能力\"></a>产品负责人的三个能力</h2><ol>\n<li><p>商业嗅觉及推理能力</p>\n</li>\n<li><p>业务架构及创新能力</p>\n</li>\n<li><p>善于沟通及领导能力</p>\n</li>\n</ol>\n"},{"title":"怎么样创建你的Blog","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-10-03T16:13:07.000Z","password":null,"summary":null,"_content":"\n\t有任何问题请联系我扣扣：1210188858，vx：guo1210188858，如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。\n\n# 我的博客源代码地址\n大家可以直接素质二连，star&fork我的博客源代码：\nhttps://github.com/HaoxinGuo/HaoxinGuo.github.io/tree/hexo，然后改改配置就可以写文章啦。\n\n为了减小源码的体积，将插件目录node_modules进行了压缩，大家下载完后需要解压。\n\n- 首先运行git clone git@github.com:HaoxinGuo/HaoxinGuo.github.io.git将所有文件下载到本地。\n- 解压node_modules.zip，然后删除node_modules.zip和.git文件夹。\n# 快速搭建\n如果你不想自己从头开始慢慢自定义主题的话，可以直接下载我的修改好的主题，然后稍微修改几个地方就好了：\n\n- 根目录配置文件_config.yml和主题目录配置文件_config.yml中修改个人信息。\n- 根目录配置文件中修改deploy一栏的repository。\n- 根目录配置文件中修改baidu_url_submit一栏的token。\n- 主题配置文件中修改gitalk一栏，修改方法见正文。\n**当然前提是个性化设置章节之前的环境还是需要配置好！**\n\n平时常用命令：\n```\nhexo g  # 生成博客网页文件\nhexo s  # 本地预览博客\nhexo d  # 上传网页文件到github\n#注：必须使用hexo d上传\n```\n\n目录结构\n\n- 安装Node.js\n- 添加国内镜像源\n- 安装Git\n- 注册Github账号\n- 安装Hexo\n- 连接Github与本地\n- 写文章、发布文章\n- 绑定域名\n- 备份博客源文件\n- 博客源代码下载\n\n# 安装Node.js\n首先下载稳定版[Node.js](https://nodejs.org/en/)。\n![node.js下载](xiazaishili.png)\n安装选项全部默认，一路点击Next。\n最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。\n![node.js安装成功显示示例](npmshili.png)\n# 添加国内镜像源\n使用阿里的国内镜像进行加速。\n'''\nnpm config set registry https://registry.npm.taobao.org\n'''\n# Git安装\n\n为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git[下载地址](https://git-scm.com/download/win)。\n![安装GIT](gitxiazai.png)\n**安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt**，之后我们就可以直接在命令提示符里打开git了。\n\n安装完成后在命令提示符中输入git --version验证是否安装成功。\n\n# 注册Github账号\n接下来就去注册一个github账号，用来存放我们的网站。[注册地址](https://github.com/)\n注册完成后打开https://github.com/，新建一个项目，如下所示：\n![新建项目](newrepository.png)\n然后如下图所示，输入自己的项目名字，后面一定要加**.github.io**后缀，**勾选README初始化**。名称一定要和你的github名字完全一样，比如你github名字叫HaoxinGuo，那么仓库名字一定要是HaoxinGuo.github.io。\n![仓库名字命名](chushihua.png)\n# 安装Notepad++\n安装[Notepad++]( https://notepad-plus-plus.org/downloads/ )，方便以后编辑Markdown文件。\n# 安装Hexo\n在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在C:\\user\\12101\\desktop\\blog目录下。\n以管理员身份运行cmd，进到该目录下，关于cmd的操作命令可以参考该[链接1]( https://blog.csdn.net/LJFPHP/article/details/78818696 )[链接2]( https://blog.csdn.net/xiaosemei/article/details/79270904 ) ，输入\n```\nnpm i hexo-cli -g\n```\n安装Hexo。可能会有几个报错，无视它就行。\n安装完后输入hexo -v验证是否安装成功。\n![hexo安装成功](hexo.png)\n# 初始化网站\n初始化我们的网站，输入```hexo init```初始化文件夹，接着输入```npm install```安装必备的组件。\n这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到我们的博客啦，效果如下：\n按ctrl+c关闭本地服务器。\n# 连接Github与本地\n首先右键打开git bash，然后输入下面命令：\n```\ngit config --global user.name \"Your Name of Github\"\ngit config --global user.email \"your email of Github\"\n```\n用户名和邮箱根据你注册github的信息自行修改。\n然后生成密钥SSH key：\n```\nssh-keygen -t rsa -C \"your email of Github\"\n```\n打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。\n![settings](setting.png)\n![SSH and GPG keys](SSH.png)\n![新建一个SSH](NewSSH.png)\n在git bash(右键git bash here )中输入```cat ~/.ssh/id_rsa.pub```或者打开如图所示的文件“id_rsa.pub”\n![文件位置](RA.png)\n将文件中的内容复制到框中，点击确定保存。\n## 测试是否成功\n输入```ssh -T git@github.com```，如果如下图所示，出现你的用户名，那就成功了。\n![Git配置成功](chenggong.png)\n\n# 创建你的Blog\n## 克隆你的yourname.github.io项目到本地\n```\ngit clone git@github/Yourname.github.io\n```\n## 克隆我的git项目到本地\n```\ngit clone git@github/HaoxinGuo\n```\n删除.git文件，其余的粘贴到你的**yourname.github.io**文件中，接下来修改配置文件\n## 配置自己的文件\n博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。\n### 修改最后一行的配置\n```\ndeploy:\n  type: git\n  repository: https://github.com/HaoxinGuo/HaoxinGuo.github.io\n  branch: master\n```\nrepository修改为你自己的github.io项目地址。\n## 写文章、发布文章\n首先在博客根目录下右键打开git bash，安装一个扩展```npm i hexo-deployer-git```。\n然后输入```hexo new post \"article title\"```，新建一篇文章。\n然后打开```..\\blog\\source\\_posts```的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。\n\n编写完markdown(注意编码为UTF-8，要不然打开网页后乱码)文件后，根目录下输入```hexo g```生成静态网页，然后输入```hexo s```可以本地预览效果，最后输入```hexo d```上传到github上。这时打开你的github.io主页就能看到发布的文章啦。","source":"_posts/2019-how-to-build-your-Blog.md","raw":"---\ntitle: 怎么样创建你的Blog\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-10-04 00:13:07\npassword:\nsummary:\ntags:\ncategories:\n---\n\n\t有任何问题请联系我扣扣：1210188858，vx：guo1210188858，如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。\n\n# 我的博客源代码地址\n大家可以直接素质二连，star&fork我的博客源代码：\nhttps://github.com/HaoxinGuo/HaoxinGuo.github.io/tree/hexo，然后改改配置就可以写文章啦。\n\n为了减小源码的体积，将插件目录node_modules进行了压缩，大家下载完后需要解压。\n\n- 首先运行git clone git@github.com:HaoxinGuo/HaoxinGuo.github.io.git将所有文件下载到本地。\n- 解压node_modules.zip，然后删除node_modules.zip和.git文件夹。\n# 快速搭建\n如果你不想自己从头开始慢慢自定义主题的话，可以直接下载我的修改好的主题，然后稍微修改几个地方就好了：\n\n- 根目录配置文件_config.yml和主题目录配置文件_config.yml中修改个人信息。\n- 根目录配置文件中修改deploy一栏的repository。\n- 根目录配置文件中修改baidu_url_submit一栏的token。\n- 主题配置文件中修改gitalk一栏，修改方法见正文。\n**当然前提是个性化设置章节之前的环境还是需要配置好！**\n\n平时常用命令：\n```\nhexo g  # 生成博客网页文件\nhexo s  # 本地预览博客\nhexo d  # 上传网页文件到github\n#注：必须使用hexo d上传\n```\n\n目录结构\n\n- 安装Node.js\n- 添加国内镜像源\n- 安装Git\n- 注册Github账号\n- 安装Hexo\n- 连接Github与本地\n- 写文章、发布文章\n- 绑定域名\n- 备份博客源文件\n- 博客源代码下载\n\n# 安装Node.js\n首先下载稳定版[Node.js](https://nodejs.org/en/)。\n![node.js下载](xiazaishili.png)\n安装选项全部默认，一路点击Next。\n最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。\n![node.js安装成功显示示例](npmshili.png)\n# 添加国内镜像源\n使用阿里的国内镜像进行加速。\n'''\nnpm config set registry https://registry.npm.taobao.org\n'''\n# Git安装\n\n为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git[下载地址](https://git-scm.com/download/win)。\n![安装GIT](gitxiazai.png)\n**安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt**，之后我们就可以直接在命令提示符里打开git了。\n\n安装完成后在命令提示符中输入git --version验证是否安装成功。\n\n# 注册Github账号\n接下来就去注册一个github账号，用来存放我们的网站。[注册地址](https://github.com/)\n注册完成后打开https://github.com/，新建一个项目，如下所示：\n![新建项目](newrepository.png)\n然后如下图所示，输入自己的项目名字，后面一定要加**.github.io**后缀，**勾选README初始化**。名称一定要和你的github名字完全一样，比如你github名字叫HaoxinGuo，那么仓库名字一定要是HaoxinGuo.github.io。\n![仓库名字命名](chushihua.png)\n# 安装Notepad++\n安装[Notepad++]( https://notepad-plus-plus.org/downloads/ )，方便以后编辑Markdown文件。\n# 安装Hexo\n在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在C:\\user\\12101\\desktop\\blog目录下。\n以管理员身份运行cmd，进到该目录下，关于cmd的操作命令可以参考该[链接1]( https://blog.csdn.net/LJFPHP/article/details/78818696 )[链接2]( https://blog.csdn.net/xiaosemei/article/details/79270904 ) ，输入\n```\nnpm i hexo-cli -g\n```\n安装Hexo。可能会有几个报错，无视它就行。\n安装完后输入hexo -v验证是否安装成功。\n![hexo安装成功](hexo.png)\n# 初始化网站\n初始化我们的网站，输入```hexo init```初始化文件夹，接着输入```npm install```安装必备的组件。\n这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开http://localhost:4000/，就可以看到我们的博客啦，效果如下：\n按ctrl+c关闭本地服务器。\n# 连接Github与本地\n首先右键打开git bash，然后输入下面命令：\n```\ngit config --global user.name \"Your Name of Github\"\ngit config --global user.email \"your email of Github\"\n```\n用户名和邮箱根据你注册github的信息自行修改。\n然后生成密钥SSH key：\n```\nssh-keygen -t rsa -C \"your email of Github\"\n```\n打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。\n![settings](setting.png)\n![SSH and GPG keys](SSH.png)\n![新建一个SSH](NewSSH.png)\n在git bash(右键git bash here )中输入```cat ~/.ssh/id_rsa.pub```或者打开如图所示的文件“id_rsa.pub”\n![文件位置](RA.png)\n将文件中的内容复制到框中，点击确定保存。\n## 测试是否成功\n输入```ssh -T git@github.com```，如果如下图所示，出现你的用户名，那就成功了。\n![Git配置成功](chenggong.png)\n\n# 创建你的Blog\n## 克隆你的yourname.github.io项目到本地\n```\ngit clone git@github/Yourname.github.io\n```\n## 克隆我的git项目到本地\n```\ngit clone git@github/HaoxinGuo\n```\n删除.git文件，其余的粘贴到你的**yourname.github.io**文件中，接下来修改配置文件\n## 配置自己的文件\n博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。\n### 修改最后一行的配置\n```\ndeploy:\n  type: git\n  repository: https://github.com/HaoxinGuo/HaoxinGuo.github.io\n  branch: master\n```\nrepository修改为你自己的github.io项目地址。\n## 写文章、发布文章\n首先在博客根目录下右键打开git bash，安装一个扩展```npm i hexo-deployer-git```。\n然后输入```hexo new post \"article title\"```，新建一篇文章。\n然后打开```..\\blog\\source\\_posts```的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。\n\n编写完markdown(注意编码为UTF-8，要不然打开网页后乱码)文件后，根目录下输入```hexo g```生成静态网页，然后输入```hexo s```可以本地预览效果，最后输入```hexo d```上传到github上。这时打开你的github.io主页就能看到发布的文章啦。","slug":"2019-how-to-build-your-Blog","published":1,"updated":"2019-10-03T16:15:14.952Z","_id":"ck1awgxba00152wvcgxd5mrcz","comments":1,"layout":"post","photos":[],"link":"","content":"<pre><code>有任何问题请联系我扣扣：1210188858，vx：guo1210188858，如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。</code></pre><h1 id=\"我的博客源代码地址\"><a href=\"#我的博客源代码地址\" class=\"headerlink\" title=\"我的博客源代码地址\"></a>我的博客源代码地址</h1><p>大家可以直接素质二连，star&amp;fork我的博客源代码：<br><a href=\"https://github.com/HaoxinGuo/HaoxinGuo.github.io/tree/hexo，然后改改配置就可以写文章啦。\" target=\"_blank\" rel=\"noopener\">https://github.com/HaoxinGuo/HaoxinGuo.github.io/tree/hexo，然后改改配置就可以写文章啦。</a></p>\n<p>为了减小源码的体积，将插件目录node_modules进行了压缩，大家下载完后需要解压。</p>\n<ul>\n<li><p>首先运行git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:HaoxinGuo/HaoxinGuo.github.io.git将所有文件下载到本地。</p>\n</li>\n<li><p>解压node_modules.zip，然后删除node_modules.zip和.git文件夹。</p>\n<h1 id=\"快速搭建\"><a href=\"#快速搭建\" class=\"headerlink\" title=\"快速搭建\"></a>快速搭建</h1><p>如果你不想自己从头开始慢慢自定义主题的话，可以直接下载我的修改好的主题，然后稍微修改几个地方就好了：</p>\n</li>\n<li><p>根目录配置文件_config.yml和主题目录配置文件_config.yml中修改个人信息。</p>\n</li>\n<li><p>根目录配置文件中修改deploy一栏的repository。</p>\n</li>\n<li><p>根目录配置文件中修改baidu_url_submit一栏的token。</p>\n</li>\n<li><p>主题配置文件中修改gitalk一栏，修改方法见正文。</p>\n</li>\n</ul>\n<p><strong>当然前提是个性化设置章节之前的环境还是需要配置好！</strong></p>\n<p>平时常用命令：</p>\n<pre><code>hexo g  # 生成博客网页文件\nhexo s  # 本地预览博客\nhexo d  # 上传网页文件到github\n#注：必须使用hexo d上传</code></pre><p>目录结构</p>\n<ul>\n<li>安装Node.js</li>\n<li>添加国内镜像源</li>\n<li>安装Git</li>\n<li>注册Github账号</li>\n<li>安装Hexo</li>\n<li>连接Github与本地</li>\n<li>写文章、发布文章</li>\n<li>绑定域名</li>\n<li>备份博客源文件</li>\n<li>博客源代码下载</li>\n</ul>\n<h1 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h1><p>首先下载稳定版<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a>。<br><img src=\"xiazaishili.png\" alt=\"node.js下载\"><br>安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。<br><img src=\"npmshili.png\" alt=\"node.js安装成功显示示例\"></p>\n<h1 id=\"添加国内镜像源\"><a href=\"#添加国内镜像源\" class=\"headerlink\" title=\"添加国内镜像源\"></a>添加国内镜像源</h1><p>使用阿里的国内镜像进行加速。<br>‘’’<br>npm config set registry <a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a><br>‘’’</p>\n<h1 id=\"Git安装\"><a href=\"#Git安装\" class=\"headerlink\" title=\"Git安装\"></a>Git安装</h1><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git<a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">下载地址</a>。<br><img src=\"gitxiazai.png\" alt=\"安装GIT\"><br><strong>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt</strong>，之后我们就可以直接在命令提示符里打开git了。</p>\n<p>安装完成后在命令提示符中输入git –version验证是否安装成功。</p>\n<h1 id=\"注册Github账号\"><a href=\"#注册Github账号\" class=\"headerlink\" title=\"注册Github账号\"></a>注册Github账号</h1><p>接下来就去注册一个github账号，用来存放我们的网站。<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">注册地址</a><br>注册完成后打开<a href=\"https://github.com/，新建一个项目，如下所示：\" target=\"_blank\" rel=\"noopener\">https://github.com/，新建一个项目，如下所示：</a><br><img src=\"newrepository.png\" alt=\"新建项目\"><br>然后如下图所示，输入自己的项目名字，后面一定要加<strong>.github.io</strong>后缀，<strong>勾选README初始化</strong>。名称一定要和你的github名字完全一样，比如你github名字叫HaoxinGuo，那么仓库名字一定要是HaoxinGuo.github.io。<br><img src=\"chushihua.png\" alt=\"仓库名字命名\"></p>\n<h1 id=\"安装Notepad\"><a href=\"#安装Notepad\" class=\"headerlink\" title=\"安装Notepad++\"></a>安装Notepad++</h1><p>安装<a href=\"https://notepad-plus-plus.org/downloads/\" target=\"_blank\" rel=\"noopener\">Notepad++</a>，方便以后编辑Markdown文件。</p>\n<h1 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h1><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在C:\\user\\12101\\desktop\\blog目录下。<br>以管理员身份运行cmd，进到该目录下，关于cmd的操作命令可以参考该<a href=\"https://blog.csdn.net/LJFPHP/article/details/78818696\" target=\"_blank\" rel=\"noopener\">链接1</a><a href=\"https://blog.csdn.net/xiaosemei/article/details/79270904\" target=\"_blank\" rel=\"noopener\">链接2</a> ，输入</p>\n<pre><code>npm i hexo-cli -g</code></pre><p>安装Hexo。可能会有几个报错，无视它就行。<br>安装完后输入hexo -v验证是否安装成功。<br><img src=\"hexo.png\" alt=\"hexo安装成功\"></p>\n<h1 id=\"初始化网站\"><a href=\"#初始化网站\" class=\"headerlink\" title=\"初始化网站\"></a>初始化网站</h1><p>初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。<br>这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开<a href=\"http://localhost:4000/，就可以看到我们的博客啦，效果如下：\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/，就可以看到我们的博客啦，效果如下：</a><br>按ctrl+c关闭本地服务器。</p>\n<h1 id=\"连接Github与本地\"><a href=\"#连接Github与本地\" class=\"headerlink\" title=\"连接Github与本地\"></a>连接Github与本地</h1><p>首先右键打开git bash，然后输入下面命令：</p>\n<pre><code>git config --global user.name &quot;Your Name of Github&quot;\ngit config --global user.email &quot;your email of Github&quot;</code></pre><p>用户名和邮箱根据你注册github的信息自行修改。<br>然后生成密钥SSH key：</p>\n<pre><code>ssh-keygen -t rsa -C &quot;your email of Github&quot;</code></pre><p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。<br><img src=\"setting.png\" alt=\"settings\"><br><img src=\"SSH.png\" alt=\"SSH and GPG keys\"><br><img src=\"NewSSH.png\" alt=\"新建一个SSH\"><br>在git bash(右键git bash here )中输入<code>cat ~/.ssh/id_rsa.pub</code>或者打开如图所示的文件“id_rsa.pub”<br><img src=\"RA.png\" alt=\"文件位置\"><br>将文件中的内容复制到框中，点击确定保存。</p>\n<h2 id=\"测试是否成功\"><a href=\"#测试是否成功\" class=\"headerlink\" title=\"测试是否成功\"></a>测试是否成功</h2><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。<br><img src=\"chenggong.png\" alt=\"Git配置成功\"></p>\n<h1 id=\"创建你的Blog\"><a href=\"#创建你的Blog\" class=\"headerlink\" title=\"创建你的Blog\"></a>创建你的Blog</h1><h2 id=\"克隆你的yourname-github-io项目到本地\"><a href=\"#克隆你的yourname-github-io项目到本地\" class=\"headerlink\" title=\"克隆你的yourname.github.io项目到本地\"></a>克隆你的yourname.github.io项目到本地</h2><pre><code>git clone git@github/Yourname.github.io</code></pre><h2 id=\"克隆我的git项目到本地\"><a href=\"#克隆我的git项目到本地\" class=\"headerlink\" title=\"克隆我的git项目到本地\"></a>克隆我的git项目到本地</h2><pre><code>git clone git@github/HaoxinGuo</code></pre><p>删除.git文件，其余的粘贴到你的<strong>yourname.github.io</strong>文件中，接下来修改配置文件</p>\n<h2 id=\"配置自己的文件\"><a href=\"#配置自己的文件\" class=\"headerlink\" title=\"配置自己的文件\"></a>配置自己的文件</h2><p>博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p>\n<h3 id=\"修改最后一行的配置\"><a href=\"#修改最后一行的配置\" class=\"headerlink\" title=\"修改最后一行的配置\"></a>修改最后一行的配置</h3><pre><code>deploy:\n  type: git\n  repository: https://github.com/HaoxinGuo/HaoxinGuo.github.io\n  branch: master</code></pre><p>repository修改为你自己的github.io项目地址。</p>\n<h2 id=\"写文章、发布文章\"><a href=\"#写文章、发布文章\" class=\"headerlink\" title=\"写文章、发布文章\"></a>写文章、发布文章</h2><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。<br>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。<br>然后打开<code>..\\blog\\source\\_posts</code>的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。</p>\n<p>编写完markdown(注意编码为UTF-8，要不然打开网页后乱码)文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<pre><code>有任何问题请联系我扣扣：1210188858，vx：guo1210188858，如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。</code></pre><h1 id=\"我的博客源代码地址\"><a href=\"#我的博客源代码地址\" class=\"headerlink\" title=\"我的博客源代码地址\"></a>我的博客源代码地址</h1><p>大家可以直接素质二连，star&amp;fork我的博客源代码：<br><a href=\"https://github.com/HaoxinGuo/HaoxinGuo.github.io/tree/hexo，然后改改配置就可以写文章啦。\" target=\"_blank\" rel=\"noopener\">https://github.com/HaoxinGuo/HaoxinGuo.github.io/tree/hexo，然后改改配置就可以写文章啦。</a></p>\n<p>为了减小源码的体积，将插件目录node_modules进行了压缩，大家下载完后需要解压。</p>\n<ul>\n<li><p>首先运行git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:HaoxinGuo/HaoxinGuo.github.io.git将所有文件下载到本地。</p>\n</li>\n<li><p>解压node_modules.zip，然后删除node_modules.zip和.git文件夹。</p>\n<h1 id=\"快速搭建\"><a href=\"#快速搭建\" class=\"headerlink\" title=\"快速搭建\"></a>快速搭建</h1><p>如果你不想自己从头开始慢慢自定义主题的话，可以直接下载我的修改好的主题，然后稍微修改几个地方就好了：</p>\n</li>\n<li><p>根目录配置文件_config.yml和主题目录配置文件_config.yml中修改个人信息。</p>\n</li>\n<li><p>根目录配置文件中修改deploy一栏的repository。</p>\n</li>\n<li><p>根目录配置文件中修改baidu_url_submit一栏的token。</p>\n</li>\n<li><p>主题配置文件中修改gitalk一栏，修改方法见正文。</p>\n</li>\n</ul>\n<p><strong>当然前提是个性化设置章节之前的环境还是需要配置好！</strong></p>\n<p>平时常用命令：</p>\n<pre><code>hexo g  # 生成博客网页文件\nhexo s  # 本地预览博客\nhexo d  # 上传网页文件到github\n#注：必须使用hexo d上传</code></pre><p>目录结构</p>\n<ul>\n<li>安装Node.js</li>\n<li>添加国内镜像源</li>\n<li>安装Git</li>\n<li>注册Github账号</li>\n<li>安装Hexo</li>\n<li>连接Github与本地</li>\n<li>写文章、发布文章</li>\n<li>绑定域名</li>\n<li>备份博客源文件</li>\n<li>博客源代码下载</li>\n</ul>\n<h1 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h1><p>首先下载稳定版<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a>。<br><img src=\"xiazaishili.png\" alt=\"node.js下载\"><br>安装选项全部默认，一路点击Next。<br>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。<br><img src=\"npmshili.png\" alt=\"node.js安装成功显示示例\"></p>\n<h1 id=\"添加国内镜像源\"><a href=\"#添加国内镜像源\" class=\"headerlink\" title=\"添加国内镜像源\"></a>添加国内镜像源</h1><p>使用阿里的国内镜像进行加速。<br>‘’’<br>npm config set registry <a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a><br>‘’’</p>\n<h1 id=\"Git安装\"><a href=\"#Git安装\" class=\"headerlink\" title=\"Git安装\"></a>Git安装</h1><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git<a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">下载地址</a>。<br><img src=\"gitxiazai.png\" alt=\"安装GIT\"><br><strong>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt</strong>，之后我们就可以直接在命令提示符里打开git了。</p>\n<p>安装完成后在命令提示符中输入git –version验证是否安装成功。</p>\n<h1 id=\"注册Github账号\"><a href=\"#注册Github账号\" class=\"headerlink\" title=\"注册Github账号\"></a>注册Github账号</h1><p>接下来就去注册一个github账号，用来存放我们的网站。<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">注册地址</a><br>注册完成后打开<a href=\"https://github.com/，新建一个项目，如下所示：\" target=\"_blank\" rel=\"noopener\">https://github.com/，新建一个项目，如下所示：</a><br><img src=\"newrepository.png\" alt=\"新建项目\"><br>然后如下图所示，输入自己的项目名字，后面一定要加<strong>.github.io</strong>后缀，<strong>勾选README初始化</strong>。名称一定要和你的github名字完全一样，比如你github名字叫HaoxinGuo，那么仓库名字一定要是HaoxinGuo.github.io。<br><img src=\"chushihua.png\" alt=\"仓库名字命名\"></p>\n<h1 id=\"安装Notepad\"><a href=\"#安装Notepad\" class=\"headerlink\" title=\"安装Notepad++\"></a>安装Notepad++</h1><p>安装<a href=\"https://notepad-plus-plus.org/downloads/\" target=\"_blank\" rel=\"noopener\">Notepad++</a>，方便以后编辑Markdown文件。</p>\n<h1 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h1><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在C:\\user\\12101\\desktop\\blog目录下。<br>以管理员身份运行cmd，进到该目录下，关于cmd的操作命令可以参考该<a href=\"https://blog.csdn.net/LJFPHP/article/details/78818696\" target=\"_blank\" rel=\"noopener\">链接1</a><a href=\"https://blog.csdn.net/xiaosemei/article/details/79270904\" target=\"_blank\" rel=\"noopener\">链接2</a> ，输入</p>\n<pre><code>npm i hexo-cli -g</code></pre><p>安装Hexo。可能会有几个报错，无视它就行。<br>安装完后输入hexo -v验证是否安装成功。<br><img src=\"hexo.png\" alt=\"hexo安装成功\"></p>\n<h1 id=\"初始化网站\"><a href=\"#初始化网站\" class=\"headerlink\" title=\"初始化网站\"></a>初始化网站</h1><p>初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。<br>这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开<a href=\"http://localhost:4000/，就可以看到我们的博客啦，效果如下：\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/，就可以看到我们的博客啦，效果如下：</a><br>按ctrl+c关闭本地服务器。</p>\n<h1 id=\"连接Github与本地\"><a href=\"#连接Github与本地\" class=\"headerlink\" title=\"连接Github与本地\"></a>连接Github与本地</h1><p>首先右键打开git bash，然后输入下面命令：</p>\n<pre><code>git config --global user.name &quot;Your Name of Github&quot;\ngit config --global user.email &quot;your email of Github&quot;</code></pre><p>用户名和邮箱根据你注册github的信息自行修改。<br>然后生成密钥SSH key：</p>\n<pre><code>ssh-keygen -t rsa -C &quot;your email of Github&quot;</code></pre><p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。<br><img src=\"setting.png\" alt=\"settings\"><br><img src=\"SSH.png\" alt=\"SSH and GPG keys\"><br><img src=\"NewSSH.png\" alt=\"新建一个SSH\"><br>在git bash(右键git bash here )中输入<code>cat ~/.ssh/id_rsa.pub</code>或者打开如图所示的文件“id_rsa.pub”<br><img src=\"RA.png\" alt=\"文件位置\"><br>将文件中的内容复制到框中，点击确定保存。</p>\n<h2 id=\"测试是否成功\"><a href=\"#测试是否成功\" class=\"headerlink\" title=\"测试是否成功\"></a>测试是否成功</h2><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。<br><img src=\"chenggong.png\" alt=\"Git配置成功\"></p>\n<h1 id=\"创建你的Blog\"><a href=\"#创建你的Blog\" class=\"headerlink\" title=\"创建你的Blog\"></a>创建你的Blog</h1><h2 id=\"克隆你的yourname-github-io项目到本地\"><a href=\"#克隆你的yourname-github-io项目到本地\" class=\"headerlink\" title=\"克隆你的yourname.github.io项目到本地\"></a>克隆你的yourname.github.io项目到本地</h2><pre><code>git clone git@github/Yourname.github.io</code></pre><h2 id=\"克隆我的git项目到本地\"><a href=\"#克隆我的git项目到本地\" class=\"headerlink\" title=\"克隆我的git项目到本地\"></a>克隆我的git项目到本地</h2><pre><code>git clone git@github/HaoxinGuo</code></pre><p>删除.git文件，其余的粘贴到你的<strong>yourname.github.io</strong>文件中，接下来修改配置文件</p>\n<h2 id=\"配置自己的文件\"><a href=\"#配置自己的文件\" class=\"headerlink\" title=\"配置自己的文件\"></a>配置自己的文件</h2><p>博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p>\n<h3 id=\"修改最后一行的配置\"><a href=\"#修改最后一行的配置\" class=\"headerlink\" title=\"修改最后一行的配置\"></a>修改最后一行的配置</h3><pre><code>deploy:\n  type: git\n  repository: https://github.com/HaoxinGuo/HaoxinGuo.github.io\n  branch: master</code></pre><p>repository修改为你自己的github.io项目地址。</p>\n<h2 id=\"写文章、发布文章\"><a href=\"#写文章、发布文章\" class=\"headerlink\" title=\"写文章、发布文章\"></a>写文章、发布文章</h2><p>首先在博客根目录下右键打开git bash，安装一个扩展<code>npm i hexo-deployer-git</code>。<br>然后输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。<br>然后打开<code>..\\blog\\source\\_posts</code>的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。</p>\n<p>编写完markdown(注意编码为UTF-8，要不然打开网页后乱码)文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>\n"},{"title":"批量处理gz/dot文件生成PDF/PNG文件","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T08:42:20.000Z","password":null,"summary":"批量处理gz/dot文件生成需要的PDF/PNG文件。","_content":"\n# dot2pdf\n#批量处理gz/dot文件生成需要的PDF/PNG文件\n整理了批量转换文件的操作方法。\n## graphviz介绍\ngraphviz是一款快速绘图的软件，可以绘制各种想要的图（**流程图，UML图**）等，只需关注内容，而不需要关注排版，适合需要大量绘制流程图、UML图的工作人员。\n## git介绍\nGit是目前世界上最先进的分布式版本控制系统（没有之一）。可以结合github做大量的工作。\n## graphviz+latex\n近来做Opensees相关Element和Integrator的总结，需要绘制大量的图，故采用graphviz进行作图，由于图片数量大，希望能够批量处理这些文件，供LaTeX调用，节约时间，故利用git以及cmd写了批处理的程序。\n## dot2pdf\ngit版本代码如下：\n```bash\n#this file is transverse dot file to pdf for Batch processing\n#writen by guohaoxin\nfor f in *.dot; \ndo  \n\techo $f; #printf the file name in the gui\n\tt=$(basename include/$f .dot); # define the variable \n\techo $t>>list.txt; #printf the file list to the txt file for check\n    dot -Tpdf $f -o $t.pdf;\t #dot2pdf\n\t#dot -Tpng $f -o $t.png;\t #dot2png\ndone\n```\ncmd版本如下：\n```shell\n::name：\tdot2pdf/dot2png.cmd\n:: Purpose: \tBatch conversion file form .dot/gv to pdf/png\n:: Author:\thttps://github.com/HaoxinGuo\n:: Revision: \tMarch 2019 - initial version\necho start the processing\nfor %%I in (*.dot) do (dot -Tpdf %%I -o %%~nI.pdf)\n::for %%I in (*.dot) do (dot -Tpng %%I -o %%~nI.png\n```\n更多介绍可以转到我的github:[HaoxinGuo](https://github.com/HaoxinGuo/dot2pdf)","source":"_posts/2019-dot2pdf.md","raw":"---\ntitle: 批量处理gz/dot文件生成PDF/PNG文件\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 16:42:20\npassword:\nsummary: 批量处理gz/dot文件生成需要的PDF/PNG文件。\ntags:\n- Linux 批处理\ncategories:\n- Linux\n---\n\n# dot2pdf\n#批量处理gz/dot文件生成需要的PDF/PNG文件\n整理了批量转换文件的操作方法。\n## graphviz介绍\ngraphviz是一款快速绘图的软件，可以绘制各种想要的图（**流程图，UML图**）等，只需关注内容，而不需要关注排版，适合需要大量绘制流程图、UML图的工作人员。\n## git介绍\nGit是目前世界上最先进的分布式版本控制系统（没有之一）。可以结合github做大量的工作。\n## graphviz+latex\n近来做Opensees相关Element和Integrator的总结，需要绘制大量的图，故采用graphviz进行作图，由于图片数量大，希望能够批量处理这些文件，供LaTeX调用，节约时间，故利用git以及cmd写了批处理的程序。\n## dot2pdf\ngit版本代码如下：\n```bash\n#this file is transverse dot file to pdf for Batch processing\n#writen by guohaoxin\nfor f in *.dot; \ndo  \n\techo $f; #printf the file name in the gui\n\tt=$(basename include/$f .dot); # define the variable \n\techo $t>>list.txt; #printf the file list to the txt file for check\n    dot -Tpdf $f -o $t.pdf;\t #dot2pdf\n\t#dot -Tpng $f -o $t.png;\t #dot2png\ndone\n```\ncmd版本如下：\n```shell\n::name：\tdot2pdf/dot2png.cmd\n:: Purpose: \tBatch conversion file form .dot/gv to pdf/png\n:: Author:\thttps://github.com/HaoxinGuo\n:: Revision: \tMarch 2019 - initial version\necho start the processing\nfor %%I in (*.dot) do (dot -Tpdf %%I -o %%~nI.pdf)\n::for %%I in (*.dot) do (dot -Tpng %%I -o %%~nI.png\n```\n更多介绍可以转到我的github:[HaoxinGuo](https://github.com/HaoxinGuo/dot2pdf)","slug":"2019-dot2pdf","published":1,"updated":"2019-09-30T08:43:29.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbc00192wvcjxpdjbqw","content":"<h1 id=\"dot2pdf\"><a href=\"#dot2pdf\" class=\"headerlink\" title=\"dot2pdf\"></a>dot2pdf</h1><p>#批量处理gz/dot文件生成需要的PDF/PNG文件<br>整理了批量转换文件的操作方法。</p>\n<h2 id=\"graphviz介绍\"><a href=\"#graphviz介绍\" class=\"headerlink\" title=\"graphviz介绍\"></a>graphviz介绍</h2><p>graphviz是一款快速绘图的软件，可以绘制各种想要的图（<strong>流程图，UML图</strong>）等，只需关注内容，而不需要关注排版，适合需要大量绘制流程图、UML图的工作人员。</p>\n<h2 id=\"git介绍\"><a href=\"#git介绍\" class=\"headerlink\" title=\"git介绍\"></a>git介绍</h2><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。可以结合github做大量的工作。</p>\n<h2 id=\"graphviz-latex\"><a href=\"#graphviz-latex\" class=\"headerlink\" title=\"graphviz+latex\"></a>graphviz+latex</h2><p>近来做Opensees相关Element和Integrator的总结，需要绘制大量的图，故采用graphviz进行作图，由于图片数量大，希望能够批量处理这些文件，供LaTeX调用，节约时间，故利用git以及cmd写了批处理的程序。</p>\n<h2 id=\"dot2pdf-1\"><a href=\"#dot2pdf-1\" class=\"headerlink\" title=\"dot2pdf\"></a>dot2pdf</h2><p>git版本代码如下：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token comment\" spellcheck=\"true\">#this file is transverse dot file to pdf for Batch processing</span>\n<span class=\"token comment\" spellcheck=\"true\">#writen by guohaoxin</span>\n<span class=\"token keyword\">for</span> f <span class=\"token keyword\">in</span> *.dot<span class=\"token punctuation\">;</span> \n<span class=\"token keyword\">do</span>  \n    <span class=\"token keyword\">echo</span> <span class=\"token variable\">$f</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">#printf the file name in the gui</span>\n    t<span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">basename</span> include/$f .dot<span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\"># define the variable </span>\n    <span class=\"token keyword\">echo</span> <span class=\"token variable\">$t</span><span class=\"token operator\">>></span>list.txt<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">#printf the file list to the txt file for check</span>\n    dot -Tpdf <span class=\"token variable\">$f</span> -o <span class=\"token variable\">$t</span>.pdf<span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">#dot2pdf</span>\n    <span class=\"token comment\" spellcheck=\"true\">#dot -Tpng $f -o $t.png;     #dot2png</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>cmd版本如下：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">::name：    dot2pdf/dot2png.cmd\n:: Purpose:     Batch conversion file form .dot/gv to pdf/png\n:: Author:    https://github.com/HaoxinGuo\n:: Revision:     March 2019 - initial version\necho start the processing\nfor %%I in (*.dot) do (dot -Tpdf %%I -o %%~nI.pdf)\n::for %%I in (*.dot) do (dot -Tpng %%I -o %%~nI.png<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>更多介绍可以转到我的github:<a href=\"https://github.com/HaoxinGuo/dot2pdf\" target=\"_blank\" rel=\"noopener\">HaoxinGuo</a></p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"dot2pdf\"><a href=\"#dot2pdf\" class=\"headerlink\" title=\"dot2pdf\"></a>dot2pdf</h1><p>#批量处理gz/dot文件生成需要的PDF/PNG文件<br>整理了批量转换文件的操作方法。</p>\n<h2 id=\"graphviz介绍\"><a href=\"#graphviz介绍\" class=\"headerlink\" title=\"graphviz介绍\"></a>graphviz介绍</h2><p>graphviz是一款快速绘图的软件，可以绘制各种想要的图（<strong>流程图，UML图</strong>）等，只需关注内容，而不需要关注排版，适合需要大量绘制流程图、UML图的工作人员。</p>\n<h2 id=\"git介绍\"><a href=\"#git介绍\" class=\"headerlink\" title=\"git介绍\"></a>git介绍</h2><p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。可以结合github做大量的工作。</p>\n<h2 id=\"graphviz-latex\"><a href=\"#graphviz-latex\" class=\"headerlink\" title=\"graphviz+latex\"></a>graphviz+latex</h2><p>近来做Opensees相关Element和Integrator的总结，需要绘制大量的图，故采用graphviz进行作图，由于图片数量大，希望能够批量处理这些文件，供LaTeX调用，节约时间，故利用git以及cmd写了批处理的程序。</p>\n<h2 id=\"dot2pdf-1\"><a href=\"#dot2pdf-1\" class=\"headerlink\" title=\"dot2pdf\"></a>dot2pdf</h2><p>git版本代码如下：</p>\n<pre><code class=\"bash\">#this file is transverse dot file to pdf for Batch processing\n#writen by guohaoxin\nfor f in *.dot; \ndo  \n    echo $f; #printf the file name in the gui\n    t=$(basename include/$f .dot); # define the variable \n    echo $t&gt;&gt;list.txt; #printf the file list to the txt file for check\n    dot -Tpdf $f -o $t.pdf;     #dot2pdf\n    #dot -Tpng $f -o $t.png;     #dot2png\ndone</code></pre>\n<p>cmd版本如下：</p>\n<pre><code class=\"shell\">::name：    dot2pdf/dot2png.cmd\n:: Purpose:     Batch conversion file form .dot/gv to pdf/png\n:: Author:    https://github.com/HaoxinGuo\n:: Revision:     March 2019 - initial version\necho start the processing\nfor %%I in (*.dot) do (dot -Tpdf %%I -o %%~nI.pdf)\n::for %%I in (*.dot) do (dot -Tpng %%I -o %%~nI.png</code></pre>\n<p>更多介绍可以转到我的github:<a href=\"https://github.com/HaoxinGuo/dot2pdf\" target=\"_blank\" rel=\"noopener\">HaoxinGuo</a></p>\n"},{"title":"上瘾：让用户养成使用习惯的四大产品逻辑","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T01:33:26.000Z","password":null,"summary":"如何让用户习惯于使用你的产品呢？这本书给出了一个极其简明的上瘾模型（the Hook Model）：触发——行动——多变的酬赏——投入。","_content":"\n# 《上瘾：让用户养成使用习惯的四大产品逻辑》\n尼尔·埃亚尔 瑞安·胡佛\n\n# 序言 与产品谈一场恋爱\n\n那么如何让用户习惯于使用你的产品呢？\n这本书给出了一个极其简明的上瘾模型（the Hook Model）：触发——行动——多变的酬赏——投入。\n万事开头难。第一步就是引发用户去使用你的产品，这叫作“触发”。\n触发之后，第二步就是行动。行动要兼具动机和能力，有了动机，还需要用户的能力足够完成行为。\n行动之后，要给用户酬赏，还得是多变的酬赏。所谓多变的酬赏，就是指酬赏要有不可预期性。\n最后，是让用户在产品上进行越来越多的“投入”。用户与产品亲密接触得越多，就越离不开它。\n通过用户的“投入”，就可能产生下一次“触发”，从而开始一个正向循环。\n于是你就上瘾了（hooked）。\n\n#  前言 为什么有的产品会让人上瘾？\n\n习惯是指我们下意识做出的举动。\n\n 1. 集网络连接、海量数据、超快网速三者于一身的技术正在使这个世界上瘾成性。\n 2. 生产习惯养成类产品可以让商家稳占竞争优势。\n 3. 上瘾模型将用户面临的问题与企业提供的应对策略衔接在一起，二者频繁互动，促成用户养成习惯。\n 4. 上瘾模型包括四个阶段：触发，行动，多变的酬赏，投入。\n\n# 第1章：习惯的力量\n简单的习惯是在很少或没有意识思考的情况下完成的行为，它们指导了近一半的日常行为。\n习惯是大脑学习复杂行为的方式之一。\n神经科学家认为，习惯使我们能够通过在基底神经节中存储自动反应来将注意力集中在其他事物上，基底神经节是与非自愿行为相关的大脑区域。\n当大脑采取捷径并停止积极思考下一步该做什么时，就会形成习惯。大脑很快学会编纂行为，为其遇到的任何情况提供解决方案。\n## 为什么习惯有利于商业\n\n### 1.提高客户终身价值\n客户终身价值（CLV）：客户切换到竞争对手之前从客户处获得的金额，停止使用该产品或模具。\n用户习惯会增加客户使用产品的时间和频率，从而导致更高的CLTV。\n### 2.提供定价灵活性\n当客户围绕产品形成惯例时，他们会依赖它并对价格变得不那么敏感。\n习惯使公司有更大的灵活性来提高价格。\n### 3.增压增长\n持续在产品中找到价值的用户更有可能告诉他们的朋友。\n经常使用会创造更多机会来鼓励人们邀请他们的朋友，广播内容并通过口口相传来分享。\nHooked用户成为品牌推广者，以极少或免费的方式吸引新用户。\n具有较高用户参与度的产品也有可能比竞争对手更快地增长。\n### 4.提高竞争优势\n\n用户习惯是竞争优势。改变客户惯例的产品不易受到其他公司的攻击。\n哈佛商学院（Harvard Business School）市场营销学教授约翰古尔维尔（John Gourville）的一篇经典论文称，对于新的市场进入者而言，他们不仅会更好，而且必须要好九倍。\n高标准的出现是因为旧习惯变得艰难，新产品和服务需要提供显着改进，以动摇用户摆脱旧惯例。\n即使使用新产品的好处明显且充实，需要高度改变行为的产品也注定要失败。\n### 5.在习惯区\n\n公司可以通过绘制两个因素来开始确定其产品的习惯形成潜力：频率（行为发生的频率）和感知效用（用户对其他解决方案的行为有多么有用和有益。）\n具有足够频率和感知效用的行为进入“习惯区域”，有助于使其成为默认行为。\n如果这些因素中的任何一个不足并且行为低于阈值，那么期望的行为将不太可能成为习惯。\n有些行为永远不会成为习惯，因为它们不会频繁发生。\n另一方面，即使是提供最小感知益处的行为也可能成为习惯，因为它经常发生。\n![频率和可感知用途](https://img-blog.csdnimg.cn/20190508135151639.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n## 维生素与止痛药\n\n所有成功创新的共同点=他们解决问题！！！\n投资者希望投资止痛药 - 因为他们解决了明显的需求，减轻了特定的痛苦，并且经常有可量化的市场。\n相比之下，维生素不一定能解决明显的痛点。相反，它们吸引用户的情感而不是功能需求。\n社交媒体怎么样？许多人会说他们正在销售维生素，因为他们的用户没有做任何特别重要的事情，而不是寻求快速推动社会验证。\n但是，请考虑这个想法：一个习惯就是在不采取行动时会引起一些痛苦。\n习惯形成技术既是维生素又是止痛药。\n他们最初提供的是富含维生素的维生素，但一旦习惯成熟，它们就会提供持续的止痛药。\n\n# 第2章：触发器\n新习惯需要建立基础。触发器为持续的行为改变提供了基础。\n触发器是行为的执行器。\n它有两种类型：外部和内部。\n## 外部触发器\n习惯形成首先通过号召，用户提示，暗示用户来开始改变行为。\n外部触发器嵌入了信息，告诉用户下一步该做什么。\n外部触发器传达用户应采取的下一个操作。\n通常，明确表达所需的行动。\n在线外部触发器可以采用突出按钮等形式。\n外部触发器的类型\n\n### 1.付费触发器\n例如广告，搜索引擎营销和其他付费频道。\n保持用户回访的有效而昂贵的方法。\n习惯形成公司往往不会长时间依赖付费触发器，如果​​有的话。\n因为对于大多数商业模式而言，为重新接管付费是不可持续的，所以公司通常使用付费触发器来获取新用户，然后利用其他触发器将其带回来。\n### 2.回馈型触发器\n它们是免费的，因为它们不能直接购买，但往往需要以公共和媒体关系所花费的时间进行投资。\n例如有利的媒体提及，特色应用程序商店展示位置，病毒视频等。\n### 3.人际关系型触发器\n一个人告诉别人有关产品或服务的信息可能是一个非常有效的外部触发动作。\n正确使用关系触发器需要建立一个积极的用户群，热衷于与他人分享产品的好处。\n### 4.自主型触发器\n它们始终出现在日常生活中，最终由用户选择允许这些触发器出现。\n例如app图标，电子邮件简报，app通知等。\n只要用户同意接收触发器，设置触发器的公司就拥有用户注意力的份额。\n虽然付费，回馈型和人际关系触发器以新用户获取为目标，但自主型触发器以促使用户重复参与为重点，直到形成习惯。\n如果没有自主型的触发器，不能在用户默许的前提下获得他们的关注，产品就很难经常提示用户改变他们的行为。\n## 内部触发器\n\n当产品与你的思想，情感或预先存在的活动紧密结合时，这就是内部触发器在起作用。\n我们无法看到，触摸或听到内部触发器。\n内部触发器会自动显示在您的脑海中 将内部触发器与嵌入产品是消费者技术的关键。\n情绪，特别是消极情绪是强大的内部触发因素，并极大地影响我们的日常生活。\n厌倦，孤独，沮丧，困惑和犹豫不决的感觉经常引起轻微的痛苦或刺激，并促使几乎瞬间的，通常是无意识的行动来平息消极的感觉。\n积极的情绪也可以作为内部触发因素，甚至可以通过满足困扰我们的事物来触发自己。被娱乐的欲望可以被认为是满足厌倦的需要。分享好消息的需要也可以被认为是寻找和维持社交关系的尝试。\n发现减轻疼痛的产品的用户将随着时间的推移与产品形成强烈的积极关联。\n在继续使用之后，产品和需要它的用户之间开始形成债券。渐渐地，当用户在遇到某些内部触发因素时转向您的产品时，这些会成为一种习惯。\n一旦我们被迷住了，使用这些产品并不总是需要明确的号召性用语。相反，他们依靠我们对感情的自动反应来促成期望的行为。\n一旦技术在用户心中创建了一个关联产品是选择的解决方案，它们就会自行返回，不再需要外部触发器的提示。\n内部触发器和产品之间的关联不是一夜之间形成的。内部触发器可能需要数周或数月的频繁使用才能形成。\n## 构建触发器\n\n成功创造习惯的产品通过声称特定的感觉来缓解用户的痛苦。\n要做到这一点，产品设计师必须了解用户的内部触发因素 - 即他们寻求解决的痛苦。\n它需要设计师深入挖掘以了解用户的感受。\n习惯形成产品的最终目标是通过创建关联来解决用户的痛苦，以便用户将公司的产品或服务识别为救济的来源。\n公司必须首先在情感方面确定特定的挫折或痛点，而不是产品特征。\n最好的起点是学习成功的习惯形成产品背后的驱动因素 - 不是复制它们，而是要了解它们如何解决用户的问题。\n用户的清晰描述 - 他们的欲望，情感，他们使用产品的背景，对于构建正确的解决方案至关重要。\n一种方法是尽可能多地询问“为什么？”这个问题。通常这发生在第五个原因上。\n在弄清楚为什么人们使用习惯形成产品时，内部触发器是根本原因，“为什么？”是一个可以帮助钻探核心的问题。\n\n\n# 牢记并分享\n\n 1. 触发是上瘾模型的第一个阶段，它可促使用户来取行动。\n 2. 触发分为两类—一外部触发和内部触发。\n 3. 外部触发通过将信息渗透在用户生活的各个方面来引导他们采取下一步行动。\n 4. 内部触发通过用户记忆存储中的各种关联来提醒他们采取下一步行动。\n 5. 负面情绪往往可以充当内部触发。\n 6. 要开发习惯养成类产品，设计者需要揣摩用户的心理，了解那些有可能成为内部触发的各种情绪，并且要知道如何利用外部触发来促使用户付诸行动。\n\n# 第3章：行动\n是否存在行为公式？产品设计师可以影响用户采取行动吗？\nFogg行为模型\n$B = MAT$\n其中B =行为，M =动机，A =能力，T =触发\n如果此公式的任何组件缺失或不足，用户将不会越过“行动线”，并且不会实施某些行为。\n示例：您的手机响了，但您没有回答。\n如果你的手机被埋在一个袋子里很难到达=能力有限。\n如果您认为来电者是电话推销员=缺乏动力\n电话铃声沉默=没有触发器\n## 动机\n采取行动或“行动能量”的愿望程度/热情。\n## 核心动机\n1.寻求快乐，避免痛苦\n2.寻求希望，避免恐惧\n3.寻求社会认可并避免拒绝\n## 能力\n产品的创新过程分解成三个基本步骤：第一步，了解人们使用某个产品或服务的原因。接下来，列举出用户使用该产品的必经环节。最后一步，在明确整个过程的所有环节后开始做减法，直到做到极致。\n用户能够轻松采取行动或具有执行特定行为的能力。\n任何显著减少完成任务的步骤的技术或产品将有较高的使用率。\n更容易=更好\n简单的元素\n\n影响任务难度的因素：\n1.时间：完成一项行动需要多长时间\n2.金钱：采取行动的财政成本\n3.体力劳动：采取行动所涉及的劳动量\n4.脑力：采取行动所需的精神努力和注意力水平\n5.社会偏差：他人如何接受这种行为。\n6.非常规：动作与现有例程匹配或中断的程度\n\n增加动力是昂贵且耗时的。\n使产品变得如此简单以至于用户已经知道如何使用它会容易得多。\n## 动机和能力？\n动机 - 我们用来制定决策和形成意见的心理捷径。\n1.稀缺效应\n实验1：一个罐子里装有10个饼干而另一个罐装只有2个。哪些饼干会让人更有价值？\n虽然饼干和罐子是相同的，但参与者更重视近空罐子里的饼干和罐子。\n实验2：参与者被给予2个饼干或10个罐子。组中有10个饼干的人突然有8个被带走。相反，那些有2的人增加了8个新的。这些变化将如何影响参与者对cookie的评价方式？\n该组只剩下2个饼干，评价它们更有价值，而那些经历突然丰富的饼干则更不重视饼干。\n2.环境效应\n世界级小提琴家约书亚贝尔决定在华盛顿特区地铁站举行免费的即兴音乐会。贝尔定期以每张票数百美元的价格出售像卡内基音乐厅这样的场地，但是当他置于DC地铁的环境中时，他的音乐被置若罔闻。\n即使与客观数量的关系很少，感知也可以根据产品的框架形成个人现实。\n3.锚定效应\n人们在做出决定时经常会锚定一条信息。\n4.赠券效应\n如果零售商向客户提供已打孔的打卡，会发生什么？人们会更有可能采取行动吗？\n答案是肯定的。\n赠券效应是一种增加动力的现象，因为人们认为它们正在接近目标。\n## Key Point\n行动是上瘾模型的第二个阶段\n行动是人们在期待酬赏时最直接的反应。\n根据福格博士建立的行为模型：\n1.要促成某种行为，触发、动机和能力这三者缺一不可。\n2.要增加预想行为的发生率，触发要显而易见，行为要易于实施，动机要合乎常理。\n3.人类行为不外乎受三种核动机的影响：追求快乐，逃避痛苦；追求希望，逃避恐惧；追求认同，逃避排斥。\n4.时间、金钱、体力、脑力社会偏差非常规牲笑六个因素会对用户的能力产生影响。能力还会因大因地而异。\n启发法是指我们借助认知经验对事物做出快速判断。产品设计者可以从上千种启发法中选择一些来获取灵感，提高产品的吸引力。\n","source":"_posts/2019-hooked.md","raw":"---\ntitle: 上瘾：让用户养成使用习惯的四大产品逻辑\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 09:33:26\npassword:\nsummary: 如何让用户习惯于使用你的产品呢？这本书给出了一个极其简明的上瘾模型（the Hook Model）：触发——行动——多变的酬赏——投入。\ntags:\n- 读书笔记\ncategories:\n- 读书笔记\n---\n\n# 《上瘾：让用户养成使用习惯的四大产品逻辑》\n尼尔·埃亚尔 瑞安·胡佛\n\n# 序言 与产品谈一场恋爱\n\n那么如何让用户习惯于使用你的产品呢？\n这本书给出了一个极其简明的上瘾模型（the Hook Model）：触发——行动——多变的酬赏——投入。\n万事开头难。第一步就是引发用户去使用你的产品，这叫作“触发”。\n触发之后，第二步就是行动。行动要兼具动机和能力，有了动机，还需要用户的能力足够完成行为。\n行动之后，要给用户酬赏，还得是多变的酬赏。所谓多变的酬赏，就是指酬赏要有不可预期性。\n最后，是让用户在产品上进行越来越多的“投入”。用户与产品亲密接触得越多，就越离不开它。\n通过用户的“投入”，就可能产生下一次“触发”，从而开始一个正向循环。\n于是你就上瘾了（hooked）。\n\n#  前言 为什么有的产品会让人上瘾？\n\n习惯是指我们下意识做出的举动。\n\n 1. 集网络连接、海量数据、超快网速三者于一身的技术正在使这个世界上瘾成性。\n 2. 生产习惯养成类产品可以让商家稳占竞争优势。\n 3. 上瘾模型将用户面临的问题与企业提供的应对策略衔接在一起，二者频繁互动，促成用户养成习惯。\n 4. 上瘾模型包括四个阶段：触发，行动，多变的酬赏，投入。\n\n# 第1章：习惯的力量\n简单的习惯是在很少或没有意识思考的情况下完成的行为，它们指导了近一半的日常行为。\n习惯是大脑学习复杂行为的方式之一。\n神经科学家认为，习惯使我们能够通过在基底神经节中存储自动反应来将注意力集中在其他事物上，基底神经节是与非自愿行为相关的大脑区域。\n当大脑采取捷径并停止积极思考下一步该做什么时，就会形成习惯。大脑很快学会编纂行为，为其遇到的任何情况提供解决方案。\n## 为什么习惯有利于商业\n\n### 1.提高客户终身价值\n客户终身价值（CLV）：客户切换到竞争对手之前从客户处获得的金额，停止使用该产品或模具。\n用户习惯会增加客户使用产品的时间和频率，从而导致更高的CLTV。\n### 2.提供定价灵活性\n当客户围绕产品形成惯例时，他们会依赖它并对价格变得不那么敏感。\n习惯使公司有更大的灵活性来提高价格。\n### 3.增压增长\n持续在产品中找到价值的用户更有可能告诉他们的朋友。\n经常使用会创造更多机会来鼓励人们邀请他们的朋友，广播内容并通过口口相传来分享。\nHooked用户成为品牌推广者，以极少或免费的方式吸引新用户。\n具有较高用户参与度的产品也有可能比竞争对手更快地增长。\n### 4.提高竞争优势\n\n用户习惯是竞争优势。改变客户惯例的产品不易受到其他公司的攻击。\n哈佛商学院（Harvard Business School）市场营销学教授约翰古尔维尔（John Gourville）的一篇经典论文称，对于新的市场进入者而言，他们不仅会更好，而且必须要好九倍。\n高标准的出现是因为旧习惯变得艰难，新产品和服务需要提供显着改进，以动摇用户摆脱旧惯例。\n即使使用新产品的好处明显且充实，需要高度改变行为的产品也注定要失败。\n### 5.在习惯区\n\n公司可以通过绘制两个因素来开始确定其产品的习惯形成潜力：频率（行为发生的频率）和感知效用（用户对其他解决方案的行为有多么有用和有益。）\n具有足够频率和感知效用的行为进入“习惯区域”，有助于使其成为默认行为。\n如果这些因素中的任何一个不足并且行为低于阈值，那么期望的行为将不太可能成为习惯。\n有些行为永远不会成为习惯，因为它们不会频繁发生。\n另一方面，即使是提供最小感知益处的行为也可能成为习惯，因为它经常发生。\n![频率和可感知用途](https://img-blog.csdnimg.cn/20190508135151639.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n## 维生素与止痛药\n\n所有成功创新的共同点=他们解决问题！！！\n投资者希望投资止痛药 - 因为他们解决了明显的需求，减轻了特定的痛苦，并且经常有可量化的市场。\n相比之下，维生素不一定能解决明显的痛点。相反，它们吸引用户的情感而不是功能需求。\n社交媒体怎么样？许多人会说他们正在销售维生素，因为他们的用户没有做任何特别重要的事情，而不是寻求快速推动社会验证。\n但是，请考虑这个想法：一个习惯就是在不采取行动时会引起一些痛苦。\n习惯形成技术既是维生素又是止痛药。\n他们最初提供的是富含维生素的维生素，但一旦习惯成熟，它们就会提供持续的止痛药。\n\n# 第2章：触发器\n新习惯需要建立基础。触发器为持续的行为改变提供了基础。\n触发器是行为的执行器。\n它有两种类型：外部和内部。\n## 外部触发器\n习惯形成首先通过号召，用户提示，暗示用户来开始改变行为。\n外部触发器嵌入了信息，告诉用户下一步该做什么。\n外部触发器传达用户应采取的下一个操作。\n通常，明确表达所需的行动。\n在线外部触发器可以采用突出按钮等形式。\n外部触发器的类型\n\n### 1.付费触发器\n例如广告，搜索引擎营销和其他付费频道。\n保持用户回访的有效而昂贵的方法。\n习惯形成公司往往不会长时间依赖付费触发器，如果​​有的话。\n因为对于大多数商业模式而言，为重新接管付费是不可持续的，所以公司通常使用付费触发器来获取新用户，然后利用其他触发器将其带回来。\n### 2.回馈型触发器\n它们是免费的，因为它们不能直接购买，但往往需要以公共和媒体关系所花费的时间进行投资。\n例如有利的媒体提及，特色应用程序商店展示位置，病毒视频等。\n### 3.人际关系型触发器\n一个人告诉别人有关产品或服务的信息可能是一个非常有效的外部触发动作。\n正确使用关系触发器需要建立一个积极的用户群，热衷于与他人分享产品的好处。\n### 4.自主型触发器\n它们始终出现在日常生活中，最终由用户选择允许这些触发器出现。\n例如app图标，电子邮件简报，app通知等。\n只要用户同意接收触发器，设置触发器的公司就拥有用户注意力的份额。\n虽然付费，回馈型和人际关系触发器以新用户获取为目标，但自主型触发器以促使用户重复参与为重点，直到形成习惯。\n如果没有自主型的触发器，不能在用户默许的前提下获得他们的关注，产品就很难经常提示用户改变他们的行为。\n## 内部触发器\n\n当产品与你的思想，情感或预先存在的活动紧密结合时，这就是内部触发器在起作用。\n我们无法看到，触摸或听到内部触发器。\n内部触发器会自动显示在您的脑海中 将内部触发器与嵌入产品是消费者技术的关键。\n情绪，特别是消极情绪是强大的内部触发因素，并极大地影响我们的日常生活。\n厌倦，孤独，沮丧，困惑和犹豫不决的感觉经常引起轻微的痛苦或刺激，并促使几乎瞬间的，通常是无意识的行动来平息消极的感觉。\n积极的情绪也可以作为内部触发因素，甚至可以通过满足困扰我们的事物来触发自己。被娱乐的欲望可以被认为是满足厌倦的需要。分享好消息的需要也可以被认为是寻找和维持社交关系的尝试。\n发现减轻疼痛的产品的用户将随着时间的推移与产品形成强烈的积极关联。\n在继续使用之后，产品和需要它的用户之间开始形成债券。渐渐地，当用户在遇到某些内部触发因素时转向您的产品时，这些会成为一种习惯。\n一旦我们被迷住了，使用这些产品并不总是需要明确的号召性用语。相反，他们依靠我们对感情的自动反应来促成期望的行为。\n一旦技术在用户心中创建了一个关联产品是选择的解决方案，它们就会自行返回，不再需要外部触发器的提示。\n内部触发器和产品之间的关联不是一夜之间形成的。内部触发器可能需要数周或数月的频繁使用才能形成。\n## 构建触发器\n\n成功创造习惯的产品通过声称特定的感觉来缓解用户的痛苦。\n要做到这一点，产品设计师必须了解用户的内部触发因素 - 即他们寻求解决的痛苦。\n它需要设计师深入挖掘以了解用户的感受。\n习惯形成产品的最终目标是通过创建关联来解决用户的痛苦，以便用户将公司的产品或服务识别为救济的来源。\n公司必须首先在情感方面确定特定的挫折或痛点，而不是产品特征。\n最好的起点是学习成功的习惯形成产品背后的驱动因素 - 不是复制它们，而是要了解它们如何解决用户的问题。\n用户的清晰描述 - 他们的欲望，情感，他们使用产品的背景，对于构建正确的解决方案至关重要。\n一种方法是尽可能多地询问“为什么？”这个问题。通常这发生在第五个原因上。\n在弄清楚为什么人们使用习惯形成产品时，内部触发器是根本原因，“为什么？”是一个可以帮助钻探核心的问题。\n\n\n# 牢记并分享\n\n 1. 触发是上瘾模型的第一个阶段，它可促使用户来取行动。\n 2. 触发分为两类—一外部触发和内部触发。\n 3. 外部触发通过将信息渗透在用户生活的各个方面来引导他们采取下一步行动。\n 4. 内部触发通过用户记忆存储中的各种关联来提醒他们采取下一步行动。\n 5. 负面情绪往往可以充当内部触发。\n 6. 要开发习惯养成类产品，设计者需要揣摩用户的心理，了解那些有可能成为内部触发的各种情绪，并且要知道如何利用外部触发来促使用户付诸行动。\n\n# 第3章：行动\n是否存在行为公式？产品设计师可以影响用户采取行动吗？\nFogg行为模型\n$B = MAT$\n其中B =行为，M =动机，A =能力，T =触发\n如果此公式的任何组件缺失或不足，用户将不会越过“行动线”，并且不会实施某些行为。\n示例：您的手机响了，但您没有回答。\n如果你的手机被埋在一个袋子里很难到达=能力有限。\n如果您认为来电者是电话推销员=缺乏动力\n电话铃声沉默=没有触发器\n## 动机\n采取行动或“行动能量”的愿望程度/热情。\n## 核心动机\n1.寻求快乐，避免痛苦\n2.寻求希望，避免恐惧\n3.寻求社会认可并避免拒绝\n## 能力\n产品的创新过程分解成三个基本步骤：第一步，了解人们使用某个产品或服务的原因。接下来，列举出用户使用该产品的必经环节。最后一步，在明确整个过程的所有环节后开始做减法，直到做到极致。\n用户能够轻松采取行动或具有执行特定行为的能力。\n任何显著减少完成任务的步骤的技术或产品将有较高的使用率。\n更容易=更好\n简单的元素\n\n影响任务难度的因素：\n1.时间：完成一项行动需要多长时间\n2.金钱：采取行动的财政成本\n3.体力劳动：采取行动所涉及的劳动量\n4.脑力：采取行动所需的精神努力和注意力水平\n5.社会偏差：他人如何接受这种行为。\n6.非常规：动作与现有例程匹配或中断的程度\n\n增加动力是昂贵且耗时的。\n使产品变得如此简单以至于用户已经知道如何使用它会容易得多。\n## 动机和能力？\n动机 - 我们用来制定决策和形成意见的心理捷径。\n1.稀缺效应\n实验1：一个罐子里装有10个饼干而另一个罐装只有2个。哪些饼干会让人更有价值？\n虽然饼干和罐子是相同的，但参与者更重视近空罐子里的饼干和罐子。\n实验2：参与者被给予2个饼干或10个罐子。组中有10个饼干的人突然有8个被带走。相反，那些有2的人增加了8个新的。这些变化将如何影响参与者对cookie的评价方式？\n该组只剩下2个饼干，评价它们更有价值，而那些经历突然丰富的饼干则更不重视饼干。\n2.环境效应\n世界级小提琴家约书亚贝尔决定在华盛顿特区地铁站举行免费的即兴音乐会。贝尔定期以每张票数百美元的价格出售像卡内基音乐厅这样的场地，但是当他置于DC地铁的环境中时，他的音乐被置若罔闻。\n即使与客观数量的关系很少，感知也可以根据产品的框架形成个人现实。\n3.锚定效应\n人们在做出决定时经常会锚定一条信息。\n4.赠券效应\n如果零售商向客户提供已打孔的打卡，会发生什么？人们会更有可能采取行动吗？\n答案是肯定的。\n赠券效应是一种增加动力的现象，因为人们认为它们正在接近目标。\n## Key Point\n行动是上瘾模型的第二个阶段\n行动是人们在期待酬赏时最直接的反应。\n根据福格博士建立的行为模型：\n1.要促成某种行为，触发、动机和能力这三者缺一不可。\n2.要增加预想行为的发生率，触发要显而易见，行为要易于实施，动机要合乎常理。\n3.人类行为不外乎受三种核动机的影响：追求快乐，逃避痛苦；追求希望，逃避恐惧；追求认同，逃避排斥。\n4.时间、金钱、体力、脑力社会偏差非常规牲笑六个因素会对用户的能力产生影响。能力还会因大因地而异。\n启发法是指我们借助认知经验对事物做出快速判断。产品设计者可以从上千种启发法中选择一些来获取灵感，提高产品的吸引力。\n","slug":"2019-hooked","published":1,"updated":"2019-09-30T01:39:46.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbe001d2wvcx8u5c814","content":"<h1 id=\"《上瘾：让用户养成使用习惯的四大产品逻辑》\"><a href=\"#《上瘾：让用户养成使用习惯的四大产品逻辑》\" class=\"headerlink\" title=\"《上瘾：让用户养成使用习惯的四大产品逻辑》\"></a>《上瘾：让用户养成使用习惯的四大产品逻辑》</h1><p>尼尔·埃亚尔 瑞安·胡佛</p>\n<h1 id=\"序言-与产品谈一场恋爱\"><a href=\"#序言-与产品谈一场恋爱\" class=\"headerlink\" title=\"序言 与产品谈一场恋爱\"></a>序言 与产品谈一场恋爱</h1><p>那么如何让用户习惯于使用你的产品呢？<br>这本书给出了一个极其简明的上瘾模型（the Hook Model）：触发——行动——多变的酬赏——投入。<br>万事开头难。第一步就是引发用户去使用你的产品，这叫作“触发”。<br>触发之后，第二步就是行动。行动要兼具动机和能力，有了动机，还需要用户的能力足够完成行为。<br>行动之后，要给用户酬赏，还得是多变的酬赏。所谓多变的酬赏，就是指酬赏要有不可预期性。<br>最后，是让用户在产品上进行越来越多的“投入”。用户与产品亲密接触得越多，就越离不开它。<br>通过用户的“投入”，就可能产生下一次“触发”，从而开始一个正向循环。<br>于是你就上瘾了（hooked）。</p>\n<h1 id=\"前言-为什么有的产品会让人上瘾？\"><a href=\"#前言-为什么有的产品会让人上瘾？\" class=\"headerlink\" title=\"前言 为什么有的产品会让人上瘾？\"></a>前言 为什么有的产品会让人上瘾？</h1><p>习惯是指我们下意识做出的举动。</p>\n<ol>\n<li>集网络连接、海量数据、超快网速三者于一身的技术正在使这个世界上瘾成性。</li>\n<li>生产习惯养成类产品可以让商家稳占竞争优势。</li>\n<li>上瘾模型将用户面临的问题与企业提供的应对策略衔接在一起，二者频繁互动，促成用户养成习惯。</li>\n<li>上瘾模型包括四个阶段：触发，行动，多变的酬赏，投入。</li>\n</ol>\n<h1 id=\"第1章：习惯的力量\"><a href=\"#第1章：习惯的力量\" class=\"headerlink\" title=\"第1章：习惯的力量\"></a>第1章：习惯的力量</h1><p>简单的习惯是在很少或没有意识思考的情况下完成的行为，它们指导了近一半的日常行为。<br>习惯是大脑学习复杂行为的方式之一。<br>神经科学家认为，习惯使我们能够通过在基底神经节中存储自动反应来将注意力集中在其他事物上，基底神经节是与非自愿行为相关的大脑区域。<br>当大脑采取捷径并停止积极思考下一步该做什么时，就会形成习惯。大脑很快学会编纂行为，为其遇到的任何情况提供解决方案。</p>\n<h2 id=\"为什么习惯有利于商业\"><a href=\"#为什么习惯有利于商业\" class=\"headerlink\" title=\"为什么习惯有利于商业\"></a>为什么习惯有利于商业</h2><h3 id=\"1-提高客户终身价值\"><a href=\"#1-提高客户终身价值\" class=\"headerlink\" title=\"1.提高客户终身价值\"></a>1.提高客户终身价值</h3><p>客户终身价值（CLV）：客户切换到竞争对手之前从客户处获得的金额，停止使用该产品或模具。<br>用户习惯会增加客户使用产品的时间和频率，从而导致更高的CLTV。</p>\n<h3 id=\"2-提供定价灵活性\"><a href=\"#2-提供定价灵活性\" class=\"headerlink\" title=\"2.提供定价灵活性\"></a>2.提供定价灵活性</h3><p>当客户围绕产品形成惯例时，他们会依赖它并对价格变得不那么敏感。<br>习惯使公司有更大的灵活性来提高价格。</p>\n<h3 id=\"3-增压增长\"><a href=\"#3-增压增长\" class=\"headerlink\" title=\"3.增压增长\"></a>3.增压增长</h3><p>持续在产品中找到价值的用户更有可能告诉他们的朋友。<br>经常使用会创造更多机会来鼓励人们邀请他们的朋友，广播内容并通过口口相传来分享。<br>Hooked用户成为品牌推广者，以极少或免费的方式吸引新用户。<br>具有较高用户参与度的产品也有可能比竞争对手更快地增长。</p>\n<h3 id=\"4-提高竞争优势\"><a href=\"#4-提高竞争优势\" class=\"headerlink\" title=\"4.提高竞争优势\"></a>4.提高竞争优势</h3><p>用户习惯是竞争优势。改变客户惯例的产品不易受到其他公司的攻击。<br>哈佛商学院（Harvard Business School）市场营销学教授约翰古尔维尔（John Gourville）的一篇经典论文称，对于新的市场进入者而言，他们不仅会更好，而且必须要好九倍。<br>高标准的出现是因为旧习惯变得艰难，新产品和服务需要提供显着改进，以动摇用户摆脱旧惯例。<br>即使使用新产品的好处明显且充实，需要高度改变行为的产品也注定要失败。</p>\n<h3 id=\"5-在习惯区\"><a href=\"#5-在习惯区\" class=\"headerlink\" title=\"5.在习惯区\"></a>5.在习惯区</h3><p>公司可以通过绘制两个因素来开始确定其产品的习惯形成潜力：频率（行为发生的频率）和感知效用（用户对其他解决方案的行为有多么有用和有益。）<br>具有足够频率和感知效用的行为进入“习惯区域”，有助于使其成为默认行为。<br>如果这些因素中的任何一个不足并且行为低于阈值，那么期望的行为将不太可能成为习惯。<br>有些行为永远不会成为习惯，因为它们不会频繁发生。<br>另一方面，即使是提供最小感知益处的行为也可能成为习惯，因为它经常发生。<br><img src=\"https://img-blog.csdnimg.cn/20190508135151639.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"频率和可感知用途\"></p>\n<h2 id=\"维生素与止痛药\"><a href=\"#维生素与止痛药\" class=\"headerlink\" title=\"维生素与止痛药\"></a>维生素与止痛药</h2><p>所有成功创新的共同点=他们解决问题！！！<br>投资者希望投资止痛药 - 因为他们解决了明显的需求，减轻了特定的痛苦，并且经常有可量化的市场。<br>相比之下，维生素不一定能解决明显的痛点。相反，它们吸引用户的情感而不是功能需求。<br>社交媒体怎么样？许多人会说他们正在销售维生素，因为他们的用户没有做任何特别重要的事情，而不是寻求快速推动社会验证。<br>但是，请考虑这个想法：一个习惯就是在不采取行动时会引起一些痛苦。<br>习惯形成技术既是维生素又是止痛药。<br>他们最初提供的是富含维生素的维生素，但一旦习惯成熟，它们就会提供持续的止痛药。</p>\n<h1 id=\"第2章：触发器\"><a href=\"#第2章：触发器\" class=\"headerlink\" title=\"第2章：触发器\"></a>第2章：触发器</h1><p>新习惯需要建立基础。触发器为持续的行为改变提供了基础。<br>触发器是行为的执行器。<br>它有两种类型：外部和内部。</p>\n<h2 id=\"外部触发器\"><a href=\"#外部触发器\" class=\"headerlink\" title=\"外部触发器\"></a>外部触发器</h2><p>习惯形成首先通过号召，用户提示，暗示用户来开始改变行为。<br>外部触发器嵌入了信息，告诉用户下一步该做什么。<br>外部触发器传达用户应采取的下一个操作。<br>通常，明确表达所需的行动。<br>在线外部触发器可以采用突出按钮等形式。<br>外部触发器的类型</p>\n<h3 id=\"1-付费触发器\"><a href=\"#1-付费触发器\" class=\"headerlink\" title=\"1.付费触发器\"></a>1.付费触发器</h3><p>例如广告，搜索引擎营销和其他付费频道。<br>保持用户回访的有效而昂贵的方法。<br>习惯形成公司往往不会长时间依赖付费触发器，如果​​有的话。<br>因为对于大多数商业模式而言，为重新接管付费是不可持续的，所以公司通常使用付费触发器来获取新用户，然后利用其他触发器将其带回来。</p>\n<h3 id=\"2-回馈型触发器\"><a href=\"#2-回馈型触发器\" class=\"headerlink\" title=\"2.回馈型触发器\"></a>2.回馈型触发器</h3><p>它们是免费的，因为它们不能直接购买，但往往需要以公共和媒体关系所花费的时间进行投资。<br>例如有利的媒体提及，特色应用程序商店展示位置，病毒视频等。</p>\n<h3 id=\"3-人际关系型触发器\"><a href=\"#3-人际关系型触发器\" class=\"headerlink\" title=\"3.人际关系型触发器\"></a>3.人际关系型触发器</h3><p>一个人告诉别人有关产品或服务的信息可能是一个非常有效的外部触发动作。<br>正确使用关系触发器需要建立一个积极的用户群，热衷于与他人分享产品的好处。</p>\n<h3 id=\"4-自主型触发器\"><a href=\"#4-自主型触发器\" class=\"headerlink\" title=\"4.自主型触发器\"></a>4.自主型触发器</h3><p>它们始终出现在日常生活中，最终由用户选择允许这些触发器出现。<br>例如app图标，电子邮件简报，app通知等。<br>只要用户同意接收触发器，设置触发器的公司就拥有用户注意力的份额。<br>虽然付费，回馈型和人际关系触发器以新用户获取为目标，但自主型触发器以促使用户重复参与为重点，直到形成习惯。<br>如果没有自主型的触发器，不能在用户默许的前提下获得他们的关注，产品就很难经常提示用户改变他们的行为。</p>\n<h2 id=\"内部触发器\"><a href=\"#内部触发器\" class=\"headerlink\" title=\"内部触发器\"></a>内部触发器</h2><p>当产品与你的思想，情感或预先存在的活动紧密结合时，这就是内部触发器在起作用。<br>我们无法看到，触摸或听到内部触发器。<br>内部触发器会自动显示在您的脑海中 将内部触发器与嵌入产品是消费者技术的关键。<br>情绪，特别是消极情绪是强大的内部触发因素，并极大地影响我们的日常生活。<br>厌倦，孤独，沮丧，困惑和犹豫不决的感觉经常引起轻微的痛苦或刺激，并促使几乎瞬间的，通常是无意识的行动来平息消极的感觉。<br>积极的情绪也可以作为内部触发因素，甚至可以通过满足困扰我们的事物来触发自己。被娱乐的欲望可以被认为是满足厌倦的需要。分享好消息的需要也可以被认为是寻找和维持社交关系的尝试。<br>发现减轻疼痛的产品的用户将随着时间的推移与产品形成强烈的积极关联。<br>在继续使用之后，产品和需要它的用户之间开始形成债券。渐渐地，当用户在遇到某些内部触发因素时转向您的产品时，这些会成为一种习惯。<br>一旦我们被迷住了，使用这些产品并不总是需要明确的号召性用语。相反，他们依靠我们对感情的自动反应来促成期望的行为。<br>一旦技术在用户心中创建了一个关联产品是选择的解决方案，它们就会自行返回，不再需要外部触发器的提示。<br>内部触发器和产品之间的关联不是一夜之间形成的。内部触发器可能需要数周或数月的频繁使用才能形成。</p>\n<h2 id=\"构建触发器\"><a href=\"#构建触发器\" class=\"headerlink\" title=\"构建触发器\"></a>构建触发器</h2><p>成功创造习惯的产品通过声称特定的感觉来缓解用户的痛苦。<br>要做到这一点，产品设计师必须了解用户的内部触发因素 - 即他们寻求解决的痛苦。<br>它需要设计师深入挖掘以了解用户的感受。<br>习惯形成产品的最终目标是通过创建关联来解决用户的痛苦，以便用户将公司的产品或服务识别为救济的来源。<br>公司必须首先在情感方面确定特定的挫折或痛点，而不是产品特征。<br>最好的起点是学习成功的习惯形成产品背后的驱动因素 - 不是复制它们，而是要了解它们如何解决用户的问题。<br>用户的清晰描述 - 他们的欲望，情感，他们使用产品的背景，对于构建正确的解决方案至关重要。<br>一种方法是尽可能多地询问“为什么？”这个问题。通常这发生在第五个原因上。<br>在弄清楚为什么人们使用习惯形成产品时，内部触发器是根本原因，“为什么？”是一个可以帮助钻探核心的问题。</p>\n<h1 id=\"牢记并分享\"><a href=\"#牢记并分享\" class=\"headerlink\" title=\"牢记并分享\"></a>牢记并分享</h1><ol>\n<li>触发是上瘾模型的第一个阶段，它可促使用户来取行动。</li>\n<li>触发分为两类—一外部触发和内部触发。</li>\n<li>外部触发通过将信息渗透在用户生活的各个方面来引导他们采取下一步行动。</li>\n<li>内部触发通过用户记忆存储中的各种关联来提醒他们采取下一步行动。</li>\n<li>负面情绪往往可以充当内部触发。</li>\n<li>要开发习惯养成类产品，设计者需要揣摩用户的心理，了解那些有可能成为内部触发的各种情绪，并且要知道如何利用外部触发来促使用户付诸行动。</li>\n</ol>\n<h1 id=\"第3章：行动\"><a href=\"#第3章：行动\" class=\"headerlink\" title=\"第3章：行动\"></a>第3章：行动</h1><p>是否存在行为公式？产品设计师可以影响用户采取行动吗？<br>Fogg行为模型<br>$B = MAT$<br>其中B =行为，M =动机，A =能力，T =触发<br>如果此公式的任何组件缺失或不足，用户将不会越过“行动线”，并且不会实施某些行为。<br>示例：您的手机响了，但您没有回答。<br>如果你的手机被埋在一个袋子里很难到达=能力有限。<br>如果您认为来电者是电话推销员=缺乏动力<br>电话铃声沉默=没有触发器</p>\n<h2 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h2><p>采取行动或“行动能量”的愿望程度/热情。</p>\n<h2 id=\"核心动机\"><a href=\"#核心动机\" class=\"headerlink\" title=\"核心动机\"></a>核心动机</h2><p>1.寻求快乐，避免痛苦<br>2.寻求希望，避免恐惧<br>3.寻求社会认可并避免拒绝</p>\n<h2 id=\"能力\"><a href=\"#能力\" class=\"headerlink\" title=\"能力\"></a>能力</h2><p>产品的创新过程分解成三个基本步骤：第一步，了解人们使用某个产品或服务的原因。接下来，列举出用户使用该产品的必经环节。最后一步，在明确整个过程的所有环节后开始做减法，直到做到极致。<br>用户能够轻松采取行动或具有执行特定行为的能力。<br>任何显著减少完成任务的步骤的技术或产品将有较高的使用率。<br>更容易=更好<br>简单的元素</p>\n<p>影响任务难度的因素：<br>1.时间：完成一项行动需要多长时间<br>2.金钱：采取行动的财政成本<br>3.体力劳动：采取行动所涉及的劳动量<br>4.脑力：采取行动所需的精神努力和注意力水平<br>5.社会偏差：他人如何接受这种行为。<br>6.非常规：动作与现有例程匹配或中断的程度</p>\n<p>增加动力是昂贵且耗时的。<br>使产品变得如此简单以至于用户已经知道如何使用它会容易得多。</p>\n<h2 id=\"动机和能力？\"><a href=\"#动机和能力？\" class=\"headerlink\" title=\"动机和能力？\"></a>动机和能力？</h2><p>动机 - 我们用来制定决策和形成意见的心理捷径。<br>1.稀缺效应<br>实验1：一个罐子里装有10个饼干而另一个罐装只有2个。哪些饼干会让人更有价值？<br>虽然饼干和罐子是相同的，但参与者更重视近空罐子里的饼干和罐子。<br>实验2：参与者被给予2个饼干或10个罐子。组中有10个饼干的人突然有8个被带走。相反，那些有2的人增加了8个新的。这些变化将如何影响参与者对cookie的评价方式？<br>该组只剩下2个饼干，评价它们更有价值，而那些经历突然丰富的饼干则更不重视饼干。<br>2.环境效应<br>世界级小提琴家约书亚贝尔决定在华盛顿特区地铁站举行免费的即兴音乐会。贝尔定期以每张票数百美元的价格出售像卡内基音乐厅这样的场地，但是当他置于DC地铁的环境中时，他的音乐被置若罔闻。<br>即使与客观数量的关系很少，感知也可以根据产品的框架形成个人现实。<br>3.锚定效应<br>人们在做出决定时经常会锚定一条信息。<br>4.赠券效应<br>如果零售商向客户提供已打孔的打卡，会发生什么？人们会更有可能采取行动吗？<br>答案是肯定的。<br>赠券效应是一种增加动力的现象，因为人们认为它们正在接近目标。</p>\n<h2 id=\"Key-Point\"><a href=\"#Key-Point\" class=\"headerlink\" title=\"Key Point\"></a>Key Point</h2><p>行动是上瘾模型的第二个阶段<br>行动是人们在期待酬赏时最直接的反应。<br>根据福格博士建立的行为模型：<br>1.要促成某种行为，触发、动机和能力这三者缺一不可。<br>2.要增加预想行为的发生率，触发要显而易见，行为要易于实施，动机要合乎常理。<br>3.人类行为不外乎受三种核动机的影响：追求快乐，逃避痛苦；追求希望，逃避恐惧；追求认同，逃避排斥。<br>4.时间、金钱、体力、脑力社会偏差非常规牲笑六个因素会对用户的能力产生影响。能力还会因大因地而异。<br>启发法是指我们借助认知经验对事物做出快速判断。产品设计者可以从上千种启发法中选择一些来获取灵感，提高产品的吸引力。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"《上瘾：让用户养成使用习惯的四大产品逻辑》\"><a href=\"#《上瘾：让用户养成使用习惯的四大产品逻辑》\" class=\"headerlink\" title=\"《上瘾：让用户养成使用习惯的四大产品逻辑》\"></a>《上瘾：让用户养成使用习惯的四大产品逻辑》</h1><p>尼尔·埃亚尔 瑞安·胡佛</p>\n<h1 id=\"序言-与产品谈一场恋爱\"><a href=\"#序言-与产品谈一场恋爱\" class=\"headerlink\" title=\"序言 与产品谈一场恋爱\"></a>序言 与产品谈一场恋爱</h1><p>那么如何让用户习惯于使用你的产品呢？<br>这本书给出了一个极其简明的上瘾模型（the Hook Model）：触发——行动——多变的酬赏——投入。<br>万事开头难。第一步就是引发用户去使用你的产品，这叫作“触发”。<br>触发之后，第二步就是行动。行动要兼具动机和能力，有了动机，还需要用户的能力足够完成行为。<br>行动之后，要给用户酬赏，还得是多变的酬赏。所谓多变的酬赏，就是指酬赏要有不可预期性。<br>最后，是让用户在产品上进行越来越多的“投入”。用户与产品亲密接触得越多，就越离不开它。<br>通过用户的“投入”，就可能产生下一次“触发”，从而开始一个正向循环。<br>于是你就上瘾了（hooked）。</p>\n<h1 id=\"前言-为什么有的产品会让人上瘾？\"><a href=\"#前言-为什么有的产品会让人上瘾？\" class=\"headerlink\" title=\"前言 为什么有的产品会让人上瘾？\"></a>前言 为什么有的产品会让人上瘾？</h1><p>习惯是指我们下意识做出的举动。</p>\n<ol>\n<li>集网络连接、海量数据、超快网速三者于一身的技术正在使这个世界上瘾成性。</li>\n<li>生产习惯养成类产品可以让商家稳占竞争优势。</li>\n<li>上瘾模型将用户面临的问题与企业提供的应对策略衔接在一起，二者频繁互动，促成用户养成习惯。</li>\n<li>上瘾模型包括四个阶段：触发，行动，多变的酬赏，投入。</li>\n</ol>\n<h1 id=\"第1章：习惯的力量\"><a href=\"#第1章：习惯的力量\" class=\"headerlink\" title=\"第1章：习惯的力量\"></a>第1章：习惯的力量</h1><p>简单的习惯是在很少或没有意识思考的情况下完成的行为，它们指导了近一半的日常行为。<br>习惯是大脑学习复杂行为的方式之一。<br>神经科学家认为，习惯使我们能够通过在基底神经节中存储自动反应来将注意力集中在其他事物上，基底神经节是与非自愿行为相关的大脑区域。<br>当大脑采取捷径并停止积极思考下一步该做什么时，就会形成习惯。大脑很快学会编纂行为，为其遇到的任何情况提供解决方案。</p>\n<h2 id=\"为什么习惯有利于商业\"><a href=\"#为什么习惯有利于商业\" class=\"headerlink\" title=\"为什么习惯有利于商业\"></a>为什么习惯有利于商业</h2><h3 id=\"1-提高客户终身价值\"><a href=\"#1-提高客户终身价值\" class=\"headerlink\" title=\"1.提高客户终身价值\"></a>1.提高客户终身价值</h3><p>客户终身价值（CLV）：客户切换到竞争对手之前从客户处获得的金额，停止使用该产品或模具。<br>用户习惯会增加客户使用产品的时间和频率，从而导致更高的CLTV。</p>\n<h3 id=\"2-提供定价灵活性\"><a href=\"#2-提供定价灵活性\" class=\"headerlink\" title=\"2.提供定价灵活性\"></a>2.提供定价灵活性</h3><p>当客户围绕产品形成惯例时，他们会依赖它并对价格变得不那么敏感。<br>习惯使公司有更大的灵活性来提高价格。</p>\n<h3 id=\"3-增压增长\"><a href=\"#3-增压增长\" class=\"headerlink\" title=\"3.增压增长\"></a>3.增压增长</h3><p>持续在产品中找到价值的用户更有可能告诉他们的朋友。<br>经常使用会创造更多机会来鼓励人们邀请他们的朋友，广播内容并通过口口相传来分享。<br>Hooked用户成为品牌推广者，以极少或免费的方式吸引新用户。<br>具有较高用户参与度的产品也有可能比竞争对手更快地增长。</p>\n<h3 id=\"4-提高竞争优势\"><a href=\"#4-提高竞争优势\" class=\"headerlink\" title=\"4.提高竞争优势\"></a>4.提高竞争优势</h3><p>用户习惯是竞争优势。改变客户惯例的产品不易受到其他公司的攻击。<br>哈佛商学院（Harvard Business School）市场营销学教授约翰古尔维尔（John Gourville）的一篇经典论文称，对于新的市场进入者而言，他们不仅会更好，而且必须要好九倍。<br>高标准的出现是因为旧习惯变得艰难，新产品和服务需要提供显着改进，以动摇用户摆脱旧惯例。<br>即使使用新产品的好处明显且充实，需要高度改变行为的产品也注定要失败。</p>\n<h3 id=\"5-在习惯区\"><a href=\"#5-在习惯区\" class=\"headerlink\" title=\"5.在习惯区\"></a>5.在习惯区</h3><p>公司可以通过绘制两个因素来开始确定其产品的习惯形成潜力：频率（行为发生的频率）和感知效用（用户对其他解决方案的行为有多么有用和有益。）<br>具有足够频率和感知效用的行为进入“习惯区域”，有助于使其成为默认行为。<br>如果这些因素中的任何一个不足并且行为低于阈值，那么期望的行为将不太可能成为习惯。<br>有些行为永远不会成为习惯，因为它们不会频繁发生。<br>另一方面，即使是提供最小感知益处的行为也可能成为习惯，因为它经常发生。<br><img src=\"https://img-blog.csdnimg.cn/20190508135151639.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"频率和可感知用途\"></p>\n<h2 id=\"维生素与止痛药\"><a href=\"#维生素与止痛药\" class=\"headerlink\" title=\"维生素与止痛药\"></a>维生素与止痛药</h2><p>所有成功创新的共同点=他们解决问题！！！<br>投资者希望投资止痛药 - 因为他们解决了明显的需求，减轻了特定的痛苦，并且经常有可量化的市场。<br>相比之下，维生素不一定能解决明显的痛点。相反，它们吸引用户的情感而不是功能需求。<br>社交媒体怎么样？许多人会说他们正在销售维生素，因为他们的用户没有做任何特别重要的事情，而不是寻求快速推动社会验证。<br>但是，请考虑这个想法：一个习惯就是在不采取行动时会引起一些痛苦。<br>习惯形成技术既是维生素又是止痛药。<br>他们最初提供的是富含维生素的维生素，但一旦习惯成熟，它们就会提供持续的止痛药。</p>\n<h1 id=\"第2章：触发器\"><a href=\"#第2章：触发器\" class=\"headerlink\" title=\"第2章：触发器\"></a>第2章：触发器</h1><p>新习惯需要建立基础。触发器为持续的行为改变提供了基础。<br>触发器是行为的执行器。<br>它有两种类型：外部和内部。</p>\n<h2 id=\"外部触发器\"><a href=\"#外部触发器\" class=\"headerlink\" title=\"外部触发器\"></a>外部触发器</h2><p>习惯形成首先通过号召，用户提示，暗示用户来开始改变行为。<br>外部触发器嵌入了信息，告诉用户下一步该做什么。<br>外部触发器传达用户应采取的下一个操作。<br>通常，明确表达所需的行动。<br>在线外部触发器可以采用突出按钮等形式。<br>外部触发器的类型</p>\n<h3 id=\"1-付费触发器\"><a href=\"#1-付费触发器\" class=\"headerlink\" title=\"1.付费触发器\"></a>1.付费触发器</h3><p>例如广告，搜索引擎营销和其他付费频道。<br>保持用户回访的有效而昂贵的方法。<br>习惯形成公司往往不会长时间依赖付费触发器，如果​​有的话。<br>因为对于大多数商业模式而言，为重新接管付费是不可持续的，所以公司通常使用付费触发器来获取新用户，然后利用其他触发器将其带回来。</p>\n<h3 id=\"2-回馈型触发器\"><a href=\"#2-回馈型触发器\" class=\"headerlink\" title=\"2.回馈型触发器\"></a>2.回馈型触发器</h3><p>它们是免费的，因为它们不能直接购买，但往往需要以公共和媒体关系所花费的时间进行投资。<br>例如有利的媒体提及，特色应用程序商店展示位置，病毒视频等。</p>\n<h3 id=\"3-人际关系型触发器\"><a href=\"#3-人际关系型触发器\" class=\"headerlink\" title=\"3.人际关系型触发器\"></a>3.人际关系型触发器</h3><p>一个人告诉别人有关产品或服务的信息可能是一个非常有效的外部触发动作。<br>正确使用关系触发器需要建立一个积极的用户群，热衷于与他人分享产品的好处。</p>\n<h3 id=\"4-自主型触发器\"><a href=\"#4-自主型触发器\" class=\"headerlink\" title=\"4.自主型触发器\"></a>4.自主型触发器</h3><p>它们始终出现在日常生活中，最终由用户选择允许这些触发器出现。<br>例如app图标，电子邮件简报，app通知等。<br>只要用户同意接收触发器，设置触发器的公司就拥有用户注意力的份额。<br>虽然付费，回馈型和人际关系触发器以新用户获取为目标，但自主型触发器以促使用户重复参与为重点，直到形成习惯。<br>如果没有自主型的触发器，不能在用户默许的前提下获得他们的关注，产品就很难经常提示用户改变他们的行为。</p>\n<h2 id=\"内部触发器\"><a href=\"#内部触发器\" class=\"headerlink\" title=\"内部触发器\"></a>内部触发器</h2><p>当产品与你的思想，情感或预先存在的活动紧密结合时，这就是内部触发器在起作用。<br>我们无法看到，触摸或听到内部触发器。<br>内部触发器会自动显示在您的脑海中 将内部触发器与嵌入产品是消费者技术的关键。<br>情绪，特别是消极情绪是强大的内部触发因素，并极大地影响我们的日常生活。<br>厌倦，孤独，沮丧，困惑和犹豫不决的感觉经常引起轻微的痛苦或刺激，并促使几乎瞬间的，通常是无意识的行动来平息消极的感觉。<br>积极的情绪也可以作为内部触发因素，甚至可以通过满足困扰我们的事物来触发自己。被娱乐的欲望可以被认为是满足厌倦的需要。分享好消息的需要也可以被认为是寻找和维持社交关系的尝试。<br>发现减轻疼痛的产品的用户将随着时间的推移与产品形成强烈的积极关联。<br>在继续使用之后，产品和需要它的用户之间开始形成债券。渐渐地，当用户在遇到某些内部触发因素时转向您的产品时，这些会成为一种习惯。<br>一旦我们被迷住了，使用这些产品并不总是需要明确的号召性用语。相反，他们依靠我们对感情的自动反应来促成期望的行为。<br>一旦技术在用户心中创建了一个关联产品是选择的解决方案，它们就会自行返回，不再需要外部触发器的提示。<br>内部触发器和产品之间的关联不是一夜之间形成的。内部触发器可能需要数周或数月的频繁使用才能形成。</p>\n<h2 id=\"构建触发器\"><a href=\"#构建触发器\" class=\"headerlink\" title=\"构建触发器\"></a>构建触发器</h2><p>成功创造习惯的产品通过声称特定的感觉来缓解用户的痛苦。<br>要做到这一点，产品设计师必须了解用户的内部触发因素 - 即他们寻求解决的痛苦。<br>它需要设计师深入挖掘以了解用户的感受。<br>习惯形成产品的最终目标是通过创建关联来解决用户的痛苦，以便用户将公司的产品或服务识别为救济的来源。<br>公司必须首先在情感方面确定特定的挫折或痛点，而不是产品特征。<br>最好的起点是学习成功的习惯形成产品背后的驱动因素 - 不是复制它们，而是要了解它们如何解决用户的问题。<br>用户的清晰描述 - 他们的欲望，情感，他们使用产品的背景，对于构建正确的解决方案至关重要。<br>一种方法是尽可能多地询问“为什么？”这个问题。通常这发生在第五个原因上。<br>在弄清楚为什么人们使用习惯形成产品时，内部触发器是根本原因，“为什么？”是一个可以帮助钻探核心的问题。</p>\n<h1 id=\"牢记并分享\"><a href=\"#牢记并分享\" class=\"headerlink\" title=\"牢记并分享\"></a>牢记并分享</h1><ol>\n<li>触发是上瘾模型的第一个阶段，它可促使用户来取行动。</li>\n<li>触发分为两类—一外部触发和内部触发。</li>\n<li>外部触发通过将信息渗透在用户生活的各个方面来引导他们采取下一步行动。</li>\n<li>内部触发通过用户记忆存储中的各种关联来提醒他们采取下一步行动。</li>\n<li>负面情绪往往可以充当内部触发。</li>\n<li>要开发习惯养成类产品，设计者需要揣摩用户的心理，了解那些有可能成为内部触发的各种情绪，并且要知道如何利用外部触发来促使用户付诸行动。</li>\n</ol>\n<h1 id=\"第3章：行动\"><a href=\"#第3章：行动\" class=\"headerlink\" title=\"第3章：行动\"></a>第3章：行动</h1><p>是否存在行为公式？产品设计师可以影响用户采取行动吗？<br>Fogg行为模型<br>$B = MAT$<br>其中B =行为，M =动机，A =能力，T =触发<br>如果此公式的任何组件缺失或不足，用户将不会越过“行动线”，并且不会实施某些行为。<br>示例：您的手机响了，但您没有回答。<br>如果你的手机被埋在一个袋子里很难到达=能力有限。<br>如果您认为来电者是电话推销员=缺乏动力<br>电话铃声沉默=没有触发器</p>\n<h2 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h2><p>采取行动或“行动能量”的愿望程度/热情。</p>\n<h2 id=\"核心动机\"><a href=\"#核心动机\" class=\"headerlink\" title=\"核心动机\"></a>核心动机</h2><p>1.寻求快乐，避免痛苦<br>2.寻求希望，避免恐惧<br>3.寻求社会认可并避免拒绝</p>\n<h2 id=\"能力\"><a href=\"#能力\" class=\"headerlink\" title=\"能力\"></a>能力</h2><p>产品的创新过程分解成三个基本步骤：第一步，了解人们使用某个产品或服务的原因。接下来，列举出用户使用该产品的必经环节。最后一步，在明确整个过程的所有环节后开始做减法，直到做到极致。<br>用户能够轻松采取行动或具有执行特定行为的能力。<br>任何显著减少完成任务的步骤的技术或产品将有较高的使用率。<br>更容易=更好<br>简单的元素</p>\n<p>影响任务难度的因素：<br>1.时间：完成一项行动需要多长时间<br>2.金钱：采取行动的财政成本<br>3.体力劳动：采取行动所涉及的劳动量<br>4.脑力：采取行动所需的精神努力和注意力水平<br>5.社会偏差：他人如何接受这种行为。<br>6.非常规：动作与现有例程匹配或中断的程度</p>\n<p>增加动力是昂贵且耗时的。<br>使产品变得如此简单以至于用户已经知道如何使用它会容易得多。</p>\n<h2 id=\"动机和能力？\"><a href=\"#动机和能力？\" class=\"headerlink\" title=\"动机和能力？\"></a>动机和能力？</h2><p>动机 - 我们用来制定决策和形成意见的心理捷径。<br>1.稀缺效应<br>实验1：一个罐子里装有10个饼干而另一个罐装只有2个。哪些饼干会让人更有价值？<br>虽然饼干和罐子是相同的，但参与者更重视近空罐子里的饼干和罐子。<br>实验2：参与者被给予2个饼干或10个罐子。组中有10个饼干的人突然有8个被带走。相反，那些有2的人增加了8个新的。这些变化将如何影响参与者对cookie的评价方式？<br>该组只剩下2个饼干，评价它们更有价值，而那些经历突然丰富的饼干则更不重视饼干。<br>2.环境效应<br>世界级小提琴家约书亚贝尔决定在华盛顿特区地铁站举行免费的即兴音乐会。贝尔定期以每张票数百美元的价格出售像卡内基音乐厅这样的场地，但是当他置于DC地铁的环境中时，他的音乐被置若罔闻。<br>即使与客观数量的关系很少，感知也可以根据产品的框架形成个人现实。<br>3.锚定效应<br>人们在做出决定时经常会锚定一条信息。<br>4.赠券效应<br>如果零售商向客户提供已打孔的打卡，会发生什么？人们会更有可能采取行动吗？<br>答案是肯定的。<br>赠券效应是一种增加动力的现象，因为人们认为它们正在接近目标。</p>\n<h2 id=\"Key-Point\"><a href=\"#Key-Point\" class=\"headerlink\" title=\"Key Point\"></a>Key Point</h2><p>行动是上瘾模型的第二个阶段<br>行动是人们在期待酬赏时最直接的反应。<br>根据福格博士建立的行为模型：<br>1.要促成某种行为，触发、动机和能力这三者缺一不可。<br>2.要增加预想行为的发生率，触发要显而易见，行为要易于实施，动机要合乎常理。<br>3.人类行为不外乎受三种核动机的影响：追求快乐，逃避痛苦；追求希望，逃避恐惧；追求认同，逃避排斥。<br>4.时间、金钱、体力、脑力社会偏差非常规牲笑六个因素会对用户的能力产生影响。能力还会因大因地而异。<br>启发法是指我们借助认知经验对事物做出快速判断。产品设计者可以从上千种启发法中选择一些来获取灵感，提高产品的吸引力。</p>\n"},{"title":"启示录","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T01:36:25.000Z","password":null,"summary":"人员是指负责定义和开发产品的团队成员的角色和职责。流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。产品是指富有创意的产品具有的鲜明特性。","_content":"\n# 启示录\n\n------\n\n本文的结构，人员、流程、产品。\n\n人员是指负责定义和开发产品的团队成员的角色和职责。\n\n流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。\n\n产品是指富有创意的产品具有的鲜明特性。\n\n# 人员\n\n这一部分作者通过介绍产品经理与项目经理、营销人员、设计、开发人员的联系和区别，向我们阐述产品经理的主要的职责就是：定义产品机会和定义要开发的产品。最后向我们介绍了怎么和上司交流，怎么管理自己，产品经理需要具备的素质等。\n\n## 关键角色和职责\n\n### 产品经理 \n\n产品经理的主要职责分为两项：评估产品机会和定义要开发的产品。\n\n产品需求的来源：\n\n1. boss的要求\n\n2. 用户的反馈\n\n3. PM团队对自身产品的重构和分析\n\n4. 团队其他成员（运营，开发，销售、UI）对产品的反馈\n\n5. 数据分析，测试的结果\n\n### 用户体验设计师\n\n交互设计师负责深入理解目标用户，设计有价值的、可用的功能，以及用户的导航和产品的使用流程。交互设计师和产品经理密切合作，将功能与设计相结合，满足用户需求。目标是确保同时具有可用性和价值。可用性指的是用户明白如何使用产品，价值指的是用户对产品的渴求程度。\n\n### 项目管理人员\n\n核心任务是制定计划和跟踪进度。\n\n### 开发团队\n\n### 运维团队\n\n### 产品营销人员\n\n对外发布产品，宣传产品，促进产品销售提供支持\n\n## 产品管理和营销\n\n产品经理的工作是从细节上定义开发团队开发什么产品，市场营销的职责是对外宣传产品。\n\n## 产品管理和项目管理\n\n项目管理关注如何执行计划以按期交付产品。\n\n项目经理的七个优点：\n\n1. 工作的紧迫感\n\n2. 善于捕捉问题\n\n3. 思路清晰\n\n4. 用数据说话\n\n5. 果断\n\n6. 判断力\n\n7. 态度\n\n## 产品管理和产品设计\n\n与用户体验设计密切相关的分工：\n\n1. 用户研究：专门研究、分析用户，评估产品或原型是否符合特定用户的使用习惯。\n\n2. 交互设计\n\n3. 视觉设计\n\n4. 原型制作 \n\n## 产品管理和软件开发\n\n定义正确的产品和正确的开发产品。\n\n开发人员帮助产品经理完善产品定义的方式：\n\n1. 让开发人员直接面对用户或者顾客，体会用户的困惑和疑虑，了解问题的严重性。可以邀请开发人员参与原型测试。\n\n2. 向开发人员了解最新的技术发展动向，讨论那些技术可以用到产品里。\n\n3. 让开发人员在探索产品的初期阶段参与评估产品设计，协助策划方案。\n\n产品经理应该配合开发人员的工作，方式如下：\n\n1. 产品经理只负责定义满足基本需求的产品，产品经理应该意识到，自己定义的不是最终的产品，而是满足基本需求的产品。\n\n2. 一旦进入产品开发阶段，要尽可能的避免修改产品的需求和设计。\n\n3. 产品开发阶段难免会产生诸多的问题，比如用例丢失，用例设计考虑不全等，这很正常，产品经理应该迅速采取行动，在维持产品基本功能的基础上、尽量避免修改的原则上，拿出解决方案。\n\n## 招聘产品经理\n\n### 寻找出色的产品经理\n\n1. 个人素质和态度\n\n2. 对产品的热情\n\n3. 用户立场\n\n4. 智力\n\n5. 职业操守\n\n6. 正直\n\n7. 信心\n\n8. 态度\n\n9. 技能\n\n10. 运用技术的能力\n\n11. 注意力\n\n\n12. 时间管理\n\n13. 沟通技巧\n\n14. 商业技能\n\n## 管理产品经理\n\n产品总监的关键职责有两方面。第一，组建优秀的产品经理团队。第二，规划公司的全局产品战略，对产品组合负责。\n\n### 建设产品管理团队\n\n### 规划公司的产品战略\n\n## 管理上司\n\n1. 为项目波动做好准备\n\n2. 注意沟通的方式与频率\n\n3. 会签沟通\n\n4. 多提建议，少谈问题\n\n5. 向上司借力\n\n6. 充分准备\n\n7. 缩短邮件篇幅\n\n8. 多用数据和事实说话\n\n9. 内部宣传\n\n10. 做让领导省心的员工\n\n# 流程\n\n该部分向我们讨论了怎么探索及开发富有创意的产品时反复应用的流程和成功的实践经验。\n\n确定产品原则-->产品评审团-->市场调研-->PRD-->基本产品-->产品验证-->改进产品-->敏捷开发（瀑布式开发）\n\n## 评估产品机会\n\n### 确定待解决的问题\n\n评估产品机会时产品经理的重要职责。评估产品机会的目的在于：淘汰馊主意，避免浪费时间和金钱。\n\n为了评估产品机会，产品经理需要回答如下十个问题：\n\n1. 产品要解决什么问题？（产品价值）\n\n2. 为谁解决问题？（目标市场）\n\n3. 成功的机会有多大？（市场规模）\n\n4. 怎么样判断产品成功与否？（度量指标或收益指标）\n\n5. 有哪些同类产品？（竞争格局）\n\n6. 为什么我们最适合做这个产品？（竞争优势）\n\n7. 时机合适吗？（市场时机）\n\n8. 如何把产品推向市场？（营销组合策略）\n\n9. 成功的必要条件是什么？（解决方法要满足的条件）\n\n10. 根据以上问题，给出评论结论。（继续或放弃）\n\n## 产品探索\n\n### 定义正确的产品\n\n软件项目可以划分为两个阶段：弄清楚要开发什么产品（定义正确的产品）；开发该产品（正确的开发产品）。第一阶段探索产品，第二阶段则强调执行。\n\n首先，产品经理应该探索是否有用户需要产品，也就是，要寻找市场，让用户验证你的构思。\n\n其次，产品经理要探索能够解决问题的产品方案，他必须是有价值的，可用的，可行的，也就是说要设计解决方案，请用户和开发团队来验证。\n\n## 产品原则\n\n### 确定什么最重要\n\n产品原则是对团队信仰和价值观的总结，用来指导产品团队做出正确的取舍和决策。它体现了产品团队的目标和愿景，是产品战略的重要组成部分。从形式上看，他是一系列明确的、体现团队特色的产品价值准则。\n\n关于争论的原因：\n\n1. 每位同属对公司的产品都有自己的看法\n\n2. 大家都十分在乎产品，明白公司盈利需要靠用户，只有产品才能吸引用户\n\n3. 许多人都认为自己比其他人更了解目标用户\n\n所以我们需要在一下几点达成共识：\n\n1. 究竟要解决什么问题？\n\n2. 要为哪些人物角色解决这个问题？\n\n3. 产品要达到什么目标？\n\n4. 每项目标的优先级是什么？\n\n在我看来，每当团队内出现严重的意见分歧的时候，并非大家对事实的认定有争议，而是对目标和目标的优先级有不同的理解。\n\n比如说，团队应该确定哪个目标对用户最重要，是易用性，响应速度、功能、成本、安全性还是用户隐私？只有先统一从产品目标和目标优先级的认识，大家在此共识上进一步讨论的各种方案的合理性。\n\n## 产品评审团\n\n职责：监督产品研发流程，制定关键决策。\n\n## 特约用户\n\n**示范性的应用程序**\n\n## 市场调研\n\n## 市场调研的作用\n\n1. 用户调查\n\n2. 产品使用分析\n\n3. 数据挖掘\n\n4. 拜访用户\n\n5. 人物角色\n\n6. 可用性测试\n\n7. 同类产品分析\n\n市场调研的结果可以作为研发产品的依据和参考，但不能决定产品研发的方向。\n\n探索产品的过程则要回答如下问题：\n\n1. 采用什么技术来更好地解决产品要解决的问题？\n\n2. 设计什么样的用户体验？\n\n成功的产品基于以下两点认识：深入理解用户需求，以及明白什么样的解决方案在现阶段是可行的。\n\n## 产品人物角色\n\n## 重新定义产品说明文档\n\n## 用户体验设计与实现\n\n先定义用户体验再动手开发\n\n敏捷方法里有个概念叫“第零次迭代”，产品经理和用户体验设计师利用这段时间先完成产品设计工作，然后交由开发人员开始迭代开发。\n\n## 基本产品\n\n## 产品验证\n\n证明产品的价值、可用性和可行性\n\n产品验证是指在正式开发、部署产品前，验证产品说明文档描述的产品是否符合预期要求。\n\n**可行性测试**\n\n**可用性测试**\n\n**价值测试**\n\n## 原型测试\n\n## 改进现有产品\n\n**不是一味地添加功能**\n\n## 平滑部署\n\n避免更新产品导致用户反感\n\n用户产生反感主要有以下几个原因：\n\n1. 事前没有收到更新通知，\n\n2. 用户没有时间学习，适应新版本，产品公司也没有提供旧版本方便用户在过渡阶段的使用\n\n3. 新版本无法正常运行\n\n4. 新旧版本不兼容\n\n5. 新添加的功能和特性毫无必要\n\n## 快速响应阶段\n\n## 合理运用敏捷方法\n\n敏捷方法（包括Scrum和极限编程）有很多优点，但这类方法原值定制软件领域，不完全适用于开发产品软件。\n\n## 合理运用瀑布式开发方法\n\n瀑布式开发方法（持续改进方法、里程碑式开发方法）的基本原则：\n\n1. 采用阶段式开发\n\n2. 采用阶段式评审\n\n存在的问题：\n\n1. 产品验证严重滞回\n\n2. 变更计划代价不菲\n\n3. 无法适应快速的市场变化\n\n## 创业型公司的产品经理\n\n**关键在于产品探索**\n\n## 大公司如何创新\n\n**有困难，但值得一试**\n\n企业文化和老板观念是创新的氛围的两大影响因素。\n\n**20%法则**\n\n**臭鼬工程**\n\n**主动观察**\n\n**改善用户体验**\n\n**收购小公司**\n\n## 在大公司施展拳脚\n\n**十大秘诀**\n\n大公司尽量规避风险，矩阵式管理方式，节约公司的运营成本。\n\n1. 了解公司制定决策的方式\n\n2. 建立人脉网络\n\n3. 臭鼬工程\n\n4. 自己顶上\n\n5. 有选择的据理力争\n\n6. 会前沟通，形成默契\n\n7. 合理分配时间\n\n8. 分享信息\n\n9. 向上司借力\n\n10. 传播你的产品理念\n\n**大部分人游荡在黑暗里，他们只知道抱怨，缺从不想办法寻找开关。**\n\n# 产品\n\n\n## 苹果公司给我的启示\n\n苹果值得学习的优秀经验：\n\n1. 硬件为软件服务\n\n2. 软件为用户体验服务\n\n3. 用户体验为情感服务\n\n4. 产品为真正的需求服务\n\n## 提防有特殊需求的产品\n\n特例产品混淆了客户需求和产品需求，必然会使公司偏离正轨。\n\n产品原则决定了是否接受客户提出的特殊要求。\n\n## 新瓶装老酒\n\n如何在成熟的市场上抢的一席之地？\n\n第一：对目标市场了如指掌，对现有产品的缺陷洞若观火。我喜欢通过产品可用性测试掌握产品情况（包括自己的产品和竞争对手的产品）\n\n第二：跟踪最新的技术趋势。新技术层出不穷，让之前无法实现的方案变得可能。\n\n优秀的产品经理应该抓住现有技术与用户需求的契合点。\n\n## 恐惧、贪婪、欲望\n\n**产品中情感的作用**\n\n消费者购买产品大多属于情感需求。\n\n## 情感接纳曲线\n\n技术接纳曲线\n\n情感接纳曲线\n\n根据消费者的情感特征，把他们分为技术爱好者，非理性消费者，理性消费者，超理性消费者和观望者。\n\n1. 关注用户的不满情绪？\n\n愤怒的用户决定着产品未来的发展方向。\n\n## 可用性与美感\n\n两者缺一不可。\n\n## 大众网络服务产品\n\n十大要点：\n\n1. 可用性\n\n2. 人物角色\n\n3. 扩展性\n\n4. 持续可用性\n\n5. 客户服务\n\n6. 保护用户隐私\n\n7. 口碑营销\n\n8. 全球化\n\n9.平滑部署\n\n10.用户社区管理\n\n## 打造企业级产品的经验\n\n企业级产品判断的标准：软件的销售对象和软件的类型\n\n企业级软件的销售对象主要是企业，类型主要包括企业基础软件（安全软件，系统管理软件，通信软件）和企业应用软件（营销自动化软件，客户关系管理软件，企业资源计划软件）。\n\n1. 可用性\n\n2. 产品正常工作\n\n3. 特例产品\n\n4. 特约用户\n\n5. 销售渠道的需求\n\n6. 客户和用户的需求\n\n7. 产品安装 \n\n8. 产品的配置、自定义和集成\n\n9. 产品升级\n\n10. 销售策略\n\n\n合格软件产品具备的特征：\n\n1. 产品具有价值，用户愿意掏钱购买产品。\n\n2. 产品可以在多种环境下运行，不是定制软件\n\n3. 只要提供必要的销售工具和销售培训，产品就可以通过销售渠道顺利销售出去。\n\n4. 产品公司能够为该产品提供支持，不断完善产品\n\n5. 经销商、服务合作伙伴，客户明白如何安装，配置和使用产品。\n\n专用解决方案除了以上描述的产品特征外，还应具备以下特征：\n\n1. 软件可以帮助企业解决业务问题，通常是特定（垂直）的行业问题\n\n2. 产品可能由一个或多个组件整合而成，组件可以有本公司或者合作方开发\n\n3. 必要时，产品应该获得合作方的产品认证\n\n专用方案直接解决企业的业务问题。\n\n## 打造平台级的产品经验\n\n平台产品：一类基础软件，应用开发者在其基础上开发应用程序。\n\n平台产品需要们面对不同的客户：\n\n1. 应用软件开发商\n\n2. 开发人员\n\n3. 终端用户\n\n# 总结\n\n## 最佳实践经验\n\n** =十大要点**\n\n1. 产品管理的职责  许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活。\n\n2. 用户体验  对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造有实用价值的产品。\n\n3. 机会评估  用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准。\n\n4. 特约用户  有些产品团队企图绕过用户，直接设计、开发产品，这种想法可笑至极。打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。\n\n5. 产品原则  产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策。\n\n6. 人物角色  人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据。\n\n7. 探索（定义）产品  产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。\n\n8. 使用原型  使用高保真原型是探索（定义）产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计思路。\n\n9. 用户参与原型测试  有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。\n\n10. 根据数据改进产品  成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。\n\n\n## 产品经理的反省清单\n\n**十大问题**\n\n出色的产品经理会时刻关注产品的现状与未来。以下是产品经理无时无刻不在思考的问题。\n\n1. 产品能吸引目标消费者的关注吗？\n\n2. 产品的设计是否人性化，是否易于操作？\n\n3. 产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？\n\n4. 我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？\n\n5. 产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？\n\n6. 产品能正常运行吗？\n\n7. 产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？\n\n8. 产品的特色是否与目标用户的需求一致？产品特色是否鲜明？\n\n9. 产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？\n\n10. 我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2019-inspired.md","raw":"---\ntitle: 启示录\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 09:36:25\npassword:\nsummary: 人员是指负责定义和开发产品的团队成员的角色和职责。流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。产品是指富有创意的产品具有的鲜明特性。\ntags:\n- 读书笔记\ncategories:\n- 读书笔记\n---\n\n# 启示录\n\n------\n\n本文的结构，人员、流程、产品。\n\n人员是指负责定义和开发产品的团队成员的角色和职责。\n\n流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。\n\n产品是指富有创意的产品具有的鲜明特性。\n\n# 人员\n\n这一部分作者通过介绍产品经理与项目经理、营销人员、设计、开发人员的联系和区别，向我们阐述产品经理的主要的职责就是：定义产品机会和定义要开发的产品。最后向我们介绍了怎么和上司交流，怎么管理自己，产品经理需要具备的素质等。\n\n## 关键角色和职责\n\n### 产品经理 \n\n产品经理的主要职责分为两项：评估产品机会和定义要开发的产品。\n\n产品需求的来源：\n\n1. boss的要求\n\n2. 用户的反馈\n\n3. PM团队对自身产品的重构和分析\n\n4. 团队其他成员（运营，开发，销售、UI）对产品的反馈\n\n5. 数据分析，测试的结果\n\n### 用户体验设计师\n\n交互设计师负责深入理解目标用户，设计有价值的、可用的功能，以及用户的导航和产品的使用流程。交互设计师和产品经理密切合作，将功能与设计相结合，满足用户需求。目标是确保同时具有可用性和价值。可用性指的是用户明白如何使用产品，价值指的是用户对产品的渴求程度。\n\n### 项目管理人员\n\n核心任务是制定计划和跟踪进度。\n\n### 开发团队\n\n### 运维团队\n\n### 产品营销人员\n\n对外发布产品，宣传产品，促进产品销售提供支持\n\n## 产品管理和营销\n\n产品经理的工作是从细节上定义开发团队开发什么产品，市场营销的职责是对外宣传产品。\n\n## 产品管理和项目管理\n\n项目管理关注如何执行计划以按期交付产品。\n\n项目经理的七个优点：\n\n1. 工作的紧迫感\n\n2. 善于捕捉问题\n\n3. 思路清晰\n\n4. 用数据说话\n\n5. 果断\n\n6. 判断力\n\n7. 态度\n\n## 产品管理和产品设计\n\n与用户体验设计密切相关的分工：\n\n1. 用户研究：专门研究、分析用户，评估产品或原型是否符合特定用户的使用习惯。\n\n2. 交互设计\n\n3. 视觉设计\n\n4. 原型制作 \n\n## 产品管理和软件开发\n\n定义正确的产品和正确的开发产品。\n\n开发人员帮助产品经理完善产品定义的方式：\n\n1. 让开发人员直接面对用户或者顾客，体会用户的困惑和疑虑，了解问题的严重性。可以邀请开发人员参与原型测试。\n\n2. 向开发人员了解最新的技术发展动向，讨论那些技术可以用到产品里。\n\n3. 让开发人员在探索产品的初期阶段参与评估产品设计，协助策划方案。\n\n产品经理应该配合开发人员的工作，方式如下：\n\n1. 产品经理只负责定义满足基本需求的产品，产品经理应该意识到，自己定义的不是最终的产品，而是满足基本需求的产品。\n\n2. 一旦进入产品开发阶段，要尽可能的避免修改产品的需求和设计。\n\n3. 产品开发阶段难免会产生诸多的问题，比如用例丢失，用例设计考虑不全等，这很正常，产品经理应该迅速采取行动，在维持产品基本功能的基础上、尽量避免修改的原则上，拿出解决方案。\n\n## 招聘产品经理\n\n### 寻找出色的产品经理\n\n1. 个人素质和态度\n\n2. 对产品的热情\n\n3. 用户立场\n\n4. 智力\n\n5. 职业操守\n\n6. 正直\n\n7. 信心\n\n8. 态度\n\n9. 技能\n\n10. 运用技术的能力\n\n11. 注意力\n\n\n12. 时间管理\n\n13. 沟通技巧\n\n14. 商业技能\n\n## 管理产品经理\n\n产品总监的关键职责有两方面。第一，组建优秀的产品经理团队。第二，规划公司的全局产品战略，对产品组合负责。\n\n### 建设产品管理团队\n\n### 规划公司的产品战略\n\n## 管理上司\n\n1. 为项目波动做好准备\n\n2. 注意沟通的方式与频率\n\n3. 会签沟通\n\n4. 多提建议，少谈问题\n\n5. 向上司借力\n\n6. 充分准备\n\n7. 缩短邮件篇幅\n\n8. 多用数据和事实说话\n\n9. 内部宣传\n\n10. 做让领导省心的员工\n\n# 流程\n\n该部分向我们讨论了怎么探索及开发富有创意的产品时反复应用的流程和成功的实践经验。\n\n确定产品原则-->产品评审团-->市场调研-->PRD-->基本产品-->产品验证-->改进产品-->敏捷开发（瀑布式开发）\n\n## 评估产品机会\n\n### 确定待解决的问题\n\n评估产品机会时产品经理的重要职责。评估产品机会的目的在于：淘汰馊主意，避免浪费时间和金钱。\n\n为了评估产品机会，产品经理需要回答如下十个问题：\n\n1. 产品要解决什么问题？（产品价值）\n\n2. 为谁解决问题？（目标市场）\n\n3. 成功的机会有多大？（市场规模）\n\n4. 怎么样判断产品成功与否？（度量指标或收益指标）\n\n5. 有哪些同类产品？（竞争格局）\n\n6. 为什么我们最适合做这个产品？（竞争优势）\n\n7. 时机合适吗？（市场时机）\n\n8. 如何把产品推向市场？（营销组合策略）\n\n9. 成功的必要条件是什么？（解决方法要满足的条件）\n\n10. 根据以上问题，给出评论结论。（继续或放弃）\n\n## 产品探索\n\n### 定义正确的产品\n\n软件项目可以划分为两个阶段：弄清楚要开发什么产品（定义正确的产品）；开发该产品（正确的开发产品）。第一阶段探索产品，第二阶段则强调执行。\n\n首先，产品经理应该探索是否有用户需要产品，也就是，要寻找市场，让用户验证你的构思。\n\n其次，产品经理要探索能够解决问题的产品方案，他必须是有价值的，可用的，可行的，也就是说要设计解决方案，请用户和开发团队来验证。\n\n## 产品原则\n\n### 确定什么最重要\n\n产品原则是对团队信仰和价值观的总结，用来指导产品团队做出正确的取舍和决策。它体现了产品团队的目标和愿景，是产品战略的重要组成部分。从形式上看，他是一系列明确的、体现团队特色的产品价值准则。\n\n关于争论的原因：\n\n1. 每位同属对公司的产品都有自己的看法\n\n2. 大家都十分在乎产品，明白公司盈利需要靠用户，只有产品才能吸引用户\n\n3. 许多人都认为自己比其他人更了解目标用户\n\n所以我们需要在一下几点达成共识：\n\n1. 究竟要解决什么问题？\n\n2. 要为哪些人物角色解决这个问题？\n\n3. 产品要达到什么目标？\n\n4. 每项目标的优先级是什么？\n\n在我看来，每当团队内出现严重的意见分歧的时候，并非大家对事实的认定有争议，而是对目标和目标的优先级有不同的理解。\n\n比如说，团队应该确定哪个目标对用户最重要，是易用性，响应速度、功能、成本、安全性还是用户隐私？只有先统一从产品目标和目标优先级的认识，大家在此共识上进一步讨论的各种方案的合理性。\n\n## 产品评审团\n\n职责：监督产品研发流程，制定关键决策。\n\n## 特约用户\n\n**示范性的应用程序**\n\n## 市场调研\n\n## 市场调研的作用\n\n1. 用户调查\n\n2. 产品使用分析\n\n3. 数据挖掘\n\n4. 拜访用户\n\n5. 人物角色\n\n6. 可用性测试\n\n7. 同类产品分析\n\n市场调研的结果可以作为研发产品的依据和参考，但不能决定产品研发的方向。\n\n探索产品的过程则要回答如下问题：\n\n1. 采用什么技术来更好地解决产品要解决的问题？\n\n2. 设计什么样的用户体验？\n\n成功的产品基于以下两点认识：深入理解用户需求，以及明白什么样的解决方案在现阶段是可行的。\n\n## 产品人物角色\n\n## 重新定义产品说明文档\n\n## 用户体验设计与实现\n\n先定义用户体验再动手开发\n\n敏捷方法里有个概念叫“第零次迭代”，产品经理和用户体验设计师利用这段时间先完成产品设计工作，然后交由开发人员开始迭代开发。\n\n## 基本产品\n\n## 产品验证\n\n证明产品的价值、可用性和可行性\n\n产品验证是指在正式开发、部署产品前，验证产品说明文档描述的产品是否符合预期要求。\n\n**可行性测试**\n\n**可用性测试**\n\n**价值测试**\n\n## 原型测试\n\n## 改进现有产品\n\n**不是一味地添加功能**\n\n## 平滑部署\n\n避免更新产品导致用户反感\n\n用户产生反感主要有以下几个原因：\n\n1. 事前没有收到更新通知，\n\n2. 用户没有时间学习，适应新版本，产品公司也没有提供旧版本方便用户在过渡阶段的使用\n\n3. 新版本无法正常运行\n\n4. 新旧版本不兼容\n\n5. 新添加的功能和特性毫无必要\n\n## 快速响应阶段\n\n## 合理运用敏捷方法\n\n敏捷方法（包括Scrum和极限编程）有很多优点，但这类方法原值定制软件领域，不完全适用于开发产品软件。\n\n## 合理运用瀑布式开发方法\n\n瀑布式开发方法（持续改进方法、里程碑式开发方法）的基本原则：\n\n1. 采用阶段式开发\n\n2. 采用阶段式评审\n\n存在的问题：\n\n1. 产品验证严重滞回\n\n2. 变更计划代价不菲\n\n3. 无法适应快速的市场变化\n\n## 创业型公司的产品经理\n\n**关键在于产品探索**\n\n## 大公司如何创新\n\n**有困难，但值得一试**\n\n企业文化和老板观念是创新的氛围的两大影响因素。\n\n**20%法则**\n\n**臭鼬工程**\n\n**主动观察**\n\n**改善用户体验**\n\n**收购小公司**\n\n## 在大公司施展拳脚\n\n**十大秘诀**\n\n大公司尽量规避风险，矩阵式管理方式，节约公司的运营成本。\n\n1. 了解公司制定决策的方式\n\n2. 建立人脉网络\n\n3. 臭鼬工程\n\n4. 自己顶上\n\n5. 有选择的据理力争\n\n6. 会前沟通，形成默契\n\n7. 合理分配时间\n\n8. 分享信息\n\n9. 向上司借力\n\n10. 传播你的产品理念\n\n**大部分人游荡在黑暗里，他们只知道抱怨，缺从不想办法寻找开关。**\n\n# 产品\n\n\n## 苹果公司给我的启示\n\n苹果值得学习的优秀经验：\n\n1. 硬件为软件服务\n\n2. 软件为用户体验服务\n\n3. 用户体验为情感服务\n\n4. 产品为真正的需求服务\n\n## 提防有特殊需求的产品\n\n特例产品混淆了客户需求和产品需求，必然会使公司偏离正轨。\n\n产品原则决定了是否接受客户提出的特殊要求。\n\n## 新瓶装老酒\n\n如何在成熟的市场上抢的一席之地？\n\n第一：对目标市场了如指掌，对现有产品的缺陷洞若观火。我喜欢通过产品可用性测试掌握产品情况（包括自己的产品和竞争对手的产品）\n\n第二：跟踪最新的技术趋势。新技术层出不穷，让之前无法实现的方案变得可能。\n\n优秀的产品经理应该抓住现有技术与用户需求的契合点。\n\n## 恐惧、贪婪、欲望\n\n**产品中情感的作用**\n\n消费者购买产品大多属于情感需求。\n\n## 情感接纳曲线\n\n技术接纳曲线\n\n情感接纳曲线\n\n根据消费者的情感特征，把他们分为技术爱好者，非理性消费者，理性消费者，超理性消费者和观望者。\n\n1. 关注用户的不满情绪？\n\n愤怒的用户决定着产品未来的发展方向。\n\n## 可用性与美感\n\n两者缺一不可。\n\n## 大众网络服务产品\n\n十大要点：\n\n1. 可用性\n\n2. 人物角色\n\n3. 扩展性\n\n4. 持续可用性\n\n5. 客户服务\n\n6. 保护用户隐私\n\n7. 口碑营销\n\n8. 全球化\n\n9.平滑部署\n\n10.用户社区管理\n\n## 打造企业级产品的经验\n\n企业级产品判断的标准：软件的销售对象和软件的类型\n\n企业级软件的销售对象主要是企业，类型主要包括企业基础软件（安全软件，系统管理软件，通信软件）和企业应用软件（营销自动化软件，客户关系管理软件，企业资源计划软件）。\n\n1. 可用性\n\n2. 产品正常工作\n\n3. 特例产品\n\n4. 特约用户\n\n5. 销售渠道的需求\n\n6. 客户和用户的需求\n\n7. 产品安装 \n\n8. 产品的配置、自定义和集成\n\n9. 产品升级\n\n10. 销售策略\n\n\n合格软件产品具备的特征：\n\n1. 产品具有价值，用户愿意掏钱购买产品。\n\n2. 产品可以在多种环境下运行，不是定制软件\n\n3. 只要提供必要的销售工具和销售培训，产品就可以通过销售渠道顺利销售出去。\n\n4. 产品公司能够为该产品提供支持，不断完善产品\n\n5. 经销商、服务合作伙伴，客户明白如何安装，配置和使用产品。\n\n专用解决方案除了以上描述的产品特征外，还应具备以下特征：\n\n1. 软件可以帮助企业解决业务问题，通常是特定（垂直）的行业问题\n\n2. 产品可能由一个或多个组件整合而成，组件可以有本公司或者合作方开发\n\n3. 必要时，产品应该获得合作方的产品认证\n\n专用方案直接解决企业的业务问题。\n\n## 打造平台级的产品经验\n\n平台产品：一类基础软件，应用开发者在其基础上开发应用程序。\n\n平台产品需要们面对不同的客户：\n\n1. 应用软件开发商\n\n2. 开发人员\n\n3. 终端用户\n\n# 总结\n\n## 最佳实践经验\n\n** =十大要点**\n\n1. 产品管理的职责  许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活。\n\n2. 用户体验  对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造有实用价值的产品。\n\n3. 机会评估  用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准。\n\n4. 特约用户  有些产品团队企图绕过用户，直接设计、开发产品，这种想法可笑至极。打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。\n\n5. 产品原则  产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策。\n\n6. 人物角色  人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据。\n\n7. 探索（定义）产品  产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。\n\n8. 使用原型  使用高保真原型是探索（定义）产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计思路。\n\n9. 用户参与原型测试  有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。\n\n10. 根据数据改进产品  成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。\n\n\n## 产品经理的反省清单\n\n**十大问题**\n\n出色的产品经理会时刻关注产品的现状与未来。以下是产品经理无时无刻不在思考的问题。\n\n1. 产品能吸引目标消费者的关注吗？\n\n2. 产品的设计是否人性化，是否易于操作？\n\n3. 产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？\n\n4. 我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？\n\n5. 产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？\n\n6. 产品能正常运行吗？\n\n7. 产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？\n\n8. 产品的特色是否与目标用户的需求一致？产品特色是否鲜明？\n\n9. 产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？\n\n10. 我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2019-inspired","published":1,"updated":"2019-09-30T01:38:39.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbg001g2wvcmstubsg3","content":"<h1 id=\"启示录\"><a href=\"#启示录\" class=\"headerlink\" title=\"启示录\"></a>启示录</h1><hr>\n<p>本文的结构，人员、流程、产品。</p>\n<p>人员是指负责定义和开发产品的团队成员的角色和职责。</p>\n<p>流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。</p>\n<p>产品是指富有创意的产品具有的鲜明特性。</p>\n<h1 id=\"人员\"><a href=\"#人员\" class=\"headerlink\" title=\"人员\"></a>人员</h1><p>这一部分作者通过介绍产品经理与项目经理、营销人员、设计、开发人员的联系和区别，向我们阐述产品经理的主要的职责就是：定义产品机会和定义要开发的产品。最后向我们介绍了怎么和上司交流，怎么管理自己，产品经理需要具备的素质等。</p>\n<h2 id=\"关键角色和职责\"><a href=\"#关键角色和职责\" class=\"headerlink\" title=\"关键角色和职责\"></a>关键角色和职责</h2><h3 id=\"产品经理\"><a href=\"#产品经理\" class=\"headerlink\" title=\"产品经理\"></a>产品经理</h3><p>产品经理的主要职责分为两项：评估产品机会和定义要开发的产品。</p>\n<p>产品需求的来源：</p>\n<ol>\n<li><p>boss的要求</p>\n</li>\n<li><p>用户的反馈</p>\n</li>\n<li><p>PM团队对自身产品的重构和分析</p>\n</li>\n<li><p>团队其他成员（运营，开发，销售、UI）对产品的反馈</p>\n</li>\n<li><p>数据分析，测试的结果</p>\n</li>\n</ol>\n<h3 id=\"用户体验设计师\"><a href=\"#用户体验设计师\" class=\"headerlink\" title=\"用户体验设计师\"></a>用户体验设计师</h3><p>交互设计师负责深入理解目标用户，设计有价值的、可用的功能，以及用户的导航和产品的使用流程。交互设计师和产品经理密切合作，将功能与设计相结合，满足用户需求。目标是确保同时具有可用性和价值。可用性指的是用户明白如何使用产品，价值指的是用户对产品的渴求程度。</p>\n<h3 id=\"项目管理人员\"><a href=\"#项目管理人员\" class=\"headerlink\" title=\"项目管理人员\"></a>项目管理人员</h3><p>核心任务是制定计划和跟踪进度。</p>\n<h3 id=\"开发团队\"><a href=\"#开发团队\" class=\"headerlink\" title=\"开发团队\"></a>开发团队</h3><h3 id=\"运维团队\"><a href=\"#运维团队\" class=\"headerlink\" title=\"运维团队\"></a>运维团队</h3><h3 id=\"产品营销人员\"><a href=\"#产品营销人员\" class=\"headerlink\" title=\"产品营销人员\"></a>产品营销人员</h3><p>对外发布产品，宣传产品，促进产品销售提供支持</p>\n<h2 id=\"产品管理和营销\"><a href=\"#产品管理和营销\" class=\"headerlink\" title=\"产品管理和营销\"></a>产品管理和营销</h2><p>产品经理的工作是从细节上定义开发团队开发什么产品，市场营销的职责是对外宣传产品。</p>\n<h2 id=\"产品管理和项目管理\"><a href=\"#产品管理和项目管理\" class=\"headerlink\" title=\"产品管理和项目管理\"></a>产品管理和项目管理</h2><p>项目管理关注如何执行计划以按期交付产品。</p>\n<p>项目经理的七个优点：</p>\n<ol>\n<li><p>工作的紧迫感</p>\n</li>\n<li><p>善于捕捉问题</p>\n</li>\n<li><p>思路清晰</p>\n</li>\n<li><p>用数据说话</p>\n</li>\n<li><p>果断</p>\n</li>\n<li><p>判断力</p>\n</li>\n<li><p>态度</p>\n</li>\n</ol>\n<h2 id=\"产品管理和产品设计\"><a href=\"#产品管理和产品设计\" class=\"headerlink\" title=\"产品管理和产品设计\"></a>产品管理和产品设计</h2><p>与用户体验设计密切相关的分工：</p>\n<ol>\n<li><p>用户研究：专门研究、分析用户，评估产品或原型是否符合特定用户的使用习惯。</p>\n</li>\n<li><p>交互设计</p>\n</li>\n<li><p>视觉设计</p>\n</li>\n<li><p>原型制作 </p>\n</li>\n</ol>\n<h2 id=\"产品管理和软件开发\"><a href=\"#产品管理和软件开发\" class=\"headerlink\" title=\"产品管理和软件开发\"></a>产品管理和软件开发</h2><p>定义正确的产品和正确的开发产品。</p>\n<p>开发人员帮助产品经理完善产品定义的方式：</p>\n<ol>\n<li><p>让开发人员直接面对用户或者顾客，体会用户的困惑和疑虑，了解问题的严重性。可以邀请开发人员参与原型测试。</p>\n</li>\n<li><p>向开发人员了解最新的技术发展动向，讨论那些技术可以用到产品里。</p>\n</li>\n<li><p>让开发人员在探索产品的初期阶段参与评估产品设计，协助策划方案。</p>\n</li>\n</ol>\n<p>产品经理应该配合开发人员的工作，方式如下：</p>\n<ol>\n<li><p>产品经理只负责定义满足基本需求的产品，产品经理应该意识到，自己定义的不是最终的产品，而是满足基本需求的产品。</p>\n</li>\n<li><p>一旦进入产品开发阶段，要尽可能的避免修改产品的需求和设计。</p>\n</li>\n<li><p>产品开发阶段难免会产生诸多的问题，比如用例丢失，用例设计考虑不全等，这很正常，产品经理应该迅速采取行动，在维持产品基本功能的基础上、尽量避免修改的原则上，拿出解决方案。</p>\n</li>\n</ol>\n<h2 id=\"招聘产品经理\"><a href=\"#招聘产品经理\" class=\"headerlink\" title=\"招聘产品经理\"></a>招聘产品经理</h2><h3 id=\"寻找出色的产品经理\"><a href=\"#寻找出色的产品经理\" class=\"headerlink\" title=\"寻找出色的产品经理\"></a>寻找出色的产品经理</h3><ol>\n<li><p>个人素质和态度</p>\n</li>\n<li><p>对产品的热情</p>\n</li>\n<li><p>用户立场</p>\n</li>\n<li><p>智力</p>\n</li>\n<li><p>职业操守</p>\n</li>\n<li><p>正直</p>\n</li>\n<li><p>信心</p>\n</li>\n<li><p>态度</p>\n</li>\n<li><p>技能</p>\n</li>\n<li><p>运用技术的能力</p>\n</li>\n<li><p>注意力</p>\n</li>\n</ol>\n<ol start=\"12\">\n<li><p>时间管理</p>\n</li>\n<li><p>沟通技巧</p>\n</li>\n<li><p>商业技能</p>\n</li>\n</ol>\n<h2 id=\"管理产品经理\"><a href=\"#管理产品经理\" class=\"headerlink\" title=\"管理产品经理\"></a>管理产品经理</h2><p>产品总监的关键职责有两方面。第一，组建优秀的产品经理团队。第二，规划公司的全局产品战略，对产品组合负责。</p>\n<h3 id=\"建设产品管理团队\"><a href=\"#建设产品管理团队\" class=\"headerlink\" title=\"建设产品管理团队\"></a>建设产品管理团队</h3><h3 id=\"规划公司的产品战略\"><a href=\"#规划公司的产品战略\" class=\"headerlink\" title=\"规划公司的产品战略\"></a>规划公司的产品战略</h3><h2 id=\"管理上司\"><a href=\"#管理上司\" class=\"headerlink\" title=\"管理上司\"></a>管理上司</h2><ol>\n<li><p>为项目波动做好准备</p>\n</li>\n<li><p>注意沟通的方式与频率</p>\n</li>\n<li><p>会签沟通</p>\n</li>\n<li><p>多提建议，少谈问题</p>\n</li>\n<li><p>向上司借力</p>\n</li>\n<li><p>充分准备</p>\n</li>\n<li><p>缩短邮件篇幅</p>\n</li>\n<li><p>多用数据和事实说话</p>\n</li>\n<li><p>内部宣传</p>\n</li>\n<li><p>做让领导省心的员工</p>\n</li>\n</ol>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><p>该部分向我们讨论了怎么探索及开发富有创意的产品时反复应用的流程和成功的实践经验。</p>\n<p>确定产品原则–&gt;产品评审团–&gt;市场调研–&gt;PRD–&gt;基本产品–&gt;产品验证–&gt;改进产品–&gt;敏捷开发（瀑布式开发）</p>\n<h2 id=\"评估产品机会\"><a href=\"#评估产品机会\" class=\"headerlink\" title=\"评估产品机会\"></a>评估产品机会</h2><h3 id=\"确定待解决的问题\"><a href=\"#确定待解决的问题\" class=\"headerlink\" title=\"确定待解决的问题\"></a>确定待解决的问题</h3><p>评估产品机会时产品经理的重要职责。评估产品机会的目的在于：淘汰馊主意，避免浪费时间和金钱。</p>\n<p>为了评估产品机会，产品经理需要回答如下十个问题：</p>\n<ol>\n<li><p>产品要解决什么问题？（产品价值）</p>\n</li>\n<li><p>为谁解决问题？（目标市场）</p>\n</li>\n<li><p>成功的机会有多大？（市场规模）</p>\n</li>\n<li><p>怎么样判断产品成功与否？（度量指标或收益指标）</p>\n</li>\n<li><p>有哪些同类产品？（竞争格局）</p>\n</li>\n<li><p>为什么我们最适合做这个产品？（竞争优势）</p>\n</li>\n<li><p>时机合适吗？（市场时机）</p>\n</li>\n<li><p>如何把产品推向市场？（营销组合策略）</p>\n</li>\n<li><p>成功的必要条件是什么？（解决方法要满足的条件）</p>\n</li>\n<li><p>根据以上问题，给出评论结论。（继续或放弃）</p>\n</li>\n</ol>\n<h2 id=\"产品探索\"><a href=\"#产品探索\" class=\"headerlink\" title=\"产品探索\"></a>产品探索</h2><h3 id=\"定义正确的产品\"><a href=\"#定义正确的产品\" class=\"headerlink\" title=\"定义正确的产品\"></a>定义正确的产品</h3><p>软件项目可以划分为两个阶段：弄清楚要开发什么产品（定义正确的产品）；开发该产品（正确的开发产品）。第一阶段探索产品，第二阶段则强调执行。</p>\n<p>首先，产品经理应该探索是否有用户需要产品，也就是，要寻找市场，让用户验证你的构思。</p>\n<p>其次，产品经理要探索能够解决问题的产品方案，他必须是有价值的，可用的，可行的，也就是说要设计解决方案，请用户和开发团队来验证。</p>\n<h2 id=\"产品原则\"><a href=\"#产品原则\" class=\"headerlink\" title=\"产品原则\"></a>产品原则</h2><h3 id=\"确定什么最重要\"><a href=\"#确定什么最重要\" class=\"headerlink\" title=\"确定什么最重要\"></a>确定什么最重要</h3><p>产品原则是对团队信仰和价值观的总结，用来指导产品团队做出正确的取舍和决策。它体现了产品团队的目标和愿景，是产品战略的重要组成部分。从形式上看，他是一系列明确的、体现团队特色的产品价值准则。</p>\n<p>关于争论的原因：</p>\n<ol>\n<li><p>每位同属对公司的产品都有自己的看法</p>\n</li>\n<li><p>大家都十分在乎产品，明白公司盈利需要靠用户，只有产品才能吸引用户</p>\n</li>\n<li><p>许多人都认为自己比其他人更了解目标用户</p>\n</li>\n</ol>\n<p>所以我们需要在一下几点达成共识：</p>\n<ol>\n<li><p>究竟要解决什么问题？</p>\n</li>\n<li><p>要为哪些人物角色解决这个问题？</p>\n</li>\n<li><p>产品要达到什么目标？</p>\n</li>\n<li><p>每项目标的优先级是什么？</p>\n</li>\n</ol>\n<p>在我看来，每当团队内出现严重的意见分歧的时候，并非大家对事实的认定有争议，而是对目标和目标的优先级有不同的理解。</p>\n<p>比如说，团队应该确定哪个目标对用户最重要，是易用性，响应速度、功能、成本、安全性还是用户隐私？只有先统一从产品目标和目标优先级的认识，大家在此共识上进一步讨论的各种方案的合理性。</p>\n<h2 id=\"产品评审团\"><a href=\"#产品评审团\" class=\"headerlink\" title=\"产品评审团\"></a>产品评审团</h2><p>职责：监督产品研发流程，制定关键决策。</p>\n<h2 id=\"特约用户\"><a href=\"#特约用户\" class=\"headerlink\" title=\"特约用户\"></a>特约用户</h2><p><strong>示范性的应用程序</strong></p>\n<h2 id=\"市场调研\"><a href=\"#市场调研\" class=\"headerlink\" title=\"市场调研\"></a>市场调研</h2><h2 id=\"市场调研的作用\"><a href=\"#市场调研的作用\" class=\"headerlink\" title=\"市场调研的作用\"></a>市场调研的作用</h2><ol>\n<li><p>用户调查</p>\n</li>\n<li><p>产品使用分析</p>\n</li>\n<li><p>数据挖掘</p>\n</li>\n<li><p>拜访用户</p>\n</li>\n<li><p>人物角色</p>\n</li>\n<li><p>可用性测试</p>\n</li>\n<li><p>同类产品分析</p>\n</li>\n</ol>\n<p>市场调研的结果可以作为研发产品的依据和参考，但不能决定产品研发的方向。</p>\n<p>探索产品的过程则要回答如下问题：</p>\n<ol>\n<li><p>采用什么技术来更好地解决产品要解决的问题？</p>\n</li>\n<li><p>设计什么样的用户体验？</p>\n</li>\n</ol>\n<p>成功的产品基于以下两点认识：深入理解用户需求，以及明白什么样的解决方案在现阶段是可行的。</p>\n<h2 id=\"产品人物角色\"><a href=\"#产品人物角色\" class=\"headerlink\" title=\"产品人物角色\"></a>产品人物角色</h2><h2 id=\"重新定义产品说明文档\"><a href=\"#重新定义产品说明文档\" class=\"headerlink\" title=\"重新定义产品说明文档\"></a>重新定义产品说明文档</h2><h2 id=\"用户体验设计与实现\"><a href=\"#用户体验设计与实现\" class=\"headerlink\" title=\"用户体验设计与实现\"></a>用户体验设计与实现</h2><p>先定义用户体验再动手开发</p>\n<p>敏捷方法里有个概念叫“第零次迭代”，产品经理和用户体验设计师利用这段时间先完成产品设计工作，然后交由开发人员开始迭代开发。</p>\n<h2 id=\"基本产品\"><a href=\"#基本产品\" class=\"headerlink\" title=\"基本产品\"></a>基本产品</h2><h2 id=\"产品验证\"><a href=\"#产品验证\" class=\"headerlink\" title=\"产品验证\"></a>产品验证</h2><p>证明产品的价值、可用性和可行性</p>\n<p>产品验证是指在正式开发、部署产品前，验证产品说明文档描述的产品是否符合预期要求。</p>\n<p><strong>可行性测试</strong></p>\n<p><strong>可用性测试</strong></p>\n<p><strong>价值测试</strong></p>\n<h2 id=\"原型测试\"><a href=\"#原型测试\" class=\"headerlink\" title=\"原型测试\"></a>原型测试</h2><h2 id=\"改进现有产品\"><a href=\"#改进现有产品\" class=\"headerlink\" title=\"改进现有产品\"></a>改进现有产品</h2><p><strong>不是一味地添加功能</strong></p>\n<h2 id=\"平滑部署\"><a href=\"#平滑部署\" class=\"headerlink\" title=\"平滑部署\"></a>平滑部署</h2><p>避免更新产品导致用户反感</p>\n<p>用户产生反感主要有以下几个原因：</p>\n<ol>\n<li><p>事前没有收到更新通知，</p>\n</li>\n<li><p>用户没有时间学习，适应新版本，产品公司也没有提供旧版本方便用户在过渡阶段的使用</p>\n</li>\n<li><p>新版本无法正常运行</p>\n</li>\n<li><p>新旧版本不兼容</p>\n</li>\n<li><p>新添加的功能和特性毫无必要</p>\n</li>\n</ol>\n<h2 id=\"快速响应阶段\"><a href=\"#快速响应阶段\" class=\"headerlink\" title=\"快速响应阶段\"></a>快速响应阶段</h2><h2 id=\"合理运用敏捷方法\"><a href=\"#合理运用敏捷方法\" class=\"headerlink\" title=\"合理运用敏捷方法\"></a>合理运用敏捷方法</h2><p>敏捷方法（包括Scrum和极限编程）有很多优点，但这类方法原值定制软件领域，不完全适用于开发产品软件。</p>\n<h2 id=\"合理运用瀑布式开发方法\"><a href=\"#合理运用瀑布式开发方法\" class=\"headerlink\" title=\"合理运用瀑布式开发方法\"></a>合理运用瀑布式开发方法</h2><p>瀑布式开发方法（持续改进方法、里程碑式开发方法）的基本原则：</p>\n<ol>\n<li><p>采用阶段式开发</p>\n</li>\n<li><p>采用阶段式评审</p>\n</li>\n</ol>\n<p>存在的问题：</p>\n<ol>\n<li><p>产品验证严重滞回</p>\n</li>\n<li><p>变更计划代价不菲</p>\n</li>\n<li><p>无法适应快速的市场变化</p>\n</li>\n</ol>\n<h2 id=\"创业型公司的产品经理\"><a href=\"#创业型公司的产品经理\" class=\"headerlink\" title=\"创业型公司的产品经理\"></a>创业型公司的产品经理</h2><p><strong>关键在于产品探索</strong></p>\n<h2 id=\"大公司如何创新\"><a href=\"#大公司如何创新\" class=\"headerlink\" title=\"大公司如何创新\"></a>大公司如何创新</h2><p><strong>有困难，但值得一试</strong></p>\n<p>企业文化和老板观念是创新的氛围的两大影响因素。</p>\n<p><strong>20%法则</strong></p>\n<p><strong>臭鼬工程</strong></p>\n<p><strong>主动观察</strong></p>\n<p><strong>改善用户体验</strong></p>\n<p><strong>收购小公司</strong></p>\n<h2 id=\"在大公司施展拳脚\"><a href=\"#在大公司施展拳脚\" class=\"headerlink\" title=\"在大公司施展拳脚\"></a>在大公司施展拳脚</h2><p><strong>十大秘诀</strong></p>\n<p>大公司尽量规避风险，矩阵式管理方式，节约公司的运营成本。</p>\n<ol>\n<li><p>了解公司制定决策的方式</p>\n</li>\n<li><p>建立人脉网络</p>\n</li>\n<li><p>臭鼬工程</p>\n</li>\n<li><p>自己顶上</p>\n</li>\n<li><p>有选择的据理力争</p>\n</li>\n<li><p>会前沟通，形成默契</p>\n</li>\n<li><p>合理分配时间</p>\n</li>\n<li><p>分享信息</p>\n</li>\n<li><p>向上司借力</p>\n</li>\n<li><p>传播你的产品理念</p>\n</li>\n</ol>\n<p><strong>大部分人游荡在黑暗里，他们只知道抱怨，缺从不想办法寻找开关。</strong></p>\n<h1 id=\"产品\"><a href=\"#产品\" class=\"headerlink\" title=\"产品\"></a>产品</h1><h2 id=\"苹果公司给我的启示\"><a href=\"#苹果公司给我的启示\" class=\"headerlink\" title=\"苹果公司给我的启示\"></a>苹果公司给我的启示</h2><p>苹果值得学习的优秀经验：</p>\n<ol>\n<li><p>硬件为软件服务</p>\n</li>\n<li><p>软件为用户体验服务</p>\n</li>\n<li><p>用户体验为情感服务</p>\n</li>\n<li><p>产品为真正的需求服务</p>\n</li>\n</ol>\n<h2 id=\"提防有特殊需求的产品\"><a href=\"#提防有特殊需求的产品\" class=\"headerlink\" title=\"提防有特殊需求的产品\"></a>提防有特殊需求的产品</h2><p>特例产品混淆了客户需求和产品需求，必然会使公司偏离正轨。</p>\n<p>产品原则决定了是否接受客户提出的特殊要求。</p>\n<h2 id=\"新瓶装老酒\"><a href=\"#新瓶装老酒\" class=\"headerlink\" title=\"新瓶装老酒\"></a>新瓶装老酒</h2><p>如何在成熟的市场上抢的一席之地？</p>\n<p>第一：对目标市场了如指掌，对现有产品的缺陷洞若观火。我喜欢通过产品可用性测试掌握产品情况（包括自己的产品和竞争对手的产品）</p>\n<p>第二：跟踪最新的技术趋势。新技术层出不穷，让之前无法实现的方案变得可能。</p>\n<p>优秀的产品经理应该抓住现有技术与用户需求的契合点。</p>\n<h2 id=\"恐惧、贪婪、欲望\"><a href=\"#恐惧、贪婪、欲望\" class=\"headerlink\" title=\"恐惧、贪婪、欲望\"></a>恐惧、贪婪、欲望</h2><p><strong>产品中情感的作用</strong></p>\n<p>消费者购买产品大多属于情感需求。</p>\n<h2 id=\"情感接纳曲线\"><a href=\"#情感接纳曲线\" class=\"headerlink\" title=\"情感接纳曲线\"></a>情感接纳曲线</h2><p>技术接纳曲线</p>\n<p>情感接纳曲线</p>\n<p>根据消费者的情感特征，把他们分为技术爱好者，非理性消费者，理性消费者，超理性消费者和观望者。</p>\n<ol>\n<li>关注用户的不满情绪？</li>\n</ol>\n<p>愤怒的用户决定着产品未来的发展方向。</p>\n<h2 id=\"可用性与美感\"><a href=\"#可用性与美感\" class=\"headerlink\" title=\"可用性与美感\"></a>可用性与美感</h2><p>两者缺一不可。</p>\n<h2 id=\"大众网络服务产品\"><a href=\"#大众网络服务产品\" class=\"headerlink\" title=\"大众网络服务产品\"></a>大众网络服务产品</h2><p>十大要点：</p>\n<ol>\n<li><p>可用性</p>\n</li>\n<li><p>人物角色</p>\n</li>\n<li><p>扩展性</p>\n</li>\n<li><p>持续可用性</p>\n</li>\n<li><p>客户服务</p>\n</li>\n<li><p>保护用户隐私</p>\n</li>\n<li><p>口碑营销</p>\n</li>\n<li><p>全球化</p>\n</li>\n</ol>\n<p>9.平滑部署</p>\n<p>10.用户社区管理</p>\n<h2 id=\"打造企业级产品的经验\"><a href=\"#打造企业级产品的经验\" class=\"headerlink\" title=\"打造企业级产品的经验\"></a>打造企业级产品的经验</h2><p>企业级产品判断的标准：软件的销售对象和软件的类型</p>\n<p>企业级软件的销售对象主要是企业，类型主要包括企业基础软件（安全软件，系统管理软件，通信软件）和企业应用软件（营销自动化软件，客户关系管理软件，企业资源计划软件）。</p>\n<ol>\n<li><p>可用性</p>\n</li>\n<li><p>产品正常工作</p>\n</li>\n<li><p>特例产品</p>\n</li>\n<li><p>特约用户</p>\n</li>\n<li><p>销售渠道的需求</p>\n</li>\n<li><p>客户和用户的需求</p>\n</li>\n<li><p>产品安装 </p>\n</li>\n<li><p>产品的配置、自定义和集成</p>\n</li>\n<li><p>产品升级</p>\n</li>\n<li><p>销售策略</p>\n</li>\n</ol>\n<p>合格软件产品具备的特征：</p>\n<ol>\n<li><p>产品具有价值，用户愿意掏钱购买产品。</p>\n</li>\n<li><p>产品可以在多种环境下运行，不是定制软件</p>\n</li>\n<li><p>只要提供必要的销售工具和销售培训，产品就可以通过销售渠道顺利销售出去。</p>\n</li>\n<li><p>产品公司能够为该产品提供支持，不断完善产品</p>\n</li>\n<li><p>经销商、服务合作伙伴，客户明白如何安装，配置和使用产品。</p>\n</li>\n</ol>\n<p>专用解决方案除了以上描述的产品特征外，还应具备以下特征：</p>\n<ol>\n<li><p>软件可以帮助企业解决业务问题，通常是特定（垂直）的行业问题</p>\n</li>\n<li><p>产品可能由一个或多个组件整合而成，组件可以有本公司或者合作方开发</p>\n</li>\n<li><p>必要时，产品应该获得合作方的产品认证</p>\n</li>\n</ol>\n<p>专用方案直接解决企业的业务问题。</p>\n<h2 id=\"打造平台级的产品经验\"><a href=\"#打造平台级的产品经验\" class=\"headerlink\" title=\"打造平台级的产品经验\"></a>打造平台级的产品经验</h2><p>平台产品：一类基础软件，应用开发者在其基础上开发应用程序。</p>\n<p>平台产品需要们面对不同的客户：</p>\n<ol>\n<li><p>应用软件开发商</p>\n</li>\n<li><p>开发人员</p>\n</li>\n<li><p>终端用户</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"最佳实践经验\"><a href=\"#最佳实践经验\" class=\"headerlink\" title=\"最佳实践经验\"></a>最佳实践经验</h2><p><em><em> =十大要点</em></em></p>\n<ol>\n<li><p>产品管理的职责  许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活。</p>\n</li>\n<li><p>用户体验  对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造有实用价值的产品。</p>\n</li>\n<li><p>机会评估  用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准。</p>\n</li>\n<li><p>特约用户  有些产品团队企图绕过用户，直接设计、开发产品，这种想法可笑至极。打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。</p>\n</li>\n<li><p>产品原则  产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策。</p>\n</li>\n<li><p>人物角色  人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据。</p>\n</li>\n<li><p>探索（定义）产品  产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。</p>\n</li>\n<li><p>使用原型  使用高保真原型是探索（定义）产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计思路。</p>\n</li>\n<li><p>用户参与原型测试  有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。</p>\n</li>\n<li><p>根据数据改进产品  成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。</p>\n</li>\n</ol>\n<h2 id=\"产品经理的反省清单\"><a href=\"#产品经理的反省清单\" class=\"headerlink\" title=\"产品经理的反省清单\"></a>产品经理的反省清单</h2><p><strong>十大问题</strong></p>\n<p>出色的产品经理会时刻关注产品的现状与未来。以下是产品经理无时无刻不在思考的问题。</p>\n<ol>\n<li><p>产品能吸引目标消费者的关注吗？</p>\n</li>\n<li><p>产品的设计是否人性化，是否易于操作？</p>\n</li>\n<li><p>产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？</p>\n</li>\n<li><p>我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？</p>\n</li>\n<li><p>产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？</p>\n</li>\n<li><p>产品能正常运行吗？</p>\n</li>\n<li><p>产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？</p>\n</li>\n<li><p>产品的特色是否与目标用户的需求一致？产品特色是否鲜明？</p>\n</li>\n<li><p>产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？</p>\n</li>\n<li><p>我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？</p>\n</li>\n</ol>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"启示录\"><a href=\"#启示录\" class=\"headerlink\" title=\"启示录\"></a>启示录</h1><hr>\n<p>本文的结构，人员、流程、产品。</p>\n<p>人员是指负责定义和开发产品的团队成员的角色和职责。</p>\n<p>流程是指探索、开发富有创意的产品时，反复应用的步骤和成功的实践经验。</p>\n<p>产品是指富有创意的产品具有的鲜明特性。</p>\n<h1 id=\"人员\"><a href=\"#人员\" class=\"headerlink\" title=\"人员\"></a>人员</h1><p>这一部分作者通过介绍产品经理与项目经理、营销人员、设计、开发人员的联系和区别，向我们阐述产品经理的主要的职责就是：定义产品机会和定义要开发的产品。最后向我们介绍了怎么和上司交流，怎么管理自己，产品经理需要具备的素质等。</p>\n<h2 id=\"关键角色和职责\"><a href=\"#关键角色和职责\" class=\"headerlink\" title=\"关键角色和职责\"></a>关键角色和职责</h2><h3 id=\"产品经理\"><a href=\"#产品经理\" class=\"headerlink\" title=\"产品经理\"></a>产品经理</h3><p>产品经理的主要职责分为两项：评估产品机会和定义要开发的产品。</p>\n<p>产品需求的来源：</p>\n<ol>\n<li><p>boss的要求</p>\n</li>\n<li><p>用户的反馈</p>\n</li>\n<li><p>PM团队对自身产品的重构和分析</p>\n</li>\n<li><p>团队其他成员（运营，开发，销售、UI）对产品的反馈</p>\n</li>\n<li><p>数据分析，测试的结果</p>\n</li>\n</ol>\n<h3 id=\"用户体验设计师\"><a href=\"#用户体验设计师\" class=\"headerlink\" title=\"用户体验设计师\"></a>用户体验设计师</h3><p>交互设计师负责深入理解目标用户，设计有价值的、可用的功能，以及用户的导航和产品的使用流程。交互设计师和产品经理密切合作，将功能与设计相结合，满足用户需求。目标是确保同时具有可用性和价值。可用性指的是用户明白如何使用产品，价值指的是用户对产品的渴求程度。</p>\n<h3 id=\"项目管理人员\"><a href=\"#项目管理人员\" class=\"headerlink\" title=\"项目管理人员\"></a>项目管理人员</h3><p>核心任务是制定计划和跟踪进度。</p>\n<h3 id=\"开发团队\"><a href=\"#开发团队\" class=\"headerlink\" title=\"开发团队\"></a>开发团队</h3><h3 id=\"运维团队\"><a href=\"#运维团队\" class=\"headerlink\" title=\"运维团队\"></a>运维团队</h3><h3 id=\"产品营销人员\"><a href=\"#产品营销人员\" class=\"headerlink\" title=\"产品营销人员\"></a>产品营销人员</h3><p>对外发布产品，宣传产品，促进产品销售提供支持</p>\n<h2 id=\"产品管理和营销\"><a href=\"#产品管理和营销\" class=\"headerlink\" title=\"产品管理和营销\"></a>产品管理和营销</h2><p>产品经理的工作是从细节上定义开发团队开发什么产品，市场营销的职责是对外宣传产品。</p>\n<h2 id=\"产品管理和项目管理\"><a href=\"#产品管理和项目管理\" class=\"headerlink\" title=\"产品管理和项目管理\"></a>产品管理和项目管理</h2><p>项目管理关注如何执行计划以按期交付产品。</p>\n<p>项目经理的七个优点：</p>\n<ol>\n<li><p>工作的紧迫感</p>\n</li>\n<li><p>善于捕捉问题</p>\n</li>\n<li><p>思路清晰</p>\n</li>\n<li><p>用数据说话</p>\n</li>\n<li><p>果断</p>\n</li>\n<li><p>判断力</p>\n</li>\n<li><p>态度</p>\n</li>\n</ol>\n<h2 id=\"产品管理和产品设计\"><a href=\"#产品管理和产品设计\" class=\"headerlink\" title=\"产品管理和产品设计\"></a>产品管理和产品设计</h2><p>与用户体验设计密切相关的分工：</p>\n<ol>\n<li><p>用户研究：专门研究、分析用户，评估产品或原型是否符合特定用户的使用习惯。</p>\n</li>\n<li><p>交互设计</p>\n</li>\n<li><p>视觉设计</p>\n</li>\n<li><p>原型制作 </p>\n</li>\n</ol>\n<h2 id=\"产品管理和软件开发\"><a href=\"#产品管理和软件开发\" class=\"headerlink\" title=\"产品管理和软件开发\"></a>产品管理和软件开发</h2><p>定义正确的产品和正确的开发产品。</p>\n<p>开发人员帮助产品经理完善产品定义的方式：</p>\n<ol>\n<li><p>让开发人员直接面对用户或者顾客，体会用户的困惑和疑虑，了解问题的严重性。可以邀请开发人员参与原型测试。</p>\n</li>\n<li><p>向开发人员了解最新的技术发展动向，讨论那些技术可以用到产品里。</p>\n</li>\n<li><p>让开发人员在探索产品的初期阶段参与评估产品设计，协助策划方案。</p>\n</li>\n</ol>\n<p>产品经理应该配合开发人员的工作，方式如下：</p>\n<ol>\n<li><p>产品经理只负责定义满足基本需求的产品，产品经理应该意识到，自己定义的不是最终的产品，而是满足基本需求的产品。</p>\n</li>\n<li><p>一旦进入产品开发阶段，要尽可能的避免修改产品的需求和设计。</p>\n</li>\n<li><p>产品开发阶段难免会产生诸多的问题，比如用例丢失，用例设计考虑不全等，这很正常，产品经理应该迅速采取行动，在维持产品基本功能的基础上、尽量避免修改的原则上，拿出解决方案。</p>\n</li>\n</ol>\n<h2 id=\"招聘产品经理\"><a href=\"#招聘产品经理\" class=\"headerlink\" title=\"招聘产品经理\"></a>招聘产品经理</h2><h3 id=\"寻找出色的产品经理\"><a href=\"#寻找出色的产品经理\" class=\"headerlink\" title=\"寻找出色的产品经理\"></a>寻找出色的产品经理</h3><ol>\n<li><p>个人素质和态度</p>\n</li>\n<li><p>对产品的热情</p>\n</li>\n<li><p>用户立场</p>\n</li>\n<li><p>智力</p>\n</li>\n<li><p>职业操守</p>\n</li>\n<li><p>正直</p>\n</li>\n<li><p>信心</p>\n</li>\n<li><p>态度</p>\n</li>\n<li><p>技能</p>\n</li>\n<li><p>运用技术的能力</p>\n</li>\n<li><p>注意力</p>\n</li>\n</ol>\n<ol start=\"12\">\n<li><p>时间管理</p>\n</li>\n<li><p>沟通技巧</p>\n</li>\n<li><p>商业技能</p>\n</li>\n</ol>\n<h2 id=\"管理产品经理\"><a href=\"#管理产品经理\" class=\"headerlink\" title=\"管理产品经理\"></a>管理产品经理</h2><p>产品总监的关键职责有两方面。第一，组建优秀的产品经理团队。第二，规划公司的全局产品战略，对产品组合负责。</p>\n<h3 id=\"建设产品管理团队\"><a href=\"#建设产品管理团队\" class=\"headerlink\" title=\"建设产品管理团队\"></a>建设产品管理团队</h3><h3 id=\"规划公司的产品战略\"><a href=\"#规划公司的产品战略\" class=\"headerlink\" title=\"规划公司的产品战略\"></a>规划公司的产品战略</h3><h2 id=\"管理上司\"><a href=\"#管理上司\" class=\"headerlink\" title=\"管理上司\"></a>管理上司</h2><ol>\n<li><p>为项目波动做好准备</p>\n</li>\n<li><p>注意沟通的方式与频率</p>\n</li>\n<li><p>会签沟通</p>\n</li>\n<li><p>多提建议，少谈问题</p>\n</li>\n<li><p>向上司借力</p>\n</li>\n<li><p>充分准备</p>\n</li>\n<li><p>缩短邮件篇幅</p>\n</li>\n<li><p>多用数据和事实说话</p>\n</li>\n<li><p>内部宣传</p>\n</li>\n<li><p>做让领导省心的员工</p>\n</li>\n</ol>\n<h1 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h1><p>该部分向我们讨论了怎么探索及开发富有创意的产品时反复应用的流程和成功的实践经验。</p>\n<p>确定产品原则–&gt;产品评审团–&gt;市场调研–&gt;PRD–&gt;基本产品–&gt;产品验证–&gt;改进产品–&gt;敏捷开发（瀑布式开发）</p>\n<h2 id=\"评估产品机会\"><a href=\"#评估产品机会\" class=\"headerlink\" title=\"评估产品机会\"></a>评估产品机会</h2><h3 id=\"确定待解决的问题\"><a href=\"#确定待解决的问题\" class=\"headerlink\" title=\"确定待解决的问题\"></a>确定待解决的问题</h3><p>评估产品机会时产品经理的重要职责。评估产品机会的目的在于：淘汰馊主意，避免浪费时间和金钱。</p>\n<p>为了评估产品机会，产品经理需要回答如下十个问题：</p>\n<ol>\n<li><p>产品要解决什么问题？（产品价值）</p>\n</li>\n<li><p>为谁解决问题？（目标市场）</p>\n</li>\n<li><p>成功的机会有多大？（市场规模）</p>\n</li>\n<li><p>怎么样判断产品成功与否？（度量指标或收益指标）</p>\n</li>\n<li><p>有哪些同类产品？（竞争格局）</p>\n</li>\n<li><p>为什么我们最适合做这个产品？（竞争优势）</p>\n</li>\n<li><p>时机合适吗？（市场时机）</p>\n</li>\n<li><p>如何把产品推向市场？（营销组合策略）</p>\n</li>\n<li><p>成功的必要条件是什么？（解决方法要满足的条件）</p>\n</li>\n<li><p>根据以上问题，给出评论结论。（继续或放弃）</p>\n</li>\n</ol>\n<h2 id=\"产品探索\"><a href=\"#产品探索\" class=\"headerlink\" title=\"产品探索\"></a>产品探索</h2><h3 id=\"定义正确的产品\"><a href=\"#定义正确的产品\" class=\"headerlink\" title=\"定义正确的产品\"></a>定义正确的产品</h3><p>软件项目可以划分为两个阶段：弄清楚要开发什么产品（定义正确的产品）；开发该产品（正确的开发产品）。第一阶段探索产品，第二阶段则强调执行。</p>\n<p>首先，产品经理应该探索是否有用户需要产品，也就是，要寻找市场，让用户验证你的构思。</p>\n<p>其次，产品经理要探索能够解决问题的产品方案，他必须是有价值的，可用的，可行的，也就是说要设计解决方案，请用户和开发团队来验证。</p>\n<h2 id=\"产品原则\"><a href=\"#产品原则\" class=\"headerlink\" title=\"产品原则\"></a>产品原则</h2><h3 id=\"确定什么最重要\"><a href=\"#确定什么最重要\" class=\"headerlink\" title=\"确定什么最重要\"></a>确定什么最重要</h3><p>产品原则是对团队信仰和价值观的总结，用来指导产品团队做出正确的取舍和决策。它体现了产品团队的目标和愿景，是产品战略的重要组成部分。从形式上看，他是一系列明确的、体现团队特色的产品价值准则。</p>\n<p>关于争论的原因：</p>\n<ol>\n<li><p>每位同属对公司的产品都有自己的看法</p>\n</li>\n<li><p>大家都十分在乎产品，明白公司盈利需要靠用户，只有产品才能吸引用户</p>\n</li>\n<li><p>许多人都认为自己比其他人更了解目标用户</p>\n</li>\n</ol>\n<p>所以我们需要在一下几点达成共识：</p>\n<ol>\n<li><p>究竟要解决什么问题？</p>\n</li>\n<li><p>要为哪些人物角色解决这个问题？</p>\n</li>\n<li><p>产品要达到什么目标？</p>\n</li>\n<li><p>每项目标的优先级是什么？</p>\n</li>\n</ol>\n<p>在我看来，每当团队内出现严重的意见分歧的时候，并非大家对事实的认定有争议，而是对目标和目标的优先级有不同的理解。</p>\n<p>比如说，团队应该确定哪个目标对用户最重要，是易用性，响应速度、功能、成本、安全性还是用户隐私？只有先统一从产品目标和目标优先级的认识，大家在此共识上进一步讨论的各种方案的合理性。</p>\n<h2 id=\"产品评审团\"><a href=\"#产品评审团\" class=\"headerlink\" title=\"产品评审团\"></a>产品评审团</h2><p>职责：监督产品研发流程，制定关键决策。</p>\n<h2 id=\"特约用户\"><a href=\"#特约用户\" class=\"headerlink\" title=\"特约用户\"></a>特约用户</h2><p><strong>示范性的应用程序</strong></p>\n<h2 id=\"市场调研\"><a href=\"#市场调研\" class=\"headerlink\" title=\"市场调研\"></a>市场调研</h2><h2 id=\"市场调研的作用\"><a href=\"#市场调研的作用\" class=\"headerlink\" title=\"市场调研的作用\"></a>市场调研的作用</h2><ol>\n<li><p>用户调查</p>\n</li>\n<li><p>产品使用分析</p>\n</li>\n<li><p>数据挖掘</p>\n</li>\n<li><p>拜访用户</p>\n</li>\n<li><p>人物角色</p>\n</li>\n<li><p>可用性测试</p>\n</li>\n<li><p>同类产品分析</p>\n</li>\n</ol>\n<p>市场调研的结果可以作为研发产品的依据和参考，但不能决定产品研发的方向。</p>\n<p>探索产品的过程则要回答如下问题：</p>\n<ol>\n<li><p>采用什么技术来更好地解决产品要解决的问题？</p>\n</li>\n<li><p>设计什么样的用户体验？</p>\n</li>\n</ol>\n<p>成功的产品基于以下两点认识：深入理解用户需求，以及明白什么样的解决方案在现阶段是可行的。</p>\n<h2 id=\"产品人物角色\"><a href=\"#产品人物角色\" class=\"headerlink\" title=\"产品人物角色\"></a>产品人物角色</h2><h2 id=\"重新定义产品说明文档\"><a href=\"#重新定义产品说明文档\" class=\"headerlink\" title=\"重新定义产品说明文档\"></a>重新定义产品说明文档</h2><h2 id=\"用户体验设计与实现\"><a href=\"#用户体验设计与实现\" class=\"headerlink\" title=\"用户体验设计与实现\"></a>用户体验设计与实现</h2><p>先定义用户体验再动手开发</p>\n<p>敏捷方法里有个概念叫“第零次迭代”，产品经理和用户体验设计师利用这段时间先完成产品设计工作，然后交由开发人员开始迭代开发。</p>\n<h2 id=\"基本产品\"><a href=\"#基本产品\" class=\"headerlink\" title=\"基本产品\"></a>基本产品</h2><h2 id=\"产品验证\"><a href=\"#产品验证\" class=\"headerlink\" title=\"产品验证\"></a>产品验证</h2><p>证明产品的价值、可用性和可行性</p>\n<p>产品验证是指在正式开发、部署产品前，验证产品说明文档描述的产品是否符合预期要求。</p>\n<p><strong>可行性测试</strong></p>\n<p><strong>可用性测试</strong></p>\n<p><strong>价值测试</strong></p>\n<h2 id=\"原型测试\"><a href=\"#原型测试\" class=\"headerlink\" title=\"原型测试\"></a>原型测试</h2><h2 id=\"改进现有产品\"><a href=\"#改进现有产品\" class=\"headerlink\" title=\"改进现有产品\"></a>改进现有产品</h2><p><strong>不是一味地添加功能</strong></p>\n<h2 id=\"平滑部署\"><a href=\"#平滑部署\" class=\"headerlink\" title=\"平滑部署\"></a>平滑部署</h2><p>避免更新产品导致用户反感</p>\n<p>用户产生反感主要有以下几个原因：</p>\n<ol>\n<li><p>事前没有收到更新通知，</p>\n</li>\n<li><p>用户没有时间学习，适应新版本，产品公司也没有提供旧版本方便用户在过渡阶段的使用</p>\n</li>\n<li><p>新版本无法正常运行</p>\n</li>\n<li><p>新旧版本不兼容</p>\n</li>\n<li><p>新添加的功能和特性毫无必要</p>\n</li>\n</ol>\n<h2 id=\"快速响应阶段\"><a href=\"#快速响应阶段\" class=\"headerlink\" title=\"快速响应阶段\"></a>快速响应阶段</h2><h2 id=\"合理运用敏捷方法\"><a href=\"#合理运用敏捷方法\" class=\"headerlink\" title=\"合理运用敏捷方法\"></a>合理运用敏捷方法</h2><p>敏捷方法（包括Scrum和极限编程）有很多优点，但这类方法原值定制软件领域，不完全适用于开发产品软件。</p>\n<h2 id=\"合理运用瀑布式开发方法\"><a href=\"#合理运用瀑布式开发方法\" class=\"headerlink\" title=\"合理运用瀑布式开发方法\"></a>合理运用瀑布式开发方法</h2><p>瀑布式开发方法（持续改进方法、里程碑式开发方法）的基本原则：</p>\n<ol>\n<li><p>采用阶段式开发</p>\n</li>\n<li><p>采用阶段式评审</p>\n</li>\n</ol>\n<p>存在的问题：</p>\n<ol>\n<li><p>产品验证严重滞回</p>\n</li>\n<li><p>变更计划代价不菲</p>\n</li>\n<li><p>无法适应快速的市场变化</p>\n</li>\n</ol>\n<h2 id=\"创业型公司的产品经理\"><a href=\"#创业型公司的产品经理\" class=\"headerlink\" title=\"创业型公司的产品经理\"></a>创业型公司的产品经理</h2><p><strong>关键在于产品探索</strong></p>\n<h2 id=\"大公司如何创新\"><a href=\"#大公司如何创新\" class=\"headerlink\" title=\"大公司如何创新\"></a>大公司如何创新</h2><p><strong>有困难，但值得一试</strong></p>\n<p>企业文化和老板观念是创新的氛围的两大影响因素。</p>\n<p><strong>20%法则</strong></p>\n<p><strong>臭鼬工程</strong></p>\n<p><strong>主动观察</strong></p>\n<p><strong>改善用户体验</strong></p>\n<p><strong>收购小公司</strong></p>\n<h2 id=\"在大公司施展拳脚\"><a href=\"#在大公司施展拳脚\" class=\"headerlink\" title=\"在大公司施展拳脚\"></a>在大公司施展拳脚</h2><p><strong>十大秘诀</strong></p>\n<p>大公司尽量规避风险，矩阵式管理方式，节约公司的运营成本。</p>\n<ol>\n<li><p>了解公司制定决策的方式</p>\n</li>\n<li><p>建立人脉网络</p>\n</li>\n<li><p>臭鼬工程</p>\n</li>\n<li><p>自己顶上</p>\n</li>\n<li><p>有选择的据理力争</p>\n</li>\n<li><p>会前沟通，形成默契</p>\n</li>\n<li><p>合理分配时间</p>\n</li>\n<li><p>分享信息</p>\n</li>\n<li><p>向上司借力</p>\n</li>\n<li><p>传播你的产品理念</p>\n</li>\n</ol>\n<p><strong>大部分人游荡在黑暗里，他们只知道抱怨，缺从不想办法寻找开关。</strong></p>\n<h1 id=\"产品\"><a href=\"#产品\" class=\"headerlink\" title=\"产品\"></a>产品</h1><h2 id=\"苹果公司给我的启示\"><a href=\"#苹果公司给我的启示\" class=\"headerlink\" title=\"苹果公司给我的启示\"></a>苹果公司给我的启示</h2><p>苹果值得学习的优秀经验：</p>\n<ol>\n<li><p>硬件为软件服务</p>\n</li>\n<li><p>软件为用户体验服务</p>\n</li>\n<li><p>用户体验为情感服务</p>\n</li>\n<li><p>产品为真正的需求服务</p>\n</li>\n</ol>\n<h2 id=\"提防有特殊需求的产品\"><a href=\"#提防有特殊需求的产品\" class=\"headerlink\" title=\"提防有特殊需求的产品\"></a>提防有特殊需求的产品</h2><p>特例产品混淆了客户需求和产品需求，必然会使公司偏离正轨。</p>\n<p>产品原则决定了是否接受客户提出的特殊要求。</p>\n<h2 id=\"新瓶装老酒\"><a href=\"#新瓶装老酒\" class=\"headerlink\" title=\"新瓶装老酒\"></a>新瓶装老酒</h2><p>如何在成熟的市场上抢的一席之地？</p>\n<p>第一：对目标市场了如指掌，对现有产品的缺陷洞若观火。我喜欢通过产品可用性测试掌握产品情况（包括自己的产品和竞争对手的产品）</p>\n<p>第二：跟踪最新的技术趋势。新技术层出不穷，让之前无法实现的方案变得可能。</p>\n<p>优秀的产品经理应该抓住现有技术与用户需求的契合点。</p>\n<h2 id=\"恐惧、贪婪、欲望\"><a href=\"#恐惧、贪婪、欲望\" class=\"headerlink\" title=\"恐惧、贪婪、欲望\"></a>恐惧、贪婪、欲望</h2><p><strong>产品中情感的作用</strong></p>\n<p>消费者购买产品大多属于情感需求。</p>\n<h2 id=\"情感接纳曲线\"><a href=\"#情感接纳曲线\" class=\"headerlink\" title=\"情感接纳曲线\"></a>情感接纳曲线</h2><p>技术接纳曲线</p>\n<p>情感接纳曲线</p>\n<p>根据消费者的情感特征，把他们分为技术爱好者，非理性消费者，理性消费者，超理性消费者和观望者。</p>\n<ol>\n<li>关注用户的不满情绪？</li>\n</ol>\n<p>愤怒的用户决定着产品未来的发展方向。</p>\n<h2 id=\"可用性与美感\"><a href=\"#可用性与美感\" class=\"headerlink\" title=\"可用性与美感\"></a>可用性与美感</h2><p>两者缺一不可。</p>\n<h2 id=\"大众网络服务产品\"><a href=\"#大众网络服务产品\" class=\"headerlink\" title=\"大众网络服务产品\"></a>大众网络服务产品</h2><p>十大要点：</p>\n<ol>\n<li><p>可用性</p>\n</li>\n<li><p>人物角色</p>\n</li>\n<li><p>扩展性</p>\n</li>\n<li><p>持续可用性</p>\n</li>\n<li><p>客户服务</p>\n</li>\n<li><p>保护用户隐私</p>\n</li>\n<li><p>口碑营销</p>\n</li>\n<li><p>全球化</p>\n</li>\n</ol>\n<p>9.平滑部署</p>\n<p>10.用户社区管理</p>\n<h2 id=\"打造企业级产品的经验\"><a href=\"#打造企业级产品的经验\" class=\"headerlink\" title=\"打造企业级产品的经验\"></a>打造企业级产品的经验</h2><p>企业级产品判断的标准：软件的销售对象和软件的类型</p>\n<p>企业级软件的销售对象主要是企业，类型主要包括企业基础软件（安全软件，系统管理软件，通信软件）和企业应用软件（营销自动化软件，客户关系管理软件，企业资源计划软件）。</p>\n<ol>\n<li><p>可用性</p>\n</li>\n<li><p>产品正常工作</p>\n</li>\n<li><p>特例产品</p>\n</li>\n<li><p>特约用户</p>\n</li>\n<li><p>销售渠道的需求</p>\n</li>\n<li><p>客户和用户的需求</p>\n</li>\n<li><p>产品安装 </p>\n</li>\n<li><p>产品的配置、自定义和集成</p>\n</li>\n<li><p>产品升级</p>\n</li>\n<li><p>销售策略</p>\n</li>\n</ol>\n<p>合格软件产品具备的特征：</p>\n<ol>\n<li><p>产品具有价值，用户愿意掏钱购买产品。</p>\n</li>\n<li><p>产品可以在多种环境下运行，不是定制软件</p>\n</li>\n<li><p>只要提供必要的销售工具和销售培训，产品就可以通过销售渠道顺利销售出去。</p>\n</li>\n<li><p>产品公司能够为该产品提供支持，不断完善产品</p>\n</li>\n<li><p>经销商、服务合作伙伴，客户明白如何安装，配置和使用产品。</p>\n</li>\n</ol>\n<p>专用解决方案除了以上描述的产品特征外，还应具备以下特征：</p>\n<ol>\n<li><p>软件可以帮助企业解决业务问题，通常是特定（垂直）的行业问题</p>\n</li>\n<li><p>产品可能由一个或多个组件整合而成，组件可以有本公司或者合作方开发</p>\n</li>\n<li><p>必要时，产品应该获得合作方的产品认证</p>\n</li>\n</ol>\n<p>专用方案直接解决企业的业务问题。</p>\n<h2 id=\"打造平台级的产品经验\"><a href=\"#打造平台级的产品经验\" class=\"headerlink\" title=\"打造平台级的产品经验\"></a>打造平台级的产品经验</h2><p>平台产品：一类基础软件，应用开发者在其基础上开发应用程序。</p>\n<p>平台产品需要们面对不同的客户：</p>\n<ol>\n<li><p>应用软件开发商</p>\n</li>\n<li><p>开发人员</p>\n</li>\n<li><p>终端用户</p>\n</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"最佳实践经验\"><a href=\"#最佳实践经验\" class=\"headerlink\" title=\"最佳实践经验\"></a>最佳实践经验</h2><p><em><em> =十大要点</em></em></p>\n<ol>\n<li><p>产品管理的职责  许多产品经理将大把的时间浪费在与产品管理无关的工作上，比如，营销管理和项目管理，这些都不是产品经理应该干的活。</p>\n</li>\n<li><p>用户体验  对于大多数软件产品来说，用户体验就是产品的生命。产品经理应该与交互设计师、开发人员密切合作，设计良好的用户体验，打造有实用价值的产品。</p>\n</li>\n<li><p>机会评估  用方便快捷的机会评估方法取代过时的市场需求文档。动手设计产品前，先明确产品要解决什么问题，为谁解决问题，以及评估产品的标准。</p>\n</li>\n<li><p>特约用户  有些产品团队企图绕过用户，直接设计、开发产品，这种想法可笑至极。打造优秀的产品没有任何捷径，只能请用户反复试用产品，不断改进。</p>\n</li>\n<li><p>产品原则  产品管理工作的主要内容是制定决策。明确的产品原则可以帮助产品经理和产品团队树立清晰的价值标准，作出果断的决策。</p>\n</li>\n<li><p>人物角色  人物角色是协助产品经理制定决策的另一项工具。把目标用户按特征分类，逐一分析、理解其情感和行为，以此作为决策的依据。</p>\n</li>\n<li><p>探索（定义）产品  产品经理的主要职责是探索（定义）有价值的、可用的、可行的产品。除非产品经理确定这三点，否则同事的努力都将付之东流。</p>\n</li>\n<li><p>使用原型  使用高保真原型是探索（定义）产品的关键步骤。原因如下：第一，迫使产品经理深入定义解决方案；第二，可以让真实的用户参与测试、验证产品创意；第三，可以直观地向团队展示产品的设计思路。</p>\n</li>\n<li><p>用户参与原型测试  有了产品原型，产品经理可以方便地请用户验证产品创意。原型测试是所有产品经理和产品设计师都必须掌握的工作技能。获取有效的用户反馈是产品经理最重要的工作。</p>\n</li>\n<li><p>根据数据改进产品  成功的产品经理懂得利用数据来改进现有产品。改进产品不是根据客户要求一味增加新功能，而是根据产品的实际应用情况，不断地提升产品的各项指标，逐步完善产品。</p>\n</li>\n</ol>\n<h2 id=\"产品经理的反省清单\"><a href=\"#产品经理的反省清单\" class=\"headerlink\" title=\"产品经理的反省清单\"></a>产品经理的反省清单</h2><p><strong>十大问题</strong></p>\n<p>出色的产品经理会时刻关注产品的现状与未来。以下是产品经理无时无刻不在思考的问题。</p>\n<ol>\n<li><p>产品能吸引目标消费者的关注吗？</p>\n</li>\n<li><p>产品的设计是否人性化，是否易于操作？</p>\n</li>\n<li><p>产品能在竞争中取胜吗？即使是面对未来风云变化的市场，依旧有取胜的把握吗？</p>\n</li>\n<li><p>我了解目标用户吗？产品（不是理想的产品，而是实际开发出来的产品）是否能得到他们的认可？</p>\n</li>\n<li><p>产品是否有别于市面上的其他产品？我能在两分钟内向公司高管清楚地阐明这些差别吗？能在一分钟内向客户解释清楚吗？能在半分钟内向经验丰富的行业分析师解释清楚吗？</p>\n</li>\n<li><p>产品能正常运行吗？</p>\n</li>\n<li><p>产品是否完整？用户对产品的印象如何？销售业绩如何？销售任务能否顺利完成？</p>\n</li>\n<li><p>产品的特色是否与目标用户的需求一致？产品特色是否鲜明？</p>\n</li>\n<li><p>产品值钱吗？值多少钱？为什么值这么多钱？用户会选择更便宜的产品吗？</p>\n</li>\n<li><p>我了解其他团队成员对产品的看法吗？他们觉得产品好在哪里？他们的看法是否与我的观点一致？</p>\n</li>\n</ol>\n"},{"title":"2019-how to fix connection rest by port","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-10-03T08:54:05.000Z","password":null,"summary":null,"_content":"## ����\n�������׼�������ҵĲ��͵�ʱ����ͻȻgit�������ҵ�repositories\n�������Է���Connection reset�����⣺\n```\n$ ssh -T git@github.com\nConnection reset by 52.74.223.119 port 22\n```\nһֱ������ʾ�����������ٶȼ������ң���Ϊ��ssh�������ˣ�ɾ��ԭ����ssh,Ȼ���������ɲ�add��github�ϣ�Ȼ����ʵ��û����ô��\n$ ssh -T git@github.com\nConnection reset by 52.74.223.119 port 22\nping github.com \n����\nping github.global.ssl.fastly.net\n�޷�����\nԭ��\nDNS�޷�����\n���������\n��hosts(windows/system32/drivers/etc/hots)add:\n192.30.255.112  github.com git \n185.31.16.184 github.global.ssl.fastly.net","source":"_posts/2019-how-to-fix-connection-rest-by-port.md","raw":"---\ntitle: 2019-how to fix connection rest by port\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-10-03 16:54:05\npassword:\nsummary:\ntags:\ncategories:\n---\n## ����\n�������׼�������ҵĲ��͵�ʱ����ͻȻgit�������ҵ�repositories\n�������Է���Connection reset�����⣺\n```\n$ ssh -T git@github.com\nConnection reset by 52.74.223.119 port 22\n```\nһֱ������ʾ�����������ٶȼ������ң���Ϊ��ssh�������ˣ�ɾ��ԭ����ssh,Ȼ���������ɲ�add��github�ϣ�Ȼ����ʵ��û����ô��\n$ ssh -T git@github.com\nConnection reset by 52.74.223.119 port 22\nping github.com \n����\nping github.global.ssl.fastly.net\n�޷�����\nԭ��\nDNS�޷�����\n���������\n��hosts(windows/system32/drivers/etc/hots)add:\n192.30.255.112  github.com git \n185.31.16.184 github.global.ssl.fastly.net","slug":"2019-how-to-fix-connection-rest-by-port","published":1,"updated":"2019-10-03T08:54:35.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbh001k2wvchqbshbd7","content":"<h2 id=\"����\"><a href=\"#����\" class=\"headerlink\" title=\"����\"></a>����</h2><p>�������׼�������ҵĲ��͵�ʱ����ͻȻgit�������ҵ�repositories<br>�������Է���Connection reset�����⣺</p>\n<pre><code>$ ssh -T git@github.com\nConnection reset by 52.74.223.119 port 22</code></pre><p>һֱ������ʾ�����������ٶȼ������ң���Ϊ��ssh�������ˣ�ɾ��ԭ����ssh,Ȼ���������ɲ�add��github�ϣ�Ȼ����ʵ��û����ô��<br>$ ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a><br>Connection reset by 52.74.223.119 port 22<br>ping github.com<br>����<br>ping github.global.ssl.fastly.net<br>�޷�����<br>ԭ��<br>DNS�޷�����<br>���������<br>��hosts(windows/system32/drivers/etc/hots)add:<br>192.30.255.112  github.com git<br>185.31.16.184 github.global.ssl.fastly.net</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h2 id=\"����\"><a href=\"#����\" class=\"headerlink\" title=\"����\"></a>����</h2><p>�������׼�������ҵĲ��͵�ʱ����ͻȻgit�������ҵ�repositories<br>�������Է���Connection reset�����⣺</p>\n<pre><code>$ ssh -T git@github.com\nConnection reset by 52.74.223.119 port 22</code></pre><p>һֱ������ʾ�����������ٶȼ������ң���Ϊ��ssh�������ˣ�ɾ��ԭ����ssh,Ȼ���������ɲ�add��github�ϣ�Ȼ����ʵ��û����ô��<br>$ ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a><br>Connection reset by 52.74.223.119 port 22<br>ping github.com<br>����<br>ping github.global.ssl.fastly.net<br>�޷�����<br>ԭ��<br>DNS�޷�����<br>���������<br>��hosts(windows/system32/drivers/etc/hots)add:<br>192.30.255.112  github.com git<br>185.31.16.184 github.global.ssl.fastly.net</p>\n"},{"title":"markdown文件和Word文件的转换","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T10:00:11.000Z","password":null,"summary":"在使用markdown和Word时存在转换格式的问题，整理了快速转换的方法。","_content":"\n# 问题描述\n在markdown中写作完成初稿，之后在word中进行精细化排版设置。这就需要markdown转换word。以前一直没有找到合适的工具，今天终于发现了一个理想的工具：Writage。\n# 技术背景\nWritage是一款word插件，下载网址为：http://www.writage.com/\n- 功能：支持markdown与word互相转换\n\n安装：\n- Writage，word插件\n- Pandoc，文档转换后台软件\n\n实际上实现文档格式转换的是pandoc软件，Writage作为word插件，将pandoc的功能集成到了word选项中，避免了繁琐的cmd 命令操作。\n# 解决方案\n\n安装Writage和Pandoc软件后，word中不会直接出现选项卡，但在【打开】和【保存】的对话框中会出现相关的选项，如下：\n##  markdown转换word\n\n- 通过word软件打开markdown文件实现：\n- 打开原markdown文档后，另存为word格式即可；\n## word转换markdown\n\n- 首先设置word文档中的标准样式，如一级、二级标题等，如此才能与markdown的格式对应；\n- word格式另存为markdown；\n\n# 实施示例\n## 插件安装\n\n- 下载软件：http://www.writage.com/\n- 分别安装软件，全部按照默认安装即可\n- 重启电脑\n## markdown转换word\n\n- 创建markdown文档，可以在任意编辑器，如cmd markdown\n- 导出markdown文本文档\n- word软件打开markdown\n- word中markdown文档的预览效果如下\n\t由于markdown中的图片无法设置大小，因此在word中排布的图片格式不标准，需要人工调整。其他格式，如一级、二级标题，项目列表等基本没有问题。\n- 调整格式后，即可保存为word、pdf等格式\n## word转换markdown\n\n直接另存为markdown格式即可：\n各级标题的设置，实际上在markdown编辑器中更方便修改设置。\n# 常见问题\n\nmarkdown转换word的过程中，尤其需要注意的问题是：图片的下载和存储。\n## markdown转换word\n\n在原生的markdown文档中，图片以网络超链接的形式保存：\n以上的网址即为图片的网络路径，如果markdown文档中有这一类图片，那么需要在网络连接的情况下，才能正常输出有图片的word文档。否则，图片处显示空白。\n\n## word转换markdown\n\nword转换markdown之后，文档中的图片输出到本地文件夹media下：\n文件夹与输出的markdown文档在同一目录下:\n在markdown中图片引用本地相对路径：\n故必须保证markdown与media文件夹在一起，才能完整的在markdown编辑器中显示图片。","source":"_posts/2019-maandword.md","raw":"---\ntitle: markdown文件和Word文件的转换\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 18:00:11\npassword:\nsummary: 在使用markdown和Word时存在转换格式的问题，整理了快速转换的方法。\ntags:\n- 软件 技巧 Markdown Word\ncategories:\n- 软件\n---\n\n# 问题描述\n在markdown中写作完成初稿，之后在word中进行精细化排版设置。这就需要markdown转换word。以前一直没有找到合适的工具，今天终于发现了一个理想的工具：Writage。\n# 技术背景\nWritage是一款word插件，下载网址为：http://www.writage.com/\n- 功能：支持markdown与word互相转换\n\n安装：\n- Writage，word插件\n- Pandoc，文档转换后台软件\n\n实际上实现文档格式转换的是pandoc软件，Writage作为word插件，将pandoc的功能集成到了word选项中，避免了繁琐的cmd 命令操作。\n# 解决方案\n\n安装Writage和Pandoc软件后，word中不会直接出现选项卡，但在【打开】和【保存】的对话框中会出现相关的选项，如下：\n##  markdown转换word\n\n- 通过word软件打开markdown文件实现：\n- 打开原markdown文档后，另存为word格式即可；\n## word转换markdown\n\n- 首先设置word文档中的标准样式，如一级、二级标题等，如此才能与markdown的格式对应；\n- word格式另存为markdown；\n\n# 实施示例\n## 插件安装\n\n- 下载软件：http://www.writage.com/\n- 分别安装软件，全部按照默认安装即可\n- 重启电脑\n## markdown转换word\n\n- 创建markdown文档，可以在任意编辑器，如cmd markdown\n- 导出markdown文本文档\n- word软件打开markdown\n- word中markdown文档的预览效果如下\n\t由于markdown中的图片无法设置大小，因此在word中排布的图片格式不标准，需要人工调整。其他格式，如一级、二级标题，项目列表等基本没有问题。\n- 调整格式后，即可保存为word、pdf等格式\n## word转换markdown\n\n直接另存为markdown格式即可：\n各级标题的设置，实际上在markdown编辑器中更方便修改设置。\n# 常见问题\n\nmarkdown转换word的过程中，尤其需要注意的问题是：图片的下载和存储。\n## markdown转换word\n\n在原生的markdown文档中，图片以网络超链接的形式保存：\n以上的网址即为图片的网络路径，如果markdown文档中有这一类图片，那么需要在网络连接的情况下，才能正常输出有图片的word文档。否则，图片处显示空白。\n\n## word转换markdown\n\nword转换markdown之后，文档中的图片输出到本地文件夹media下：\n文件夹与输出的markdown文档在同一目录下:\n在markdown中图片引用本地相对路径：\n故必须保证markdown与media文件夹在一起，才能完整的在markdown编辑器中显示图片。","slug":"2019-maandword","published":1,"updated":"2019-09-30T10:08:00.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbj001m2wvcf5ikrnqt","content":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>在markdown中写作完成初稿，之后在word中进行精细化排版设置。这就需要markdown转换word。以前一直没有找到合适的工具，今天终于发现了一个理想的工具：Writage。</p>\n<h1 id=\"技术背景\"><a href=\"#技术背景\" class=\"headerlink\" title=\"技术背景\"></a>技术背景</h1><p>Writage是一款word插件，下载网址为：<a href=\"http://www.writage.com/\" target=\"_blank\" rel=\"noopener\">http://www.writage.com/</a></p>\n<ul>\n<li>功能：支持markdown与word互相转换</li>\n</ul>\n<p>安装：</p>\n<ul>\n<li>Writage，word插件</li>\n<li>Pandoc，文档转换后台软件</li>\n</ul>\n<p>实际上实现文档格式转换的是pandoc软件，Writage作为word插件，将pandoc的功能集成到了word选项中，避免了繁琐的cmd 命令操作。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>安装Writage和Pandoc软件后，word中不会直接出现选项卡，但在【打开】和【保存】的对话框中会出现相关的选项，如下：</p>\n<h2 id=\"markdown转换word\"><a href=\"#markdown转换word\" class=\"headerlink\" title=\"markdown转换word\"></a>markdown转换word</h2><ul>\n<li><p>通过word软件打开markdown文件实现：</p>\n</li>\n<li><p>打开原markdown文档后，另存为word格式即可；</p>\n<h2 id=\"word转换markdown\"><a href=\"#word转换markdown\" class=\"headerlink\" title=\"word转换markdown\"></a>word转换markdown</h2></li>\n<li><p>首先设置word文档中的标准样式，如一级、二级标题等，如此才能与markdown的格式对应；</p>\n</li>\n<li><p>word格式另存为markdown；</p>\n</li>\n</ul>\n<h1 id=\"实施示例\"><a href=\"#实施示例\" class=\"headerlink\" title=\"实施示例\"></a>实施示例</h1><h2 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h2><ul>\n<li><p>下载软件：<a href=\"http://www.writage.com/\" target=\"_blank\" rel=\"noopener\">http://www.writage.com/</a></p>\n</li>\n<li><p>分别安装软件，全部按照默认安装即可</p>\n</li>\n<li><p>重启电脑</p>\n<h2 id=\"markdown转换word-1\"><a href=\"#markdown转换word-1\" class=\"headerlink\" title=\"markdown转换word\"></a>markdown转换word</h2></li>\n<li><p>创建markdown文档，可以在任意编辑器，如cmd markdown</p>\n</li>\n<li><p>导出markdown文本文档</p>\n</li>\n<li><p>word软件打开markdown</p>\n</li>\n<li><p>word中markdown文档的预览效果如下<br>  由于markdown中的图片无法设置大小，因此在word中排布的图片格式不标准，需要人工调整。其他格式，如一级、二级标题，项目列表等基本没有问题。</p>\n</li>\n<li><p>调整格式后，即可保存为word、pdf等格式</p>\n<h2 id=\"word转换markdown-1\"><a href=\"#word转换markdown-1\" class=\"headerlink\" title=\"word转换markdown\"></a>word转换markdown</h2></li>\n</ul>\n<p>直接另存为markdown格式即可：<br>各级标题的设置，实际上在markdown编辑器中更方便修改设置。</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><p>markdown转换word的过程中，尤其需要注意的问题是：图片的下载和存储。</p>\n<h2 id=\"markdown转换word-2\"><a href=\"#markdown转换word-2\" class=\"headerlink\" title=\"markdown转换word\"></a>markdown转换word</h2><p>在原生的markdown文档中，图片以网络超链接的形式保存：<br>以上的网址即为图片的网络路径，如果markdown文档中有这一类图片，那么需要在网络连接的情况下，才能正常输出有图片的word文档。否则，图片处显示空白。</p>\n<h2 id=\"word转换markdown-2\"><a href=\"#word转换markdown-2\" class=\"headerlink\" title=\"word转换markdown\"></a>word转换markdown</h2><p>word转换markdown之后，文档中的图片输出到本地文件夹media下：<br>文件夹与输出的markdown文档在同一目录下:<br>在markdown中图片引用本地相对路径：<br>故必须保证markdown与media文件夹在一起，才能完整的在markdown编辑器中显示图片。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><p>在markdown中写作完成初稿，之后在word中进行精细化排版设置。这就需要markdown转换word。以前一直没有找到合适的工具，今天终于发现了一个理想的工具：Writage。</p>\n<h1 id=\"技术背景\"><a href=\"#技术背景\" class=\"headerlink\" title=\"技术背景\"></a>技术背景</h1><p>Writage是一款word插件，下载网址为：<a href=\"http://www.writage.com/\" target=\"_blank\" rel=\"noopener\">http://www.writage.com/</a></p>\n<ul>\n<li>功能：支持markdown与word互相转换</li>\n</ul>\n<p>安装：</p>\n<ul>\n<li>Writage，word插件</li>\n<li>Pandoc，文档转换后台软件</li>\n</ul>\n<p>实际上实现文档格式转换的是pandoc软件，Writage作为word插件，将pandoc的功能集成到了word选项中，避免了繁琐的cmd 命令操作。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>安装Writage和Pandoc软件后，word中不会直接出现选项卡，但在【打开】和【保存】的对话框中会出现相关的选项，如下：</p>\n<h2 id=\"markdown转换word\"><a href=\"#markdown转换word\" class=\"headerlink\" title=\"markdown转换word\"></a>markdown转换word</h2><ul>\n<li><p>通过word软件打开markdown文件实现：</p>\n</li>\n<li><p>打开原markdown文档后，另存为word格式即可；</p>\n<h2 id=\"word转换markdown\"><a href=\"#word转换markdown\" class=\"headerlink\" title=\"word转换markdown\"></a>word转换markdown</h2></li>\n<li><p>首先设置word文档中的标准样式，如一级、二级标题等，如此才能与markdown的格式对应；</p>\n</li>\n<li><p>word格式另存为markdown；</p>\n</li>\n</ul>\n<h1 id=\"实施示例\"><a href=\"#实施示例\" class=\"headerlink\" title=\"实施示例\"></a>实施示例</h1><h2 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h2><ul>\n<li><p>下载软件：<a href=\"http://www.writage.com/\" target=\"_blank\" rel=\"noopener\">http://www.writage.com/</a></p>\n</li>\n<li><p>分别安装软件，全部按照默认安装即可</p>\n</li>\n<li><p>重启电脑</p>\n<h2 id=\"markdown转换word-1\"><a href=\"#markdown转换word-1\" class=\"headerlink\" title=\"markdown转换word\"></a>markdown转换word</h2></li>\n<li><p>创建markdown文档，可以在任意编辑器，如cmd markdown</p>\n</li>\n<li><p>导出markdown文本文档</p>\n</li>\n<li><p>word软件打开markdown</p>\n</li>\n<li><p>word中markdown文档的预览效果如下<br>  由于markdown中的图片无法设置大小，因此在word中排布的图片格式不标准，需要人工调整。其他格式，如一级、二级标题，项目列表等基本没有问题。</p>\n</li>\n<li><p>调整格式后，即可保存为word、pdf等格式</p>\n<h2 id=\"word转换markdown-1\"><a href=\"#word转换markdown-1\" class=\"headerlink\" title=\"word转换markdown\"></a>word转换markdown</h2></li>\n</ul>\n<p>直接另存为markdown格式即可：<br>各级标题的设置，实际上在markdown编辑器中更方便修改设置。</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><p>markdown转换word的过程中，尤其需要注意的问题是：图片的下载和存储。</p>\n<h2 id=\"markdown转换word-2\"><a href=\"#markdown转换word-2\" class=\"headerlink\" title=\"markdown转换word\"></a>markdown转换word</h2><p>在原生的markdown文档中，图片以网络超链接的形式保存：<br>以上的网址即为图片的网络路径，如果markdown文档中有这一类图片，那么需要在网络连接的情况下，才能正常输出有图片的word文档。否则，图片处显示空白。</p>\n<h2 id=\"word转换markdown-2\"><a href=\"#word转换markdown-2\" class=\"headerlink\" title=\"word转换markdown\"></a>word转换markdown</h2><p>word转换markdown之后，文档中的图片输出到本地文件夹media下：<br>文件夹与输出的markdown文档在同一目录下:<br>在markdown中图片引用本地相对路径：<br>故必须保证markdown与media文件夹在一起，才能完整的在markdown编辑器中显示图片。</p>\n"},{"title":"自动检测图像中的圆形或者圆形对象","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T01:30:49.000Z","password":null,"summary":null,"_content":"\n# 加载图像\n该示例使用带有各种颜色的圆形塑料片的图像。如图1所示。\n![图1](https://img-blog.csdnimg.cn/20190328103834308.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n\n```MATLAB\nrgb = imread('DetectCirclesExample_01.png');%读入图片\nimshow(rgb)%显示图\n```\n除了有足够的圆形可以检测外，这个图像中对圆形的检测时还有一些有趣的事情：\n\n 1. 存在不同颜色的芯片，其与背景具有不同的对比度。 一方面，蓝色和红色在这个背景上有强烈的对比。 另一方面，一些黄色芯片与背景对比较差;\n 2. 可以发现一些芯片是相互叠加的，还有一些芯片是靠近在一起并且几乎相互接触的。 重叠对象边界和对象的遮挡通常是对象检测的挑战。\n# 确定搜索圈的半径范围\nimfindcircles函数需要一个半径范围来搜索圆圈。 找到合适的半径范围的快速方法是使用交互式工具imdistline来获得各种对象半径的近似估计。如图2所示。\n![图2](https://img-blog.csdnimg.cn/20190328104130957.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n\n```MATLAB\nd = imdistline;%显示交互式工具，测量半径\n```\nimdistline创建了一个可拖动的工具，可以移动以适应芯片，并且可以读取数字以获得其半径的近似估计。 大多数芯片的半径范围为20像素。 使用稍大的20-25像素的半径范围以确保可以检测到足够多的芯片。 注意在进行下一步操作之前需要删除imdistline工具。\n```MATLAB\ndelete(d)%删除交互式工具\n```\n# 初步尝试查找圆形\n在此图像上调用imfindcircles，搜索半径为[20 25]像素。 在此之前，最好查看物体是否比背景更亮或更暗。 要查看图像的暗亮程度，可以调取此图像的灰度版本\n背景非常明亮，大多数芯片比背景更暗。 但是，默认情况下，imfindcircles会找到比背景更亮的圆形对象。 因此，在imfindcircles中将参数'ObjectPolarity'设置为'dark'以搜索比背景暗的图像。\n```MATLAB\ngray_image = rgb2gray(rgb);%图像的灰度版本\nimshow(gray_image)%显示图像\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark');%查找圆形\n```\n得到对的结果如下：\n```MATLAB\ncenters =[ ]\nradii =[ ]\n```\n请注意，输出中心位置和半径为空，这意味着没有找到圆圈。 这种情况经常发生，因为imfindcircles是一个圆形探测器，与大多数探测器类似，imfindcircles有一个内部探测阈值，决定了它的灵敏度。 简单来说，这意味着检测器对某个（圆形）检测的置信度必须大于某个水平才能被认为是有效检测\nimfindcircles有一个参数'Sensitivity'，可用于控制此内部阈值，从而控制算法的灵敏度。 较高的“灵敏度”值会将检测阈值设置得较低，从而导致检测到更多圆圈。 \n# 提高检测灵敏度\n回到圆形图像，有可能在默认的灵敏度水平下，所有圆都低于内部阈值，这就是没有检测到圆的原因。 默认情况下，“灵敏度”（0到1之间的数字）设置为0.85。 将“敏感度”提高到0.9。\n```MATLAB\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.9)\n```\n这次imfindcircles发现了一些圆圈 - 准确地说是5个圆圈，如图3。 中心包含圆心的位置，半径包含这些圆的估计半径。\n# 在图像上绘制圆圈\n函数viscircles可用于在图像上绘制圆圈。 来自imfindcircles的输出变量中心和半径可以直接传递给viscircles。\n```MATLAB\nimshow(rgb)\nh = viscircles(centers,radii);\n```\n![图3](https://img-blog.csdnimg.cn/20190328104510292.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)圆心被正确定位，其相应的半径似乎与实际芯片很好地匹配。 但仍有不少圆形被遗漏。 尝试将“灵敏度”提高到0.92。\n```MATLAB\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92);\nlength(centers)\n```\n因此，增加“灵敏度”会让我们得到更多的圆形。 再次在图像上绘制这些圆形，如图4。\n```MATLAB\ndelete(h)  % Delete previously drawn circles\nh = viscircles(centers,radii);\n```\n![图4](https://img-blog.csdnimg.cn/2019032810453758.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n# 使用第二种方法（两阶段）寻找圆圈\n这个结果看起来更好。 imfindcircles有两种不同的方法来寻找圆圈。 到目前为止，称为相位编码方法的默认方法用于检测圆。 还有另一种方法，通常称为两阶段方法，可以在imfindcircles中使用。 使用两阶段方法并显示结果。\n```MATLAB\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92,'Method','twostage');\ndelete(h)\nh = viscircles(centers,radii);\n```\n两阶段方法检测更多圆，灵敏度为0.92。 通常，这两种方法是互补的，因为它们具有不同的强度。 与两阶段方法相比，相位编码方法通常更快并且对噪声更加鲁棒。 但它也可能需要更高的“灵敏度”水平来获得与两阶段方法相同数量的检测。 例如，如果将“灵敏度”级别提高到更高，相位编码方法也会找到相同的芯片，比如0.95，结果如图5所示。\n```MATLAB\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.95);\ndelete(h)\nviscircles(centers,radii);\n```\n![图5](https://img-blog.csdnimg.cn/20190328104616612.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n请注意，imfindcircles中的两种方法都能准确地找到部分可见（遮挡）芯片的中心和半径。\n# 为什么有些圈子仍然被错过？\n看看最后的结果，很奇怪imfindcircles没有在图像中找到黄色芯片。 黄色芯片与背景没有强烈的对比。 事实上，它们似乎与背景具有非常相似的强度。 是否有可能黄色芯片并不像假设的那样真正“背景”更暗？ 要确认，请再次显示此图像的灰度版本。\n```MATLAB\nimshow(gray_image)\n```\n# 在图像中找到“明亮”的圆圈\n与背景相比，黄色芯片的强度几乎相同，甚至更亮。 因此，要检测黄色芯片，请将“ObjectPolarity”更改为“bright”。\n```MATLAB\n[centersBright,radiiBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92);\n```\n# 绘制不同颜色的“明亮”圆圈\n通过更改viscircles中的“Color”参数，以不同的颜色绘制明亮的圆圈。\n请注意，发现了三个缺失的黄色芯片，但仍然缺少一个黄色芯片,如图6所示。这些黄色芯片很难找到，因为它们在这种背景下并不像其他芯片那样突出。\n![图6](https://img-blog.csdnimg.cn/2019032810464896.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n# 降低'EdgeThreshold'的值\nimfindcircles中还有另一个参数可能在这里很有用，即'EdgeThreshold'。要查找圆圈，imfindcircles仅使用图像中的边缘像素。这些边缘像素基本上是具有高梯度值的像素。 “EdgeThreshold”参数控制像素的梯度值在被视为边缘像素并包含在计算中之前必须有多高。此参数的高值（接近1）将仅允许包含强边（更高的梯度值），而低值（更接近0）更宽松，甚至包括更弱的边（更低的梯度值）计算。在缺少黄色芯片的情况下，由于对比度低，所以预期一些边界像素（在芯片的圆周上）具有低梯度值。因此，降低“EdgeThreshold”参数以确保黄色芯片的大部分边缘像素都包含在计算中，如图7所示。\n![图7](https://img-blog.csdnimg.cn/20190328104710426.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n```MATLAB\n[centersBright,radiiBright,metricBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92,'EdgeThreshold',0.1);\ndelete(hBright)\nhBright = viscircles(centersBright, radiiBright,'Color','b');\n```\n# 一起绘制“黑暗”和“明亮”圆圈\n```MATLAB\nh = viscircles(centers,radii);\n```\n现在，imfindcircles找到所有黄色的，绿色的。 用蓝色绘制这些圆形，以及之前发现的其他圆形（“ObjectPolarity”设置为“dark”），如图8所示。\n![图8](https://img-blog.csdnimg.cn/20190328104732652.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n应该注意的是，将参数更改为在检测中更容易可能会发现更多的圆圈，但它也增加了检测假圆的可能性。 可以找到的真实圆圈数（检测率）和与它们一起找到的假圆圈数量之间存在权衡（误报率）\n# 完整代码\n```MATLAB\n%% Step 1: Load Image\nrgb = imread('DetectCirclesExample_01.png');\nimshow(rgb)\n%% Step 2: Determine Radius Range for Searching Circles\nd = imdistline;\ndelete(d)\n%%  Step 3: Initial Attempt to Find Circles\ngray_image = rgb2gray(rgb);\nimshow(gray_image)\n[centers,radii] = imfindcircles(rgb,[35 43],'ObjectPolarity','dark');\n%% Step 4: Increase Detection Sensitivity\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.9);\nStep 5: Draw the Circles on the Image\nimshow(rgb)\nh = viscircles(centers,radii);\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92);\nlength(centers)\ndelete(h)  % Delete previously drawn circles\nh = viscircles(centers,radii);\n%% Step 6: Use the Second Method (Two-stage) for Finding Circles\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92,'Method','twostage');\ndelete(h)\nh = viscircles(centers,radii);\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.95);\ndelete(h)\nviscircles(centers,radii);\n%% Step 7: Why are Some Circles Still Getting Missed?\nimshow(gray_image)\n%% Step 8: Find 'Bright' Circles in the Image\n[centersBright,radiiBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92);\n%% Step 9: Draw 'Bright' Circles with Different Color\nimshow(rgb)\nhBright = viscircles(centersBright, radiiBright,'Color','b');\n%% Step 10: Lower the Value of 'EdgeThreshold'\n[centersBright,radiiBright,metricBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92,'EdgeThreshold',0.1);\ndelete(hBright)\nhBright = viscircles(centersBright, radiiBright,'Color','b');\n%% Step 11: Draw 'Dark' and 'Bright' Circles Together\nh = viscircles(centers,radii);\n```\n#  github\n具体内容及代码下载见[HaoxinGuo](https://github.com/HaoxinGuo/ImagIdf)。\n","source":"_posts/2019-matlab-to-deliver.md","raw":"---\ntitle: 自动检测图像中的圆形或者圆形对象\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 09:30:49\npassword:\nsummary:\ntags: 自动检测图像 Matlab\ncategories: Matlab\n---\n\n# 加载图像\n该示例使用带有各种颜色的圆形塑料片的图像。如图1所示。\n![图1](https://img-blog.csdnimg.cn/20190328103834308.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n\n```MATLAB\nrgb = imread('DetectCirclesExample_01.png');%读入图片\nimshow(rgb)%显示图\n```\n除了有足够的圆形可以检测外，这个图像中对圆形的检测时还有一些有趣的事情：\n\n 1. 存在不同颜色的芯片，其与背景具有不同的对比度。 一方面，蓝色和红色在这个背景上有强烈的对比。 另一方面，一些黄色芯片与背景对比较差;\n 2. 可以发现一些芯片是相互叠加的，还有一些芯片是靠近在一起并且几乎相互接触的。 重叠对象边界和对象的遮挡通常是对象检测的挑战。\n# 确定搜索圈的半径范围\nimfindcircles函数需要一个半径范围来搜索圆圈。 找到合适的半径范围的快速方法是使用交互式工具imdistline来获得各种对象半径的近似估计。如图2所示。\n![图2](https://img-blog.csdnimg.cn/20190328104130957.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n\n```MATLAB\nd = imdistline;%显示交互式工具，测量半径\n```\nimdistline创建了一个可拖动的工具，可以移动以适应芯片，并且可以读取数字以获得其半径的近似估计。 大多数芯片的半径范围为20像素。 使用稍大的20-25像素的半径范围以确保可以检测到足够多的芯片。 注意在进行下一步操作之前需要删除imdistline工具。\n```MATLAB\ndelete(d)%删除交互式工具\n```\n# 初步尝试查找圆形\n在此图像上调用imfindcircles，搜索半径为[20 25]像素。 在此之前，最好查看物体是否比背景更亮或更暗。 要查看图像的暗亮程度，可以调取此图像的灰度版本\n背景非常明亮，大多数芯片比背景更暗。 但是，默认情况下，imfindcircles会找到比背景更亮的圆形对象。 因此，在imfindcircles中将参数'ObjectPolarity'设置为'dark'以搜索比背景暗的图像。\n```MATLAB\ngray_image = rgb2gray(rgb);%图像的灰度版本\nimshow(gray_image)%显示图像\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark');%查找圆形\n```\n得到对的结果如下：\n```MATLAB\ncenters =[ ]\nradii =[ ]\n```\n请注意，输出中心位置和半径为空，这意味着没有找到圆圈。 这种情况经常发生，因为imfindcircles是一个圆形探测器，与大多数探测器类似，imfindcircles有一个内部探测阈值，决定了它的灵敏度。 简单来说，这意味着检测器对某个（圆形）检测的置信度必须大于某个水平才能被认为是有效检测\nimfindcircles有一个参数'Sensitivity'，可用于控制此内部阈值，从而控制算法的灵敏度。 较高的“灵敏度”值会将检测阈值设置得较低，从而导致检测到更多圆圈。 \n# 提高检测灵敏度\n回到圆形图像，有可能在默认的灵敏度水平下，所有圆都低于内部阈值，这就是没有检测到圆的原因。 默认情况下，“灵敏度”（0到1之间的数字）设置为0.85。 将“敏感度”提高到0.9。\n```MATLAB\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.9)\n```\n这次imfindcircles发现了一些圆圈 - 准确地说是5个圆圈，如图3。 中心包含圆心的位置，半径包含这些圆的估计半径。\n# 在图像上绘制圆圈\n函数viscircles可用于在图像上绘制圆圈。 来自imfindcircles的输出变量中心和半径可以直接传递给viscircles。\n```MATLAB\nimshow(rgb)\nh = viscircles(centers,radii);\n```\n![图3](https://img-blog.csdnimg.cn/20190328104510292.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)圆心被正确定位，其相应的半径似乎与实际芯片很好地匹配。 但仍有不少圆形被遗漏。 尝试将“灵敏度”提高到0.92。\n```MATLAB\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92);\nlength(centers)\n```\n因此，增加“灵敏度”会让我们得到更多的圆形。 再次在图像上绘制这些圆形，如图4。\n```MATLAB\ndelete(h)  % Delete previously drawn circles\nh = viscircles(centers,radii);\n```\n![图4](https://img-blog.csdnimg.cn/2019032810453758.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n# 使用第二种方法（两阶段）寻找圆圈\n这个结果看起来更好。 imfindcircles有两种不同的方法来寻找圆圈。 到目前为止，称为相位编码方法的默认方法用于检测圆。 还有另一种方法，通常称为两阶段方法，可以在imfindcircles中使用。 使用两阶段方法并显示结果。\n```MATLAB\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92,'Method','twostage');\ndelete(h)\nh = viscircles(centers,radii);\n```\n两阶段方法检测更多圆，灵敏度为0.92。 通常，这两种方法是互补的，因为它们具有不同的强度。 与两阶段方法相比，相位编码方法通常更快并且对噪声更加鲁棒。 但它也可能需要更高的“灵敏度”水平来获得与两阶段方法相同数量的检测。 例如，如果将“灵敏度”级别提高到更高，相位编码方法也会找到相同的芯片，比如0.95，结果如图5所示。\n```MATLAB\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.95);\ndelete(h)\nviscircles(centers,radii);\n```\n![图5](https://img-blog.csdnimg.cn/20190328104616612.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n请注意，imfindcircles中的两种方法都能准确地找到部分可见（遮挡）芯片的中心和半径。\n# 为什么有些圈子仍然被错过？\n看看最后的结果，很奇怪imfindcircles没有在图像中找到黄色芯片。 黄色芯片与背景没有强烈的对比。 事实上，它们似乎与背景具有非常相似的强度。 是否有可能黄色芯片并不像假设的那样真正“背景”更暗？ 要确认，请再次显示此图像的灰度版本。\n```MATLAB\nimshow(gray_image)\n```\n# 在图像中找到“明亮”的圆圈\n与背景相比，黄色芯片的强度几乎相同，甚至更亮。 因此，要检测黄色芯片，请将“ObjectPolarity”更改为“bright”。\n```MATLAB\n[centersBright,radiiBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92);\n```\n# 绘制不同颜色的“明亮”圆圈\n通过更改viscircles中的“Color”参数，以不同的颜色绘制明亮的圆圈。\n请注意，发现了三个缺失的黄色芯片，但仍然缺少一个黄色芯片,如图6所示。这些黄色芯片很难找到，因为它们在这种背景下并不像其他芯片那样突出。\n![图6](https://img-blog.csdnimg.cn/2019032810464896.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n# 降低'EdgeThreshold'的值\nimfindcircles中还有另一个参数可能在这里很有用，即'EdgeThreshold'。要查找圆圈，imfindcircles仅使用图像中的边缘像素。这些边缘像素基本上是具有高梯度值的像素。 “EdgeThreshold”参数控制像素的梯度值在被视为边缘像素并包含在计算中之前必须有多高。此参数的高值（接近1）将仅允许包含强边（更高的梯度值），而低值（更接近0）更宽松，甚至包括更弱的边（更低的梯度值）计算。在缺少黄色芯片的情况下，由于对比度低，所以预期一些边界像素（在芯片的圆周上）具有低梯度值。因此，降低“EdgeThreshold”参数以确保黄色芯片的大部分边缘像素都包含在计算中，如图7所示。\n![图7](https://img-blog.csdnimg.cn/20190328104710426.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n```MATLAB\n[centersBright,radiiBright,metricBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92,'EdgeThreshold',0.1);\ndelete(hBright)\nhBright = viscircles(centersBright, radiiBright,'Color','b');\n```\n# 一起绘制“黑暗”和“明亮”圆圈\n```MATLAB\nh = viscircles(centers,radii);\n```\n现在，imfindcircles找到所有黄色的，绿色的。 用蓝色绘制这些圆形，以及之前发现的其他圆形（“ObjectPolarity”设置为“dark”），如图8所示。\n![图8](https://img-blog.csdnimg.cn/20190328104732652.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70)\n应该注意的是，将参数更改为在检测中更容易可能会发现更多的圆圈，但它也增加了检测假圆的可能性。 可以找到的真实圆圈数（检测率）和与它们一起找到的假圆圈数量之间存在权衡（误报率）\n# 完整代码\n```MATLAB\n%% Step 1: Load Image\nrgb = imread('DetectCirclesExample_01.png');\nimshow(rgb)\n%% Step 2: Determine Radius Range for Searching Circles\nd = imdistline;\ndelete(d)\n%%  Step 3: Initial Attempt to Find Circles\ngray_image = rgb2gray(rgb);\nimshow(gray_image)\n[centers,radii] = imfindcircles(rgb,[35 43],'ObjectPolarity','dark');\n%% Step 4: Increase Detection Sensitivity\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.9);\nStep 5: Draw the Circles on the Image\nimshow(rgb)\nh = viscircles(centers,radii);\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92);\nlength(centers)\ndelete(h)  % Delete previously drawn circles\nh = viscircles(centers,radii);\n%% Step 6: Use the Second Method (Two-stage) for Finding Circles\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92,'Method','twostage');\ndelete(h)\nh = viscircles(centers,radii);\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.95);\ndelete(h)\nviscircles(centers,radii);\n%% Step 7: Why are Some Circles Still Getting Missed?\nimshow(gray_image)\n%% Step 8: Find 'Bright' Circles in the Image\n[centersBright,radiiBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92);\n%% Step 9: Draw 'Bright' Circles with Different Color\nimshow(rgb)\nhBright = viscircles(centersBright, radiiBright,'Color','b');\n%% Step 10: Lower the Value of 'EdgeThreshold'\n[centersBright,radiiBright,metricBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92,'EdgeThreshold',0.1);\ndelete(hBright)\nhBright = viscircles(centersBright, radiiBright,'Color','b');\n%% Step 11: Draw 'Dark' and 'Bright' Circles Together\nh = viscircles(centers,radii);\n```\n#  github\n具体内容及代码下载见[HaoxinGuo](https://github.com/HaoxinGuo/ImagIdf)。\n","slug":"2019-matlab-to-deliver","published":1,"updated":"2019-09-30T01:32:59.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbk001q2wvc7fs4i2nw","content":"<h1 id=\"加载图像\"><a href=\"#加载图像\" class=\"headerlink\" title=\"加载图像\"></a>加载图像</h1><p>该示例使用带有各种颜色的圆形塑料片的图像。如图1所示。<br><img src=\"https://img-blog.csdnimg.cn/20190328103834308.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图1\"></p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">rgb = imread('DetectCirclesExample_01.png');%读入图片\nimshow(rgb)%显示图<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>除了有足够的圆形可以检测外，这个图像中对圆形的检测时还有一些有趣的事情：</p>\n<ol>\n<li>存在不同颜色的芯片，其与背景具有不同的对比度。 一方面，蓝色和红色在这个背景上有强烈的对比。 另一方面，一些黄色芯片与背景对比较差;</li>\n<li>可以发现一些芯片是相互叠加的，还有一些芯片是靠近在一起并且几乎相互接触的。 重叠对象边界和对象的遮挡通常是对象检测的挑战。<h1 id=\"确定搜索圈的半径范围\"><a href=\"#确定搜索圈的半径范围\" class=\"headerlink\" title=\"确定搜索圈的半径范围\"></a>确定搜索圈的半径范围</h1>imfindcircles函数需要一个半径范围来搜索圆圈。 找到合适的半径范围的快速方法是使用交互式工具imdistline来获得各种对象半径的近似估计。如图2所示。<br><img src=\"https://img-blog.csdnimg.cn/20190328104130957.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图2\"></li>\n</ol>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">d = imdistline;%显示交互式工具，测量半径<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>imdistline创建了一个可拖动的工具，可以移动以适应芯片，并且可以读取数字以获得其半径的近似估计。 大多数芯片的半径范围为20像素。 使用稍大的20-25像素的半径范围以确保可以检测到足够多的芯片。 注意在进行下一步操作之前需要删除imdistline工具。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">delete(d)%删除交互式工具<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h1 id=\"初步尝试查找圆形\"><a href=\"#初步尝试查找圆形\" class=\"headerlink\" title=\"初步尝试查找圆形\"></a>初步尝试查找圆形</h1><p>在此图像上调用imfindcircles，搜索半径为[20 25]像素。 在此之前，最好查看物体是否比背景更亮或更暗。 要查看图像的暗亮程度，可以调取此图像的灰度版本<br>背景非常明亮，大多数芯片比背景更暗。 但是，默认情况下，imfindcircles会找到比背景更亮的圆形对象。 因此，在imfindcircles中将参数’ObjectPolarity’设置为’dark’以搜索比背景暗的图像。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">gray_image = rgb2gray(rgb);%图像的灰度版本\nimshow(gray_image)%显示图像\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark');%查找圆形<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>得到对的结果如下：</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">centers =[ ]\nradii =[ ]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>请注意，输出中心位置和半径为空，这意味着没有找到圆圈。 这种情况经常发生，因为imfindcircles是一个圆形探测器，与大多数探测器类似，imfindcircles有一个内部探测阈值，决定了它的灵敏度。 简单来说，这意味着检测器对某个（圆形）检测的置信度必须大于某个水平才能被认为是有效检测<br>imfindcircles有一个参数’Sensitivity’，可用于控制此内部阈值，从而控制算法的灵敏度。 较高的“灵敏度”值会将检测阈值设置得较低，从而导致检测到更多圆圈。 </p>\n<h1 id=\"提高检测灵敏度\"><a href=\"#提高检测灵敏度\" class=\"headerlink\" title=\"提高检测灵敏度\"></a>提高检测灵敏度</h1><p>回到圆形图像，有可能在默认的灵敏度水平下，所有圆都低于内部阈值，这就是没有检测到圆的原因。 默认情况下，“灵敏度”（0到1之间的数字）设置为0.85。 将“敏感度”提高到0.9。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.9)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这次imfindcircles发现了一些圆圈 - 准确地说是5个圆圈，如图3。 中心包含圆心的位置，半径包含这些圆的估计半径。</p>\n<h1 id=\"在图像上绘制圆圈\"><a href=\"#在图像上绘制圆圈\" class=\"headerlink\" title=\"在图像上绘制圆圈\"></a>在图像上绘制圆圈</h1><p>函数viscircles可用于在图像上绘制圆圈。 来自imfindcircles的输出变量中心和半径可以直接传递给viscircles。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">imshow(rgb)\nh = viscircles(centers,radii);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190328104510292.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图3\">圆心被正确定位，其相应的半径似乎与实际芯片很好地匹配。 但仍有不少圆形被遗漏。 尝试将“灵敏度”提高到0.92。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92);\nlength(centers)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>因此，增加“灵敏度”会让我们得到更多的圆形。 再次在图像上绘制这些圆形，如图4。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">delete(h)  % Delete previously drawn circles\nh = viscircles(centers,radii);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019032810453758.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图4\"></p>\n<h1 id=\"使用第二种方法（两阶段）寻找圆圈\"><a href=\"#使用第二种方法（两阶段）寻找圆圈\" class=\"headerlink\" title=\"使用第二种方法（两阶段）寻找圆圈\"></a>使用第二种方法（两阶段）寻找圆圈</h1><p>这个结果看起来更好。 imfindcircles有两种不同的方法来寻找圆圈。 到目前为止，称为相位编码方法的默认方法用于检测圆。 还有另一种方法，通常称为两阶段方法，可以在imfindcircles中使用。 使用两阶段方法并显示结果。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92,'Method','twostage');\ndelete(h)\nh = viscircles(centers,radii);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>两阶段方法检测更多圆，灵敏度为0.92。 通常，这两种方法是互补的，因为它们具有不同的强度。 与两阶段方法相比，相位编码方法通常更快并且对噪声更加鲁棒。 但它也可能需要更高的“灵敏度”水平来获得与两阶段方法相同数量的检测。 例如，如果将“灵敏度”级别提高到更高，相位编码方法也会找到相同的芯片，比如0.95，结果如图5所示。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.95);\ndelete(h)\nviscircles(centers,radii);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190328104616612.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图5\"><br>请注意，imfindcircles中的两种方法都能准确地找到部分可见（遮挡）芯片的中心和半径。</p>\n<h1 id=\"为什么有些圈子仍然被错过？\"><a href=\"#为什么有些圈子仍然被错过？\" class=\"headerlink\" title=\"为什么有些圈子仍然被错过？\"></a>为什么有些圈子仍然被错过？</h1><p>看看最后的结果，很奇怪imfindcircles没有在图像中找到黄色芯片。 黄色芯片与背景没有强烈的对比。 事实上，它们似乎与背景具有非常相似的强度。 是否有可能黄色芯片并不像假设的那样真正“背景”更暗？ 要确认，请再次显示此图像的灰度版本。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">imshow(gray_image)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h1 id=\"在图像中找到“明亮”的圆圈\"><a href=\"#在图像中找到“明亮”的圆圈\" class=\"headerlink\" title=\"在图像中找到“明亮”的圆圈\"></a>在图像中找到“明亮”的圆圈</h1><p>与背景相比，黄色芯片的强度几乎相同，甚至更亮。 因此，要检测黄色芯片，请将“ObjectPolarity”更改为“bright”。</p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">[centersBright,radiiBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h1 id=\"绘制不同颜色的“明亮”圆圈\"><a href=\"#绘制不同颜色的“明亮”圆圈\" class=\"headerlink\" title=\"绘制不同颜色的“明亮”圆圈\"></a>绘制不同颜色的“明亮”圆圈</h1><p>通过更改viscircles中的“Color”参数，以不同的颜色绘制明亮的圆圈。<br>请注意，发现了三个缺失的黄色芯片，但仍然缺少一个黄色芯片,如图6所示。这些黄色芯片很难找到，因为它们在这种背景下并不像其他芯片那样突出。<br><img src=\"https://img-blog.csdnimg.cn/2019032810464896.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图6\"></p>\n<h1 id=\"降低’EdgeThreshold’的值\"><a href=\"#降低’EdgeThreshold’的值\" class=\"headerlink\" title=\"降低’EdgeThreshold’的值\"></a>降低’EdgeThreshold’的值</h1><p>imfindcircles中还有另一个参数可能在这里很有用，即’EdgeThreshold’。要查找圆圈，imfindcircles仅使用图像中的边缘像素。这些边缘像素基本上是具有高梯度值的像素。 “EdgeThreshold”参数控制像素的梯度值在被视为边缘像素并包含在计算中之前必须有多高。此参数的高值（接近1）将仅允许包含强边（更高的梯度值），而低值（更接近0）更宽松，甚至包括更弱的边（更低的梯度值）计算。在缺少黄色芯片的情况下，由于对比度低，所以预期一些边界像素（在芯片的圆周上）具有低梯度值。因此，降低“EdgeThreshold”参数以确保黄色芯片的大部分边缘像素都包含在计算中，如图7所示。<br><img src=\"https://img-blog.csdnimg.cn/20190328104710426.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图7\"></p>\n<pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">[centersBright,radiiBright,metricBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92,'EdgeThreshold',0.1);\ndelete(hBright)\nhBright = viscircles(centersBright, radiiBright,'Color','b');<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"一起绘制“黑暗”和“明亮”圆圈\"><a href=\"#一起绘制“黑暗”和“明亮”圆圈\" class=\"headerlink\" title=\"一起绘制“黑暗”和“明亮”圆圈\"></a>一起绘制“黑暗”和“明亮”圆圈</h1><pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">h = viscircles(centers,radii);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>现在，imfindcircles找到所有黄色的，绿色的。 用蓝色绘制这些圆形，以及之前发现的其他圆形（“ObjectPolarity”设置为“dark”），如图8所示。<br><img src=\"https://img-blog.csdnimg.cn/20190328104732652.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图8\"><br>应该注意的是，将参数更改为在检测中更容易可能会发现更多的圆圈，但它也增加了检测假圆的可能性。 可以找到的真实圆圈数（检测率）和与它们一起找到的假圆圈数量之间存在权衡（误报率）</p>\n<h1 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h1><pre class=\"line-numbers language-MATLAB\"><code class=\"language-MATLAB\">%% Step 1: Load Image\nrgb = imread('DetectCirclesExample_01.png');\nimshow(rgb)\n%% Step 2: Determine Radius Range for Searching Circles\nd = imdistline;\ndelete(d)\n%%  Step 3: Initial Attempt to Find Circles\ngray_image = rgb2gray(rgb);\nimshow(gray_image)\n[centers,radii] = imfindcircles(rgb,[35 43],'ObjectPolarity','dark');\n%% Step 4: Increase Detection Sensitivity\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.9);\nStep 5: Draw the Circles on the Image\nimshow(rgb)\nh = viscircles(centers,radii);\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92);\nlength(centers)\ndelete(h)  % Delete previously drawn circles\nh = viscircles(centers,radii);\n%% Step 6: Use the Second Method (Two-stage) for Finding Circles\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.92,'Method','twostage');\ndelete(h)\nh = viscircles(centers,radii);\n[centers,radii] = imfindcircles(rgb,[20 25],'ObjectPolarity','dark', ...\n'Sensitivity',0.95);\ndelete(h)\nviscircles(centers,radii);\n%% Step 7: Why are Some Circles Still Getting Missed?\nimshow(gray_image)\n%% Step 8: Find 'Bright' Circles in the Image\n[centersBright,radiiBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92);\n%% Step 9: Draw 'Bright' Circles with Different Color\nimshow(rgb)\nhBright = viscircles(centersBright, radiiBright,'Color','b');\n%% Step 10: Lower the Value of 'EdgeThreshold'\n[centersBright,radiiBright,metricBright] = imfindcircles(rgb,[20 25], ...\n'ObjectPolarity','bright','Sensitivity',0.92,'EdgeThreshold',0.1);\ndelete(hBright)\nhBright = viscircles(centersBright, radiiBright,'Color','b');\n%% Step 11: Draw 'Dark' and 'Bright' Circles Together\nh = viscircles(centers,radii);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h1><p>具体内容及代码下载见<a href=\"https://github.com/HaoxinGuo/ImagIdf\" target=\"_blank\" rel=\"noopener\">HaoxinGuo</a>。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"加载图像\"><a href=\"#加载图像\" class=\"headerlink\" title=\"加载图像\"></a>加载图像</h1><p>该示例使用带有各种颜色的圆形塑料片的图像。如图1所示。<br><img src=\"https://img-blog.csdnimg.cn/20190328103834308.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图1\"></p>\n<pre><code class=\"MATLAB\">rgb = imread(&#39;DetectCirclesExample_01.png&#39;);%读入图片\nimshow(rgb)%显示图</code></pre>\n<p>除了有足够的圆形可以检测外，这个图像中对圆形的检测时还有一些有趣的事情：</p>\n<ol>\n<li>存在不同颜色的芯片，其与背景具有不同的对比度。 一方面，蓝色和红色在这个背景上有强烈的对比。 另一方面，一些黄色芯片与背景对比较差;</li>\n<li>可以发现一些芯片是相互叠加的，还有一些芯片是靠近在一起并且几乎相互接触的。 重叠对象边界和对象的遮挡通常是对象检测的挑战。<h1 id=\"确定搜索圈的半径范围\"><a href=\"#确定搜索圈的半径范围\" class=\"headerlink\" title=\"确定搜索圈的半径范围\"></a>确定搜索圈的半径范围</h1>imfindcircles函数需要一个半径范围来搜索圆圈。 找到合适的半径范围的快速方法是使用交互式工具imdistline来获得各种对象半径的近似估计。如图2所示。<br><img src=\"https://img-blog.csdnimg.cn/20190328104130957.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图2\"></li>\n</ol>\n<pre><code class=\"MATLAB\">d = imdistline;%显示交互式工具，测量半径</code></pre>\n<p>imdistline创建了一个可拖动的工具，可以移动以适应芯片，并且可以读取数字以获得其半径的近似估计。 大多数芯片的半径范围为20像素。 使用稍大的20-25像素的半径范围以确保可以检测到足够多的芯片。 注意在进行下一步操作之前需要删除imdistline工具。</p>\n<pre><code class=\"MATLAB\">delete(d)%删除交互式工具</code></pre>\n<h1 id=\"初步尝试查找圆形\"><a href=\"#初步尝试查找圆形\" class=\"headerlink\" title=\"初步尝试查找圆形\"></a>初步尝试查找圆形</h1><p>在此图像上调用imfindcircles，搜索半径为[20 25]像素。 在此之前，最好查看物体是否比背景更亮或更暗。 要查看图像的暗亮程度，可以调取此图像的灰度版本<br>背景非常明亮，大多数芯片比背景更暗。 但是，默认情况下，imfindcircles会找到比背景更亮的圆形对象。 因此，在imfindcircles中将参数’ObjectPolarity’设置为’dark’以搜索比背景暗的图像。</p>\n<pre><code class=\"MATLAB\">gray_image = rgb2gray(rgb);%图像的灰度版本\nimshow(gray_image)%显示图像\n[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;);%查找圆形</code></pre>\n<p>得到对的结果如下：</p>\n<pre><code class=\"MATLAB\">centers =[ ]\nradii =[ ]</code></pre>\n<p>请注意，输出中心位置和半径为空，这意味着没有找到圆圈。 这种情况经常发生，因为imfindcircles是一个圆形探测器，与大多数探测器类似，imfindcircles有一个内部探测阈值，决定了它的灵敏度。 简单来说，这意味着检测器对某个（圆形）检测的置信度必须大于某个水平才能被认为是有效检测<br>imfindcircles有一个参数’Sensitivity’，可用于控制此内部阈值，从而控制算法的灵敏度。 较高的“灵敏度”值会将检测阈值设置得较低，从而导致检测到更多圆圈。 </p>\n<h1 id=\"提高检测灵敏度\"><a href=\"#提高检测灵敏度\" class=\"headerlink\" title=\"提高检测灵敏度\"></a>提高检测灵敏度</h1><p>回到圆形图像，有可能在默认的灵敏度水平下，所有圆都低于内部阈值，这就是没有检测到圆的原因。 默认情况下，“灵敏度”（0到1之间的数字）设置为0.85。 将“敏感度”提高到0.9。</p>\n<pre><code class=\"MATLAB\">[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;, ...\n&#39;Sensitivity&#39;,0.9)</code></pre>\n<p>这次imfindcircles发现了一些圆圈 - 准确地说是5个圆圈，如图3。 中心包含圆心的位置，半径包含这些圆的估计半径。</p>\n<h1 id=\"在图像上绘制圆圈\"><a href=\"#在图像上绘制圆圈\" class=\"headerlink\" title=\"在图像上绘制圆圈\"></a>在图像上绘制圆圈</h1><p>函数viscircles可用于在图像上绘制圆圈。 来自imfindcircles的输出变量中心和半径可以直接传递给viscircles。</p>\n<pre><code class=\"MATLAB\">imshow(rgb)\nh = viscircles(centers,radii);</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190328104510292.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图3\">圆心被正确定位，其相应的半径似乎与实际芯片很好地匹配。 但仍有不少圆形被遗漏。 尝试将“灵敏度”提高到0.92。</p>\n<pre><code class=\"MATLAB\">[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;, ...\n&#39;Sensitivity&#39;,0.92);\nlength(centers)</code></pre>\n<p>因此，增加“灵敏度”会让我们得到更多的圆形。 再次在图像上绘制这些圆形，如图4。</p>\n<pre><code class=\"MATLAB\">delete(h)  % Delete previously drawn circles\nh = viscircles(centers,radii);</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019032810453758.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图4\"></p>\n<h1 id=\"使用第二种方法（两阶段）寻找圆圈\"><a href=\"#使用第二种方法（两阶段）寻找圆圈\" class=\"headerlink\" title=\"使用第二种方法（两阶段）寻找圆圈\"></a>使用第二种方法（两阶段）寻找圆圈</h1><p>这个结果看起来更好。 imfindcircles有两种不同的方法来寻找圆圈。 到目前为止，称为相位编码方法的默认方法用于检测圆。 还有另一种方法，通常称为两阶段方法，可以在imfindcircles中使用。 使用两阶段方法并显示结果。</p>\n<pre><code class=\"MATLAB\">[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;, ...\n&#39;Sensitivity&#39;,0.92,&#39;Method&#39;,&#39;twostage&#39;);\ndelete(h)\nh = viscircles(centers,radii);</code></pre>\n<p>两阶段方法检测更多圆，灵敏度为0.92。 通常，这两种方法是互补的，因为它们具有不同的强度。 与两阶段方法相比，相位编码方法通常更快并且对噪声更加鲁棒。 但它也可能需要更高的“灵敏度”水平来获得与两阶段方法相同数量的检测。 例如，如果将“灵敏度”级别提高到更高，相位编码方法也会找到相同的芯片，比如0.95，结果如图5所示。</p>\n<pre><code class=\"MATLAB\">[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;, ...\n&#39;Sensitivity&#39;,0.95);\ndelete(h)\nviscircles(centers,radii);</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190328104616612.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图5\"><br>请注意，imfindcircles中的两种方法都能准确地找到部分可见（遮挡）芯片的中心和半径。</p>\n<h1 id=\"为什么有些圈子仍然被错过？\"><a href=\"#为什么有些圈子仍然被错过？\" class=\"headerlink\" title=\"为什么有些圈子仍然被错过？\"></a>为什么有些圈子仍然被错过？</h1><p>看看最后的结果，很奇怪imfindcircles没有在图像中找到黄色芯片。 黄色芯片与背景没有强烈的对比。 事实上，它们似乎与背景具有非常相似的强度。 是否有可能黄色芯片并不像假设的那样真正“背景”更暗？ 要确认，请再次显示此图像的灰度版本。</p>\n<pre><code class=\"MATLAB\">imshow(gray_image)</code></pre>\n<h1 id=\"在图像中找到“明亮”的圆圈\"><a href=\"#在图像中找到“明亮”的圆圈\" class=\"headerlink\" title=\"在图像中找到“明亮”的圆圈\"></a>在图像中找到“明亮”的圆圈</h1><p>与背景相比，黄色芯片的强度几乎相同，甚至更亮。 因此，要检测黄色芯片，请将“ObjectPolarity”更改为“bright”。</p>\n<pre><code class=\"MATLAB\">[centersBright,radiiBright] = imfindcircles(rgb,[20 25], ...\n&#39;ObjectPolarity&#39;,&#39;bright&#39;,&#39;Sensitivity&#39;,0.92);</code></pre>\n<h1 id=\"绘制不同颜色的“明亮”圆圈\"><a href=\"#绘制不同颜色的“明亮”圆圈\" class=\"headerlink\" title=\"绘制不同颜色的“明亮”圆圈\"></a>绘制不同颜色的“明亮”圆圈</h1><p>通过更改viscircles中的“Color”参数，以不同的颜色绘制明亮的圆圈。<br>请注意，发现了三个缺失的黄色芯片，但仍然缺少一个黄色芯片,如图6所示。这些黄色芯片很难找到，因为它们在这种背景下并不像其他芯片那样突出。<br><img src=\"https://img-blog.csdnimg.cn/2019032810464896.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图6\"></p>\n<h1 id=\"降低’EdgeThreshold’的值\"><a href=\"#降低’EdgeThreshold’的值\" class=\"headerlink\" title=\"降低’EdgeThreshold’的值\"></a>降低’EdgeThreshold’的值</h1><p>imfindcircles中还有另一个参数可能在这里很有用，即’EdgeThreshold’。要查找圆圈，imfindcircles仅使用图像中的边缘像素。这些边缘像素基本上是具有高梯度值的像素。 “EdgeThreshold”参数控制像素的梯度值在被视为边缘像素并包含在计算中之前必须有多高。此参数的高值（接近1）将仅允许包含强边（更高的梯度值），而低值（更接近0）更宽松，甚至包括更弱的边（更低的梯度值）计算。在缺少黄色芯片的情况下，由于对比度低，所以预期一些边界像素（在芯片的圆周上）具有低梯度值。因此，降低“EdgeThreshold”参数以确保黄色芯片的大部分边缘像素都包含在计算中，如图7所示。<br><img src=\"https://img-blog.csdnimg.cn/20190328104710426.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图7\"></p>\n<pre><code class=\"MATLAB\">[centersBright,radiiBright,metricBright] = imfindcircles(rgb,[20 25], ...\n&#39;ObjectPolarity&#39;,&#39;bright&#39;,&#39;Sensitivity&#39;,0.92,&#39;EdgeThreshold&#39;,0.1);\ndelete(hBright)\nhBright = viscircles(centersBright, radiiBright,&#39;Color&#39;,&#39;b&#39;);</code></pre>\n<h1 id=\"一起绘制“黑暗”和“明亮”圆圈\"><a href=\"#一起绘制“黑暗”和“明亮”圆圈\" class=\"headerlink\" title=\"一起绘制“黑暗”和“明亮”圆圈\"></a>一起绘制“黑暗”和“明亮”圆圈</h1><pre><code class=\"MATLAB\">h = viscircles(centers,radii);</code></pre>\n<p>现在，imfindcircles找到所有黄色的，绿色的。 用蓝色绘制这些圆形，以及之前发现的其他圆形（“ObjectPolarity”设置为“dark”），如图8所示。<br><img src=\"https://img-blog.csdnimg.cn/20190328104732652.png#pic_center?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b2hhb3hpbg==,size_16,color_FFFFFF,t_70\" alt=\"图8\"><br>应该注意的是，将参数更改为在检测中更容易可能会发现更多的圆圈，但它也增加了检测假圆的可能性。 可以找到的真实圆圈数（检测率）和与它们一起找到的假圆圈数量之间存在权衡（误报率）</p>\n<h1 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h1><pre><code class=\"MATLAB\">%% Step 1: Load Image\nrgb = imread(&#39;DetectCirclesExample_01.png&#39;);\nimshow(rgb)\n%% Step 2: Determine Radius Range for Searching Circles\nd = imdistline;\ndelete(d)\n%%  Step 3: Initial Attempt to Find Circles\ngray_image = rgb2gray(rgb);\nimshow(gray_image)\n[centers,radii] = imfindcircles(rgb,[35 43],&#39;ObjectPolarity&#39;,&#39;dark&#39;);\n%% Step 4: Increase Detection Sensitivity\n[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;, ...\n&#39;Sensitivity&#39;,0.9);\nStep 5: Draw the Circles on the Image\nimshow(rgb)\nh = viscircles(centers,radii);\n[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;, ...\n&#39;Sensitivity&#39;,0.92);\nlength(centers)\ndelete(h)  % Delete previously drawn circles\nh = viscircles(centers,radii);\n%% Step 6: Use the Second Method (Two-stage) for Finding Circles\n[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;, ...\n&#39;Sensitivity&#39;,0.92,&#39;Method&#39;,&#39;twostage&#39;);\ndelete(h)\nh = viscircles(centers,radii);\n[centers,radii] = imfindcircles(rgb,[20 25],&#39;ObjectPolarity&#39;,&#39;dark&#39;, ...\n&#39;Sensitivity&#39;,0.95);\ndelete(h)\nviscircles(centers,radii);\n%% Step 7: Why are Some Circles Still Getting Missed?\nimshow(gray_image)\n%% Step 8: Find &#39;Bright&#39; Circles in the Image\n[centersBright,radiiBright] = imfindcircles(rgb,[20 25], ...\n&#39;ObjectPolarity&#39;,&#39;bright&#39;,&#39;Sensitivity&#39;,0.92);\n%% Step 9: Draw &#39;Bright&#39; Circles with Different Color\nimshow(rgb)\nhBright = viscircles(centersBright, radiiBright,&#39;Color&#39;,&#39;b&#39;);\n%% Step 10: Lower the Value of &#39;EdgeThreshold&#39;\n[centersBright,radiiBright,metricBright] = imfindcircles(rgb,[20 25], ...\n&#39;ObjectPolarity&#39;,&#39;bright&#39;,&#39;Sensitivity&#39;,0.92,&#39;EdgeThreshold&#39;,0.1);\ndelete(hBright)\nhBright = viscircles(centersBright, radiiBright,&#39;Color&#39;,&#39;b&#39;);\n%% Step 11: Draw &#39;Dark&#39; and &#39;Bright&#39; Circles Together\nh = viscircles(centers,radii);</code></pre>\n<h1 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h1><p>具体内容及代码下载见<a href=\"https://github.com/HaoxinGuo/ImagIdf\" target=\"_blank\" rel=\"noopener\">HaoxinGuo</a>。</p>\n"},{"title":"用户运营","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T08:51:45.000Z","password":null,"summary":null,"_content":"\n用户运营是做什么的；要让我用一句话描述用户运营，那就是“以用户为中心”做产品与用户之间的交互连接\n\n用户运营常用的手段有用户数据分析，搭建用户模型，对用户进行用户分层，分级，积分体系，会员体系等等，从而达到用户增长，留存，付费，复购等运营目的。\n\n一、抛开运营，深入用户\n\n二、C+B的运营思维\n\n互联网运营的核心痛点在于：转化潜在用户（拉新）、转化现有用户、转化价值用户（购买）、提升用户价值（包括复购、交叉销售等）。\n\n借鉴B端思维——服务好老用户思维，挖掘老用户的价值，为公司带来营收增长，则是用户“增长”新的突破点。\n\n三、定位沉默用户，带动“增长”\n\n四、选择方式，精准触达\n\n1. Push/站内消息\n\n2. 短信\n\n3. EDM\n\n4. 电话回访（慎用）\n\n5. 利益点（红包/优惠券/礼品）\n\n然而在我看来，用户运营未来的核心价值并不是能带来多少用户数量的增长，而是如何为企业带来营收的增长。\n\n此外B端+C端运营思维的结合也是未来的趋势，两者彼此借鉴，根据产品的特征对运营思维进行改良，做一些微创新，才能更好的迎接时代变化。\n\n企业方面，选择用户运营的时，首先要看他是否有全局观，既能触类旁通又能迅速切换思维；\n其次要看他是否有自成一套的运营方法论，并且可以结合已有的模型进行微创新，最终形成可变现的运营策略落地执行；\n最后，要看是否有从0到1的经历，以及是否操盘过高日活/月活的产品。\n\n我希望自己成为能主导整个公司方向的人，起到关键的作用，这是我当时做产品的初衷。\n\n虽然离这个目标还很远，但是做产品确实让我学会了思考问题的本质，开始提升自己的认知，让自己从一个被动的人，转变为主动的人，每个人的一生都不应该受限，想办法去创造可能就是我们生命的意义。\n\nWhy 产品？\n\n1.现状层面：\n\n本硕都是社科专业，本科有去专业对口的岗位实习过，工作内容没什么挑战性，按流程走就好了，自己不是很感兴趣\n硕士期间萌生了转行的想法，了解了一些行业后，选择了互联网，选择了产品岗\n\n\n2.个人特质层面：\n\n喜欢做一些有挑战性的事情，且抗压能力还不错，比如曾经独自41天穷游滇藏线，徒步&途搭至拉萨，适应极限挑战，996对我来说，好像也不是很care\n学习能力还算ok，不是智商爆表的学霸，但也好像还不算蠢。用我朋友的话说，“能从普通本科学校考到头部985还算蠢的话，那那些没考上的岂不都是智障？”当然，这只是句玩笑话，会考试不代表学习能力就强。对于产品所需要的那些知识，只要用对方法，我想是没问题的，时间长短而已。\n\n3.个人情怀层面：\n\n没有那种想要改变世界的梦想，如果能通过自己的思考，做出一款帮助用户提升或改善生活方式的产品，我觉得就很好了。目前的想法就是这样~\n\n4.现实层面：\n\n从已有的经验和案例来看，产品岗的发展路径确实不错??\n想尽快的经济独立，金融和互联网是不错的选择，但是金融的硬性准入门槛摆在那儿","source":"_posts/2019-operation.md","raw":"---\ntitle: 用户运营\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 16:51:45\npassword:\nsummary:\ntags:\n- 读书笔记 运营\ncategories:\n- 读书笔记\n---\n\n用户运营是做什么的；要让我用一句话描述用户运营，那就是“以用户为中心”做产品与用户之间的交互连接\n\n用户运营常用的手段有用户数据分析，搭建用户模型，对用户进行用户分层，分级，积分体系，会员体系等等，从而达到用户增长，留存，付费，复购等运营目的。\n\n一、抛开运营，深入用户\n\n二、C+B的运营思维\n\n互联网运营的核心痛点在于：转化潜在用户（拉新）、转化现有用户、转化价值用户（购买）、提升用户价值（包括复购、交叉销售等）。\n\n借鉴B端思维——服务好老用户思维，挖掘老用户的价值，为公司带来营收增长，则是用户“增长”新的突破点。\n\n三、定位沉默用户，带动“增长”\n\n四、选择方式，精准触达\n\n1. Push/站内消息\n\n2. 短信\n\n3. EDM\n\n4. 电话回访（慎用）\n\n5. 利益点（红包/优惠券/礼品）\n\n然而在我看来，用户运营未来的核心价值并不是能带来多少用户数量的增长，而是如何为企业带来营收的增长。\n\n此外B端+C端运营思维的结合也是未来的趋势，两者彼此借鉴，根据产品的特征对运营思维进行改良，做一些微创新，才能更好的迎接时代变化。\n\n企业方面，选择用户运营的时，首先要看他是否有全局观，既能触类旁通又能迅速切换思维；\n其次要看他是否有自成一套的运营方法论，并且可以结合已有的模型进行微创新，最终形成可变现的运营策略落地执行；\n最后，要看是否有从0到1的经历，以及是否操盘过高日活/月活的产品。\n\n我希望自己成为能主导整个公司方向的人，起到关键的作用，这是我当时做产品的初衷。\n\n虽然离这个目标还很远，但是做产品确实让我学会了思考问题的本质，开始提升自己的认知，让自己从一个被动的人，转变为主动的人，每个人的一生都不应该受限，想办法去创造可能就是我们生命的意义。\n\nWhy 产品？\n\n1.现状层面：\n\n本硕都是社科专业，本科有去专业对口的岗位实习过，工作内容没什么挑战性，按流程走就好了，自己不是很感兴趣\n硕士期间萌生了转行的想法，了解了一些行业后，选择了互联网，选择了产品岗\n\n\n2.个人特质层面：\n\n喜欢做一些有挑战性的事情，且抗压能力还不错，比如曾经独自41天穷游滇藏线，徒步&途搭至拉萨，适应极限挑战，996对我来说，好像也不是很care\n学习能力还算ok，不是智商爆表的学霸，但也好像还不算蠢。用我朋友的话说，“能从普通本科学校考到头部985还算蠢的话，那那些没考上的岂不都是智障？”当然，这只是句玩笑话，会考试不代表学习能力就强。对于产品所需要的那些知识，只要用对方法，我想是没问题的，时间长短而已。\n\n3.个人情怀层面：\n\n没有那种想要改变世界的梦想，如果能通过自己的思考，做出一款帮助用户提升或改善生活方式的产品，我觉得就很好了。目前的想法就是这样~\n\n4.现实层面：\n\n从已有的经验和案例来看，产品岗的发展路径确实不错??\n想尽快的经济独立，金融和互联网是不错的选择，但是金融的硬性准入门槛摆在那儿","slug":"2019-operation","published":1,"updated":"2019-09-30T08:52:42.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbl001s2wvcm9chwdhr","content":"<p>用户运营是做什么的；要让我用一句话描述用户运营，那就是“以用户为中心”做产品与用户之间的交互连接</p>\n<p>用户运营常用的手段有用户数据分析，搭建用户模型，对用户进行用户分层，分级，积分体系，会员体系等等，从而达到用户增长，留存，付费，复购等运营目的。</p>\n<p>一、抛开运营，深入用户</p>\n<p>二、C+B的运营思维</p>\n<p>互联网运营的核心痛点在于：转化潜在用户（拉新）、转化现有用户、转化价值用户（购买）、提升用户价值（包括复购、交叉销售等）。</p>\n<p>借鉴B端思维——服务好老用户思维，挖掘老用户的价值，为公司带来营收增长，则是用户“增长”新的突破点。</p>\n<p>三、定位沉默用户，带动“增长”</p>\n<p>四、选择方式，精准触达</p>\n<ol>\n<li><p>Push/站内消息</p>\n</li>\n<li><p>短信</p>\n</li>\n<li><p>EDM</p>\n</li>\n<li><p>电话回访（慎用）</p>\n</li>\n<li><p>利益点（红包/优惠券/礼品）</p>\n</li>\n</ol>\n<p>然而在我看来，用户运营未来的核心价值并不是能带来多少用户数量的增长，而是如何为企业带来营收的增长。</p>\n<p>此外B端+C端运营思维的结合也是未来的趋势，两者彼此借鉴，根据产品的特征对运营思维进行改良，做一些微创新，才能更好的迎接时代变化。</p>\n<p>企业方面，选择用户运营的时，首先要看他是否有全局观，既能触类旁通又能迅速切换思维；<br>其次要看他是否有自成一套的运营方法论，并且可以结合已有的模型进行微创新，最终形成可变现的运营策略落地执行；<br>最后，要看是否有从0到1的经历，以及是否操盘过高日活/月活的产品。</p>\n<p>我希望自己成为能主导整个公司方向的人，起到关键的作用，这是我当时做产品的初衷。</p>\n<p>虽然离这个目标还很远，但是做产品确实让我学会了思考问题的本质，开始提升自己的认知，让自己从一个被动的人，转变为主动的人，每个人的一生都不应该受限，想办法去创造可能就是我们生命的意义。</p>\n<p>Why 产品？</p>\n<p>1.现状层面：</p>\n<p>本硕都是社科专业，本科有去专业对口的岗位实习过，工作内容没什么挑战性，按流程走就好了，自己不是很感兴趣<br>硕士期间萌生了转行的想法，了解了一些行业后，选择了互联网，选择了产品岗</p>\n<p>2.个人特质层面：</p>\n<p>喜欢做一些有挑战性的事情，且抗压能力还不错，比如曾经独自41天穷游滇藏线，徒步&amp;途搭至拉萨，适应极限挑战，996对我来说，好像也不是很care<br>学习能力还算ok，不是智商爆表的学霸，但也好像还不算蠢。用我朋友的话说，“能从普通本科学校考到头部985还算蠢的话，那那些没考上的岂不都是智障？”当然，这只是句玩笑话，会考试不代表学习能力就强。对于产品所需要的那些知识，只要用对方法，我想是没问题的，时间长短而已。</p>\n<p>3.个人情怀层面：</p>\n<p>没有那种想要改变世界的梦想，如果能通过自己的思考，做出一款帮助用户提升或改善生活方式的产品，我觉得就很好了。目前的想法就是这样~</p>\n<p>4.现实层面：</p>\n<p>从已有的经验和案例来看，产品岗的发展路径确实不错??<br>想尽快的经济独立，金融和互联网是不错的选择，但是金融的硬性准入门槛摆在那儿</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<p>用户运营是做什么的；要让我用一句话描述用户运营，那就是“以用户为中心”做产品与用户之间的交互连接</p>\n<p>用户运营常用的手段有用户数据分析，搭建用户模型，对用户进行用户分层，分级，积分体系，会员体系等等，从而达到用户增长，留存，付费，复购等运营目的。</p>\n<p>一、抛开运营，深入用户</p>\n<p>二、C+B的运营思维</p>\n<p>互联网运营的核心痛点在于：转化潜在用户（拉新）、转化现有用户、转化价值用户（购买）、提升用户价值（包括复购、交叉销售等）。</p>\n<p>借鉴B端思维——服务好老用户思维，挖掘老用户的价值，为公司带来营收增长，则是用户“增长”新的突破点。</p>\n<p>三、定位沉默用户，带动“增长”</p>\n<p>四、选择方式，精准触达</p>\n<ol>\n<li><p>Push/站内消息</p>\n</li>\n<li><p>短信</p>\n</li>\n<li><p>EDM</p>\n</li>\n<li><p>电话回访（慎用）</p>\n</li>\n<li><p>利益点（红包/优惠券/礼品）</p>\n</li>\n</ol>\n<p>然而在我看来，用户运营未来的核心价值并不是能带来多少用户数量的增长，而是如何为企业带来营收的增长。</p>\n<p>此外B端+C端运营思维的结合也是未来的趋势，两者彼此借鉴，根据产品的特征对运营思维进行改良，做一些微创新，才能更好的迎接时代变化。</p>\n<p>企业方面，选择用户运营的时，首先要看他是否有全局观，既能触类旁通又能迅速切换思维；<br>其次要看他是否有自成一套的运营方法论，并且可以结合已有的模型进行微创新，最终形成可变现的运营策略落地执行；<br>最后，要看是否有从0到1的经历，以及是否操盘过高日活/月活的产品。</p>\n<p>我希望自己成为能主导整个公司方向的人，起到关键的作用，这是我当时做产品的初衷。</p>\n<p>虽然离这个目标还很远，但是做产品确实让我学会了思考问题的本质，开始提升自己的认知，让自己从一个被动的人，转变为主动的人，每个人的一生都不应该受限，想办法去创造可能就是我们生命的意义。</p>\n<p>Why 产品？</p>\n<p>1.现状层面：</p>\n<p>本硕都是社科专业，本科有去专业对口的岗位实习过，工作内容没什么挑战性，按流程走就好了，自己不是很感兴趣<br>硕士期间萌生了转行的想法，了解了一些行业后，选择了互联网，选择了产品岗</p>\n<p>2.个人特质层面：</p>\n<p>喜欢做一些有挑战性的事情，且抗压能力还不错，比如曾经独自41天穷游滇藏线，徒步&amp;途搭至拉萨，适应极限挑战，996对我来说，好像也不是很care<br>学习能力还算ok，不是智商爆表的学霸，但也好像还不算蠢。用我朋友的话说，“能从普通本科学校考到头部985还算蠢的话，那那些没考上的岂不都是智障？”当然，这只是句玩笑话，会考试不代表学习能力就强。对于产品所需要的那些知识，只要用对方法，我想是没问题的，时间长短而已。</p>\n<p>3.个人情怀层面：</p>\n<p>没有那种想要改变世界的梦想，如果能通过自己的思考，做出一款帮助用户提升或改善生活方式的产品，我觉得就很好了。目前的想法就是这样~</p>\n<p>4.现实层面：</p>\n<p>从已有的经验和案例来看，产品岗的发展路径确实不错??<br>想尽快的经济独立，金融和互联网是不错的选择，但是金融的硬性准入门槛摆在那儿</p>\n"},{"title":"产品经理面试问题集锦","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-29T10:54:06.000Z","password":null,"summary":"整理的PM面试问题集锦。","_content":"\n\n# 自我介绍部分\n\n## 一分钟自我介绍\n\n## 一句话介绍自己\n\n1. 群面介绍\n\n1. 单面介绍\n\n## 你的职业规划，为什么想进大公司？\n\n1. 一方面保持专业深度的不断提升，向周围优秀的同事们学习，学习公司的文化，通过追赶他们，让自己成为一个更加职业化、专业化的职业人。\n\n1. 保持行业广度的不谈拓展，让自己有视野、有内涵、有前瞻、有承担，成为一名职场精英，并且密切配合公司对于岗位需要的调整和深化，持续提升自己的胜任力。\n\n1. 成长起来，承担起自己的职责，让自己更有影响力。\n\n## 说出你自己身上的三个优点，三个缺点？\n1. 优点：我觉得我自己的最大优势是有趣、不固执。我会对自己的想法充满激情，但也不怕承认自己是错的，这样当产品或者市场迅速发生变化时，我也能很灵活，这样同事们也可以慢慢的更加信任我了。\n1. 我觉得我做事情效率高，习惯把重复性的工作简化和批量化，能够为自己节约很多的时间。比如，在绘制组织管理图是利用graphViz绘图，利用dot2pdf进行批量生成文件。利用md文档，快捷生成Word、PDF、LATEX格式，满足多种要求。\n1. 缺点：不知道如何拒绝，朋友要求帮忙一下，一般不会拒绝，有时候会影响到自己的自身工作进度。\n\n举个例子，研一下学期快期末考试的时候，一个好朋友希望我给她拍一个短片vlog，虽然临近期末，我也不太好拒绝，所以就帮她拍了，从准备到实施以及到最后的出片大约花了我五天的时间。\n乐于助人是好事，但是一味的想做“好人”是有问题的，后面我会通过多任务处理来设定工作的优先顺序，明确的向朋友说明自己的时间安排，并给一个自己能在合适可以给予帮助的时间估计，让寻求人自行决定能否接受帮助。我相信这样的时间管理方式，能够最大程度的改正我的这个缺点。\n\n## 最成功的的一件事情？\n\n我认为我最成功的一件事，是在今年暑假的时候，在广联达产品部实习，我和7位同是实习的开发人员，一起做出一款成功的产品，基于GBMP的路径漫游产品。我作为产品负责人，对产品的最终成果负责。我首先对市场上现有产品进行了竞品分析，确定了我们需要解决的痛点、难点和关键点。我们采用敏捷开发的形式，每周一个迭代，自己身兼开发，设计和测试，经过两个月的工作，我们小组获得了部门领导的一致好评。现该产品已经内嵌到一个产品中。\n\n## 最失败的一件事情？\n\n曾经作为班级联郊游活动的发起人，想组织了我们学院和人文学院的联春游获得活动，期间我做了很多努力，比如联络对方学院的负责人，联系旅游中介，联系住宿吗，联系学校相关部门进行报备。\n但是由于临近期末，加上学校期末对学生安全关注高，最终没能达到预期的效果。虽然结果令人遗憾，但是从中我认识到了不足，也积累了经验，举办活动，我认为失败是在所难免的，有时候失败比成功更能是人成长，经过我的锻炼和学习，我相信如果再经历相关的实践工作，我一定会做的更好！\n\n## 你在业余时间喜欢做什么？\n我最近在学习一些有关产品经理的书籍，比如《参与感》《用户体验要素》《运营之光》，差不多10+ 本吧，还有最新上\n的《幕后产品》，希望自己可以更多地了解这个行业，这个工作。\n我平时也会把自己学到的东西分享出来，包括开发了一个小软件，在CSDN 上分享一些自己的心得。\n之前也会是摄影、剪视频和飞无人机，体验创作的乐趣。\n\n## 你为什么想来我们公司？\n1. 公司文化/地位\n2. 人才培养\n3. 专业对口\n\n# 产品基础知识\n\n## 为什么选择产品这一职位？\n\n1. 研究生期间主要负责结构分析软件积分器部分的实现，也开发了自己的软件和算法，在这个过程中逐渐了解到产品经理这个岗位，之后又参加了P1产品经理系列课程的学习，阅读了一些有关产品的书籍。此外又在广联进行了实习，自己逻辑能力、沟通能力、组织能力、管理能力都比较适合产品。\n\n2. \n我属于创作型人格，对于把一个作品从无到有做出来这件事特别着迷。不管是拍照、拍微电影、还是设计一个大家都在使用的产品，都能给我带来巨大的成就感，为了这种成就感我甚至几个晚上熬通宵都没问题。\n\n1. 挑战和成就感。产品经理这一职位，自己对产品的一个小小的改动，就能影响到大量的用户。然后产品上线，看着产品的 PV的增长，可以很快的感受到你工作的价值。\n\n1. 产品经理要负责协调沟通各方面、开发、测试、运营、 UE 。繁多的事情，会给产品经理带来重大的挑战，我喜欢有挑战的做事情。\n\n1. 希望工作有设计策划的成就感；大学的专业学桥梁设计，比较追求理想化的东西，比如项目管理的掌控感，做产品实现自己想法的感觉。\n\n## 产品经理的职责是什么？产品经理需要的能力?\n\n我个人认为产品经理就是以解决用户核心需求，公司需求为目的，从需求调研，需求产出，需求落地，到需求验证全程跟进负责的人。\n\n具体来看，需求调研，包括要做一款什么样的产品？需求调研的方法包括：1、问卷调查 2、电话回访 3、见面约访 4、数据分析 5、业务需求等内容，也包括市场分析，竞品分析等；\n\n需求产出，包括从需求池中找出优先级最高的需求；需求落地，包括设计出图，研发代码实现，功能测试，产品验收等，需求验证包括数据验证等。\n\n我从以下两个方面阐述产品经理需要的能力：\n\n个人基本素质方面：\n\n1. 沟通能力，产品是技术，测试，视觉，运营和推广等部门沟通的桥梁，很多的工作需要与各个部门的人合作完成，横向沟通，纵向沟通的沟通效果非常重要。\n\n1. 逻辑能力，产品经理逻辑工作复杂，且产品实现逻辑也很严谨，所以逻辑性和条理性很重要；\n\n1. 学习能力，互联网站在时代的最前沿，很多东西需要去创造，作为开拓者需要不断去学习。\n\n产品基本能力方面：\n\n1. 对行业的了解\n\n1. 站在用户思考的能力，能够站在主流用户/不同使用习惯/不同背景的用户角度去思考问题，而不是简单的把自己当做一个用户去思考决策问题\n\n1. 数据分析能力，决策需要数据的支撑，收集数据、整理数据和分析数据是一项非常重要的能力。\n\n1. 文档/原型能力\n\n## 如何获取和发现用户需求？\n\n问卷调查：问卷设计以选择题为主，可用通过问卷平台来发放。回答问卷的用户最好是你的产品的目标用户，要不然你的问卷结果的数据没有什么意义。\n\n核心用户访谈：这种方法成本比较高，但是往往你可以得到很多有用的信息。访谈可以涉及到的问题面会远远超过问卷。而且问卷调查的问题往往偏理性，而用户访谈你可以通过用户的情绪、表情、语气来获得更多感性的内容。\n\n竞品分析：可以帮助你快速了解此行业的最新动态。仔细研究竞争对手的产品会帮助你大致了解用户的痛点和需求。然后你在团队头脑风暴或者用户访谈的时候，你可以知道哪些功能你的竞争对手做的不好。这些功能点和需求，就是你的机会。\n\n通过数据分析：比如移动搜索端的产品，当你在决定做哪些领域之前，你需要选取一定的用户行为分析样本，然后对用户的行为进行标注。搜索领域用户的行为主要是：Query查询。当你获得了一天Top 十万的Query，你随机抽取其中的1000个Query，你可以分析这些Query，然后你会大致了解整体用户的搜索意图。然后对照你现有的产品，看看哪些领域，你的搜索结果是没有符合用户需求的。\n\n## 你是怎么挖掘产品需求的？\n\n在我看来，需求来源主要包括两大方面：\n\n一方面是来自于公司外部，即用户、市场、竞品等等；\n\n一方面是来自于公司内部，即企业战略、团队头脑风暴、产品数据分析等等。\n\n![图片](https://uploader.shimo.im/f/AlagXWDkmmQrOlOI.jpg!thumbnail)\n\n\n## 你是怎么判定各个产品需求的优先级的？\n\n1. 晚上看之前的笔记。重要性和紧急性；开发难度和成本\n2. 在判断产品的优先级时，一般通过KANO模型进行判断。KANO模型定义了三个层次的用户需求:基本型需求、期望型需求和兴奋型需求。基本需求是必须具备的，即使不说也应该做到，这部分需求一般是产品初期需要做的功能。期望型需求是用户期望的，用户能够较清晰地知道的。而兴奋型需求是超出用户预期的，用户不知道有这方面的需求，如果提供，用户满意度会更高。\n\nKANO模型后面还有了其他方面的一些延伸：\n\n\t魅力需求：用户意想不到的，如果不提供此需求，用户满意度不会降低，但当提供此需求，用户满意度会有很大提升；\n\t期望需求：当提供此需求，用户满意度会提升，当不提供此需求，用户满意度会降低；\n\t必备需求：当优化此需求，用户满意度不会提升，当不提供此需求，用户满意度会大幅降低；\n\t无差异需求：无论提供或不提供此需求，用户满意度都不会有改变，用户根本不在意；\n\t反向需求：用户根本都没有此需求，提供后用户满意度反而会下降。\t\n\n## 你为做产品都做了哪些准备？\n\n1. 书籍，看过的书籍，《用户体验要素》《启示录》 《上瘾》\n\n1. 产品经理互联网训练营，需求分析，PRD文档等\n\n1. 日常生活，PMcaff 三节课 人人都是产品经理 APP\n\n## 你个人想做什么方向的产品？为什么？\n\n## 比较好的产品？\n\n### 微信阅读\n\n联系微信阅读和《上瘾》这本书\n\n![图片](https://uploader.shimo.im/f/nq5b3HnZwQM8ZJRr.jpg!thumbnail)\n### 知乎\n\n“我是知乎的超级粉丝。知乎是一个问答型APP，用户可以发布问题寻求帮助，通常会有一些相关主题的专家来回答问题。比如说，有人可能会问：‘更换轮胎最好的办法是什么？’或‘创业公司应该等候时机再筹集风险投资吗？’，甚至是‘住在牧场里是什么感觉？’网站上的问题五花八门，从‘帮我解决问题’到‘你对某事有什么看法’，再到‘请分享这方面的经验’，一切都应有尽有。\n\n“我喜欢知乎的原因之一就是它在解决专业问题时的专业性。基本上任何行业的专家都有，提供专业意见，能够给出极其详尽、深思熟虑的答案。\n\n“然而，在解决专业问题之余，我发现我还很喜欢使用这个APP。事实上它是一个基于学习和探索的社区。你可以认识网站上的人，评价他们的回答，因为你可以信任他们。\n\n“我想它是少数能将学习和乐趣连结起来的APP之一。它是一个问答型APP，每当我偶然发现一个自己从来不感兴趣但却很想知道的话题，就会到上面去询问别人。“在我个人使用的经历中，很多时候它都代替了百度，能够帮我搜到我想要的答案。\n想想看，其实通过搜索引擎来解决问题，是有几种缺陷的。\n\n“第一，你会使用关键词来搜索，即便要解答一个问题，也同样如此。你是希望找到一个页面，能为你提供全面纵览的视角来解答你的问题。这并不是一种以解决方案为导向的搜索方式，通常效率很低。\n\n“第二是信任问题。你可能不信任搜索结果中网页作者的证据。就算你信任他，他们也可能在自己的专业领域里把问题搞错了。“知乎允许用户对问题答案以评论的方式进行反馈（也有“点赞”和“反对”的形式）。\n\n“当然，我仍会在网上搜索答案，但我发现我越来越经常使用知乎来解决问题，并且它也是我浏览和学习新知识的地方。”\n\n**盈利模式**\n\n1. 广告\n\n1. 会员\n\n1. 提成\n\n### 网易云音乐\n\n网易云音乐的定位是“移动音乐社区”，并以歌单为核心的组织方式强化用户UGC社交属性。\n\n网易云音乐以“音乐社交”的差异点切入市场，迅速获得大批活跃用户。并以此为基，向产业链上游延伸。以产品撬动市场，试图颠覆传统、改变行业。\n\n网易云音乐从多纬度满足用户发现音乐的需求，个性推荐，歌单，主播电台，排行榜等，基于朋友的社交分享功能，提供对歌曲、歌单、专辑、电台的点赞、评论、转发。可以关注基于通讯录的朋友、微博的朋友、明星、音乐达人、还可关注基于LBS附近的人。\n\n在网易云音乐中，弱化了专辑，强化了歌单，好处是：利用算法提高曲库利用率，把用户喜欢听但主观寻找不找的音乐找出来推荐给用户，弱化版权不足的缺点，网易云音乐把握住了人性。好的音乐是由用户决定的，因为好的UGC会得到大家的认可，这个看评论区就可以看出来，如果有音乐人在某首歌曲下留言，他可能是被赞最多的，同样，即使是普通用户留言，也可以达到同样的效果。谁不渴望获得别人的认可，在娱乐自己的同时，还能得到他人的关注认可。于是，高粘性促使用户的听歌习惯在无形中转变，由听音乐转换到发现音乐再到爱上音乐，换句话来说，一个没有权威、畅所欲言的国度是不是你渴望的？\n\n## 不喜欢的产品？\n\n## 成功的产品有什么标准？\n\n\n个人看来：一款成功的产品必须具有以下标准：\n\n1. 能解决目标用户的痛点。\n\n1. 拥有较好的用户体验。\n\n1. 能够为企业或个人带来利益。\n\n1. 具有不错的用户粘性。\n\n## 你是因为做不了技术才做产品的吗？\n\n## 产品经理如何与运营沟通？\n\n1. “换位思考”和“尊重”\n\n1. 理解产品的定位与价值 很多时候产品和运营沟通，出现的主要矛盾点就在于产品定位和对应的人群。\n\n1. 理解运营流程；产品中会有很多标准的执行流程，但是在运营的过程中，很多流程是灵活的，有些不需要标准化。这个时候就不能运用产品经理的流程化和标准化的思维去理解运营人员的工作，不然就很容易发生矛盾。\n\n1. 需求决定权归属明确\n\n在产品的前期，产品性质与人群匹配的过程中，需求的决定还是取决于产品经理。因为产品经理要确保产品的初衷，定位和价值不发生改变，或者根据市场的需求，做相应的改变。\n\n1. 运营与产品是一家\n\n最后一定要抱着产品和运营是一家的观点去和运营沟通。产品和运营，都是为了能够让产品更好的获得更多的用户。\n一些点子和需求，需要大家共同商讨确定。不同的观点可以带来不同的思路，不要因为岗位的不同，职责不同，为了使自己方便而让其他人作出让步，只要这个需求是正确的，最终目的是为了获得更多的目标用户，那么产品和运营都需要支持。\n\n## 产品经理如何与强势的技术沟通？\n\n产品与开发之间主要产品矛盾的点是什么呢？——工期\n\n1. 做好自己的本质工作，明确需求的优先级，准备详实的文档，沟通重要保持清晰的思路，要注重细节与全局的把控。\n\n1. 理解对方的深层顾虑\n\n1. 学习开发技术，可以不要求技能有多精进，能够掌握各种最新技术，也可以不要求代码有多么优美整洁，架构设计得多么合理。但是最起码也要能够使用现有的框架、组件、资源去完成一个独立产品的开发。在开发中了解自己平时所负责的产品，是如何通过代码实现出来的。要抛弃学技术就是为了“说行话”这个想法。\n\n1. 大多数产品和开发之间的沟通问题，都不是沟通能力的问题，而是产品经理思考能力的问题。\n\n## 遇到不可沟通的人怎么办？or 和开发人员闹僵了怎么处理？\n\n如果在项目进行过程中遇到了这样的问题，我的处理办法是：\n\n1. 摆数据：拿出相关数据来佐证改动的必要性，数据可以是页面点击数，用户粘性。\n\n1. 讲事实：在数据论证的基础上，阐述项目规划、目标和领导预期，并结合所需要的改动的功能点进行说明。论证修改后悔取得双方互赢的良好效果。\n\n1. 适当妥协：站在技术的角度，首先要理解技术拒绝更改的原因。在合理的范围内做适当的妥协，如项目的拖延时间等等，关键是项目有所输出并保证质量。\n\n1. 向上沟通。\n\n当然，在处理本次冲突的基础上，还需要客观的分析冲突发生的原因，是由于沟通机制存在问题还是由于沟通双方的沟通方式没有磨合好。及时分析，避免下次出现这种情况。\n\n## 产品被同行抄袭该怎么处理？\n\n对于技术和交互的抄袭，诉之法庭是最好的解决办法，而对于模式的抄袭，最为关键的是集中优势建立核心资源壁垒，抓紧时间强占市场。\n\n1. 建立技术壁垒\n\n1. 建立资源壁垒\n\n1. 建立用户口碑壁垒\n\n## 你觉得你的执行能力怎么样？\n\n我觉得我的执行能力有待提高，现在属于合格水平。比如上次学校的活动，我们要在3天内拉到3000元的活动赞助。我们第一天做策划方案，接下来两天，3人小组白天刷企业，晚上修改策划，最终搞定3500元的赞助费。对于一个事情，我push的能力很强，但执行能力不仅是push能力，还有规划、团队协作能力，我都有待提高。拉赞助的活动，我们最后虽然成功了，但是在刷企业的路线规划、分头行动的沟通效率上还有待提高。\n\n## 如何做需求的优先级排序和版本规划\n\n产品的版本规划，对于不同的产品、不同阶段的产品，其排期方式可能不同。不同职级的PM所需要掌握的管理的方法也不同，这里选取相对初级的产品经理而不是全面的产品负责人。\n\n1. boss的需求，\n\n1. 版本的主要功能及商业化\n\n1. 明显可以提高日活/拉新等的优化和调整类需求\n\n1. 尝试性功能和提高运营效率等\n\n\n**产品未上线：**\n\n1. 基于当时的环境和实际情况\n\n1. 用户需求是一个动态变化的过程\n\n**对于免费性商品且以经上线**\n\n需求的商业价值原则--重要性紧迫性原则。\n\n用户需求重要性的判断标准：用户基数，使用次数和类别重要性。\n\n用户需求重要性=功能使用用户百分比（用户使用率）X 功能使用频次（功能/内容使用率） X 类别重要百分比（基本型、期望性、兴奋性）\n\n**收费性**\n\n重要性==收益。\n\n使用一下四种方法进行优先级进行排序：\n\n1. 看用户量和发生频率\n\n1. 看开发难度和效果\n\n1. 看产品价值\n\n1. 看对目标群体的熟悉程度\n\n## 产品需求的来源有那些？\n\n1. 老板提出的战略性需求。\n\n1. 产品经理根据产品方向规划需求。\n\n1. 推广规划的活动和数据分析出来一些需求。\n\n1. 用户访谈提出需求。\n\n1. 其他参与者和关注者反馈的需求。\n\n## 如何处理可能完成不了的紧急任务？\n\n面对这样的棘手的事情，有以下三个原则：\n\n1. 保持信息的畅通\n\n1. 从源头出发，辅以紧急措施\n\n1. 坦然面对利益和责任，知错要能改。\n\n之后，自己有以下解决方式：\n\n1. 向同事寻求帮忙，优点是同事熟悉业务，上手快，最可靠。\n\n1. 向同行业的人寻求帮助，优点是人气成本低，成本是沟通成本大，风险是涉密，收益上更有利于自己；\n\n1. 雇佣合适的人来完成。\n\n总之，解决方案的选择，是以下各种因素权衡后的结果：公司的利益，任务的结果，上司承担的风险，解决成本，自己的舆论和给公司的形象。\n\n同时，还要思考为什么不能按时完成任务？是前期计划不合理，还是执行有问题？这个习惯有利于找到症结后迅速打开局面。同时还能知道问题的源头。\n\n## 产品上线后要注意的指标？\n\n考虑到不同类型的产品和平台，其关键指标有着不小的差异，所以以“PC端的媒体网站”来进行论述：\n\n第一类：流量类指标\n\n总PV，平均浏览页面数，跳出率，退出率，平均访问时长，流量的各渠道占比\n\n第二类：文章类指标\n\n浏览量最高的文章/栏目，浏览量最低的文章/栏目，每日发表文章数，文章流量的时间分布，日用户评论数\n\n第三类：用户类指标\n\n日总PV，注册用户数，新用户占比，次日留存率，周留存率，日/月活跃用户\n\n第四类：商业类指标\n\n广告点击次数，引入新广告品牌是否是知名品牌\n\n通用用户数据指标包括：\n\n1. ARPU：总收入/用户数，没用户平均收入\n\n1. 注册用户数\n\n1. 活跃用户数\n\n1. 新用户占比\n\n1. 用户流失率\n\n1. 次日留存率\n\n1. 渠道转化率\n\n## 如何判断一个产品的好坏\n\n**用户体验的五大层次：有用，能用，可用，用的好，形成品牌**\n\n不同角色的人因为利益诉求不同，评判产品的标准也有所不同，其结论也会不同。\n\n例如：\n\n站在用户的角度来看，产品好不好在于需求怎么样被满足，是否满足了期望性需求，是否满足兴奋性需求。从用户体验上来说，处在“有用，能用，可用，用得好，形成品牌”的哪个层次。\n\n站在开发的角度，评价标准又变成了整个产品在挖需求、找痛点，搭框架、架功能做交互等方面的成果。\n\n站在投资商或者商家用户的角度，有时候产品本身的体验，用户数，影响力等方面都不用在意，能够赚钱才是好产品。\n\n此外，还要考虑这个产品在特定背景下，特定时期的表现，运营团队的表现，竞争对手的表现综合评估。\n\n## 互联网产品的盈利模式及其适用产品\n\n1. 流量变现模式：广告和导流\n\n-. 广告：在线广告（门户网站，视频网站），匹配广告（百度搜索，淘宝搜索），社交广告（Facebook用户推荐）\n\n-. 导流：导航网站（hao123），浏览器（QQ浏览器），手机管理软件（豌豆荚）\n\n1. 佣金分成模式：B2C电商平台（天猫），团购和优惠券（美团），游戏开放平台（人人网），互联网金融（支付宝）\n\n1. 增值服务模式：高级功能收费（游戏道具，QQ会员）\n\n1. 收费服务模式：提供收费服务（企业邮箱），会员数据库（51job），贸易平台（B2B电商阿里巴巴）\n\n## 如何进行产品改版？\n\n一般而言，产品改版有一下四种需求来源：\n\n1. 用户调研和用户反馈分析\n\n1. 数据分析\n\n1. 团队成员（boss，运营，市场，技术）提的需求\n\n1. PM自己对产品的思考和重构\n\n\n在改版前和改版后，产品改版方向正确与否的评判方式，有不小的区分：\n\n**改版前，主要用一下三点进行改版的评定：**\n\n1. 意见收集；2. 数据分析，3. 问卷调研\n\n**改版后，主要用一下四点进行改版评定**：\n\n1. 数据分析：整体流量分析，用户粘性分析，页面效率分析\n\n1. 用户反馈\n\n1. 行业反馈\n\n1. 商业价值\n\n## 淘汰一个人怎么回答？\n\n淘汰一个组员这样的问题原本是部门领导，人事部门或者像您这样的面试官需要考虑的问题。什么样的人更适合这个公司，更适合这个团队，如何组建团队，对组员做价值评估，这些其实真的不是我应该考虑的。\n\n因为作为一个组员往往只能站在个人的角度，站在逻辑思维的角度，个人利害的角度来回答这个问题。比方今天的面试此刻在你心里一定会有一个排名，排名靠前的自然录取的机会更大。如果你给我一个权力让我淘汰一个组员，对我最有利的做法自然是揣测并淘汰一个排名比我靠前的，因为很显然这样会增加我的录取几率。如果我不这样回答，就有悖于常理，和我的诚实。\n\n所以你看让一个组员过多来思考这个问题，往往会让公司留不住真正的人才，让团队不和谐。如果你有录取这里在座任何人的意向，我想你也一定不希望他把这种思维方式带到公司内部。\n\n## 用户产品经理和数据产品经理的区别是什么？\n\n用户产品经理：用户产品也就是常说的to c产品，重点注重用极致的用户体验获取用户。\n\n数据产品经理：主要通过数据的渠道和方法，理解和解释产品和功能的情况。比如通过对各种指标数据的分析解释产品或功能的走势及背后的原因。\n\n1. 用户产品经理的职能：（1）需求挖掘（对某一用户群进行深入理解，挖掘这类人的共同需求，针对共性需求制定解决方案；）解决方案与功能（2）实现逻辑（针对一类用户在同一场景下的需求，以优化功能，交互设计为主解决问题）及流程（3）界面原型（4）数据\n\n1. 数据产品经理的职能：解释（要基于数据解释产品或功能的某项核心指标（包括收入、DAU、ROI等等）的走势及背后的原因，往往需要细化到多个维度（比如：时间、区域、渠道等）、验证（对新推出的功能或者改进，验证其效果或者影响）、探索（通过研究内外部的数据（比如：用户的使用行为数据及搜索词等，百度指数及贴吧发言等等），数据产品经理探索规律和探索用户的需求，通过数据的方式进行初步验证；或者满足一定的功能，通过数据挖掘的方式满足功能需求。）及传播（制作有见地有传播性的图文文章，并便于在朋友圈及知乎等地传播，为自己产品赢得口碑和品牌增值）。\n\n## 如何进行数据分析？\n\n一是数据分析框架，二是数据分析方法。\n\n（一）数据分析框架\n\n1. AARRR模型\n\nAARRR模型可以告诉我们在产品的几个阶段分别需要重点关注哪些数据。AARRR是几个英文字母的缩写，分别是获取、激活、留存、收入、推荐\n\n\t获取（指产品推广，告诉我们用户从哪来）需要关注的数据为：曝光数、打开率、点击率、下载量、安装量、用户获取成本。\n\t激活（指用户使用了产品）需要关注的数据为：设备激活量、新注册用户数、日活跃、浏览数、订阅数。\n\t留存（指用户持续使用产品）需要关注的数据为：次日留存率、7日留存率、距离上次使用时长。\n\t收入（指产品获得利润）需要关注的数据为：付费率、付费频次、客单价、用户价值。\n\t推荐（指用户推荐他人使用我们的产品）需要关注的数据为：转发数、邀请数、评论数。\n\t\n1. 逻辑分析框架\n\n核心指标出现了问题一定是有相关指标出现了问题。\n\n如销售额=访客数UV*转化率*客单价，销售额下降的原因要在这三个指标里找原因\n\n如流量增长因素：PC端、APP端、WAP端、友盟等\n\n1. 漏斗分析框架\n\n用于分析开始用户到最终用户的数量变化趋势\n\n4.还有一些管理营销方面的分析框架\n\n如SWOT分析、4P理论、5W2H、SMART分析等。\n\n（二）数据分析方法\n\n1. 对比分析\n\n最常用的分析方法，通过对比的方式来找出差异，对比的对象可以是其他竞品也可以是自己的产品，对比的时间可以采用同比与环比\n\n1. 趋势分析\n\n通过折线图的方式发现问题（数据下降或是上升等等）\n\n1. 交叉分析（通过多个维度去分析数据）\n\n1. 象限分析\n\n## 杭州有多少出租车，加油站？如何预测？\n\n# 实习相关\n\n## 你觉得你实习时有什么收获？\n\n1. 对做产品的认识：\n\n产品经理的理解：同理心，需求，对事，对人，对产品本身\n\n对汇报工作的思考（还记得好多次我一直都很忙，但是感觉大家不知道我在忙什么，为此为自己总结了以下几点，为以后遵循的工作原则）尽可能将我做的工作按照以下优先级进行转化\n\n1. 对敏捷的认识：团队成员相互信任与认可，前期需求管理的主要工作在于拆分，需要经常的和及时的质量度量、测试、决策 ，自动化测试\n\n## 你在实习期间主要负责什么？\n\n1. 独立负责GBMP 产品视点漫游功能，联合开发部门实习生对此功能进行敏捷开发\n2. 对比分析Revit、Navisworks 视点漫游功能，提出了新的方案，改善了用户操作的路径和使用效率\n3. 机械库内置参数的统计和整理，为冷机吊装方案用到的机械提供参数支持\n\n## 你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？\n\n时间是最大的问题，要在有限的时间里面做完工作、做好工作很具有挑战性。每个人都只有24 小时，我从早上6：00\n到晚上24：00 的时间都规划好了，但是有时候还是不够用。解决方案就是更加努力致力于做事的效率，在有限的时间里面极致利用时间，高效发挥效率。\n\n## 吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。\n\n可以结合我们之前看的一个滴滴打车的改进方案！\n\n## 2B和2C的区别\n\n1. 2C产品的本质是人性，2B产品的背后是业务。\n\n2C产品间的区别是目标人群和场景不同，而2B产品间的区别是业务不同。\n1. 2C产品设计更偏感性，2B产品更偏理性。\n\n各种产品方法论中最常被提到的一个词是“用户痛点”。\n在2B产品的设计过程中，最重要的是分析业务流程、各种业务间依赖关系、穷尽业务场景等，抽象影响因素、梳理逻辑流程、推导因果关系，都是理性思维的主场。\n1. 交互、视觉设计，对2C产品是命脉，对2B产品则是锦上添花\n\n在这个颜值即正义的时代，一个界面丑陋的2C产品会被用户分分钟卸载掉，连被骂的机会都没有。更何况交互、视觉不仅仅是好不好看的问题，很多产品问题的解决、产品目标的实现都依赖交互视觉层面的设计。\n而对于一个2B产品，大家更常关注的是功能。2B产品的交互常比较简单，菜单、按钮、表单等常用控件已能满足需求。视觉设计的空间也比较小，而且好不好看、版式是否清晰、是否有视线引导等等对业务的影响并不大。因此交互、视觉的设计，就算有考量，在开发优先级中也是比较靠后的。\n1. 2C产品相比2B产品更易量化\n\n对于2C产品，无论产品目标是什么，通常都可以找到量化的指标。比如产品目标是用户量，可以用拉新数、日活、月活、留存率等衡量，如果产品目标是收入，可以用ARPU值、付费用户比率、收入总额来衡量。但2B产品则很难有量化的衡量。产品背后的业务可以有各种量化的指标，但这些指标是用来衡量业务的，而不能衡量支持业务的业务系统。\n1. 2C产品用户对使用成本0容忍，2B用户却能接受高学习成本\n\n《Don’t Make Me Think》是一部用户体验领域的经典，书名直译是“别让我思考”。现在一个优秀的2C产品真的可以做到这一点，操作简单、指引明确，用户常常还没觉察就已经实现(bei)目(hu)标(you)。在2C产品中产品经理会被用户喷成狗，在2B产品中却会被尊为师。2C产品的Q&A就算再精美也没人看，但在2B产品中培训手册却是必要的输出物，还要尽可能的详细。而且可能还要安排专门的培训课程，对业务人员进行系统的培训。\n\n## 当自己的产品方案跟老板的产品方案不同时，怎么处理？\n这个问题考察面试者的执行力，如果一而再，再而三地试图说服领导，就是执行力不足，谁都有可能犯错，但是不去做谁也不知道。谁做决定谁负责，只有快速地执行才能快速地试错。\n如果反复地纠结而不去执行，提高了领导对自己的管理成本。也耽误了项目本身的进度，则是不可取的，要明白当下最重要的是去验证\n## 设计一个产品\n**理解最终的目的**\n为了解决用户的痛点，为了增加用户。\n解题方法：\n1. 通过提问来理解问题\n1. 使用结构化的思维\n\n“首先我想要说说设计这个产品的目的，接着我会列出一些可行的功能点，最后我会结合产品设计的目的对这些功能点进行评估。那么，我们现在开始讲这个产品的目的......”\n1. 明确目标用户和目标消费者\n\n遇到的问题，想象产品的使用场景，以及除了用户之外，还有那些人会与产品互动。\n1. 有哪些使用案例，用户为什么要使用这个产品？他们使用的目的是什么？\n1. 现有产品是否能够良好的满足这些使用要求，这些产品是否存在明显的缺点？\n1. 什么功能或修改能改进这些缺陷？\n1. 总结\n## 改进一个产品（微信）\n1. 这个产品的设计目的是什么？\n1. 这个产品面临什么问题？\n1. 你会如何解决这个问题？\n\n4 如实现你的解决方案？\n1. 如何确认你的解决方案是行之有效的？\n\n用微信吗，说说微信有什么你想改进的吧\nA：收藏文件过多，希望给到更强大的文件分类收藏管理能力。\nQ：你觉得这个需求痛点够硬吗\nA：有这个痛点可能需要满足几个条件：1 日常用微信 2 被微信生态内的多个场景多种内容曝光 3 爱收藏；第一个几乎八成中国人日常用微信，第二个应该也是比较多毕竟现在微信生态有各种内容，第三个收藏这个需求应该还蛮普遍。综上，我觉得这个需求痛点应该还行。\nQ：这样吧，微信日活8亿，你给我算算有多少人对你这个功能改进有需求\nA：（其实就是费米问题考察我临场和拆解）拉了四层漏斗：1 日常用微信，百分百，不筛；2 被微信生态多个场景多个内容曝光，分了 群聊、朋友圈、公众号、看一看四个场景，每个场景一层小漏斗估算（每个小漏斗逻辑不详细展开了）；3 被曝光之后要爱收藏，漏斗是爱收藏的人的占比；4 收藏之后还需要有点强迫症，所以才想归类整理，这是最后一层漏斗。\n## 你最喜欢的产品\n1. 这个产品为用户解决了什么问题？\n1. 这个产品如何满足这些使用目的？是什么这个产品很“干净”？这个产品的什么地方使得用户爱上了它？\n1. 它和同类产品相比起来如何？\n1. 如果要你来设计，你会如何改进这个产品？\n## 如何将用户需求转换为产品需求？\n首先保持二八原则，只有普遍用户的需求，才能内化为产品的需求。比如某个需求就一个用户需要，其他大多数用户都不需要，你就不需要做。\n通过现象看本质，收集用户需求以后，多为自己几个为什么，找到用户的动机。\n例如：用户在沙漠中需要水，你就要问自己用户为什么需要水？用户有可能口渴了，那这时候你给他水就好，如果用户是因为太热，你能不能给他防晒服，甚至考虑一下用户体验，觉得防晒服太麻烦，提供防晒霜。有时候一个人并不能完全洞察用户的动机，需要团队的其他人员一起头脑风暴，甚至多问提这个需求的原始用户几个为什么，直到找到真正动机为止，然后结合产品本身衡量需求的性价比，最后综合团队实力，需求急切度确定最终产品需求。\n\n# 自由提问环节\n1. 对需求的精准把握，是一个产品经理的核心能力，但是用户的需求即多又模糊和个性化，把握起来有一定的难度，我特别想听您分享一下自己在这个问题上的思考和经验？\n1. 我知道我离一个出色的PM还有很长的路要走，根据我刚才的表现，你觉得我还需要提高那一块（体现你的谦虚好学，如果面试官对你评价比较积极，说明你这次面试还是比较成功的，从侧面试探出你的面试成绩。）\n1. 关于刚才提到的那个问题，不知道您是怎么认为的？（就自己没有回答好的具体问题，向面试官进行讨教。）\n1. 关于产品经理的职业发展道路，不知道您有没有什么好的建议？（将问题上升到职业发展的道路）\n\n# 个人经历\n\n## 请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果\n\n## 描述一个情景，在这个情景中你必须搜集相关信息，划定关键点\n\n## 举例说明你是怎样用事实促使他人与你达成一致意见的。\n\n## 举例证明你可以和他人合作，共同实现一个重要目标。\n\n## 举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。\n\n## 请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。\n\n## 举例说明你怎样获得一种技能，并将其转化为实践。\n\n## 举例说明，你如何制定了一个很高的目标，并且最终实现了它。\n\n","source":"_posts/2019-interview-all.md","raw":"---\ntitle: 产品经理面试问题集锦\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-29 18:54:06\npassword: \nsummary: 整理的PM面试问题集锦。\ntags:\n- 面试 PM\ncategories:\n- 面试\n---\n\n\n# 自我介绍部分\n\n## 一分钟自我介绍\n\n## 一句话介绍自己\n\n1. 群面介绍\n\n1. 单面介绍\n\n## 你的职业规划，为什么想进大公司？\n\n1. 一方面保持专业深度的不断提升，向周围优秀的同事们学习，学习公司的文化，通过追赶他们，让自己成为一个更加职业化、专业化的职业人。\n\n1. 保持行业广度的不谈拓展，让自己有视野、有内涵、有前瞻、有承担，成为一名职场精英，并且密切配合公司对于岗位需要的调整和深化，持续提升自己的胜任力。\n\n1. 成长起来，承担起自己的职责，让自己更有影响力。\n\n## 说出你自己身上的三个优点，三个缺点？\n1. 优点：我觉得我自己的最大优势是有趣、不固执。我会对自己的想法充满激情，但也不怕承认自己是错的，这样当产品或者市场迅速发生变化时，我也能很灵活，这样同事们也可以慢慢的更加信任我了。\n1. 我觉得我做事情效率高，习惯把重复性的工作简化和批量化，能够为自己节约很多的时间。比如，在绘制组织管理图是利用graphViz绘图，利用dot2pdf进行批量生成文件。利用md文档，快捷生成Word、PDF、LATEX格式，满足多种要求。\n1. 缺点：不知道如何拒绝，朋友要求帮忙一下，一般不会拒绝，有时候会影响到自己的自身工作进度。\n\n举个例子，研一下学期快期末考试的时候，一个好朋友希望我给她拍一个短片vlog，虽然临近期末，我也不太好拒绝，所以就帮她拍了，从准备到实施以及到最后的出片大约花了我五天的时间。\n乐于助人是好事，但是一味的想做“好人”是有问题的，后面我会通过多任务处理来设定工作的优先顺序，明确的向朋友说明自己的时间安排，并给一个自己能在合适可以给予帮助的时间估计，让寻求人自行决定能否接受帮助。我相信这样的时间管理方式，能够最大程度的改正我的这个缺点。\n\n## 最成功的的一件事情？\n\n我认为我最成功的一件事，是在今年暑假的时候，在广联达产品部实习，我和7位同是实习的开发人员，一起做出一款成功的产品，基于GBMP的路径漫游产品。我作为产品负责人，对产品的最终成果负责。我首先对市场上现有产品进行了竞品分析，确定了我们需要解决的痛点、难点和关键点。我们采用敏捷开发的形式，每周一个迭代，自己身兼开发，设计和测试，经过两个月的工作，我们小组获得了部门领导的一致好评。现该产品已经内嵌到一个产品中。\n\n## 最失败的一件事情？\n\n曾经作为班级联郊游活动的发起人，想组织了我们学院和人文学院的联春游获得活动，期间我做了很多努力，比如联络对方学院的负责人，联系旅游中介，联系住宿吗，联系学校相关部门进行报备。\n但是由于临近期末，加上学校期末对学生安全关注高，最终没能达到预期的效果。虽然结果令人遗憾，但是从中我认识到了不足，也积累了经验，举办活动，我认为失败是在所难免的，有时候失败比成功更能是人成长，经过我的锻炼和学习，我相信如果再经历相关的实践工作，我一定会做的更好！\n\n## 你在业余时间喜欢做什么？\n我最近在学习一些有关产品经理的书籍，比如《参与感》《用户体验要素》《运营之光》，差不多10+ 本吧，还有最新上\n的《幕后产品》，希望自己可以更多地了解这个行业，这个工作。\n我平时也会把自己学到的东西分享出来，包括开发了一个小软件，在CSDN 上分享一些自己的心得。\n之前也会是摄影、剪视频和飞无人机，体验创作的乐趣。\n\n## 你为什么想来我们公司？\n1. 公司文化/地位\n2. 人才培养\n3. 专业对口\n\n# 产品基础知识\n\n## 为什么选择产品这一职位？\n\n1. 研究生期间主要负责结构分析软件积分器部分的实现，也开发了自己的软件和算法，在这个过程中逐渐了解到产品经理这个岗位，之后又参加了P1产品经理系列课程的学习，阅读了一些有关产品的书籍。此外又在广联进行了实习，自己逻辑能力、沟通能力、组织能力、管理能力都比较适合产品。\n\n2. \n我属于创作型人格，对于把一个作品从无到有做出来这件事特别着迷。不管是拍照、拍微电影、还是设计一个大家都在使用的产品，都能给我带来巨大的成就感，为了这种成就感我甚至几个晚上熬通宵都没问题。\n\n1. 挑战和成就感。产品经理这一职位，自己对产品的一个小小的改动，就能影响到大量的用户。然后产品上线，看着产品的 PV的增长，可以很快的感受到你工作的价值。\n\n1. 产品经理要负责协调沟通各方面、开发、测试、运营、 UE 。繁多的事情，会给产品经理带来重大的挑战，我喜欢有挑战的做事情。\n\n1. 希望工作有设计策划的成就感；大学的专业学桥梁设计，比较追求理想化的东西，比如项目管理的掌控感，做产品实现自己想法的感觉。\n\n## 产品经理的职责是什么？产品经理需要的能力?\n\n我个人认为产品经理就是以解决用户核心需求，公司需求为目的，从需求调研，需求产出，需求落地，到需求验证全程跟进负责的人。\n\n具体来看，需求调研，包括要做一款什么样的产品？需求调研的方法包括：1、问卷调查 2、电话回访 3、见面约访 4、数据分析 5、业务需求等内容，也包括市场分析，竞品分析等；\n\n需求产出，包括从需求池中找出优先级最高的需求；需求落地，包括设计出图，研发代码实现，功能测试，产品验收等，需求验证包括数据验证等。\n\n我从以下两个方面阐述产品经理需要的能力：\n\n个人基本素质方面：\n\n1. 沟通能力，产品是技术，测试，视觉，运营和推广等部门沟通的桥梁，很多的工作需要与各个部门的人合作完成，横向沟通，纵向沟通的沟通效果非常重要。\n\n1. 逻辑能力，产品经理逻辑工作复杂，且产品实现逻辑也很严谨，所以逻辑性和条理性很重要；\n\n1. 学习能力，互联网站在时代的最前沿，很多东西需要去创造，作为开拓者需要不断去学习。\n\n产品基本能力方面：\n\n1. 对行业的了解\n\n1. 站在用户思考的能力，能够站在主流用户/不同使用习惯/不同背景的用户角度去思考问题，而不是简单的把自己当做一个用户去思考决策问题\n\n1. 数据分析能力，决策需要数据的支撑，收集数据、整理数据和分析数据是一项非常重要的能力。\n\n1. 文档/原型能力\n\n## 如何获取和发现用户需求？\n\n问卷调查：问卷设计以选择题为主，可用通过问卷平台来发放。回答问卷的用户最好是你的产品的目标用户，要不然你的问卷结果的数据没有什么意义。\n\n核心用户访谈：这种方法成本比较高，但是往往你可以得到很多有用的信息。访谈可以涉及到的问题面会远远超过问卷。而且问卷调查的问题往往偏理性，而用户访谈你可以通过用户的情绪、表情、语气来获得更多感性的内容。\n\n竞品分析：可以帮助你快速了解此行业的最新动态。仔细研究竞争对手的产品会帮助你大致了解用户的痛点和需求。然后你在团队头脑风暴或者用户访谈的时候，你可以知道哪些功能你的竞争对手做的不好。这些功能点和需求，就是你的机会。\n\n通过数据分析：比如移动搜索端的产品，当你在决定做哪些领域之前，你需要选取一定的用户行为分析样本，然后对用户的行为进行标注。搜索领域用户的行为主要是：Query查询。当你获得了一天Top 十万的Query，你随机抽取其中的1000个Query，你可以分析这些Query，然后你会大致了解整体用户的搜索意图。然后对照你现有的产品，看看哪些领域，你的搜索结果是没有符合用户需求的。\n\n## 你是怎么挖掘产品需求的？\n\n在我看来，需求来源主要包括两大方面：\n\n一方面是来自于公司外部，即用户、市场、竞品等等；\n\n一方面是来自于公司内部，即企业战略、团队头脑风暴、产品数据分析等等。\n\n![图片](https://uploader.shimo.im/f/AlagXWDkmmQrOlOI.jpg!thumbnail)\n\n\n## 你是怎么判定各个产品需求的优先级的？\n\n1. 晚上看之前的笔记。重要性和紧急性；开发难度和成本\n2. 在判断产品的优先级时，一般通过KANO模型进行判断。KANO模型定义了三个层次的用户需求:基本型需求、期望型需求和兴奋型需求。基本需求是必须具备的，即使不说也应该做到，这部分需求一般是产品初期需要做的功能。期望型需求是用户期望的，用户能够较清晰地知道的。而兴奋型需求是超出用户预期的，用户不知道有这方面的需求，如果提供，用户满意度会更高。\n\nKANO模型后面还有了其他方面的一些延伸：\n\n\t魅力需求：用户意想不到的，如果不提供此需求，用户满意度不会降低，但当提供此需求，用户满意度会有很大提升；\n\t期望需求：当提供此需求，用户满意度会提升，当不提供此需求，用户满意度会降低；\n\t必备需求：当优化此需求，用户满意度不会提升，当不提供此需求，用户满意度会大幅降低；\n\t无差异需求：无论提供或不提供此需求，用户满意度都不会有改变，用户根本不在意；\n\t反向需求：用户根本都没有此需求，提供后用户满意度反而会下降。\t\n\n## 你为做产品都做了哪些准备？\n\n1. 书籍，看过的书籍，《用户体验要素》《启示录》 《上瘾》\n\n1. 产品经理互联网训练营，需求分析，PRD文档等\n\n1. 日常生活，PMcaff 三节课 人人都是产品经理 APP\n\n## 你个人想做什么方向的产品？为什么？\n\n## 比较好的产品？\n\n### 微信阅读\n\n联系微信阅读和《上瘾》这本书\n\n![图片](https://uploader.shimo.im/f/nq5b3HnZwQM8ZJRr.jpg!thumbnail)\n### 知乎\n\n“我是知乎的超级粉丝。知乎是一个问答型APP，用户可以发布问题寻求帮助，通常会有一些相关主题的专家来回答问题。比如说，有人可能会问：‘更换轮胎最好的办法是什么？’或‘创业公司应该等候时机再筹集风险投资吗？’，甚至是‘住在牧场里是什么感觉？’网站上的问题五花八门，从‘帮我解决问题’到‘你对某事有什么看法’，再到‘请分享这方面的经验’，一切都应有尽有。\n\n“我喜欢知乎的原因之一就是它在解决专业问题时的专业性。基本上任何行业的专家都有，提供专业意见，能够给出极其详尽、深思熟虑的答案。\n\n“然而，在解决专业问题之余，我发现我还很喜欢使用这个APP。事实上它是一个基于学习和探索的社区。你可以认识网站上的人，评价他们的回答，因为你可以信任他们。\n\n“我想它是少数能将学习和乐趣连结起来的APP之一。它是一个问答型APP，每当我偶然发现一个自己从来不感兴趣但却很想知道的话题，就会到上面去询问别人。“在我个人使用的经历中，很多时候它都代替了百度，能够帮我搜到我想要的答案。\n想想看，其实通过搜索引擎来解决问题，是有几种缺陷的。\n\n“第一，你会使用关键词来搜索，即便要解答一个问题，也同样如此。你是希望找到一个页面，能为你提供全面纵览的视角来解答你的问题。这并不是一种以解决方案为导向的搜索方式，通常效率很低。\n\n“第二是信任问题。你可能不信任搜索结果中网页作者的证据。就算你信任他，他们也可能在自己的专业领域里把问题搞错了。“知乎允许用户对问题答案以评论的方式进行反馈（也有“点赞”和“反对”的形式）。\n\n“当然，我仍会在网上搜索答案，但我发现我越来越经常使用知乎来解决问题，并且它也是我浏览和学习新知识的地方。”\n\n**盈利模式**\n\n1. 广告\n\n1. 会员\n\n1. 提成\n\n### 网易云音乐\n\n网易云音乐的定位是“移动音乐社区”，并以歌单为核心的组织方式强化用户UGC社交属性。\n\n网易云音乐以“音乐社交”的差异点切入市场，迅速获得大批活跃用户。并以此为基，向产业链上游延伸。以产品撬动市场，试图颠覆传统、改变行业。\n\n网易云音乐从多纬度满足用户发现音乐的需求，个性推荐，歌单，主播电台，排行榜等，基于朋友的社交分享功能，提供对歌曲、歌单、专辑、电台的点赞、评论、转发。可以关注基于通讯录的朋友、微博的朋友、明星、音乐达人、还可关注基于LBS附近的人。\n\n在网易云音乐中，弱化了专辑，强化了歌单，好处是：利用算法提高曲库利用率，把用户喜欢听但主观寻找不找的音乐找出来推荐给用户，弱化版权不足的缺点，网易云音乐把握住了人性。好的音乐是由用户决定的，因为好的UGC会得到大家的认可，这个看评论区就可以看出来，如果有音乐人在某首歌曲下留言，他可能是被赞最多的，同样，即使是普通用户留言，也可以达到同样的效果。谁不渴望获得别人的认可，在娱乐自己的同时，还能得到他人的关注认可。于是，高粘性促使用户的听歌习惯在无形中转变，由听音乐转换到发现音乐再到爱上音乐，换句话来说，一个没有权威、畅所欲言的国度是不是你渴望的？\n\n## 不喜欢的产品？\n\n## 成功的产品有什么标准？\n\n\n个人看来：一款成功的产品必须具有以下标准：\n\n1. 能解决目标用户的痛点。\n\n1. 拥有较好的用户体验。\n\n1. 能够为企业或个人带来利益。\n\n1. 具有不错的用户粘性。\n\n## 你是因为做不了技术才做产品的吗？\n\n## 产品经理如何与运营沟通？\n\n1. “换位思考”和“尊重”\n\n1. 理解产品的定位与价值 很多时候产品和运营沟通，出现的主要矛盾点就在于产品定位和对应的人群。\n\n1. 理解运营流程；产品中会有很多标准的执行流程，但是在运营的过程中，很多流程是灵活的，有些不需要标准化。这个时候就不能运用产品经理的流程化和标准化的思维去理解运营人员的工作，不然就很容易发生矛盾。\n\n1. 需求决定权归属明确\n\n在产品的前期，产品性质与人群匹配的过程中，需求的决定还是取决于产品经理。因为产品经理要确保产品的初衷，定位和价值不发生改变，或者根据市场的需求，做相应的改变。\n\n1. 运营与产品是一家\n\n最后一定要抱着产品和运营是一家的观点去和运营沟通。产品和运营，都是为了能够让产品更好的获得更多的用户。\n一些点子和需求，需要大家共同商讨确定。不同的观点可以带来不同的思路，不要因为岗位的不同，职责不同，为了使自己方便而让其他人作出让步，只要这个需求是正确的，最终目的是为了获得更多的目标用户，那么产品和运营都需要支持。\n\n## 产品经理如何与强势的技术沟通？\n\n产品与开发之间主要产品矛盾的点是什么呢？——工期\n\n1. 做好自己的本质工作，明确需求的优先级，准备详实的文档，沟通重要保持清晰的思路，要注重细节与全局的把控。\n\n1. 理解对方的深层顾虑\n\n1. 学习开发技术，可以不要求技能有多精进，能够掌握各种最新技术，也可以不要求代码有多么优美整洁，架构设计得多么合理。但是最起码也要能够使用现有的框架、组件、资源去完成一个独立产品的开发。在开发中了解自己平时所负责的产品，是如何通过代码实现出来的。要抛弃学技术就是为了“说行话”这个想法。\n\n1. 大多数产品和开发之间的沟通问题，都不是沟通能力的问题，而是产品经理思考能力的问题。\n\n## 遇到不可沟通的人怎么办？or 和开发人员闹僵了怎么处理？\n\n如果在项目进行过程中遇到了这样的问题，我的处理办法是：\n\n1. 摆数据：拿出相关数据来佐证改动的必要性，数据可以是页面点击数，用户粘性。\n\n1. 讲事实：在数据论证的基础上，阐述项目规划、目标和领导预期，并结合所需要的改动的功能点进行说明。论证修改后悔取得双方互赢的良好效果。\n\n1. 适当妥协：站在技术的角度，首先要理解技术拒绝更改的原因。在合理的范围内做适当的妥协，如项目的拖延时间等等，关键是项目有所输出并保证质量。\n\n1. 向上沟通。\n\n当然，在处理本次冲突的基础上，还需要客观的分析冲突发生的原因，是由于沟通机制存在问题还是由于沟通双方的沟通方式没有磨合好。及时分析，避免下次出现这种情况。\n\n## 产品被同行抄袭该怎么处理？\n\n对于技术和交互的抄袭，诉之法庭是最好的解决办法，而对于模式的抄袭，最为关键的是集中优势建立核心资源壁垒，抓紧时间强占市场。\n\n1. 建立技术壁垒\n\n1. 建立资源壁垒\n\n1. 建立用户口碑壁垒\n\n## 你觉得你的执行能力怎么样？\n\n我觉得我的执行能力有待提高，现在属于合格水平。比如上次学校的活动，我们要在3天内拉到3000元的活动赞助。我们第一天做策划方案，接下来两天，3人小组白天刷企业，晚上修改策划，最终搞定3500元的赞助费。对于一个事情，我push的能力很强，但执行能力不仅是push能力，还有规划、团队协作能力，我都有待提高。拉赞助的活动，我们最后虽然成功了，但是在刷企业的路线规划、分头行动的沟通效率上还有待提高。\n\n## 如何做需求的优先级排序和版本规划\n\n产品的版本规划，对于不同的产品、不同阶段的产品，其排期方式可能不同。不同职级的PM所需要掌握的管理的方法也不同，这里选取相对初级的产品经理而不是全面的产品负责人。\n\n1. boss的需求，\n\n1. 版本的主要功能及商业化\n\n1. 明显可以提高日活/拉新等的优化和调整类需求\n\n1. 尝试性功能和提高运营效率等\n\n\n**产品未上线：**\n\n1. 基于当时的环境和实际情况\n\n1. 用户需求是一个动态变化的过程\n\n**对于免费性商品且以经上线**\n\n需求的商业价值原则--重要性紧迫性原则。\n\n用户需求重要性的判断标准：用户基数，使用次数和类别重要性。\n\n用户需求重要性=功能使用用户百分比（用户使用率）X 功能使用频次（功能/内容使用率） X 类别重要百分比（基本型、期望性、兴奋性）\n\n**收费性**\n\n重要性==收益。\n\n使用一下四种方法进行优先级进行排序：\n\n1. 看用户量和发生频率\n\n1. 看开发难度和效果\n\n1. 看产品价值\n\n1. 看对目标群体的熟悉程度\n\n## 产品需求的来源有那些？\n\n1. 老板提出的战略性需求。\n\n1. 产品经理根据产品方向规划需求。\n\n1. 推广规划的活动和数据分析出来一些需求。\n\n1. 用户访谈提出需求。\n\n1. 其他参与者和关注者反馈的需求。\n\n## 如何处理可能完成不了的紧急任务？\n\n面对这样的棘手的事情，有以下三个原则：\n\n1. 保持信息的畅通\n\n1. 从源头出发，辅以紧急措施\n\n1. 坦然面对利益和责任，知错要能改。\n\n之后，自己有以下解决方式：\n\n1. 向同事寻求帮忙，优点是同事熟悉业务，上手快，最可靠。\n\n1. 向同行业的人寻求帮助，优点是人气成本低，成本是沟通成本大，风险是涉密，收益上更有利于自己；\n\n1. 雇佣合适的人来完成。\n\n总之，解决方案的选择，是以下各种因素权衡后的结果：公司的利益，任务的结果，上司承担的风险，解决成本，自己的舆论和给公司的形象。\n\n同时，还要思考为什么不能按时完成任务？是前期计划不合理，还是执行有问题？这个习惯有利于找到症结后迅速打开局面。同时还能知道问题的源头。\n\n## 产品上线后要注意的指标？\n\n考虑到不同类型的产品和平台，其关键指标有着不小的差异，所以以“PC端的媒体网站”来进行论述：\n\n第一类：流量类指标\n\n总PV，平均浏览页面数，跳出率，退出率，平均访问时长，流量的各渠道占比\n\n第二类：文章类指标\n\n浏览量最高的文章/栏目，浏览量最低的文章/栏目，每日发表文章数，文章流量的时间分布，日用户评论数\n\n第三类：用户类指标\n\n日总PV，注册用户数，新用户占比，次日留存率，周留存率，日/月活跃用户\n\n第四类：商业类指标\n\n广告点击次数，引入新广告品牌是否是知名品牌\n\n通用用户数据指标包括：\n\n1. ARPU：总收入/用户数，没用户平均收入\n\n1. 注册用户数\n\n1. 活跃用户数\n\n1. 新用户占比\n\n1. 用户流失率\n\n1. 次日留存率\n\n1. 渠道转化率\n\n## 如何判断一个产品的好坏\n\n**用户体验的五大层次：有用，能用，可用，用的好，形成品牌**\n\n不同角色的人因为利益诉求不同，评判产品的标准也有所不同，其结论也会不同。\n\n例如：\n\n站在用户的角度来看，产品好不好在于需求怎么样被满足，是否满足了期望性需求，是否满足兴奋性需求。从用户体验上来说，处在“有用，能用，可用，用得好，形成品牌”的哪个层次。\n\n站在开发的角度，评价标准又变成了整个产品在挖需求、找痛点，搭框架、架功能做交互等方面的成果。\n\n站在投资商或者商家用户的角度，有时候产品本身的体验，用户数，影响力等方面都不用在意，能够赚钱才是好产品。\n\n此外，还要考虑这个产品在特定背景下，特定时期的表现，运营团队的表现，竞争对手的表现综合评估。\n\n## 互联网产品的盈利模式及其适用产品\n\n1. 流量变现模式：广告和导流\n\n-. 广告：在线广告（门户网站，视频网站），匹配广告（百度搜索，淘宝搜索），社交广告（Facebook用户推荐）\n\n-. 导流：导航网站（hao123），浏览器（QQ浏览器），手机管理软件（豌豆荚）\n\n1. 佣金分成模式：B2C电商平台（天猫），团购和优惠券（美团），游戏开放平台（人人网），互联网金融（支付宝）\n\n1. 增值服务模式：高级功能收费（游戏道具，QQ会员）\n\n1. 收费服务模式：提供收费服务（企业邮箱），会员数据库（51job），贸易平台（B2B电商阿里巴巴）\n\n## 如何进行产品改版？\n\n一般而言，产品改版有一下四种需求来源：\n\n1. 用户调研和用户反馈分析\n\n1. 数据分析\n\n1. 团队成员（boss，运营，市场，技术）提的需求\n\n1. PM自己对产品的思考和重构\n\n\n在改版前和改版后，产品改版方向正确与否的评判方式，有不小的区分：\n\n**改版前，主要用一下三点进行改版的评定：**\n\n1. 意见收集；2. 数据分析，3. 问卷调研\n\n**改版后，主要用一下四点进行改版评定**：\n\n1. 数据分析：整体流量分析，用户粘性分析，页面效率分析\n\n1. 用户反馈\n\n1. 行业反馈\n\n1. 商业价值\n\n## 淘汰一个人怎么回答？\n\n淘汰一个组员这样的问题原本是部门领导，人事部门或者像您这样的面试官需要考虑的问题。什么样的人更适合这个公司，更适合这个团队，如何组建团队，对组员做价值评估，这些其实真的不是我应该考虑的。\n\n因为作为一个组员往往只能站在个人的角度，站在逻辑思维的角度，个人利害的角度来回答这个问题。比方今天的面试此刻在你心里一定会有一个排名，排名靠前的自然录取的机会更大。如果你给我一个权力让我淘汰一个组员，对我最有利的做法自然是揣测并淘汰一个排名比我靠前的，因为很显然这样会增加我的录取几率。如果我不这样回答，就有悖于常理，和我的诚实。\n\n所以你看让一个组员过多来思考这个问题，往往会让公司留不住真正的人才，让团队不和谐。如果你有录取这里在座任何人的意向，我想你也一定不希望他把这种思维方式带到公司内部。\n\n## 用户产品经理和数据产品经理的区别是什么？\n\n用户产品经理：用户产品也就是常说的to c产品，重点注重用极致的用户体验获取用户。\n\n数据产品经理：主要通过数据的渠道和方法，理解和解释产品和功能的情况。比如通过对各种指标数据的分析解释产品或功能的走势及背后的原因。\n\n1. 用户产品经理的职能：（1）需求挖掘（对某一用户群进行深入理解，挖掘这类人的共同需求，针对共性需求制定解决方案；）解决方案与功能（2）实现逻辑（针对一类用户在同一场景下的需求，以优化功能，交互设计为主解决问题）及流程（3）界面原型（4）数据\n\n1. 数据产品经理的职能：解释（要基于数据解释产品或功能的某项核心指标（包括收入、DAU、ROI等等）的走势及背后的原因，往往需要细化到多个维度（比如：时间、区域、渠道等）、验证（对新推出的功能或者改进，验证其效果或者影响）、探索（通过研究内外部的数据（比如：用户的使用行为数据及搜索词等，百度指数及贴吧发言等等），数据产品经理探索规律和探索用户的需求，通过数据的方式进行初步验证；或者满足一定的功能，通过数据挖掘的方式满足功能需求。）及传播（制作有见地有传播性的图文文章，并便于在朋友圈及知乎等地传播，为自己产品赢得口碑和品牌增值）。\n\n## 如何进行数据分析？\n\n一是数据分析框架，二是数据分析方法。\n\n（一）数据分析框架\n\n1. AARRR模型\n\nAARRR模型可以告诉我们在产品的几个阶段分别需要重点关注哪些数据。AARRR是几个英文字母的缩写，分别是获取、激活、留存、收入、推荐\n\n\t获取（指产品推广，告诉我们用户从哪来）需要关注的数据为：曝光数、打开率、点击率、下载量、安装量、用户获取成本。\n\t激活（指用户使用了产品）需要关注的数据为：设备激活量、新注册用户数、日活跃、浏览数、订阅数。\n\t留存（指用户持续使用产品）需要关注的数据为：次日留存率、7日留存率、距离上次使用时长。\n\t收入（指产品获得利润）需要关注的数据为：付费率、付费频次、客单价、用户价值。\n\t推荐（指用户推荐他人使用我们的产品）需要关注的数据为：转发数、邀请数、评论数。\n\t\n1. 逻辑分析框架\n\n核心指标出现了问题一定是有相关指标出现了问题。\n\n如销售额=访客数UV*转化率*客单价，销售额下降的原因要在这三个指标里找原因\n\n如流量增长因素：PC端、APP端、WAP端、友盟等\n\n1. 漏斗分析框架\n\n用于分析开始用户到最终用户的数量变化趋势\n\n4.还有一些管理营销方面的分析框架\n\n如SWOT分析、4P理论、5W2H、SMART分析等。\n\n（二）数据分析方法\n\n1. 对比分析\n\n最常用的分析方法，通过对比的方式来找出差异，对比的对象可以是其他竞品也可以是自己的产品，对比的时间可以采用同比与环比\n\n1. 趋势分析\n\n通过折线图的方式发现问题（数据下降或是上升等等）\n\n1. 交叉分析（通过多个维度去分析数据）\n\n1. 象限分析\n\n## 杭州有多少出租车，加油站？如何预测？\n\n# 实习相关\n\n## 你觉得你实习时有什么收获？\n\n1. 对做产品的认识：\n\n产品经理的理解：同理心，需求，对事，对人，对产品本身\n\n对汇报工作的思考（还记得好多次我一直都很忙，但是感觉大家不知道我在忙什么，为此为自己总结了以下几点，为以后遵循的工作原则）尽可能将我做的工作按照以下优先级进行转化\n\n1. 对敏捷的认识：团队成员相互信任与认可，前期需求管理的主要工作在于拆分，需要经常的和及时的质量度量、测试、决策 ，自动化测试\n\n## 你在实习期间主要负责什么？\n\n1. 独立负责GBMP 产品视点漫游功能，联合开发部门实习生对此功能进行敏捷开发\n2. 对比分析Revit、Navisworks 视点漫游功能，提出了新的方案，改善了用户操作的路径和使用效率\n3. 机械库内置参数的统计和整理，为冷机吊装方案用到的机械提供参数支持\n\n## 你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？\n\n时间是最大的问题，要在有限的时间里面做完工作、做好工作很具有挑战性。每个人都只有24 小时，我从早上6：00\n到晚上24：00 的时间都规划好了，但是有时候还是不够用。解决方案就是更加努力致力于做事的效率，在有限的时间里面极致利用时间，高效发挥效率。\n\n## 吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。\n\n可以结合我们之前看的一个滴滴打车的改进方案！\n\n## 2B和2C的区别\n\n1. 2C产品的本质是人性，2B产品的背后是业务。\n\n2C产品间的区别是目标人群和场景不同，而2B产品间的区别是业务不同。\n1. 2C产品设计更偏感性，2B产品更偏理性。\n\n各种产品方法论中最常被提到的一个词是“用户痛点”。\n在2B产品的设计过程中，最重要的是分析业务流程、各种业务间依赖关系、穷尽业务场景等，抽象影响因素、梳理逻辑流程、推导因果关系，都是理性思维的主场。\n1. 交互、视觉设计，对2C产品是命脉，对2B产品则是锦上添花\n\n在这个颜值即正义的时代，一个界面丑陋的2C产品会被用户分分钟卸载掉，连被骂的机会都没有。更何况交互、视觉不仅仅是好不好看的问题，很多产品问题的解决、产品目标的实现都依赖交互视觉层面的设计。\n而对于一个2B产品，大家更常关注的是功能。2B产品的交互常比较简单，菜单、按钮、表单等常用控件已能满足需求。视觉设计的空间也比较小，而且好不好看、版式是否清晰、是否有视线引导等等对业务的影响并不大。因此交互、视觉的设计，就算有考量，在开发优先级中也是比较靠后的。\n1. 2C产品相比2B产品更易量化\n\n对于2C产品，无论产品目标是什么，通常都可以找到量化的指标。比如产品目标是用户量，可以用拉新数、日活、月活、留存率等衡量，如果产品目标是收入，可以用ARPU值、付费用户比率、收入总额来衡量。但2B产品则很难有量化的衡量。产品背后的业务可以有各种量化的指标，但这些指标是用来衡量业务的，而不能衡量支持业务的业务系统。\n1. 2C产品用户对使用成本0容忍，2B用户却能接受高学习成本\n\n《Don’t Make Me Think》是一部用户体验领域的经典，书名直译是“别让我思考”。现在一个优秀的2C产品真的可以做到这一点，操作简单、指引明确，用户常常还没觉察就已经实现(bei)目(hu)标(you)。在2C产品中产品经理会被用户喷成狗，在2B产品中却会被尊为师。2C产品的Q&A就算再精美也没人看，但在2B产品中培训手册却是必要的输出物，还要尽可能的详细。而且可能还要安排专门的培训课程，对业务人员进行系统的培训。\n\n## 当自己的产品方案跟老板的产品方案不同时，怎么处理？\n这个问题考察面试者的执行力，如果一而再，再而三地试图说服领导，就是执行力不足，谁都有可能犯错，但是不去做谁也不知道。谁做决定谁负责，只有快速地执行才能快速地试错。\n如果反复地纠结而不去执行，提高了领导对自己的管理成本。也耽误了项目本身的进度，则是不可取的，要明白当下最重要的是去验证\n## 设计一个产品\n**理解最终的目的**\n为了解决用户的痛点，为了增加用户。\n解题方法：\n1. 通过提问来理解问题\n1. 使用结构化的思维\n\n“首先我想要说说设计这个产品的目的，接着我会列出一些可行的功能点，最后我会结合产品设计的目的对这些功能点进行评估。那么，我们现在开始讲这个产品的目的......”\n1. 明确目标用户和目标消费者\n\n遇到的问题，想象产品的使用场景，以及除了用户之外，还有那些人会与产品互动。\n1. 有哪些使用案例，用户为什么要使用这个产品？他们使用的目的是什么？\n1. 现有产品是否能够良好的满足这些使用要求，这些产品是否存在明显的缺点？\n1. 什么功能或修改能改进这些缺陷？\n1. 总结\n## 改进一个产品（微信）\n1. 这个产品的设计目的是什么？\n1. 这个产品面临什么问题？\n1. 你会如何解决这个问题？\n\n4 如实现你的解决方案？\n1. 如何确认你的解决方案是行之有效的？\n\n用微信吗，说说微信有什么你想改进的吧\nA：收藏文件过多，希望给到更强大的文件分类收藏管理能力。\nQ：你觉得这个需求痛点够硬吗\nA：有这个痛点可能需要满足几个条件：1 日常用微信 2 被微信生态内的多个场景多种内容曝光 3 爱收藏；第一个几乎八成中国人日常用微信，第二个应该也是比较多毕竟现在微信生态有各种内容，第三个收藏这个需求应该还蛮普遍。综上，我觉得这个需求痛点应该还行。\nQ：这样吧，微信日活8亿，你给我算算有多少人对你这个功能改进有需求\nA：（其实就是费米问题考察我临场和拆解）拉了四层漏斗：1 日常用微信，百分百，不筛；2 被微信生态多个场景多个内容曝光，分了 群聊、朋友圈、公众号、看一看四个场景，每个场景一层小漏斗估算（每个小漏斗逻辑不详细展开了）；3 被曝光之后要爱收藏，漏斗是爱收藏的人的占比；4 收藏之后还需要有点强迫症，所以才想归类整理，这是最后一层漏斗。\n## 你最喜欢的产品\n1. 这个产品为用户解决了什么问题？\n1. 这个产品如何满足这些使用目的？是什么这个产品很“干净”？这个产品的什么地方使得用户爱上了它？\n1. 它和同类产品相比起来如何？\n1. 如果要你来设计，你会如何改进这个产品？\n## 如何将用户需求转换为产品需求？\n首先保持二八原则，只有普遍用户的需求，才能内化为产品的需求。比如某个需求就一个用户需要，其他大多数用户都不需要，你就不需要做。\n通过现象看本质，收集用户需求以后，多为自己几个为什么，找到用户的动机。\n例如：用户在沙漠中需要水，你就要问自己用户为什么需要水？用户有可能口渴了，那这时候你给他水就好，如果用户是因为太热，你能不能给他防晒服，甚至考虑一下用户体验，觉得防晒服太麻烦，提供防晒霜。有时候一个人并不能完全洞察用户的动机，需要团队的其他人员一起头脑风暴，甚至多问提这个需求的原始用户几个为什么，直到找到真正动机为止，然后结合产品本身衡量需求的性价比，最后综合团队实力，需求急切度确定最终产品需求。\n\n# 自由提问环节\n1. 对需求的精准把握，是一个产品经理的核心能力，但是用户的需求即多又模糊和个性化，把握起来有一定的难度，我特别想听您分享一下自己在这个问题上的思考和经验？\n1. 我知道我离一个出色的PM还有很长的路要走，根据我刚才的表现，你觉得我还需要提高那一块（体现你的谦虚好学，如果面试官对你评价比较积极，说明你这次面试还是比较成功的，从侧面试探出你的面试成绩。）\n1. 关于刚才提到的那个问题，不知道您是怎么认为的？（就自己没有回答好的具体问题，向面试官进行讨教。）\n1. 关于产品经理的职业发展道路，不知道您有没有什么好的建议？（将问题上升到职业发展的道路）\n\n# 个人经历\n\n## 请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果\n\n## 描述一个情景，在这个情景中你必须搜集相关信息，划定关键点\n\n## 举例说明你是怎样用事实促使他人与你达成一致意见的。\n\n## 举例证明你可以和他人合作，共同实现一个重要目标。\n\n## 举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。\n\n## 请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。\n\n## 举例说明你怎样获得一种技能，并将其转化为实践。\n\n## 举例说明，你如何制定了一个很高的目标，并且最终实现了它。\n\n","slug":"2019-interview-all","published":1,"updated":"2019-10-03T06:24:48.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbn001w2wvco0lrbsb4","content":"<h1 id=\"自我介绍部分\"><a href=\"#自我介绍部分\" class=\"headerlink\" title=\"自我介绍部分\"></a>自我介绍部分</h1><h2 id=\"一分钟自我介绍\"><a href=\"#一分钟自我介绍\" class=\"headerlink\" title=\"一分钟自我介绍\"></a>一分钟自我介绍</h2><h2 id=\"一句话介绍自己\"><a href=\"#一句话介绍自己\" class=\"headerlink\" title=\"一句话介绍自己\"></a>一句话介绍自己</h2><ol>\n<li><p>群面介绍</p>\n</li>\n<li><p>单面介绍</p>\n</li>\n</ol>\n<h2 id=\"你的职业规划，为什么想进大公司？\"><a href=\"#你的职业规划，为什么想进大公司？\" class=\"headerlink\" title=\"你的职业规划，为什么想进大公司？\"></a>你的职业规划，为什么想进大公司？</h2><ol>\n<li><p>一方面保持专业深度的不断提升，向周围优秀的同事们学习，学习公司的文化，通过追赶他们，让自己成为一个更加职业化、专业化的职业人。</p>\n</li>\n<li><p>保持行业广度的不谈拓展，让自己有视野、有内涵、有前瞻、有承担，成为一名职场精英，并且密切配合公司对于岗位需要的调整和深化，持续提升自己的胜任力。</p>\n</li>\n<li><p>成长起来，承担起自己的职责，让自己更有影响力。</p>\n</li>\n</ol>\n<h2 id=\"说出你自己身上的三个优点，三个缺点？\"><a href=\"#说出你自己身上的三个优点，三个缺点？\" class=\"headerlink\" title=\"说出你自己身上的三个优点，三个缺点？\"></a>说出你自己身上的三个优点，三个缺点？</h2><ol>\n<li>优点：我觉得我自己的最大优势是有趣、不固执。我会对自己的想法充满激情，但也不怕承认自己是错的，这样当产品或者市场迅速发生变化时，我也能很灵活，这样同事们也可以慢慢的更加信任我了。</li>\n<li>我觉得我做事情效率高，习惯把重复性的工作简化和批量化，能够为自己节约很多的时间。比如，在绘制组织管理图是利用graphViz绘图，利用dot2pdf进行批量生成文件。利用md文档，快捷生成Word、PDF、LATEX格式，满足多种要求。</li>\n<li>缺点：不知道如何拒绝，朋友要求帮忙一下，一般不会拒绝，有时候会影响到自己的自身工作进度。</li>\n</ol>\n<p>举个例子，研一下学期快期末考试的时候，一个好朋友希望我给她拍一个短片vlog，虽然临近期末，我也不太好拒绝，所以就帮她拍了，从准备到实施以及到最后的出片大约花了我五天的时间。<br>乐于助人是好事，但是一味的想做“好人”是有问题的，后面我会通过多任务处理来设定工作的优先顺序，明确的向朋友说明自己的时间安排，并给一个自己能在合适可以给予帮助的时间估计，让寻求人自行决定能否接受帮助。我相信这样的时间管理方式，能够最大程度的改正我的这个缺点。</p>\n<h2 id=\"最成功的的一件事情？\"><a href=\"#最成功的的一件事情？\" class=\"headerlink\" title=\"最成功的的一件事情？\"></a>最成功的的一件事情？</h2><p>我认为我最成功的一件事，是在今年暑假的时候，在广联达产品部实习，我和7位同是实习的开发人员，一起做出一款成功的产品，基于GBMP的路径漫游产品。我作为产品负责人，对产品的最终成果负责。我首先对市场上现有产品进行了竞品分析，确定了我们需要解决的痛点、难点和关键点。我们采用敏捷开发的形式，每周一个迭代，自己身兼开发，设计和测试，经过两个月的工作，我们小组获得了部门领导的一致好评。现该产品已经内嵌到一个产品中。</p>\n<h2 id=\"最失败的一件事情？\"><a href=\"#最失败的一件事情？\" class=\"headerlink\" title=\"最失败的一件事情？\"></a>最失败的一件事情？</h2><p>曾经作为班级联郊游活动的发起人，想组织了我们学院和人文学院的联春游获得活动，期间我做了很多努力，比如联络对方学院的负责人，联系旅游中介，联系住宿吗，联系学校相关部门进行报备。<br>但是由于临近期末，加上学校期末对学生安全关注高，最终没能达到预期的效果。虽然结果令人遗憾，但是从中我认识到了不足，也积累了经验，举办活动，我认为失败是在所难免的，有时候失败比成功更能是人成长，经过我的锻炼和学习，我相信如果再经历相关的实践工作，我一定会做的更好！</p>\n<h2 id=\"你在业余时间喜欢做什么？\"><a href=\"#你在业余时间喜欢做什么？\" class=\"headerlink\" title=\"你在业余时间喜欢做什么？\"></a>你在业余时间喜欢做什么？</h2><p>我最近在学习一些有关产品经理的书籍，比如《参与感》《用户体验要素》《运营之光》，差不多10+ 本吧，还有最新上<br>的《幕后产品》，希望自己可以更多地了解这个行业，这个工作。<br>我平时也会把自己学到的东西分享出来，包括开发了一个小软件，在CSDN 上分享一些自己的心得。<br>之前也会是摄影、剪视频和飞无人机，体验创作的乐趣。</p>\n<h2 id=\"你为什么想来我们公司？\"><a href=\"#你为什么想来我们公司？\" class=\"headerlink\" title=\"你为什么想来我们公司？\"></a>你为什么想来我们公司？</h2><ol>\n<li>公司文化/地位</li>\n<li>人才培养</li>\n<li>专业对口</li>\n</ol>\n<h1 id=\"产品基础知识\"><a href=\"#产品基础知识\" class=\"headerlink\" title=\"产品基础知识\"></a>产品基础知识</h1><h2 id=\"为什么选择产品这一职位？\"><a href=\"#为什么选择产品这一职位？\" class=\"headerlink\" title=\"为什么选择产品这一职位？\"></a>为什么选择产品这一职位？</h2><ol>\n<li><p>研究生期间主要负责结构分析软件积分器部分的实现，也开发了自己的软件和算法，在这个过程中逐渐了解到产品经理这个岗位，之后又参加了P1产品经理系列课程的学习，阅读了一些有关产品的书籍。此外又在广联进行了实习，自己逻辑能力、沟通能力、组织能力、管理能力都比较适合产品。</p>\n</li>\n<li><p>我属于创作型人格，对于把一个作品从无到有做出来这件事特别着迷。不管是拍照、拍微电影、还是设计一个大家都在使用的产品，都能给我带来巨大的成就感，为了这种成就感我甚至几个晚上熬通宵都没问题。</p>\n</li>\n<li><p>挑战和成就感。产品经理这一职位，自己对产品的一个小小的改动，就能影响到大量的用户。然后产品上线，看着产品的 PV的增长，可以很快的感受到你工作的价值。</p>\n</li>\n<li><p>产品经理要负责协调沟通各方面、开发、测试、运营、 UE 。繁多的事情，会给产品经理带来重大的挑战，我喜欢有挑战的做事情。</p>\n</li>\n<li><p>希望工作有设计策划的成就感；大学的专业学桥梁设计，比较追求理想化的东西，比如项目管理的掌控感，做产品实现自己想法的感觉。</p>\n</li>\n</ol>\n<h2 id=\"产品经理的职责是什么？产品经理需要的能力\"><a href=\"#产品经理的职责是什么？产品经理需要的能力\" class=\"headerlink\" title=\"产品经理的职责是什么？产品经理需要的能力?\"></a>产品经理的职责是什么？产品经理需要的能力?</h2><p>我个人认为产品经理就是以解决用户核心需求，公司需求为目的，从需求调研，需求产出，需求落地，到需求验证全程跟进负责的人。</p>\n<p>具体来看，需求调研，包括要做一款什么样的产品？需求调研的方法包括：1、问卷调查 2、电话回访 3、见面约访 4、数据分析 5、业务需求等内容，也包括市场分析，竞品分析等；</p>\n<p>需求产出，包括从需求池中找出优先级最高的需求；需求落地，包括设计出图，研发代码实现，功能测试，产品验收等，需求验证包括数据验证等。</p>\n<p>我从以下两个方面阐述产品经理需要的能力：</p>\n<p>个人基本素质方面：</p>\n<ol>\n<li><p>沟通能力，产品是技术，测试，视觉，运营和推广等部门沟通的桥梁，很多的工作需要与各个部门的人合作完成，横向沟通，纵向沟通的沟通效果非常重要。</p>\n</li>\n<li><p>逻辑能力，产品经理逻辑工作复杂，且产品实现逻辑也很严谨，所以逻辑性和条理性很重要；</p>\n</li>\n<li><p>学习能力，互联网站在时代的最前沿，很多东西需要去创造，作为开拓者需要不断去学习。</p>\n</li>\n</ol>\n<p>产品基本能力方面：</p>\n<ol>\n<li><p>对行业的了解</p>\n</li>\n<li><p>站在用户思考的能力，能够站在主流用户/不同使用习惯/不同背景的用户角度去思考问题，而不是简单的把自己当做一个用户去思考决策问题</p>\n</li>\n<li><p>数据分析能力，决策需要数据的支撑，收集数据、整理数据和分析数据是一项非常重要的能力。</p>\n</li>\n<li><p>文档/原型能力</p>\n</li>\n</ol>\n<h2 id=\"如何获取和发现用户需求？\"><a href=\"#如何获取和发现用户需求？\" class=\"headerlink\" title=\"如何获取和发现用户需求？\"></a>如何获取和发现用户需求？</h2><p>问卷调查：问卷设计以选择题为主，可用通过问卷平台来发放。回答问卷的用户最好是你的产品的目标用户，要不然你的问卷结果的数据没有什么意义。</p>\n<p>核心用户访谈：这种方法成本比较高，但是往往你可以得到很多有用的信息。访谈可以涉及到的问题面会远远超过问卷。而且问卷调查的问题往往偏理性，而用户访谈你可以通过用户的情绪、表情、语气来获得更多感性的内容。</p>\n<p>竞品分析：可以帮助你快速了解此行业的最新动态。仔细研究竞争对手的产品会帮助你大致了解用户的痛点和需求。然后你在团队头脑风暴或者用户访谈的时候，你可以知道哪些功能你的竞争对手做的不好。这些功能点和需求，就是你的机会。</p>\n<p>通过数据分析：比如移动搜索端的产品，当你在决定做哪些领域之前，你需要选取一定的用户行为分析样本，然后对用户的行为进行标注。搜索领域用户的行为主要是：Query查询。当你获得了一天Top 十万的Query，你随机抽取其中的1000个Query，你可以分析这些Query，然后你会大致了解整体用户的搜索意图。然后对照你现有的产品，看看哪些领域，你的搜索结果是没有符合用户需求的。</p>\n<h2 id=\"你是怎么挖掘产品需求的？\"><a href=\"#你是怎么挖掘产品需求的？\" class=\"headerlink\" title=\"你是怎么挖掘产品需求的？\"></a>你是怎么挖掘产品需求的？</h2><p>在我看来，需求来源主要包括两大方面：</p>\n<p>一方面是来自于公司外部，即用户、市场、竞品等等；</p>\n<p>一方面是来自于公司内部，即企业战略、团队头脑风暴、产品数据分析等等。</p>\n<p><img src=\"https://uploader.shimo.im/f/AlagXWDkmmQrOlOI.jpg!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"你是怎么判定各个产品需求的优先级的？\"><a href=\"#你是怎么判定各个产品需求的优先级的？\" class=\"headerlink\" title=\"你是怎么判定各个产品需求的优先级的？\"></a>你是怎么判定各个产品需求的优先级的？</h2><ol>\n<li>晚上看之前的笔记。重要性和紧急性；开发难度和成本</li>\n<li>在判断产品的优先级时，一般通过KANO模型进行判断。KANO模型定义了三个层次的用户需求:基本型需求、期望型需求和兴奋型需求。基本需求是必须具备的，即使不说也应该做到，这部分需求一般是产品初期需要做的功能。期望型需求是用户期望的，用户能够较清晰地知道的。而兴奋型需求是超出用户预期的，用户不知道有这方面的需求，如果提供，用户满意度会更高。</li>\n</ol>\n<p>KANO模型后面还有了其他方面的一些延伸：</p>\n<pre><code>魅力需求：用户意想不到的，如果不提供此需求，用户满意度不会降低，但当提供此需求，用户满意度会有很大提升；\n期望需求：当提供此需求，用户满意度会提升，当不提供此需求，用户满意度会降低；\n必备需求：当优化此需求，用户满意度不会提升，当不提供此需求，用户满意度会大幅降低；\n无差异需求：无论提供或不提供此需求，用户满意度都不会有改变，用户根本不在意；\n反向需求：用户根本都没有此需求，提供后用户满意度反而会下降。    </code></pre><h2 id=\"你为做产品都做了哪些准备？\"><a href=\"#你为做产品都做了哪些准备？\" class=\"headerlink\" title=\"你为做产品都做了哪些准备？\"></a>你为做产品都做了哪些准备？</h2><ol>\n<li><p>书籍，看过的书籍，《用户体验要素》《启示录》 《上瘾》</p>\n</li>\n<li><p>产品经理互联网训练营，需求分析，PRD文档等</p>\n</li>\n<li><p>日常生活，PMcaff 三节课 人人都是产品经理 APP</p>\n</li>\n</ol>\n<h2 id=\"你个人想做什么方向的产品？为什么？\"><a href=\"#你个人想做什么方向的产品？为什么？\" class=\"headerlink\" title=\"你个人想做什么方向的产品？为什么？\"></a>你个人想做什么方向的产品？为什么？</h2><h2 id=\"比较好的产品？\"><a href=\"#比较好的产品？\" class=\"headerlink\" title=\"比较好的产品？\"></a>比较好的产品？</h2><h3 id=\"微信阅读\"><a href=\"#微信阅读\" class=\"headerlink\" title=\"微信阅读\"></a>微信阅读</h3><p>联系微信阅读和《上瘾》这本书</p>\n<p><img src=\"https://uploader.shimo.im/f/nq5b3HnZwQM8ZJRr.jpg!thumbnail\" alt=\"图片\"></p>\n<h3 id=\"知乎\"><a href=\"#知乎\" class=\"headerlink\" title=\"知乎\"></a>知乎</h3><p>“我是知乎的超级粉丝。知乎是一个问答型APP，用户可以发布问题寻求帮助，通常会有一些相关主题的专家来回答问题。比如说，有人可能会问：‘更换轮胎最好的办法是什么？’或‘创业公司应该等候时机再筹集风险投资吗？’，甚至是‘住在牧场里是什么感觉？’网站上的问题五花八门，从‘帮我解决问题’到‘你对某事有什么看法’，再到‘请分享这方面的经验’，一切都应有尽有。</p>\n<p>“我喜欢知乎的原因之一就是它在解决专业问题时的专业性。基本上任何行业的专家都有，提供专业意见，能够给出极其详尽、深思熟虑的答案。</p>\n<p>“然而，在解决专业问题之余，我发现我还很喜欢使用这个APP。事实上它是一个基于学习和探索的社区。你可以认识网站上的人，评价他们的回答，因为你可以信任他们。</p>\n<p>“我想它是少数能将学习和乐趣连结起来的APP之一。它是一个问答型APP，每当我偶然发现一个自己从来不感兴趣但却很想知道的话题，就会到上面去询问别人。“在我个人使用的经历中，很多时候它都代替了百度，能够帮我搜到我想要的答案。<br>想想看，其实通过搜索引擎来解决问题，是有几种缺陷的。</p>\n<p>“第一，你会使用关键词来搜索，即便要解答一个问题，也同样如此。你是希望找到一个页面，能为你提供全面纵览的视角来解答你的问题。这并不是一种以解决方案为导向的搜索方式，通常效率很低。</p>\n<p>“第二是信任问题。你可能不信任搜索结果中网页作者的证据。就算你信任他，他们也可能在自己的专业领域里把问题搞错了。“知乎允许用户对问题答案以评论的方式进行反馈（也有“点赞”和“反对”的形式）。</p>\n<p>“当然，我仍会在网上搜索答案，但我发现我越来越经常使用知乎来解决问题，并且它也是我浏览和学习新知识的地方。”</p>\n<p><strong>盈利模式</strong></p>\n<ol>\n<li><p>广告</p>\n</li>\n<li><p>会员</p>\n</li>\n<li><p>提成</p>\n</li>\n</ol>\n<h3 id=\"网易云音乐\"><a href=\"#网易云音乐\" class=\"headerlink\" title=\"网易云音乐\"></a>网易云音乐</h3><p>网易云音乐的定位是“移动音乐社区”，并以歌单为核心的组织方式强化用户UGC社交属性。</p>\n<p>网易云音乐以“音乐社交”的差异点切入市场，迅速获得大批活跃用户。并以此为基，向产业链上游延伸。以产品撬动市场，试图颠覆传统、改变行业。</p>\n<p>网易云音乐从多纬度满足用户发现音乐的需求，个性推荐，歌单，主播电台，排行榜等，基于朋友的社交分享功能，提供对歌曲、歌单、专辑、电台的点赞、评论、转发。可以关注基于通讯录的朋友、微博的朋友、明星、音乐达人、还可关注基于LBS附近的人。</p>\n<p>在网易云音乐中，弱化了专辑，强化了歌单，好处是：利用算法提高曲库利用率，把用户喜欢听但主观寻找不找的音乐找出来推荐给用户，弱化版权不足的缺点，网易云音乐把握住了人性。好的音乐是由用户决定的，因为好的UGC会得到大家的认可，这个看评论区就可以看出来，如果有音乐人在某首歌曲下留言，他可能是被赞最多的，同样，即使是普通用户留言，也可以达到同样的效果。谁不渴望获得别人的认可，在娱乐自己的同时，还能得到他人的关注认可。于是，高粘性促使用户的听歌习惯在无形中转变，由听音乐转换到发现音乐再到爱上音乐，换句话来说，一个没有权威、畅所欲言的国度是不是你渴望的？</p>\n<h2 id=\"不喜欢的产品？\"><a href=\"#不喜欢的产品？\" class=\"headerlink\" title=\"不喜欢的产品？\"></a>不喜欢的产品？</h2><h2 id=\"成功的产品有什么标准？\"><a href=\"#成功的产品有什么标准？\" class=\"headerlink\" title=\"成功的产品有什么标准？\"></a>成功的产品有什么标准？</h2><p>个人看来：一款成功的产品必须具有以下标准：</p>\n<ol>\n<li><p>能解决目标用户的痛点。</p>\n</li>\n<li><p>拥有较好的用户体验。</p>\n</li>\n<li><p>能够为企业或个人带来利益。</p>\n</li>\n<li><p>具有不错的用户粘性。</p>\n</li>\n</ol>\n<h2 id=\"你是因为做不了技术才做产品的吗？\"><a href=\"#你是因为做不了技术才做产品的吗？\" class=\"headerlink\" title=\"你是因为做不了技术才做产品的吗？\"></a>你是因为做不了技术才做产品的吗？</h2><h2 id=\"产品经理如何与运营沟通？\"><a href=\"#产品经理如何与运营沟通？\" class=\"headerlink\" title=\"产品经理如何与运营沟通？\"></a>产品经理如何与运营沟通？</h2><ol>\n<li><p>“换位思考”和“尊重”</p>\n</li>\n<li><p>理解产品的定位与价值 很多时候产品和运营沟通，出现的主要矛盾点就在于产品定位和对应的人群。</p>\n</li>\n<li><p>理解运营流程；产品中会有很多标准的执行流程，但是在运营的过程中，很多流程是灵活的，有些不需要标准化。这个时候就不能运用产品经理的流程化和标准化的思维去理解运营人员的工作，不然就很容易发生矛盾。</p>\n</li>\n<li><p>需求决定权归属明确</p>\n</li>\n</ol>\n<p>在产品的前期，产品性质与人群匹配的过程中，需求的决定还是取决于产品经理。因为产品经理要确保产品的初衷，定位和价值不发生改变，或者根据市场的需求，做相应的改变。</p>\n<ol>\n<li>运营与产品是一家</li>\n</ol>\n<p>最后一定要抱着产品和运营是一家的观点去和运营沟通。产品和运营，都是为了能够让产品更好的获得更多的用户。<br>一些点子和需求，需要大家共同商讨确定。不同的观点可以带来不同的思路，不要因为岗位的不同，职责不同，为了使自己方便而让其他人作出让步，只要这个需求是正确的，最终目的是为了获得更多的目标用户，那么产品和运营都需要支持。</p>\n<h2 id=\"产品经理如何与强势的技术沟通？\"><a href=\"#产品经理如何与强势的技术沟通？\" class=\"headerlink\" title=\"产品经理如何与强势的技术沟通？\"></a>产品经理如何与强势的技术沟通？</h2><p>产品与开发之间主要产品矛盾的点是什么呢？——工期</p>\n<ol>\n<li><p>做好自己的本质工作，明确需求的优先级，准备详实的文档，沟通重要保持清晰的思路，要注重细节与全局的把控。</p>\n</li>\n<li><p>理解对方的深层顾虑</p>\n</li>\n<li><p>学习开发技术，可以不要求技能有多精进，能够掌握各种最新技术，也可以不要求代码有多么优美整洁，架构设计得多么合理。但是最起码也要能够使用现有的框架、组件、资源去完成一个独立产品的开发。在开发中了解自己平时所负责的产品，是如何通过代码实现出来的。要抛弃学技术就是为了“说行话”这个想法。</p>\n</li>\n<li><p>大多数产品和开发之间的沟通问题，都不是沟通能力的问题，而是产品经理思考能力的问题。</p>\n</li>\n</ol>\n<h2 id=\"遇到不可沟通的人怎么办？or-和开发人员闹僵了怎么处理？\"><a href=\"#遇到不可沟通的人怎么办？or-和开发人员闹僵了怎么处理？\" class=\"headerlink\" title=\"遇到不可沟通的人怎么办？or 和开发人员闹僵了怎么处理？\"></a>遇到不可沟通的人怎么办？or 和开发人员闹僵了怎么处理？</h2><p>如果在项目进行过程中遇到了这样的问题，我的处理办法是：</p>\n<ol>\n<li><p>摆数据：拿出相关数据来佐证改动的必要性，数据可以是页面点击数，用户粘性。</p>\n</li>\n<li><p>讲事实：在数据论证的基础上，阐述项目规划、目标和领导预期，并结合所需要的改动的功能点进行说明。论证修改后悔取得双方互赢的良好效果。</p>\n</li>\n<li><p>适当妥协：站在技术的角度，首先要理解技术拒绝更改的原因。在合理的范围内做适当的妥协，如项目的拖延时间等等，关键是项目有所输出并保证质量。</p>\n</li>\n<li><p>向上沟通。</p>\n</li>\n</ol>\n<p>当然，在处理本次冲突的基础上，还需要客观的分析冲突发生的原因，是由于沟通机制存在问题还是由于沟通双方的沟通方式没有磨合好。及时分析，避免下次出现这种情况。</p>\n<h2 id=\"产品被同行抄袭该怎么处理？\"><a href=\"#产品被同行抄袭该怎么处理？\" class=\"headerlink\" title=\"产品被同行抄袭该怎么处理？\"></a>产品被同行抄袭该怎么处理？</h2><p>对于技术和交互的抄袭，诉之法庭是最好的解决办法，而对于模式的抄袭，最为关键的是集中优势建立核心资源壁垒，抓紧时间强占市场。</p>\n<ol>\n<li><p>建立技术壁垒</p>\n</li>\n<li><p>建立资源壁垒</p>\n</li>\n<li><p>建立用户口碑壁垒</p>\n</li>\n</ol>\n<h2 id=\"你觉得你的执行能力怎么样？\"><a href=\"#你觉得你的执行能力怎么样？\" class=\"headerlink\" title=\"你觉得你的执行能力怎么样？\"></a>你觉得你的执行能力怎么样？</h2><p>我觉得我的执行能力有待提高，现在属于合格水平。比如上次学校的活动，我们要在3天内拉到3000元的活动赞助。我们第一天做策划方案，接下来两天，3人小组白天刷企业，晚上修改策划，最终搞定3500元的赞助费。对于一个事情，我push的能力很强，但执行能力不仅是push能力，还有规划、团队协作能力，我都有待提高。拉赞助的活动，我们最后虽然成功了，但是在刷企业的路线规划、分头行动的沟通效率上还有待提高。</p>\n<h2 id=\"如何做需求的优先级排序和版本规划\"><a href=\"#如何做需求的优先级排序和版本规划\" class=\"headerlink\" title=\"如何做需求的优先级排序和版本规划\"></a>如何做需求的优先级排序和版本规划</h2><p>产品的版本规划，对于不同的产品、不同阶段的产品，其排期方式可能不同。不同职级的PM所需要掌握的管理的方法也不同，这里选取相对初级的产品经理而不是全面的产品负责人。</p>\n<ol>\n<li><p>boss的需求，</p>\n</li>\n<li><p>版本的主要功能及商业化</p>\n</li>\n<li><p>明显可以提高日活/拉新等的优化和调整类需求</p>\n</li>\n<li><p>尝试性功能和提高运营效率等</p>\n</li>\n</ol>\n<p><strong>产品未上线：</strong></p>\n<ol>\n<li><p>基于当时的环境和实际情况</p>\n</li>\n<li><p>用户需求是一个动态变化的过程</p>\n</li>\n</ol>\n<p><strong>对于免费性商品且以经上线</strong></p>\n<p>需求的商业价值原则–重要性紧迫性原则。</p>\n<p>用户需求重要性的判断标准：用户基数，使用次数和类别重要性。</p>\n<p>用户需求重要性=功能使用用户百分比（用户使用率）X 功能使用频次（功能/内容使用率） X 类别重要百分比（基本型、期望性、兴奋性）</p>\n<p><strong>收费性</strong></p>\n<p>重要性==收益。</p>\n<p>使用一下四种方法进行优先级进行排序：</p>\n<ol>\n<li><p>看用户量和发生频率</p>\n</li>\n<li><p>看开发难度和效果</p>\n</li>\n<li><p>看产品价值</p>\n</li>\n<li><p>看对目标群体的熟悉程度</p>\n</li>\n</ol>\n<h2 id=\"产品需求的来源有那些？\"><a href=\"#产品需求的来源有那些？\" class=\"headerlink\" title=\"产品需求的来源有那些？\"></a>产品需求的来源有那些？</h2><ol>\n<li><p>老板提出的战略性需求。</p>\n</li>\n<li><p>产品经理根据产品方向规划需求。</p>\n</li>\n<li><p>推广规划的活动和数据分析出来一些需求。</p>\n</li>\n<li><p>用户访谈提出需求。</p>\n</li>\n<li><p>其他参与者和关注者反馈的需求。</p>\n</li>\n</ol>\n<h2 id=\"如何处理可能完成不了的紧急任务？\"><a href=\"#如何处理可能完成不了的紧急任务？\" class=\"headerlink\" title=\"如何处理可能完成不了的紧急任务？\"></a>如何处理可能完成不了的紧急任务？</h2><p>面对这样的棘手的事情，有以下三个原则：</p>\n<ol>\n<li><p>保持信息的畅通</p>\n</li>\n<li><p>从源头出发，辅以紧急措施</p>\n</li>\n<li><p>坦然面对利益和责任，知错要能改。</p>\n</li>\n</ol>\n<p>之后，自己有以下解决方式：</p>\n<ol>\n<li><p>向同事寻求帮忙，优点是同事熟悉业务，上手快，最可靠。</p>\n</li>\n<li><p>向同行业的人寻求帮助，优点是人气成本低，成本是沟通成本大，风险是涉密，收益上更有利于自己；</p>\n</li>\n<li><p>雇佣合适的人来完成。</p>\n</li>\n</ol>\n<p>总之，解决方案的选择，是以下各种因素权衡后的结果：公司的利益，任务的结果，上司承担的风险，解决成本，自己的舆论和给公司的形象。</p>\n<p>同时，还要思考为什么不能按时完成任务？是前期计划不合理，还是执行有问题？这个习惯有利于找到症结后迅速打开局面。同时还能知道问题的源头。</p>\n<h2 id=\"产品上线后要注意的指标？\"><a href=\"#产品上线后要注意的指标？\" class=\"headerlink\" title=\"产品上线后要注意的指标？\"></a>产品上线后要注意的指标？</h2><p>考虑到不同类型的产品和平台，其关键指标有着不小的差异，所以以“PC端的媒体网站”来进行论述：</p>\n<p>第一类：流量类指标</p>\n<p>总PV，平均浏览页面数，跳出率，退出率，平均访问时长，流量的各渠道占比</p>\n<p>第二类：文章类指标</p>\n<p>浏览量最高的文章/栏目，浏览量最低的文章/栏目，每日发表文章数，文章流量的时间分布，日用户评论数</p>\n<p>第三类：用户类指标</p>\n<p>日总PV，注册用户数，新用户占比，次日留存率，周留存率，日/月活跃用户</p>\n<p>第四类：商业类指标</p>\n<p>广告点击次数，引入新广告品牌是否是知名品牌</p>\n<p>通用用户数据指标包括：</p>\n<ol>\n<li><p>ARPU：总收入/用户数，没用户平均收入</p>\n</li>\n<li><p>注册用户数</p>\n</li>\n<li><p>活跃用户数</p>\n</li>\n<li><p>新用户占比</p>\n</li>\n<li><p>用户流失率</p>\n</li>\n<li><p>次日留存率</p>\n</li>\n<li><p>渠道转化率</p>\n</li>\n</ol>\n<h2 id=\"如何判断一个产品的好坏\"><a href=\"#如何判断一个产品的好坏\" class=\"headerlink\" title=\"如何判断一个产品的好坏\"></a>如何判断一个产品的好坏</h2><p><strong>用户体验的五大层次：有用，能用，可用，用的好，形成品牌</strong></p>\n<p>不同角色的人因为利益诉求不同，评判产品的标准也有所不同，其结论也会不同。</p>\n<p>例如：</p>\n<p>站在用户的角度来看，产品好不好在于需求怎么样被满足，是否满足了期望性需求，是否满足兴奋性需求。从用户体验上来说，处在“有用，能用，可用，用得好，形成品牌”的哪个层次。</p>\n<p>站在开发的角度，评价标准又变成了整个产品在挖需求、找痛点，搭框架、架功能做交互等方面的成果。</p>\n<p>站在投资商或者商家用户的角度，有时候产品本身的体验，用户数，影响力等方面都不用在意，能够赚钱才是好产品。</p>\n<p>此外，还要考虑这个产品在特定背景下，特定时期的表现，运营团队的表现，竞争对手的表现综合评估。</p>\n<h2 id=\"互联网产品的盈利模式及其适用产品\"><a href=\"#互联网产品的盈利模式及其适用产品\" class=\"headerlink\" title=\"互联网产品的盈利模式及其适用产品\"></a>互联网产品的盈利模式及其适用产品</h2><ol>\n<li>流量变现模式：广告和导流</li>\n</ol>\n<p>-. 广告：在线广告（门户网站，视频网站），匹配广告（百度搜索，淘宝搜索），社交广告（Facebook用户推荐）</p>\n<p>-. 导流：导航网站（hao123），浏览器（QQ浏览器），手机管理软件（豌豆荚）</p>\n<ol>\n<li><p>佣金分成模式：B2C电商平台（天猫），团购和优惠券（美团），游戏开放平台（人人网），互联网金融（支付宝）</p>\n</li>\n<li><p>增值服务模式：高级功能收费（游戏道具，QQ会员）</p>\n</li>\n<li><p>收费服务模式：提供收费服务（企业邮箱），会员数据库（51job），贸易平台（B2B电商阿里巴巴）</p>\n</li>\n</ol>\n<h2 id=\"如何进行产品改版？\"><a href=\"#如何进行产品改版？\" class=\"headerlink\" title=\"如何进行产品改版？\"></a>如何进行产品改版？</h2><p>一般而言，产品改版有一下四种需求来源：</p>\n<ol>\n<li><p>用户调研和用户反馈分析</p>\n</li>\n<li><p>数据分析</p>\n</li>\n<li><p>团队成员（boss，运营，市场，技术）提的需求</p>\n</li>\n<li><p>PM自己对产品的思考和重构</p>\n</li>\n</ol>\n<p>在改版前和改版后，产品改版方向正确与否的评判方式，有不小的区分：</p>\n<p><strong>改版前，主要用一下三点进行改版的评定：</strong></p>\n<ol>\n<li>意见收集；2. 数据分析，3. 问卷调研</li>\n</ol>\n<p><strong>改版后，主要用一下四点进行改版评定</strong>：</p>\n<ol>\n<li><p>数据分析：整体流量分析，用户粘性分析，页面效率分析</p>\n</li>\n<li><p>用户反馈</p>\n</li>\n<li><p>行业反馈</p>\n</li>\n<li><p>商业价值</p>\n</li>\n</ol>\n<h2 id=\"淘汰一个人怎么回答？\"><a href=\"#淘汰一个人怎么回答？\" class=\"headerlink\" title=\"淘汰一个人怎么回答？\"></a>淘汰一个人怎么回答？</h2><p>淘汰一个组员这样的问题原本是部门领导，人事部门或者像您这样的面试官需要考虑的问题。什么样的人更适合这个公司，更适合这个团队，如何组建团队，对组员做价值评估，这些其实真的不是我应该考虑的。</p>\n<p>因为作为一个组员往往只能站在个人的角度，站在逻辑思维的角度，个人利害的角度来回答这个问题。比方今天的面试此刻在你心里一定会有一个排名，排名靠前的自然录取的机会更大。如果你给我一个权力让我淘汰一个组员，对我最有利的做法自然是揣测并淘汰一个排名比我靠前的，因为很显然这样会增加我的录取几率。如果我不这样回答，就有悖于常理，和我的诚实。</p>\n<p>所以你看让一个组员过多来思考这个问题，往往会让公司留不住真正的人才，让团队不和谐。如果你有录取这里在座任何人的意向，我想你也一定不希望他把这种思维方式带到公司内部。</p>\n<h2 id=\"用户产品经理和数据产品经理的区别是什么？\"><a href=\"#用户产品经理和数据产品经理的区别是什么？\" class=\"headerlink\" title=\"用户产品经理和数据产品经理的区别是什么？\"></a>用户产品经理和数据产品经理的区别是什么？</h2><p>用户产品经理：用户产品也就是常说的to c产品，重点注重用极致的用户体验获取用户。</p>\n<p>数据产品经理：主要通过数据的渠道和方法，理解和解释产品和功能的情况。比如通过对各种指标数据的分析解释产品或功能的走势及背后的原因。</p>\n<ol>\n<li><p>用户产品经理的职能：（1）需求挖掘（对某一用户群进行深入理解，挖掘这类人的共同需求，针对共性需求制定解决方案；）解决方案与功能（2）实现逻辑（针对一类用户在同一场景下的需求，以优化功能，交互设计为主解决问题）及流程（3）界面原型（4）数据</p>\n</li>\n<li><p>数据产品经理的职能：解释（要基于数据解释产品或功能的某项核心指标（包括收入、DAU、ROI等等）的走势及背后的原因，往往需要细化到多个维度（比如：时间、区域、渠道等）、验证（对新推出的功能或者改进，验证其效果或者影响）、探索（通过研究内外部的数据（比如：用户的使用行为数据及搜索词等，百度指数及贴吧发言等等），数据产品经理探索规律和探索用户的需求，通过数据的方式进行初步验证；或者满足一定的功能，通过数据挖掘的方式满足功能需求。）及传播（制作有见地有传播性的图文文章，并便于在朋友圈及知乎等地传播，为自己产品赢得口碑和品牌增值）。</p>\n</li>\n</ol>\n<h2 id=\"如何进行数据分析？\"><a href=\"#如何进行数据分析？\" class=\"headerlink\" title=\"如何进行数据分析？\"></a>如何进行数据分析？</h2><p>一是数据分析框架，二是数据分析方法。</p>\n<p>（一）数据分析框架</p>\n<ol>\n<li>AARRR模型</li>\n</ol>\n<p>AARRR模型可以告诉我们在产品的几个阶段分别需要重点关注哪些数据。AARRR是几个英文字母的缩写，分别是获取、激活、留存、收入、推荐</p>\n<pre><code>获取（指产品推广，告诉我们用户从哪来）需要关注的数据为：曝光数、打开率、点击率、下载量、安装量、用户获取成本。\n激活（指用户使用了产品）需要关注的数据为：设备激活量、新注册用户数、日活跃、浏览数、订阅数。\n留存（指用户持续使用产品）需要关注的数据为：次日留存率、7日留存率、距离上次使用时长。\n收入（指产品获得利润）需要关注的数据为：付费率、付费频次、客单价、用户价值。\n推荐（指用户推荐他人使用我们的产品）需要关注的数据为：转发数、邀请数、评论数。</code></pre><ol>\n<li>逻辑分析框架</li>\n</ol>\n<p>核心指标出现了问题一定是有相关指标出现了问题。</p>\n<p>如销售额=访客数UV<em>转化率</em>客单价，销售额下降的原因要在这三个指标里找原因</p>\n<p>如流量增长因素：PC端、APP端、WAP端、友盟等</p>\n<ol>\n<li>漏斗分析框架</li>\n</ol>\n<p>用于分析开始用户到最终用户的数量变化趋势</p>\n<p>4.还有一些管理营销方面的分析框架</p>\n<p>如SWOT分析、4P理论、5W2H、SMART分析等。</p>\n<p>（二）数据分析方法</p>\n<ol>\n<li>对比分析</li>\n</ol>\n<p>最常用的分析方法，通过对比的方式来找出差异，对比的对象可以是其他竞品也可以是自己的产品，对比的时间可以采用同比与环比</p>\n<ol>\n<li>趋势分析</li>\n</ol>\n<p>通过折线图的方式发现问题（数据下降或是上升等等）</p>\n<ol>\n<li><p>交叉分析（通过多个维度去分析数据）</p>\n</li>\n<li><p>象限分析</p>\n</li>\n</ol>\n<h2 id=\"杭州有多少出租车，加油站？如何预测？\"><a href=\"#杭州有多少出租车，加油站？如何预测？\" class=\"headerlink\" title=\"杭州有多少出租车，加油站？如何预测？\"></a>杭州有多少出租车，加油站？如何预测？</h2><h1 id=\"实习相关\"><a href=\"#实习相关\" class=\"headerlink\" title=\"实习相关\"></a>实习相关</h1><h2 id=\"你觉得你实习时有什么收获？\"><a href=\"#你觉得你实习时有什么收获？\" class=\"headerlink\" title=\"你觉得你实习时有什么收获？\"></a>你觉得你实习时有什么收获？</h2><ol>\n<li>对做产品的认识：</li>\n</ol>\n<p>产品经理的理解：同理心，需求，对事，对人，对产品本身</p>\n<p>对汇报工作的思考（还记得好多次我一直都很忙，但是感觉大家不知道我在忙什么，为此为自己总结了以下几点，为以后遵循的工作原则）尽可能将我做的工作按照以下优先级进行转化</p>\n<ol>\n<li>对敏捷的认识：团队成员相互信任与认可，前期需求管理的主要工作在于拆分，需要经常的和及时的质量度量、测试、决策 ，自动化测试</li>\n</ol>\n<h2 id=\"你在实习期间主要负责什么？\"><a href=\"#你在实习期间主要负责什么？\" class=\"headerlink\" title=\"你在实习期间主要负责什么？\"></a>你在实习期间主要负责什么？</h2><ol>\n<li>独立负责GBMP 产品视点漫游功能，联合开发部门实习生对此功能进行敏捷开发</li>\n<li>对比分析Revit、Navisworks 视点漫游功能，提出了新的方案，改善了用户操作的路径和使用效率</li>\n<li>机械库内置参数的统计和整理，为冷机吊装方案用到的机械提供参数支持</li>\n</ol>\n<h2 id=\"你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？\"><a href=\"#你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？\" class=\"headerlink\" title=\"你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？\"></a>你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？</h2><p>时间是最大的问题，要在有限的时间里面做完工作、做好工作很具有挑战性。每个人都只有24 小时，我从早上6：00<br>到晚上24：00 的时间都规划好了，但是有时候还是不够用。解决方案就是更加努力致力于做事的效率，在有限的时间里面极致利用时间，高效发挥效率。</p>\n<h2 id=\"吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。\"><a href=\"#吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。\" class=\"headerlink\" title=\"吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。\"></a>吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。</h2><p>可以结合我们之前看的一个滴滴打车的改进方案！</p>\n<h2 id=\"2B和2C的区别\"><a href=\"#2B和2C的区别\" class=\"headerlink\" title=\"2B和2C的区别\"></a>2B和2C的区别</h2><ol>\n<li>2C产品的本质是人性，2B产品的背后是业务。</li>\n</ol>\n<p>2C产品间的区别是目标人群和场景不同，而2B产品间的区别是业务不同。</p>\n<ol>\n<li>2C产品设计更偏感性，2B产品更偏理性。</li>\n</ol>\n<p>各种产品方法论中最常被提到的一个词是“用户痛点”。<br>在2B产品的设计过程中，最重要的是分析业务流程、各种业务间依赖关系、穷尽业务场景等，抽象影响因素、梳理逻辑流程、推导因果关系，都是理性思维的主场。</p>\n<ol>\n<li>交互、视觉设计，对2C产品是命脉，对2B产品则是锦上添花</li>\n</ol>\n<p>在这个颜值即正义的时代，一个界面丑陋的2C产品会被用户分分钟卸载掉，连被骂的机会都没有。更何况交互、视觉不仅仅是好不好看的问题，很多产品问题的解决、产品目标的实现都依赖交互视觉层面的设计。<br>而对于一个2B产品，大家更常关注的是功能。2B产品的交互常比较简单，菜单、按钮、表单等常用控件已能满足需求。视觉设计的空间也比较小，而且好不好看、版式是否清晰、是否有视线引导等等对业务的影响并不大。因此交互、视觉的设计，就算有考量，在开发优先级中也是比较靠后的。</p>\n<ol>\n<li>2C产品相比2B产品更易量化</li>\n</ol>\n<p>对于2C产品，无论产品目标是什么，通常都可以找到量化的指标。比如产品目标是用户量，可以用拉新数、日活、月活、留存率等衡量，如果产品目标是收入，可以用ARPU值、付费用户比率、收入总额来衡量。但2B产品则很难有量化的衡量。产品背后的业务可以有各种量化的指标，但这些指标是用来衡量业务的，而不能衡量支持业务的业务系统。</p>\n<ol>\n<li>2C产品用户对使用成本0容忍，2B用户却能接受高学习成本</li>\n</ol>\n<p>《Don’t Make Me Think》是一部用户体验领域的经典，书名直译是“别让我思考”。现在一个优秀的2C产品真的可以做到这一点，操作简单、指引明确，用户常常还没觉察就已经实现(bei)目(hu)标(you)。在2C产品中产品经理会被用户喷成狗，在2B产品中却会被尊为师。2C产品的Q&amp;A就算再精美也没人看，但在2B产品中培训手册却是必要的输出物，还要尽可能的详细。而且可能还要安排专门的培训课程，对业务人员进行系统的培训。</p>\n<h2 id=\"当自己的产品方案跟老板的产品方案不同时，怎么处理？\"><a href=\"#当自己的产品方案跟老板的产品方案不同时，怎么处理？\" class=\"headerlink\" title=\"当自己的产品方案跟老板的产品方案不同时，怎么处理？\"></a>当自己的产品方案跟老板的产品方案不同时，怎么处理？</h2><p>这个问题考察面试者的执行力，如果一而再，再而三地试图说服领导，就是执行力不足，谁都有可能犯错，但是不去做谁也不知道。谁做决定谁负责，只有快速地执行才能快速地试错。<br>如果反复地纠结而不去执行，提高了领导对自己的管理成本。也耽误了项目本身的进度，则是不可取的，要明白当下最重要的是去验证</p>\n<h2 id=\"设计一个产品\"><a href=\"#设计一个产品\" class=\"headerlink\" title=\"设计一个产品\"></a>设计一个产品</h2><p><strong>理解最终的目的</strong><br>为了解决用户的痛点，为了增加用户。<br>解题方法：</p>\n<ol>\n<li>通过提问来理解问题</li>\n<li>使用结构化的思维</li>\n</ol>\n<p>“首先我想要说说设计这个产品的目的，接着我会列出一些可行的功能点，最后我会结合产品设计的目的对这些功能点进行评估。那么，我们现在开始讲这个产品的目的……”</p>\n<ol>\n<li>明确目标用户和目标消费者</li>\n</ol>\n<p>遇到的问题，想象产品的使用场景，以及除了用户之外，还有那些人会与产品互动。</p>\n<ol>\n<li>有哪些使用案例，用户为什么要使用这个产品？他们使用的目的是什么？</li>\n<li>现有产品是否能够良好的满足这些使用要求，这些产品是否存在明显的缺点？</li>\n<li>什么功能或修改能改进这些缺陷？</li>\n<li>总结<h2 id=\"改进一个产品（微信）\"><a href=\"#改进一个产品（微信）\" class=\"headerlink\" title=\"改进一个产品（微信）\"></a>改进一个产品（微信）</h2></li>\n<li>这个产品的设计目的是什么？</li>\n<li>这个产品面临什么问题？</li>\n<li>你会如何解决这个问题？</li>\n</ol>\n<p>4 如实现你的解决方案？</p>\n<ol>\n<li>如何确认你的解决方案是行之有效的？</li>\n</ol>\n<p>用微信吗，说说微信有什么你想改进的吧<br>A：收藏文件过多，希望给到更强大的文件分类收藏管理能力。<br>Q：你觉得这个需求痛点够硬吗<br>A：有这个痛点可能需要满足几个条件：1 日常用微信 2 被微信生态内的多个场景多种内容曝光 3 爱收藏；第一个几乎八成中国人日常用微信，第二个应该也是比较多毕竟现在微信生态有各种内容，第三个收藏这个需求应该还蛮普遍。综上，我觉得这个需求痛点应该还行。<br>Q：这样吧，微信日活8亿，你给我算算有多少人对你这个功能改进有需求<br>A：（其实就是费米问题考察我临场和拆解）拉了四层漏斗：1 日常用微信，百分百，不筛；2 被微信生态多个场景多个内容曝光，分了 群聊、朋友圈、公众号、看一看四个场景，每个场景一层小漏斗估算（每个小漏斗逻辑不详细展开了）；3 被曝光之后要爱收藏，漏斗是爱收藏的人的占比；4 收藏之后还需要有点强迫症，所以才想归类整理，这是最后一层漏斗。</p>\n<h2 id=\"你最喜欢的产品\"><a href=\"#你最喜欢的产品\" class=\"headerlink\" title=\"你最喜欢的产品\"></a>你最喜欢的产品</h2><ol>\n<li>这个产品为用户解决了什么问题？</li>\n<li>这个产品如何满足这些使用目的？是什么这个产品很“干净”？这个产品的什么地方使得用户爱上了它？</li>\n<li>它和同类产品相比起来如何？</li>\n<li>如果要你来设计，你会如何改进这个产品？<h2 id=\"如何将用户需求转换为产品需求？\"><a href=\"#如何将用户需求转换为产品需求？\" class=\"headerlink\" title=\"如何将用户需求转换为产品需求？\"></a>如何将用户需求转换为产品需求？</h2>首先保持二八原则，只有普遍用户的需求，才能内化为产品的需求。比如某个需求就一个用户需要，其他大多数用户都不需要，你就不需要做。<br>通过现象看本质，收集用户需求以后，多为自己几个为什么，找到用户的动机。<br>例如：用户在沙漠中需要水，你就要问自己用户为什么需要水？用户有可能口渴了，那这时候你给他水就好，如果用户是因为太热，你能不能给他防晒服，甚至考虑一下用户体验，觉得防晒服太麻烦，提供防晒霜。有时候一个人并不能完全洞察用户的动机，需要团队的其他人员一起头脑风暴，甚至多问提这个需求的原始用户几个为什么，直到找到真正动机为止，然后结合产品本身衡量需求的性价比，最后综合团队实力，需求急切度确定最终产品需求。</li>\n</ol>\n<h1 id=\"自由提问环节\"><a href=\"#自由提问环节\" class=\"headerlink\" title=\"自由提问环节\"></a>自由提问环节</h1><ol>\n<li>对需求的精准把握，是一个产品经理的核心能力，但是用户的需求即多又模糊和个性化，把握起来有一定的难度，我特别想听您分享一下自己在这个问题上的思考和经验？</li>\n<li>我知道我离一个出色的PM还有很长的路要走，根据我刚才的表现，你觉得我还需要提高那一块（体现你的谦虚好学，如果面试官对你评价比较积极，说明你这次面试还是比较成功的，从侧面试探出你的面试成绩。）</li>\n<li>关于刚才提到的那个问题，不知道您是怎么认为的？（就自己没有回答好的具体问题，向面试官进行讨教。）</li>\n<li>关于产品经理的职业发展道路，不知道您有没有什么好的建议？（将问题上升到职业发展的道路）</li>\n</ol>\n<h1 id=\"个人经历\"><a href=\"#个人经历\" class=\"headerlink\" title=\"个人经历\"></a>个人经历</h1><h2 id=\"请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果\"><a href=\"#请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果\" class=\"headerlink\" title=\"请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果\"></a>请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果</h2><h2 id=\"描述一个情景，在这个情景中你必须搜集相关信息，划定关键点\"><a href=\"#描述一个情景，在这个情景中你必须搜集相关信息，划定关键点\" class=\"headerlink\" title=\"描述一个情景，在这个情景中你必须搜集相关信息，划定关键点\"></a>描述一个情景，在这个情景中你必须搜集相关信息，划定关键点</h2><h2 id=\"举例说明你是怎样用事实促使他人与你达成一致意见的。\"><a href=\"#举例说明你是怎样用事实促使他人与你达成一致意见的。\" class=\"headerlink\" title=\"举例说明你是怎样用事实促使他人与你达成一致意见的。\"></a>举例说明你是怎样用事实促使他人与你达成一致意见的。</h2><h2 id=\"举例证明你可以和他人合作，共同实现一个重要目标。\"><a href=\"#举例证明你可以和他人合作，共同实现一个重要目标。\" class=\"headerlink\" title=\"举例证明你可以和他人合作，共同实现一个重要目标。\"></a>举例证明你可以和他人合作，共同实现一个重要目标。</h2><h2 id=\"举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。\"><a href=\"#举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。\" class=\"headerlink\" title=\"举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。\"></a>举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。</h2><h2 id=\"请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。\"><a href=\"#请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。\" class=\"headerlink\" title=\"请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。\"></a>请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。</h2><h2 id=\"举例说明你怎样获得一种技能，并将其转化为实践。\"><a href=\"#举例说明你怎样获得一种技能，并将其转化为实践。\" class=\"headerlink\" title=\"举例说明你怎样获得一种技能，并将其转化为实践。\"></a>举例说明你怎样获得一种技能，并将其转化为实践。</h2><h2 id=\"举例说明，你如何制定了一个很高的目标，并且最终实现了它。\"><a href=\"#举例说明，你如何制定了一个很高的目标，并且最终实现了它。\" class=\"headerlink\" title=\"举例说明，你如何制定了一个很高的目标，并且最终实现了它。\"></a>举例说明，你如何制定了一个很高的目标，并且最终实现了它。</h2>","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"自我介绍部分\"><a href=\"#自我介绍部分\" class=\"headerlink\" title=\"自我介绍部分\"></a>自我介绍部分</h1><h2 id=\"一分钟自我介绍\"><a href=\"#一分钟自我介绍\" class=\"headerlink\" title=\"一分钟自我介绍\"></a>一分钟自我介绍</h2><h2 id=\"一句话介绍自己\"><a href=\"#一句话介绍自己\" class=\"headerlink\" title=\"一句话介绍自己\"></a>一句话介绍自己</h2><ol>\n<li><p>群面介绍</p>\n</li>\n<li><p>单面介绍</p>\n</li>\n</ol>\n<h2 id=\"你的职业规划，为什么想进大公司？\"><a href=\"#你的职业规划，为什么想进大公司？\" class=\"headerlink\" title=\"你的职业规划，为什么想进大公司？\"></a>你的职业规划，为什么想进大公司？</h2><ol>\n<li><p>一方面保持专业深度的不断提升，向周围优秀的同事们学习，学习公司的文化，通过追赶他们，让自己成为一个更加职业化、专业化的职业人。</p>\n</li>\n<li><p>保持行业广度的不谈拓展，让自己有视野、有内涵、有前瞻、有承担，成为一名职场精英，并且密切配合公司对于岗位需要的调整和深化，持续提升自己的胜任力。</p>\n</li>\n<li><p>成长起来，承担起自己的职责，让自己更有影响力。</p>\n</li>\n</ol>\n<h2 id=\"说出你自己身上的三个优点，三个缺点？\"><a href=\"#说出你自己身上的三个优点，三个缺点？\" class=\"headerlink\" title=\"说出你自己身上的三个优点，三个缺点？\"></a>说出你自己身上的三个优点，三个缺点？</h2><ol>\n<li>优点：我觉得我自己的最大优势是有趣、不固执。我会对自己的想法充满激情，但也不怕承认自己是错的，这样当产品或者市场迅速发生变化时，我也能很灵活，这样同事们也可以慢慢的更加信任我了。</li>\n<li>我觉得我做事情效率高，习惯把重复性的工作简化和批量化，能够为自己节约很多的时间。比如，在绘制组织管理图是利用graphViz绘图，利用dot2pdf进行批量生成文件。利用md文档，快捷生成Word、PDF、LATEX格式，满足多种要求。</li>\n<li>缺点：不知道如何拒绝，朋友要求帮忙一下，一般不会拒绝，有时候会影响到自己的自身工作进度。</li>\n</ol>\n<p>举个例子，研一下学期快期末考试的时候，一个好朋友希望我给她拍一个短片vlog，虽然临近期末，我也不太好拒绝，所以就帮她拍了，从准备到实施以及到最后的出片大约花了我五天的时间。<br>乐于助人是好事，但是一味的想做“好人”是有问题的，后面我会通过多任务处理来设定工作的优先顺序，明确的向朋友说明自己的时间安排，并给一个自己能在合适可以给予帮助的时间估计，让寻求人自行决定能否接受帮助。我相信这样的时间管理方式，能够最大程度的改正我的这个缺点。</p>\n<h2 id=\"最成功的的一件事情？\"><a href=\"#最成功的的一件事情？\" class=\"headerlink\" title=\"最成功的的一件事情？\"></a>最成功的的一件事情？</h2><p>我认为我最成功的一件事，是在今年暑假的时候，在广联达产品部实习，我和7位同是实习的开发人员，一起做出一款成功的产品，基于GBMP的路径漫游产品。我作为产品负责人，对产品的最终成果负责。我首先对市场上现有产品进行了竞品分析，确定了我们需要解决的痛点、难点和关键点。我们采用敏捷开发的形式，每周一个迭代，自己身兼开发，设计和测试，经过两个月的工作，我们小组获得了部门领导的一致好评。现该产品已经内嵌到一个产品中。</p>\n<h2 id=\"最失败的一件事情？\"><a href=\"#最失败的一件事情？\" class=\"headerlink\" title=\"最失败的一件事情？\"></a>最失败的一件事情？</h2><p>曾经作为班级联郊游活动的发起人，想组织了我们学院和人文学院的联春游获得活动，期间我做了很多努力，比如联络对方学院的负责人，联系旅游中介，联系住宿吗，联系学校相关部门进行报备。<br>但是由于临近期末，加上学校期末对学生安全关注高，最终没能达到预期的效果。虽然结果令人遗憾，但是从中我认识到了不足，也积累了经验，举办活动，我认为失败是在所难免的，有时候失败比成功更能是人成长，经过我的锻炼和学习，我相信如果再经历相关的实践工作，我一定会做的更好！</p>\n<h2 id=\"你在业余时间喜欢做什么？\"><a href=\"#你在业余时间喜欢做什么？\" class=\"headerlink\" title=\"你在业余时间喜欢做什么？\"></a>你在业余时间喜欢做什么？</h2><p>我最近在学习一些有关产品经理的书籍，比如《参与感》《用户体验要素》《运营之光》，差不多10+ 本吧，还有最新上<br>的《幕后产品》，希望自己可以更多地了解这个行业，这个工作。<br>我平时也会把自己学到的东西分享出来，包括开发了一个小软件，在CSDN 上分享一些自己的心得。<br>之前也会是摄影、剪视频和飞无人机，体验创作的乐趣。</p>\n<h2 id=\"你为什么想来我们公司？\"><a href=\"#你为什么想来我们公司？\" class=\"headerlink\" title=\"你为什么想来我们公司？\"></a>你为什么想来我们公司？</h2><ol>\n<li>公司文化/地位</li>\n<li>人才培养</li>\n<li>专业对口</li>\n</ol>\n<h1 id=\"产品基础知识\"><a href=\"#产品基础知识\" class=\"headerlink\" title=\"产品基础知识\"></a>产品基础知识</h1><h2 id=\"为什么选择产品这一职位？\"><a href=\"#为什么选择产品这一职位？\" class=\"headerlink\" title=\"为什么选择产品这一职位？\"></a>为什么选择产品这一职位？</h2><ol>\n<li><p>研究生期间主要负责结构分析软件积分器部分的实现，也开发了自己的软件和算法，在这个过程中逐渐了解到产品经理这个岗位，之后又参加了P1产品经理系列课程的学习，阅读了一些有关产品的书籍。此外又在广联进行了实习，自己逻辑能力、沟通能力、组织能力、管理能力都比较适合产品。</p>\n</li>\n<li><p>我属于创作型人格，对于把一个作品从无到有做出来这件事特别着迷。不管是拍照、拍微电影、还是设计一个大家都在使用的产品，都能给我带来巨大的成就感，为了这种成就感我甚至几个晚上熬通宵都没问题。</p>\n</li>\n<li><p>挑战和成就感。产品经理这一职位，自己对产品的一个小小的改动，就能影响到大量的用户。然后产品上线，看着产品的 PV的增长，可以很快的感受到你工作的价值。</p>\n</li>\n<li><p>产品经理要负责协调沟通各方面、开发、测试、运营、 UE 。繁多的事情，会给产品经理带来重大的挑战，我喜欢有挑战的做事情。</p>\n</li>\n<li><p>希望工作有设计策划的成就感；大学的专业学桥梁设计，比较追求理想化的东西，比如项目管理的掌控感，做产品实现自己想法的感觉。</p>\n</li>\n</ol>\n<h2 id=\"产品经理的职责是什么？产品经理需要的能力\"><a href=\"#产品经理的职责是什么？产品经理需要的能力\" class=\"headerlink\" title=\"产品经理的职责是什么？产品经理需要的能力?\"></a>产品经理的职责是什么？产品经理需要的能力?</h2><p>我个人认为产品经理就是以解决用户核心需求，公司需求为目的，从需求调研，需求产出，需求落地，到需求验证全程跟进负责的人。</p>\n<p>具体来看，需求调研，包括要做一款什么样的产品？需求调研的方法包括：1、问卷调查 2、电话回访 3、见面约访 4、数据分析 5、业务需求等内容，也包括市场分析，竞品分析等；</p>\n<p>需求产出，包括从需求池中找出优先级最高的需求；需求落地，包括设计出图，研发代码实现，功能测试，产品验收等，需求验证包括数据验证等。</p>\n<p>我从以下两个方面阐述产品经理需要的能力：</p>\n<p>个人基本素质方面：</p>\n<ol>\n<li><p>沟通能力，产品是技术，测试，视觉，运营和推广等部门沟通的桥梁，很多的工作需要与各个部门的人合作完成，横向沟通，纵向沟通的沟通效果非常重要。</p>\n</li>\n<li><p>逻辑能力，产品经理逻辑工作复杂，且产品实现逻辑也很严谨，所以逻辑性和条理性很重要；</p>\n</li>\n<li><p>学习能力，互联网站在时代的最前沿，很多东西需要去创造，作为开拓者需要不断去学习。</p>\n</li>\n</ol>\n<p>产品基本能力方面：</p>\n<ol>\n<li><p>对行业的了解</p>\n</li>\n<li><p>站在用户思考的能力，能够站在主流用户/不同使用习惯/不同背景的用户角度去思考问题，而不是简单的把自己当做一个用户去思考决策问题</p>\n</li>\n<li><p>数据分析能力，决策需要数据的支撑，收集数据、整理数据和分析数据是一项非常重要的能力。</p>\n</li>\n<li><p>文档/原型能力</p>\n</li>\n</ol>\n<h2 id=\"如何获取和发现用户需求？\"><a href=\"#如何获取和发现用户需求？\" class=\"headerlink\" title=\"如何获取和发现用户需求？\"></a>如何获取和发现用户需求？</h2><p>问卷调查：问卷设计以选择题为主，可用通过问卷平台来发放。回答问卷的用户最好是你的产品的目标用户，要不然你的问卷结果的数据没有什么意义。</p>\n<p>核心用户访谈：这种方法成本比较高，但是往往你可以得到很多有用的信息。访谈可以涉及到的问题面会远远超过问卷。而且问卷调查的问题往往偏理性，而用户访谈你可以通过用户的情绪、表情、语气来获得更多感性的内容。</p>\n<p>竞品分析：可以帮助你快速了解此行业的最新动态。仔细研究竞争对手的产品会帮助你大致了解用户的痛点和需求。然后你在团队头脑风暴或者用户访谈的时候，你可以知道哪些功能你的竞争对手做的不好。这些功能点和需求，就是你的机会。</p>\n<p>通过数据分析：比如移动搜索端的产品，当你在决定做哪些领域之前，你需要选取一定的用户行为分析样本，然后对用户的行为进行标注。搜索领域用户的行为主要是：Query查询。当你获得了一天Top 十万的Query，你随机抽取其中的1000个Query，你可以分析这些Query，然后你会大致了解整体用户的搜索意图。然后对照你现有的产品，看看哪些领域，你的搜索结果是没有符合用户需求的。</p>\n<h2 id=\"你是怎么挖掘产品需求的？\"><a href=\"#你是怎么挖掘产品需求的？\" class=\"headerlink\" title=\"你是怎么挖掘产品需求的？\"></a>你是怎么挖掘产品需求的？</h2><p>在我看来，需求来源主要包括两大方面：</p>\n<p>一方面是来自于公司外部，即用户、市场、竞品等等；</p>\n<p>一方面是来自于公司内部，即企业战略、团队头脑风暴、产品数据分析等等。</p>\n<p><img src=\"https://uploader.shimo.im/f/AlagXWDkmmQrOlOI.jpg!thumbnail\" alt=\"图片\"></p>\n<h2 id=\"你是怎么判定各个产品需求的优先级的？\"><a href=\"#你是怎么判定各个产品需求的优先级的？\" class=\"headerlink\" title=\"你是怎么判定各个产品需求的优先级的？\"></a>你是怎么判定各个产品需求的优先级的？</h2><ol>\n<li>晚上看之前的笔记。重要性和紧急性；开发难度和成本</li>\n<li>在判断产品的优先级时，一般通过KANO模型进行判断。KANO模型定义了三个层次的用户需求:基本型需求、期望型需求和兴奋型需求。基本需求是必须具备的，即使不说也应该做到，这部分需求一般是产品初期需要做的功能。期望型需求是用户期望的，用户能够较清晰地知道的。而兴奋型需求是超出用户预期的，用户不知道有这方面的需求，如果提供，用户满意度会更高。</li>\n</ol>\n<p>KANO模型后面还有了其他方面的一些延伸：</p>\n<pre><code>魅力需求：用户意想不到的，如果不提供此需求，用户满意度不会降低，但当提供此需求，用户满意度会有很大提升；\n期望需求：当提供此需求，用户满意度会提升，当不提供此需求，用户满意度会降低；\n必备需求：当优化此需求，用户满意度不会提升，当不提供此需求，用户满意度会大幅降低；\n无差异需求：无论提供或不提供此需求，用户满意度都不会有改变，用户根本不在意；\n反向需求：用户根本都没有此需求，提供后用户满意度反而会下降。    </code></pre><h2 id=\"你为做产品都做了哪些准备？\"><a href=\"#你为做产品都做了哪些准备？\" class=\"headerlink\" title=\"你为做产品都做了哪些准备？\"></a>你为做产品都做了哪些准备？</h2><ol>\n<li><p>书籍，看过的书籍，《用户体验要素》《启示录》 《上瘾》</p>\n</li>\n<li><p>产品经理互联网训练营，需求分析，PRD文档等</p>\n</li>\n<li><p>日常生活，PMcaff 三节课 人人都是产品经理 APP</p>\n</li>\n</ol>\n<h2 id=\"你个人想做什么方向的产品？为什么？\"><a href=\"#你个人想做什么方向的产品？为什么？\" class=\"headerlink\" title=\"你个人想做什么方向的产品？为什么？\"></a>你个人想做什么方向的产品？为什么？</h2><h2 id=\"比较好的产品？\"><a href=\"#比较好的产品？\" class=\"headerlink\" title=\"比较好的产品？\"></a>比较好的产品？</h2><h3 id=\"微信阅读\"><a href=\"#微信阅读\" class=\"headerlink\" title=\"微信阅读\"></a>微信阅读</h3><p>联系微信阅读和《上瘾》这本书</p>\n<p><img src=\"https://uploader.shimo.im/f/nq5b3HnZwQM8ZJRr.jpg!thumbnail\" alt=\"图片\"></p>\n<h3 id=\"知乎\"><a href=\"#知乎\" class=\"headerlink\" title=\"知乎\"></a>知乎</h3><p>“我是知乎的超级粉丝。知乎是一个问答型APP，用户可以发布问题寻求帮助，通常会有一些相关主题的专家来回答问题。比如说，有人可能会问：‘更换轮胎最好的办法是什么？’或‘创业公司应该等候时机再筹集风险投资吗？’，甚至是‘住在牧场里是什么感觉？’网站上的问题五花八门，从‘帮我解决问题’到‘你对某事有什么看法’，再到‘请分享这方面的经验’，一切都应有尽有。</p>\n<p>“我喜欢知乎的原因之一就是它在解决专业问题时的专业性。基本上任何行业的专家都有，提供专业意见，能够给出极其详尽、深思熟虑的答案。</p>\n<p>“然而，在解决专业问题之余，我发现我还很喜欢使用这个APP。事实上它是一个基于学习和探索的社区。你可以认识网站上的人，评价他们的回答，因为你可以信任他们。</p>\n<p>“我想它是少数能将学习和乐趣连结起来的APP之一。它是一个问答型APP，每当我偶然发现一个自己从来不感兴趣但却很想知道的话题，就会到上面去询问别人。“在我个人使用的经历中，很多时候它都代替了百度，能够帮我搜到我想要的答案。<br>想想看，其实通过搜索引擎来解决问题，是有几种缺陷的。</p>\n<p>“第一，你会使用关键词来搜索，即便要解答一个问题，也同样如此。你是希望找到一个页面，能为你提供全面纵览的视角来解答你的问题。这并不是一种以解决方案为导向的搜索方式，通常效率很低。</p>\n<p>“第二是信任问题。你可能不信任搜索结果中网页作者的证据。就算你信任他，他们也可能在自己的专业领域里把问题搞错了。“知乎允许用户对问题答案以评论的方式进行反馈（也有“点赞”和“反对”的形式）。</p>\n<p>“当然，我仍会在网上搜索答案，但我发现我越来越经常使用知乎来解决问题，并且它也是我浏览和学习新知识的地方。”</p>\n<p><strong>盈利模式</strong></p>\n<ol>\n<li><p>广告</p>\n</li>\n<li><p>会员</p>\n</li>\n<li><p>提成</p>\n</li>\n</ol>\n<h3 id=\"网易云音乐\"><a href=\"#网易云音乐\" class=\"headerlink\" title=\"网易云音乐\"></a>网易云音乐</h3><p>网易云音乐的定位是“移动音乐社区”，并以歌单为核心的组织方式强化用户UGC社交属性。</p>\n<p>网易云音乐以“音乐社交”的差异点切入市场，迅速获得大批活跃用户。并以此为基，向产业链上游延伸。以产品撬动市场，试图颠覆传统、改变行业。</p>\n<p>网易云音乐从多纬度满足用户发现音乐的需求，个性推荐，歌单，主播电台，排行榜等，基于朋友的社交分享功能，提供对歌曲、歌单、专辑、电台的点赞、评论、转发。可以关注基于通讯录的朋友、微博的朋友、明星、音乐达人、还可关注基于LBS附近的人。</p>\n<p>在网易云音乐中，弱化了专辑，强化了歌单，好处是：利用算法提高曲库利用率，把用户喜欢听但主观寻找不找的音乐找出来推荐给用户，弱化版权不足的缺点，网易云音乐把握住了人性。好的音乐是由用户决定的，因为好的UGC会得到大家的认可，这个看评论区就可以看出来，如果有音乐人在某首歌曲下留言，他可能是被赞最多的，同样，即使是普通用户留言，也可以达到同样的效果。谁不渴望获得别人的认可，在娱乐自己的同时，还能得到他人的关注认可。于是，高粘性促使用户的听歌习惯在无形中转变，由听音乐转换到发现音乐再到爱上音乐，换句话来说，一个没有权威、畅所欲言的国度是不是你渴望的？</p>\n<h2 id=\"不喜欢的产品？\"><a href=\"#不喜欢的产品？\" class=\"headerlink\" title=\"不喜欢的产品？\"></a>不喜欢的产品？</h2><h2 id=\"成功的产品有什么标准？\"><a href=\"#成功的产品有什么标准？\" class=\"headerlink\" title=\"成功的产品有什么标准？\"></a>成功的产品有什么标准？</h2><p>个人看来：一款成功的产品必须具有以下标准：</p>\n<ol>\n<li><p>能解决目标用户的痛点。</p>\n</li>\n<li><p>拥有较好的用户体验。</p>\n</li>\n<li><p>能够为企业或个人带来利益。</p>\n</li>\n<li><p>具有不错的用户粘性。</p>\n</li>\n</ol>\n<h2 id=\"你是因为做不了技术才做产品的吗？\"><a href=\"#你是因为做不了技术才做产品的吗？\" class=\"headerlink\" title=\"你是因为做不了技术才做产品的吗？\"></a>你是因为做不了技术才做产品的吗？</h2><h2 id=\"产品经理如何与运营沟通？\"><a href=\"#产品经理如何与运营沟通？\" class=\"headerlink\" title=\"产品经理如何与运营沟通？\"></a>产品经理如何与运营沟通？</h2><ol>\n<li><p>“换位思考”和“尊重”</p>\n</li>\n<li><p>理解产品的定位与价值 很多时候产品和运营沟通，出现的主要矛盾点就在于产品定位和对应的人群。</p>\n</li>\n<li><p>理解运营流程；产品中会有很多标准的执行流程，但是在运营的过程中，很多流程是灵活的，有些不需要标准化。这个时候就不能运用产品经理的流程化和标准化的思维去理解运营人员的工作，不然就很容易发生矛盾。</p>\n</li>\n<li><p>需求决定权归属明确</p>\n</li>\n</ol>\n<p>在产品的前期，产品性质与人群匹配的过程中，需求的决定还是取决于产品经理。因为产品经理要确保产品的初衷，定位和价值不发生改变，或者根据市场的需求，做相应的改变。</p>\n<ol>\n<li>运营与产品是一家</li>\n</ol>\n<p>最后一定要抱着产品和运营是一家的观点去和运营沟通。产品和运营，都是为了能够让产品更好的获得更多的用户。<br>一些点子和需求，需要大家共同商讨确定。不同的观点可以带来不同的思路，不要因为岗位的不同，职责不同，为了使自己方便而让其他人作出让步，只要这个需求是正确的，最终目的是为了获得更多的目标用户，那么产品和运营都需要支持。</p>\n<h2 id=\"产品经理如何与强势的技术沟通？\"><a href=\"#产品经理如何与强势的技术沟通？\" class=\"headerlink\" title=\"产品经理如何与强势的技术沟通？\"></a>产品经理如何与强势的技术沟通？</h2><p>产品与开发之间主要产品矛盾的点是什么呢？——工期</p>\n<ol>\n<li><p>做好自己的本质工作，明确需求的优先级，准备详实的文档，沟通重要保持清晰的思路，要注重细节与全局的把控。</p>\n</li>\n<li><p>理解对方的深层顾虑</p>\n</li>\n<li><p>学习开发技术，可以不要求技能有多精进，能够掌握各种最新技术，也可以不要求代码有多么优美整洁，架构设计得多么合理。但是最起码也要能够使用现有的框架、组件、资源去完成一个独立产品的开发。在开发中了解自己平时所负责的产品，是如何通过代码实现出来的。要抛弃学技术就是为了“说行话”这个想法。</p>\n</li>\n<li><p>大多数产品和开发之间的沟通问题，都不是沟通能力的问题，而是产品经理思考能力的问题。</p>\n</li>\n</ol>\n<h2 id=\"遇到不可沟通的人怎么办？or-和开发人员闹僵了怎么处理？\"><a href=\"#遇到不可沟通的人怎么办？or-和开发人员闹僵了怎么处理？\" class=\"headerlink\" title=\"遇到不可沟通的人怎么办？or 和开发人员闹僵了怎么处理？\"></a>遇到不可沟通的人怎么办？or 和开发人员闹僵了怎么处理？</h2><p>如果在项目进行过程中遇到了这样的问题，我的处理办法是：</p>\n<ol>\n<li><p>摆数据：拿出相关数据来佐证改动的必要性，数据可以是页面点击数，用户粘性。</p>\n</li>\n<li><p>讲事实：在数据论证的基础上，阐述项目规划、目标和领导预期，并结合所需要的改动的功能点进行说明。论证修改后悔取得双方互赢的良好效果。</p>\n</li>\n<li><p>适当妥协：站在技术的角度，首先要理解技术拒绝更改的原因。在合理的范围内做适当的妥协，如项目的拖延时间等等，关键是项目有所输出并保证质量。</p>\n</li>\n<li><p>向上沟通。</p>\n</li>\n</ol>\n<p>当然，在处理本次冲突的基础上，还需要客观的分析冲突发生的原因，是由于沟通机制存在问题还是由于沟通双方的沟通方式没有磨合好。及时分析，避免下次出现这种情况。</p>\n<h2 id=\"产品被同行抄袭该怎么处理？\"><a href=\"#产品被同行抄袭该怎么处理？\" class=\"headerlink\" title=\"产品被同行抄袭该怎么处理？\"></a>产品被同行抄袭该怎么处理？</h2><p>对于技术和交互的抄袭，诉之法庭是最好的解决办法，而对于模式的抄袭，最为关键的是集中优势建立核心资源壁垒，抓紧时间强占市场。</p>\n<ol>\n<li><p>建立技术壁垒</p>\n</li>\n<li><p>建立资源壁垒</p>\n</li>\n<li><p>建立用户口碑壁垒</p>\n</li>\n</ol>\n<h2 id=\"你觉得你的执行能力怎么样？\"><a href=\"#你觉得你的执行能力怎么样？\" class=\"headerlink\" title=\"你觉得你的执行能力怎么样？\"></a>你觉得你的执行能力怎么样？</h2><p>我觉得我的执行能力有待提高，现在属于合格水平。比如上次学校的活动，我们要在3天内拉到3000元的活动赞助。我们第一天做策划方案，接下来两天，3人小组白天刷企业，晚上修改策划，最终搞定3500元的赞助费。对于一个事情，我push的能力很强，但执行能力不仅是push能力，还有规划、团队协作能力，我都有待提高。拉赞助的活动，我们最后虽然成功了，但是在刷企业的路线规划、分头行动的沟通效率上还有待提高。</p>\n<h2 id=\"如何做需求的优先级排序和版本规划\"><a href=\"#如何做需求的优先级排序和版本规划\" class=\"headerlink\" title=\"如何做需求的优先级排序和版本规划\"></a>如何做需求的优先级排序和版本规划</h2><p>产品的版本规划，对于不同的产品、不同阶段的产品，其排期方式可能不同。不同职级的PM所需要掌握的管理的方法也不同，这里选取相对初级的产品经理而不是全面的产品负责人。</p>\n<ol>\n<li><p>boss的需求，</p>\n</li>\n<li><p>版本的主要功能及商业化</p>\n</li>\n<li><p>明显可以提高日活/拉新等的优化和调整类需求</p>\n</li>\n<li><p>尝试性功能和提高运营效率等</p>\n</li>\n</ol>\n<p><strong>产品未上线：</strong></p>\n<ol>\n<li><p>基于当时的环境和实际情况</p>\n</li>\n<li><p>用户需求是一个动态变化的过程</p>\n</li>\n</ol>\n<p><strong>对于免费性商品且以经上线</strong></p>\n<p>需求的商业价值原则–重要性紧迫性原则。</p>\n<p>用户需求重要性的判断标准：用户基数，使用次数和类别重要性。</p>\n<p>用户需求重要性=功能使用用户百分比（用户使用率）X 功能使用频次（功能/内容使用率） X 类别重要百分比（基本型、期望性、兴奋性）</p>\n<p><strong>收费性</strong></p>\n<p>重要性==收益。</p>\n<p>使用一下四种方法进行优先级进行排序：</p>\n<ol>\n<li><p>看用户量和发生频率</p>\n</li>\n<li><p>看开发难度和效果</p>\n</li>\n<li><p>看产品价值</p>\n</li>\n<li><p>看对目标群体的熟悉程度</p>\n</li>\n</ol>\n<h2 id=\"产品需求的来源有那些？\"><a href=\"#产品需求的来源有那些？\" class=\"headerlink\" title=\"产品需求的来源有那些？\"></a>产品需求的来源有那些？</h2><ol>\n<li><p>老板提出的战略性需求。</p>\n</li>\n<li><p>产品经理根据产品方向规划需求。</p>\n</li>\n<li><p>推广规划的活动和数据分析出来一些需求。</p>\n</li>\n<li><p>用户访谈提出需求。</p>\n</li>\n<li><p>其他参与者和关注者反馈的需求。</p>\n</li>\n</ol>\n<h2 id=\"如何处理可能完成不了的紧急任务？\"><a href=\"#如何处理可能完成不了的紧急任务？\" class=\"headerlink\" title=\"如何处理可能完成不了的紧急任务？\"></a>如何处理可能完成不了的紧急任务？</h2><p>面对这样的棘手的事情，有以下三个原则：</p>\n<ol>\n<li><p>保持信息的畅通</p>\n</li>\n<li><p>从源头出发，辅以紧急措施</p>\n</li>\n<li><p>坦然面对利益和责任，知错要能改。</p>\n</li>\n</ol>\n<p>之后，自己有以下解决方式：</p>\n<ol>\n<li><p>向同事寻求帮忙，优点是同事熟悉业务，上手快，最可靠。</p>\n</li>\n<li><p>向同行业的人寻求帮助，优点是人气成本低，成本是沟通成本大，风险是涉密，收益上更有利于自己；</p>\n</li>\n<li><p>雇佣合适的人来完成。</p>\n</li>\n</ol>\n<p>总之，解决方案的选择，是以下各种因素权衡后的结果：公司的利益，任务的结果，上司承担的风险，解决成本，自己的舆论和给公司的形象。</p>\n<p>同时，还要思考为什么不能按时完成任务？是前期计划不合理，还是执行有问题？这个习惯有利于找到症结后迅速打开局面。同时还能知道问题的源头。</p>\n<h2 id=\"产品上线后要注意的指标？\"><a href=\"#产品上线后要注意的指标？\" class=\"headerlink\" title=\"产品上线后要注意的指标？\"></a>产品上线后要注意的指标？</h2><p>考虑到不同类型的产品和平台，其关键指标有着不小的差异，所以以“PC端的媒体网站”来进行论述：</p>\n<p>第一类：流量类指标</p>\n<p>总PV，平均浏览页面数，跳出率，退出率，平均访问时长，流量的各渠道占比</p>\n<p>第二类：文章类指标</p>\n<p>浏览量最高的文章/栏目，浏览量最低的文章/栏目，每日发表文章数，文章流量的时间分布，日用户评论数</p>\n<p>第三类：用户类指标</p>\n<p>日总PV，注册用户数，新用户占比，次日留存率，周留存率，日/月活跃用户</p>\n<p>第四类：商业类指标</p>\n<p>广告点击次数，引入新广告品牌是否是知名品牌</p>\n<p>通用用户数据指标包括：</p>\n<ol>\n<li><p>ARPU：总收入/用户数，没用户平均收入</p>\n</li>\n<li><p>注册用户数</p>\n</li>\n<li><p>活跃用户数</p>\n</li>\n<li><p>新用户占比</p>\n</li>\n<li><p>用户流失率</p>\n</li>\n<li><p>次日留存率</p>\n</li>\n<li><p>渠道转化率</p>\n</li>\n</ol>\n<h2 id=\"如何判断一个产品的好坏\"><a href=\"#如何判断一个产品的好坏\" class=\"headerlink\" title=\"如何判断一个产品的好坏\"></a>如何判断一个产品的好坏</h2><p><strong>用户体验的五大层次：有用，能用，可用，用的好，形成品牌</strong></p>\n<p>不同角色的人因为利益诉求不同，评判产品的标准也有所不同，其结论也会不同。</p>\n<p>例如：</p>\n<p>站在用户的角度来看，产品好不好在于需求怎么样被满足，是否满足了期望性需求，是否满足兴奋性需求。从用户体验上来说，处在“有用，能用，可用，用得好，形成品牌”的哪个层次。</p>\n<p>站在开发的角度，评价标准又变成了整个产品在挖需求、找痛点，搭框架、架功能做交互等方面的成果。</p>\n<p>站在投资商或者商家用户的角度，有时候产品本身的体验，用户数，影响力等方面都不用在意，能够赚钱才是好产品。</p>\n<p>此外，还要考虑这个产品在特定背景下，特定时期的表现，运营团队的表现，竞争对手的表现综合评估。</p>\n<h2 id=\"互联网产品的盈利模式及其适用产品\"><a href=\"#互联网产品的盈利模式及其适用产品\" class=\"headerlink\" title=\"互联网产品的盈利模式及其适用产品\"></a>互联网产品的盈利模式及其适用产品</h2><ol>\n<li>流量变现模式：广告和导流</li>\n</ol>\n<p>-. 广告：在线广告（门户网站，视频网站），匹配广告（百度搜索，淘宝搜索），社交广告（Facebook用户推荐）</p>\n<p>-. 导流：导航网站（hao123），浏览器（QQ浏览器），手机管理软件（豌豆荚）</p>\n<ol>\n<li><p>佣金分成模式：B2C电商平台（天猫），团购和优惠券（美团），游戏开放平台（人人网），互联网金融（支付宝）</p>\n</li>\n<li><p>增值服务模式：高级功能收费（游戏道具，QQ会员）</p>\n</li>\n<li><p>收费服务模式：提供收费服务（企业邮箱），会员数据库（51job），贸易平台（B2B电商阿里巴巴）</p>\n</li>\n</ol>\n<h2 id=\"如何进行产品改版？\"><a href=\"#如何进行产品改版？\" class=\"headerlink\" title=\"如何进行产品改版？\"></a>如何进行产品改版？</h2><p>一般而言，产品改版有一下四种需求来源：</p>\n<ol>\n<li><p>用户调研和用户反馈分析</p>\n</li>\n<li><p>数据分析</p>\n</li>\n<li><p>团队成员（boss，运营，市场，技术）提的需求</p>\n</li>\n<li><p>PM自己对产品的思考和重构</p>\n</li>\n</ol>\n<p>在改版前和改版后，产品改版方向正确与否的评判方式，有不小的区分：</p>\n<p><strong>改版前，主要用一下三点进行改版的评定：</strong></p>\n<ol>\n<li>意见收集；2. 数据分析，3. 问卷调研</li>\n</ol>\n<p><strong>改版后，主要用一下四点进行改版评定</strong>：</p>\n<ol>\n<li><p>数据分析：整体流量分析，用户粘性分析，页面效率分析</p>\n</li>\n<li><p>用户反馈</p>\n</li>\n<li><p>行业反馈</p>\n</li>\n<li><p>商业价值</p>\n</li>\n</ol>\n<h2 id=\"淘汰一个人怎么回答？\"><a href=\"#淘汰一个人怎么回答？\" class=\"headerlink\" title=\"淘汰一个人怎么回答？\"></a>淘汰一个人怎么回答？</h2><p>淘汰一个组员这样的问题原本是部门领导，人事部门或者像您这样的面试官需要考虑的问题。什么样的人更适合这个公司，更适合这个团队，如何组建团队，对组员做价值评估，这些其实真的不是我应该考虑的。</p>\n<p>因为作为一个组员往往只能站在个人的角度，站在逻辑思维的角度，个人利害的角度来回答这个问题。比方今天的面试此刻在你心里一定会有一个排名，排名靠前的自然录取的机会更大。如果你给我一个权力让我淘汰一个组员，对我最有利的做法自然是揣测并淘汰一个排名比我靠前的，因为很显然这样会增加我的录取几率。如果我不这样回答，就有悖于常理，和我的诚实。</p>\n<p>所以你看让一个组员过多来思考这个问题，往往会让公司留不住真正的人才，让团队不和谐。如果你有录取这里在座任何人的意向，我想你也一定不希望他把这种思维方式带到公司内部。</p>\n<h2 id=\"用户产品经理和数据产品经理的区别是什么？\"><a href=\"#用户产品经理和数据产品经理的区别是什么？\" class=\"headerlink\" title=\"用户产品经理和数据产品经理的区别是什么？\"></a>用户产品经理和数据产品经理的区别是什么？</h2><p>用户产品经理：用户产品也就是常说的to c产品，重点注重用极致的用户体验获取用户。</p>\n<p>数据产品经理：主要通过数据的渠道和方法，理解和解释产品和功能的情况。比如通过对各种指标数据的分析解释产品或功能的走势及背后的原因。</p>\n<ol>\n<li><p>用户产品经理的职能：（1）需求挖掘（对某一用户群进行深入理解，挖掘这类人的共同需求，针对共性需求制定解决方案；）解决方案与功能（2）实现逻辑（针对一类用户在同一场景下的需求，以优化功能，交互设计为主解决问题）及流程（3）界面原型（4）数据</p>\n</li>\n<li><p>数据产品经理的职能：解释（要基于数据解释产品或功能的某项核心指标（包括收入、DAU、ROI等等）的走势及背后的原因，往往需要细化到多个维度（比如：时间、区域、渠道等）、验证（对新推出的功能或者改进，验证其效果或者影响）、探索（通过研究内外部的数据（比如：用户的使用行为数据及搜索词等，百度指数及贴吧发言等等），数据产品经理探索规律和探索用户的需求，通过数据的方式进行初步验证；或者满足一定的功能，通过数据挖掘的方式满足功能需求。）及传播（制作有见地有传播性的图文文章，并便于在朋友圈及知乎等地传播，为自己产品赢得口碑和品牌增值）。</p>\n</li>\n</ol>\n<h2 id=\"如何进行数据分析？\"><a href=\"#如何进行数据分析？\" class=\"headerlink\" title=\"如何进行数据分析？\"></a>如何进行数据分析？</h2><p>一是数据分析框架，二是数据分析方法。</p>\n<p>（一）数据分析框架</p>\n<ol>\n<li>AARRR模型</li>\n</ol>\n<p>AARRR模型可以告诉我们在产品的几个阶段分别需要重点关注哪些数据。AARRR是几个英文字母的缩写，分别是获取、激活、留存、收入、推荐</p>\n<pre><code>获取（指产品推广，告诉我们用户从哪来）需要关注的数据为：曝光数、打开率、点击率、下载量、安装量、用户获取成本。\n激活（指用户使用了产品）需要关注的数据为：设备激活量、新注册用户数、日活跃、浏览数、订阅数。\n留存（指用户持续使用产品）需要关注的数据为：次日留存率、7日留存率、距离上次使用时长。\n收入（指产品获得利润）需要关注的数据为：付费率、付费频次、客单价、用户价值。\n推荐（指用户推荐他人使用我们的产品）需要关注的数据为：转发数、邀请数、评论数。</code></pre><ol>\n<li>逻辑分析框架</li>\n</ol>\n<p>核心指标出现了问题一定是有相关指标出现了问题。</p>\n<p>如销售额=访客数UV<em>转化率</em>客单价，销售额下降的原因要在这三个指标里找原因</p>\n<p>如流量增长因素：PC端、APP端、WAP端、友盟等</p>\n<ol>\n<li>漏斗分析框架</li>\n</ol>\n<p>用于分析开始用户到最终用户的数量变化趋势</p>\n<p>4.还有一些管理营销方面的分析框架</p>\n<p>如SWOT分析、4P理论、5W2H、SMART分析等。</p>\n<p>（二）数据分析方法</p>\n<ol>\n<li>对比分析</li>\n</ol>\n<p>最常用的分析方法，通过对比的方式来找出差异，对比的对象可以是其他竞品也可以是自己的产品，对比的时间可以采用同比与环比</p>\n<ol>\n<li>趋势分析</li>\n</ol>\n<p>通过折线图的方式发现问题（数据下降或是上升等等）</p>\n<ol>\n<li><p>交叉分析（通过多个维度去分析数据）</p>\n</li>\n<li><p>象限分析</p>\n</li>\n</ol>\n<h2 id=\"杭州有多少出租车，加油站？如何预测？\"><a href=\"#杭州有多少出租车，加油站？如何预测？\" class=\"headerlink\" title=\"杭州有多少出租车，加油站？如何预测？\"></a>杭州有多少出租车，加油站？如何预测？</h2><h1 id=\"实习相关\"><a href=\"#实习相关\" class=\"headerlink\" title=\"实习相关\"></a>实习相关</h1><h2 id=\"你觉得你实习时有什么收获？\"><a href=\"#你觉得你实习时有什么收获？\" class=\"headerlink\" title=\"你觉得你实习时有什么收获？\"></a>你觉得你实习时有什么收获？</h2><ol>\n<li>对做产品的认识：</li>\n</ol>\n<p>产品经理的理解：同理心，需求，对事，对人，对产品本身</p>\n<p>对汇报工作的思考（还记得好多次我一直都很忙，但是感觉大家不知道我在忙什么，为此为自己总结了以下几点，为以后遵循的工作原则）尽可能将我做的工作按照以下优先级进行转化</p>\n<ol>\n<li>对敏捷的认识：团队成员相互信任与认可，前期需求管理的主要工作在于拆分，需要经常的和及时的质量度量、测试、决策 ，自动化测试</li>\n</ol>\n<h2 id=\"你在实习期间主要负责什么？\"><a href=\"#你在实习期间主要负责什么？\" class=\"headerlink\" title=\"你在实习期间主要负责什么？\"></a>你在实习期间主要负责什么？</h2><ol>\n<li>独立负责GBMP 产品视点漫游功能，联合开发部门实习生对此功能进行敏捷开发</li>\n<li>对比分析Revit、Navisworks 视点漫游功能，提出了新的方案，改善了用户操作的路径和使用效率</li>\n<li>机械库内置参数的统计和整理，为冷机吊装方案用到的机械提供参数支持</li>\n</ol>\n<h2 id=\"你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？\"><a href=\"#你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？\" class=\"headerlink\" title=\"你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？\"></a>你在实习过程中遇到了哪些困难？是如何解决的？你做项目中遇到的最大困难？怎样解决？</h2><p>时间是最大的问题，要在有限的时间里面做完工作、做好工作很具有挑战性。每个人都只有24 小时，我从早上6：00<br>到晚上24：00 的时间都规划好了，但是有时候还是不够用。解决方案就是更加努力致力于做事的效率，在有限的时间里面极致利用时间，高效发挥效率。</p>\n<h2 id=\"吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。\"><a href=\"#吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。\" class=\"headerlink\" title=\"吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。\"></a>吐槽你生活中遇到的最槽糕的一次体验，并给出优化建议。</h2><p>可以结合我们之前看的一个滴滴打车的改进方案！</p>\n<h2 id=\"2B和2C的区别\"><a href=\"#2B和2C的区别\" class=\"headerlink\" title=\"2B和2C的区别\"></a>2B和2C的区别</h2><ol>\n<li>2C产品的本质是人性，2B产品的背后是业务。</li>\n</ol>\n<p>2C产品间的区别是目标人群和场景不同，而2B产品间的区别是业务不同。</p>\n<ol>\n<li>2C产品设计更偏感性，2B产品更偏理性。</li>\n</ol>\n<p>各种产品方法论中最常被提到的一个词是“用户痛点”。<br>在2B产品的设计过程中，最重要的是分析业务流程、各种业务间依赖关系、穷尽业务场景等，抽象影响因素、梳理逻辑流程、推导因果关系，都是理性思维的主场。</p>\n<ol>\n<li>交互、视觉设计，对2C产品是命脉，对2B产品则是锦上添花</li>\n</ol>\n<p>在这个颜值即正义的时代，一个界面丑陋的2C产品会被用户分分钟卸载掉，连被骂的机会都没有。更何况交互、视觉不仅仅是好不好看的问题，很多产品问题的解决、产品目标的实现都依赖交互视觉层面的设计。<br>而对于一个2B产品，大家更常关注的是功能。2B产品的交互常比较简单，菜单、按钮、表单等常用控件已能满足需求。视觉设计的空间也比较小，而且好不好看、版式是否清晰、是否有视线引导等等对业务的影响并不大。因此交互、视觉的设计，就算有考量，在开发优先级中也是比较靠后的。</p>\n<ol>\n<li>2C产品相比2B产品更易量化</li>\n</ol>\n<p>对于2C产品，无论产品目标是什么，通常都可以找到量化的指标。比如产品目标是用户量，可以用拉新数、日活、月活、留存率等衡量，如果产品目标是收入，可以用ARPU值、付费用户比率、收入总额来衡量。但2B产品则很难有量化的衡量。产品背后的业务可以有各种量化的指标，但这些指标是用来衡量业务的，而不能衡量支持业务的业务系统。</p>\n<ol>\n<li>2C产品用户对使用成本0容忍，2B用户却能接受高学习成本</li>\n</ol>\n<p>《Don’t Make Me Think》是一部用户体验领域的经典，书名直译是“别让我思考”。现在一个优秀的2C产品真的可以做到这一点，操作简单、指引明确，用户常常还没觉察就已经实现(bei)目(hu)标(you)。在2C产品中产品经理会被用户喷成狗，在2B产品中却会被尊为师。2C产品的Q&amp;A就算再精美也没人看，但在2B产品中培训手册却是必要的输出物，还要尽可能的详细。而且可能还要安排专门的培训课程，对业务人员进行系统的培训。</p>\n<h2 id=\"当自己的产品方案跟老板的产品方案不同时，怎么处理？\"><a href=\"#当自己的产品方案跟老板的产品方案不同时，怎么处理？\" class=\"headerlink\" title=\"当自己的产品方案跟老板的产品方案不同时，怎么处理？\"></a>当自己的产品方案跟老板的产品方案不同时，怎么处理？</h2><p>这个问题考察面试者的执行力，如果一而再，再而三地试图说服领导，就是执行力不足，谁都有可能犯错，但是不去做谁也不知道。谁做决定谁负责，只有快速地执行才能快速地试错。<br>如果反复地纠结而不去执行，提高了领导对自己的管理成本。也耽误了项目本身的进度，则是不可取的，要明白当下最重要的是去验证</p>\n<h2 id=\"设计一个产品\"><a href=\"#设计一个产品\" class=\"headerlink\" title=\"设计一个产品\"></a>设计一个产品</h2><p><strong>理解最终的目的</strong><br>为了解决用户的痛点，为了增加用户。<br>解题方法：</p>\n<ol>\n<li>通过提问来理解问题</li>\n<li>使用结构化的思维</li>\n</ol>\n<p>“首先我想要说说设计这个产品的目的，接着我会列出一些可行的功能点，最后我会结合产品设计的目的对这些功能点进行评估。那么，我们现在开始讲这个产品的目的……”</p>\n<ol>\n<li>明确目标用户和目标消费者</li>\n</ol>\n<p>遇到的问题，想象产品的使用场景，以及除了用户之外，还有那些人会与产品互动。</p>\n<ol>\n<li>有哪些使用案例，用户为什么要使用这个产品？他们使用的目的是什么？</li>\n<li>现有产品是否能够良好的满足这些使用要求，这些产品是否存在明显的缺点？</li>\n<li>什么功能或修改能改进这些缺陷？</li>\n<li>总结<h2 id=\"改进一个产品（微信）\"><a href=\"#改进一个产品（微信）\" class=\"headerlink\" title=\"改进一个产品（微信）\"></a>改进一个产品（微信）</h2></li>\n<li>这个产品的设计目的是什么？</li>\n<li>这个产品面临什么问题？</li>\n<li>你会如何解决这个问题？</li>\n</ol>\n<p>4 如实现你的解决方案？</p>\n<ol>\n<li>如何确认你的解决方案是行之有效的？</li>\n</ol>\n<p>用微信吗，说说微信有什么你想改进的吧<br>A：收藏文件过多，希望给到更强大的文件分类收藏管理能力。<br>Q：你觉得这个需求痛点够硬吗<br>A：有这个痛点可能需要满足几个条件：1 日常用微信 2 被微信生态内的多个场景多种内容曝光 3 爱收藏；第一个几乎八成中国人日常用微信，第二个应该也是比较多毕竟现在微信生态有各种内容，第三个收藏这个需求应该还蛮普遍。综上，我觉得这个需求痛点应该还行。<br>Q：这样吧，微信日活8亿，你给我算算有多少人对你这个功能改进有需求<br>A：（其实就是费米问题考察我临场和拆解）拉了四层漏斗：1 日常用微信，百分百，不筛；2 被微信生态多个场景多个内容曝光，分了 群聊、朋友圈、公众号、看一看四个场景，每个场景一层小漏斗估算（每个小漏斗逻辑不详细展开了）；3 被曝光之后要爱收藏，漏斗是爱收藏的人的占比；4 收藏之后还需要有点强迫症，所以才想归类整理，这是最后一层漏斗。</p>\n<h2 id=\"你最喜欢的产品\"><a href=\"#你最喜欢的产品\" class=\"headerlink\" title=\"你最喜欢的产品\"></a>你最喜欢的产品</h2><ol>\n<li>这个产品为用户解决了什么问题？</li>\n<li>这个产品如何满足这些使用目的？是什么这个产品很“干净”？这个产品的什么地方使得用户爱上了它？</li>\n<li>它和同类产品相比起来如何？</li>\n<li>如果要你来设计，你会如何改进这个产品？<h2 id=\"如何将用户需求转换为产品需求？\"><a href=\"#如何将用户需求转换为产品需求？\" class=\"headerlink\" title=\"如何将用户需求转换为产品需求？\"></a>如何将用户需求转换为产品需求？</h2>首先保持二八原则，只有普遍用户的需求，才能内化为产品的需求。比如某个需求就一个用户需要，其他大多数用户都不需要，你就不需要做。<br>通过现象看本质，收集用户需求以后，多为自己几个为什么，找到用户的动机。<br>例如：用户在沙漠中需要水，你就要问自己用户为什么需要水？用户有可能口渴了，那这时候你给他水就好，如果用户是因为太热，你能不能给他防晒服，甚至考虑一下用户体验，觉得防晒服太麻烦，提供防晒霜。有时候一个人并不能完全洞察用户的动机，需要团队的其他人员一起头脑风暴，甚至多问提这个需求的原始用户几个为什么，直到找到真正动机为止，然后结合产品本身衡量需求的性价比，最后综合团队实力，需求急切度确定最终产品需求。</li>\n</ol>\n<h1 id=\"自由提问环节\"><a href=\"#自由提问环节\" class=\"headerlink\" title=\"自由提问环节\"></a>自由提问环节</h1><ol>\n<li>对需求的精准把握，是一个产品经理的核心能力，但是用户的需求即多又模糊和个性化，把握起来有一定的难度，我特别想听您分享一下自己在这个问题上的思考和经验？</li>\n<li>我知道我离一个出色的PM还有很长的路要走，根据我刚才的表现，你觉得我还需要提高那一块（体现你的谦虚好学，如果面试官对你评价比较积极，说明你这次面试还是比较成功的，从侧面试探出你的面试成绩。）</li>\n<li>关于刚才提到的那个问题，不知道您是怎么认为的？（就自己没有回答好的具体问题，向面试官进行讨教。）</li>\n<li>关于产品经理的职业发展道路，不知道您有没有什么好的建议？（将问题上升到职业发展的道路）</li>\n</ol>\n<h1 id=\"个人经历\"><a href=\"#个人经历\" class=\"headerlink\" title=\"个人经历\"></a>个人经历</h1><h2 id=\"请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果\"><a href=\"#请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果\" class=\"headerlink\" title=\"请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果\"></a>请举例说明你在一项团队活动中如何采取主动性，最终获得你所希望的结果</h2><h2 id=\"描述一个情景，在这个情景中你必须搜集相关信息，划定关键点\"><a href=\"#描述一个情景，在这个情景中你必须搜集相关信息，划定关键点\" class=\"headerlink\" title=\"描述一个情景，在这个情景中你必须搜集相关信息，划定关键点\"></a>描述一个情景，在这个情景中你必须搜集相关信息，划定关键点</h2><h2 id=\"举例说明你是怎样用事实促使他人与你达成一致意见的。\"><a href=\"#举例说明你是怎样用事实促使他人与你达成一致意见的。\" class=\"headerlink\" title=\"举例说明你是怎样用事实促使他人与你达成一致意见的。\"></a>举例说明你是怎样用事实促使他人与你达成一致意见的。</h2><h2 id=\"举例证明你可以和他人合作，共同实现一个重要目标。\"><a href=\"#举例证明你可以和他人合作，共同实现一个重要目标。\" class=\"headerlink\" title=\"举例证明你可以和他人合作，共同实现一个重要目标。\"></a>举例证明你可以和他人合作，共同实现一个重要目标。</h2><h2 id=\"举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。\"><a href=\"#举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。\" class=\"headerlink\" title=\"举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。\"></a>举例证明，你的一个创意曾经对一个项目的成功起到至关重要的作用。</h2><h2 id=\"请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。\"><a href=\"#请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。\" class=\"headerlink\" title=\"请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。\"></a>请举例，你是怎样评估一种情况，并将注意力集中在关键问题的解决。</h2><h2 id=\"举例说明你怎样获得一种技能，并将其转化为实践。\"><a href=\"#举例说明你怎样获得一种技能，并将其转化为实践。\" class=\"headerlink\" title=\"举例说明你怎样获得一种技能，并将其转化为实践。\"></a>举例说明你怎样获得一种技能，并将其转化为实践。</h2><h2 id=\"举例说明，你如何制定了一个很高的目标，并且最终实现了它。\"><a href=\"#举例说明，你如何制定了一个很高的目标，并且最终实现了它。\" class=\"headerlink\" title=\"举例说明，你如何制定了一个很高的目标，并且最终实现了它。\"></a>举例说明，你如何制定了一个很高的目标，并且最终实现了它。</h2>"},{"title":"2019-python","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-29T10:45:57.000Z","password":null,"summary":"页面信息提取 爬虫","_content":"\n\n以[MATLAB中文论坛--MATLAB 基础讨论 ](http://www.ilovematlab.cn/forum-6-1.html)为例，进行页面信息提取，主要提取页面内问题，问题的阅读量以及问题链接，汇总阅读量大于100000的图。\n\n\n\n\n\n# 爬取网页\n\n以[MATLAB中文论坛--MATLAB 基础讨论 ](http://www.ilovematlab.cn/forum-6-1.html)为例，进行页面信息提取，主要提取页面内问题，问题的阅读量以及问题链接，汇总阅读量大于100000的图。\n解析网页信息，主要的提取代码为：\n~~~ html\n<a href=\"thread-568443-1-1.html\" onclick=\"atarget(this)\" class=\"s xst\">小白求问函数求导问题</a>\n~~~\n\n# 工具\n## python\n利用Python语言进行编程爬取网页的内容。\n## beautifulsoup\n用[beautifulsoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html)包进行解析网页。\n# 完整代码\n```python\n// An highlighted block\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Apr  9 19:39:29 201\n@author: 12101\n\"\"\"\nfrom bs4 import BeautifulSoup\nimport requests\nimport pygal\nfrom pygal.style import LightColorizedStyle as LCS, LightenStyle as LS\n\n# 得到每页的数据 urls 网页源\ndef get_titles(urls,data = None):\n    print(urls)\n    try:\n        web_data = requests.get(urls)\n        soup = BeautifulSoup(web_data.text, 'lxml')\n        souptitle=soup.find_all(\"a\",class_='s xst')\n        soupnum=soup.find_all(\"a\",class_='xi2')\n        for i in range(0,len(souptitle)):\n            link.append(souptitle[i]['href'])\n\n        for title in souptitle:\n            Title.append(title.get_text())\n        for num in soupnum:\n            nextSib=num.find_next_siblings('em')\n            if (len(nextSib)==1):       \n                Nums.append(int(nextSib[0].get_text()))\n        return Title,Nums,link\n    except:\n        return \"Someting is Wrong!\n        \n\n# 得到绘图的数据 Title 标题 Nums 数量 link 链接            \ndef getplotdata(Title,Nums,link):\n    for i in range(0,len(Title)):\n        plot_dirt={\n            \"value\":Nums[i],\n            \"lable\":Title[i],\n            \"xlink\":'http://www.ilovematlab.cn/' + link[i],\n                }\n        plot_dirts.append(plot_dirt)\n    return plot_dirts\n\n# 绘图操作定义 Plot_dirt 绘图数据字典 Title 横坐标标题\ndef Plot_dirt(name,Plot_dirt,Title):\n    my_style = LS('#333366', base_style=LCS)\n# 定义类型\n    my_config = pygal.Config()\n    my_config.x_label_rotation = 45\n    my_config.show_legend = False\n    my_config.title_font_size = 24\n    my_config.label_font_size = 14\n    my_config.major_label_font_size = 18\n    my_config.truncate_label = 15\n    my_config.show_y_guides = False\n    my_config.width = 1000\n    chart1 = pygal.Bar(my_config, style=my_style)\n    chart1.title = 'Most-Read Python Projects on Matlab'\n    chart1.x_labels = Title\n    chart1.add('',Plot_dirt)             \n    chart1.render_to_file(name) \n\n\n# 输出文件 定义样式 name 文件名 title 标题 num 阅读量 link 链接 \ndef Output_data(name,title,num,link,temp):\n    filename = name\n    with open(filename,'w',encoding='utf-8') as file_object:\n        if temp==1:\n            for i in range(0,len(title)):\n                file_object.write(title[i] + \"\\t\" + str(num[i]) + \"\\t\" + 'http://www.ilovematlab.cn/' + link[i] +  \"\\n\")\n        else:\n            for i in range(0,len(title)):\n                file_object.write(title[i] + \"\\t\" + str(num[i]) + \"\\t\" + link[i] +  \"\\n\")\n                    \n\nTitle,Nums,plot_dirts,plot_All,plot_numer,plot_title,link,plot_link=[],[],[],[],[],[],[],[]\nMaxReadNum=200000\nurls = ['http://www.ilovematlab.cn/forum-6-{}.html'.format(str(i)) for i in range(1,1001)]\nfor url in urls:\n    get_titles(url)\n# 输出所有网页的数据 标题 阅读量 链接   \nOutput_data('outputall.txt',Title,Nums,link,1)\n\n# 对得到的绘图数据进行字典处理 \ngetplotdata(Title,Nums,link)\n\n# 处理得到的数据，将大于MaxReadNum的数据提取出来\nfor i in range(0,len(plot_dirts)):\n    if plot_dirts[i]['value'] > MaxReadNum:\n        plot_All.append(plot_dirts[i])\n        plot_title.append(plot_dirts[i]['lable'])\n        plot_numer.append(plot_dirts[i]['value'])\n        plot_link.append(plot_dirts[i]['xlink'])\n\nname1='1.svg'        \nPlot_dirt(name1,plot_All,plot_title)\n\n# 输出绘图数据的文本文件\nOutput_data('outputpart.txt',plot_title,plot_numer,plot_link,2\n```\n# 结果\n<div align=\"center\">\n<img src=\"https://img-blog.csdnimg.cn/20190410122225883.png\" height=\"500\" width=\"1000\" >","source":"_posts/2019-python.md","raw":"---\ntitle: 2019-python\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-29 18:45:57\npassword:\nsummary: 页面信息提取 爬虫\ntags:\n- python\ncategories:\n- python\n---\n\n\n以[MATLAB中文论坛--MATLAB 基础讨论 ](http://www.ilovematlab.cn/forum-6-1.html)为例，进行页面信息提取，主要提取页面内问题，问题的阅读量以及问题链接，汇总阅读量大于100000的图。\n\n\n\n\n\n# 爬取网页\n\n以[MATLAB中文论坛--MATLAB 基础讨论 ](http://www.ilovematlab.cn/forum-6-1.html)为例，进行页面信息提取，主要提取页面内问题，问题的阅读量以及问题链接，汇总阅读量大于100000的图。\n解析网页信息，主要的提取代码为：\n~~~ html\n<a href=\"thread-568443-1-1.html\" onclick=\"atarget(this)\" class=\"s xst\">小白求问函数求导问题</a>\n~~~\n\n# 工具\n## python\n利用Python语言进行编程爬取网页的内容。\n## beautifulsoup\n用[beautifulsoup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html)包进行解析网页。\n# 完整代码\n```python\n// An highlighted block\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Apr  9 19:39:29 201\n@author: 12101\n\"\"\"\nfrom bs4 import BeautifulSoup\nimport requests\nimport pygal\nfrom pygal.style import LightColorizedStyle as LCS, LightenStyle as LS\n\n# 得到每页的数据 urls 网页源\ndef get_titles(urls,data = None):\n    print(urls)\n    try:\n        web_data = requests.get(urls)\n        soup = BeautifulSoup(web_data.text, 'lxml')\n        souptitle=soup.find_all(\"a\",class_='s xst')\n        soupnum=soup.find_all(\"a\",class_='xi2')\n        for i in range(0,len(souptitle)):\n            link.append(souptitle[i]['href'])\n\n        for title in souptitle:\n            Title.append(title.get_text())\n        for num in soupnum:\n            nextSib=num.find_next_siblings('em')\n            if (len(nextSib)==1):       \n                Nums.append(int(nextSib[0].get_text()))\n        return Title,Nums,link\n    except:\n        return \"Someting is Wrong!\n        \n\n# 得到绘图的数据 Title 标题 Nums 数量 link 链接            \ndef getplotdata(Title,Nums,link):\n    for i in range(0,len(Title)):\n        plot_dirt={\n            \"value\":Nums[i],\n            \"lable\":Title[i],\n            \"xlink\":'http://www.ilovematlab.cn/' + link[i],\n                }\n        plot_dirts.append(plot_dirt)\n    return plot_dirts\n\n# 绘图操作定义 Plot_dirt 绘图数据字典 Title 横坐标标题\ndef Plot_dirt(name,Plot_dirt,Title):\n    my_style = LS('#333366', base_style=LCS)\n# 定义类型\n    my_config = pygal.Config()\n    my_config.x_label_rotation = 45\n    my_config.show_legend = False\n    my_config.title_font_size = 24\n    my_config.label_font_size = 14\n    my_config.major_label_font_size = 18\n    my_config.truncate_label = 15\n    my_config.show_y_guides = False\n    my_config.width = 1000\n    chart1 = pygal.Bar(my_config, style=my_style)\n    chart1.title = 'Most-Read Python Projects on Matlab'\n    chart1.x_labels = Title\n    chart1.add('',Plot_dirt)             \n    chart1.render_to_file(name) \n\n\n# 输出文件 定义样式 name 文件名 title 标题 num 阅读量 link 链接 \ndef Output_data(name,title,num,link,temp):\n    filename = name\n    with open(filename,'w',encoding='utf-8') as file_object:\n        if temp==1:\n            for i in range(0,len(title)):\n                file_object.write(title[i] + \"\\t\" + str(num[i]) + \"\\t\" + 'http://www.ilovematlab.cn/' + link[i] +  \"\\n\")\n        else:\n            for i in range(0,len(title)):\n                file_object.write(title[i] + \"\\t\" + str(num[i]) + \"\\t\" + link[i] +  \"\\n\")\n                    \n\nTitle,Nums,plot_dirts,plot_All,plot_numer,plot_title,link,plot_link=[],[],[],[],[],[],[],[]\nMaxReadNum=200000\nurls = ['http://www.ilovematlab.cn/forum-6-{}.html'.format(str(i)) for i in range(1,1001)]\nfor url in urls:\n    get_titles(url)\n# 输出所有网页的数据 标题 阅读量 链接   \nOutput_data('outputall.txt',Title,Nums,link,1)\n\n# 对得到的绘图数据进行字典处理 \ngetplotdata(Title,Nums,link)\n\n# 处理得到的数据，将大于MaxReadNum的数据提取出来\nfor i in range(0,len(plot_dirts)):\n    if plot_dirts[i]['value'] > MaxReadNum:\n        plot_All.append(plot_dirts[i])\n        plot_title.append(plot_dirts[i]['lable'])\n        plot_numer.append(plot_dirts[i]['value'])\n        plot_link.append(plot_dirts[i]['xlink'])\n\nname1='1.svg'        \nPlot_dirt(name1,plot_All,plot_title)\n\n# 输出绘图数据的文本文件\nOutput_data('outputpart.txt',plot_title,plot_numer,plot_link,2\n```\n# 结果\n<div align=\"center\">\n<img src=\"https://img-blog.csdnimg.cn/20190410122225883.png\" height=\"500\" width=\"1000\" >","slug":"2019-python","published":1,"updated":"2019-09-29T10:57:30.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbp001z2wvca40x2b3k","content":"<p>以<a href=\"http://www.ilovematlab.cn/forum-6-1.html\" target=\"_blank\" rel=\"noopener\">MATLAB中文论坛–MATLAB 基础讨论 </a>为例，进行页面信息提取，主要提取页面内问题，问题的阅读量以及问题链接，汇总阅读量大于100000的图。</p>\n<h1 id=\"爬取网页\"><a href=\"#爬取网页\" class=\"headerlink\" title=\"爬取网页\"></a>爬取网页</h1><p>以<a href=\"http://www.ilovematlab.cn/forum-6-1.html\" target=\"_blank\" rel=\"noopener\">MATLAB中文论坛–MATLAB 基础讨论 </a>为例，进行页面信息提取，主要提取页面内问题，问题的阅读量以及问题链接，汇总阅读量大于100000的图。<br>解析网页信息，主要的提取代码为：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>thread-568443-1-1.html<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">onclick</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>atarget(this)<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>s xst<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>小白求问函数求导问题<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>a</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><h2 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h2><p>利用Python语言进行编程爬取网页的内容。</p>\n<h2 id=\"beautifulsoup\"><a href=\"#beautifulsoup\" class=\"headerlink\" title=\"beautifulsoup\"></a>beautifulsoup</h2><p>用<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\" target=\"_blank\" rel=\"noopener\">beautifulsoup</a>包进行解析网页。</p>\n<h1 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h1><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token operator\">//</span> An highlighted block\n<span class=\"token comment\" spellcheck=\"true\"># -*- coding: utf-8 -*-</span>\n<span class=\"token triple-quoted-string string\">\"\"\"\nCreated on Tue Apr  9 19:39:29 201\n@author: 12101\n\"\"\"</span>\n<span class=\"token keyword\">from</span> bs4 <span class=\"token keyword\">import</span> BeautifulSoup\n<span class=\"token keyword\">import</span> requests\n<span class=\"token keyword\">import</span> pygal\n<span class=\"token keyword\">from</span> pygal<span class=\"token punctuation\">.</span>style <span class=\"token keyword\">import</span> LightColorizedStyle <span class=\"token keyword\">as</span> LCS<span class=\"token punctuation\">,</span> LightenStyle <span class=\"token keyword\">as</span> LS\n\n<span class=\"token comment\" spellcheck=\"true\"># 得到每页的数据 urls 网页源</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_titles</span><span class=\"token punctuation\">(</span>urls<span class=\"token punctuation\">,</span>data <span class=\"token operator\">=</span> None<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>urls<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n        web_data <span class=\"token operator\">=</span> requests<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>urls<span class=\"token punctuation\">)</span>\n        soup <span class=\"token operator\">=</span> BeautifulSoup<span class=\"token punctuation\">(</span>web_data<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">,</span> <span class=\"token string\">'lxml'</span><span class=\"token punctuation\">)</span>\n        souptitle<span class=\"token operator\">=</span>soup<span class=\"token punctuation\">.</span>find_all<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span>class_<span class=\"token operator\">=</span><span class=\"token string\">'s xst'</span><span class=\"token punctuation\">)</span>\n        soupnum<span class=\"token operator\">=</span>soup<span class=\"token punctuation\">.</span>find_all<span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span>class_<span class=\"token operator\">=</span><span class=\"token string\">'xi2'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">(</span>souptitle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            link<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>souptitle<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'href'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">for</span> title <span class=\"token keyword\">in</span> souptitle<span class=\"token punctuation\">:</span>\n            Title<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>title<span class=\"token punctuation\">.</span>get_text<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> soupnum<span class=\"token punctuation\">:</span>\n            nextSib<span class=\"token operator\">=</span>num<span class=\"token punctuation\">.</span>find_next_siblings<span class=\"token punctuation\">(</span><span class=\"token string\">'em'</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">(</span>nextSib<span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>       \n                Nums<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>int<span class=\"token punctuation\">(</span>nextSib<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>get_text<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> Title<span class=\"token punctuation\">,</span>Nums<span class=\"token punctuation\">,</span>link\n    <span class=\"token keyword\">except</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> \"Someting <span class=\"token keyword\">is</span> Wrong!\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 得到绘图的数据 Title 标题 Nums 数量 link 链接            </span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">getplotdata</span><span class=\"token punctuation\">(</span>Title<span class=\"token punctuation\">,</span>Nums<span class=\"token punctuation\">,</span>link<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">(</span>Title<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        plot_dirt<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">:</span>Nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"lable\"</span><span class=\"token punctuation\">:</span>Title<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n            <span class=\"token string\">\"xlink\"</span><span class=\"token punctuation\">:</span><span class=\"token string\">'http://www.ilovematlab.cn/'</span> <span class=\"token operator\">+</span> link<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n                <span class=\"token punctuation\">}</span>\n        plot_dirts<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>plot_dirt<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> plot_dirts\n\n<span class=\"token comment\" spellcheck=\"true\"># 绘图操作定义 Plot_dirt 绘图数据字典 Title 横坐标标题</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">Plot_dirt</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>Plot_dirt<span class=\"token punctuation\">,</span>Title<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    my_style <span class=\"token operator\">=</span> LS<span class=\"token punctuation\">(</span><span class=\"token string\">'#333366'</span><span class=\"token punctuation\">,</span> base_style<span class=\"token operator\">=</span>LCS<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 定义类型</span>\n    my_config <span class=\"token operator\">=</span> pygal<span class=\"token punctuation\">.</span>Config<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    my_config<span class=\"token punctuation\">.</span>x_label_rotation <span class=\"token operator\">=</span> <span class=\"token number\">45</span>\n    my_config<span class=\"token punctuation\">.</span>show_legend <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n    my_config<span class=\"token punctuation\">.</span>title_font_size <span class=\"token operator\">=</span> <span class=\"token number\">24</span>\n    my_config<span class=\"token punctuation\">.</span>label_font_size <span class=\"token operator\">=</span> <span class=\"token number\">14</span>\n    my_config<span class=\"token punctuation\">.</span>major_label_font_size <span class=\"token operator\">=</span> <span class=\"token number\">18</span>\n    my_config<span class=\"token punctuation\">.</span>truncate_label <span class=\"token operator\">=</span> <span class=\"token number\">15</span>\n    my_config<span class=\"token punctuation\">.</span>show_y_guides <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n    my_config<span class=\"token punctuation\">.</span>width <span class=\"token operator\">=</span> <span class=\"token number\">1000</span>\n    chart1 <span class=\"token operator\">=</span> pygal<span class=\"token punctuation\">.</span>Bar<span class=\"token punctuation\">(</span>my_config<span class=\"token punctuation\">,</span> style<span class=\"token operator\">=</span>my_style<span class=\"token punctuation\">)</span>\n    chart1<span class=\"token punctuation\">.</span>title <span class=\"token operator\">=</span> <span class=\"token string\">'Most-Read Python Projects on Matlab'</span>\n    chart1<span class=\"token punctuation\">.</span>x_labels <span class=\"token operator\">=</span> Title\n    chart1<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span>Plot_dirt<span class=\"token punctuation\">)</span>             \n    chart1<span class=\"token punctuation\">.</span>render_to_file<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> \n\n\n<span class=\"token comment\" spellcheck=\"true\"># 输出文件 定义样式 name 文件名 title 标题 num 阅读量 link 链接 </span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">Output_data</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span>title<span class=\"token punctuation\">,</span>num<span class=\"token punctuation\">,</span>link<span class=\"token punctuation\">,</span>temp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    filename <span class=\"token operator\">=</span> name\n    <span class=\"token keyword\">with</span> open<span class=\"token punctuation\">(</span>filename<span class=\"token punctuation\">,</span><span class=\"token string\">'w'</span><span class=\"token punctuation\">,</span>encoding<span class=\"token operator\">=</span><span class=\"token string\">'utf-8'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> file_object<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> temp<span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">(</span>title<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                file_object<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span>title<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> str<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> <span class=\"token string\">'http://www.ilovematlab.cn/'</span> <span class=\"token operator\">+</span> link<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span>  <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">(</span>title<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n                file_object<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span>title<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> str<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> link<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span>  <span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">)</span>\n\n\nTitle<span class=\"token punctuation\">,</span>Nums<span class=\"token punctuation\">,</span>plot_dirts<span class=\"token punctuation\">,</span>plot_All<span class=\"token punctuation\">,</span>plot_numer<span class=\"token punctuation\">,</span>plot_title<span class=\"token punctuation\">,</span>link<span class=\"token punctuation\">,</span>plot_link<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nMaxReadNum<span class=\"token operator\">=</span><span class=\"token number\">200000</span>\nurls <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'http://www.ilovematlab.cn/forum-6-{}.html'</span><span class=\"token punctuation\">.</span>format<span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span> url <span class=\"token keyword\">in</span> urls<span class=\"token punctuation\">:</span>\n    get_titles<span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># 输出所有网页的数据 标题 阅读量 链接   </span>\nOutput_data<span class=\"token punctuation\">(</span><span class=\"token string\">'outputall.txt'</span><span class=\"token punctuation\">,</span>Title<span class=\"token punctuation\">,</span>Nums<span class=\"token punctuation\">,</span>link<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 对得到的绘图数据进行字典处理 </span>\ngetplotdata<span class=\"token punctuation\">(</span>Title<span class=\"token punctuation\">,</span>Nums<span class=\"token punctuation\">,</span>link<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 处理得到的数据，将大于MaxReadNum的数据提取出来</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">(</span>plot_dirts<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> plot_dirts<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'value'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> MaxReadNum<span class=\"token punctuation\">:</span>\n        plot_All<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>plot_dirts<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        plot_title<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>plot_dirts<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'lable'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        plot_numer<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>plot_dirts<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'value'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        plot_link<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>plot_dirts<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'xlink'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\nname1<span class=\"token operator\">=</span><span class=\"token string\">'1.svg'</span>        \nPlot_dirt<span class=\"token punctuation\">(</span>name1<span class=\"token punctuation\">,</span>plot_All<span class=\"token punctuation\">,</span>plot_title<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 输出绘图数据的文本文件</span>\nOutput_data<span class=\"token punctuation\">(</span><span class=\"token string\">'outputpart.txt'</span><span class=\"token punctuation\">,</span>plot_title<span class=\"token punctuation\">,</span>plot_numer<span class=\"token punctuation\">,</span>plot_link<span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1><div align=\"center\">\n<img src=\"https://img-blog.csdnimg.cn/20190410122225883.png\" height=\"500\" width=\"1000\"></div>","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<p>以<a href=\"http://www.ilovematlab.cn/forum-6-1.html\" target=\"_blank\" rel=\"noopener\">MATLAB中文论坛–MATLAB 基础讨论 </a>为例，进行页面信息提取，主要提取页面内问题，问题的阅读量以及问题链接，汇总阅读量大于100000的图。</p>\n<h1 id=\"爬取网页\"><a href=\"#爬取网页\" class=\"headerlink\" title=\"爬取网页\"></a>爬取网页</h1><p>以<a href=\"http://www.ilovematlab.cn/forum-6-1.html\" target=\"_blank\" rel=\"noopener\">MATLAB中文论坛–MATLAB 基础讨论 </a>为例，进行页面信息提取，主要提取页面内问题，问题的阅读量以及问题链接，汇总阅读量大于100000的图。<br>解析网页信息，主要的提取代码为：</p>\n<pre><code class=\"html\">&lt;a href=&quot;thread-568443-1-1.html&quot; onclick=&quot;atarget(this)&quot; class=&quot;s xst&quot;&gt;小白求问函数求导问题&lt;/a&gt;</code></pre>\n<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><h2 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h2><p>利用Python语言进行编程爬取网页的内容。</p>\n<h2 id=\"beautifulsoup\"><a href=\"#beautifulsoup\" class=\"headerlink\" title=\"beautifulsoup\"></a>beautifulsoup</h2><p>用<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\" target=\"_blank\" rel=\"noopener\">beautifulsoup</a>包进行解析网页。</p>\n<h1 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h1><pre><code class=\"python\">// An highlighted block\n# -*- coding: utf-8 -*-\n&quot;&quot;&quot;\nCreated on Tue Apr  9 19:39:29 201\n@author: 12101\n&quot;&quot;&quot;\nfrom bs4 import BeautifulSoup\nimport requests\nimport pygal\nfrom pygal.style import LightColorizedStyle as LCS, LightenStyle as LS\n\n# 得到每页的数据 urls 网页源\ndef get_titles(urls,data = None):\n    print(urls)\n    try:\n        web_data = requests.get(urls)\n        soup = BeautifulSoup(web_data.text, &#39;lxml&#39;)\n        souptitle=soup.find_all(&quot;a&quot;,class_=&#39;s xst&#39;)\n        soupnum=soup.find_all(&quot;a&quot;,class_=&#39;xi2&#39;)\n        for i in range(0,len(souptitle)):\n            link.append(souptitle[i][&#39;href&#39;])\n\n        for title in souptitle:\n            Title.append(title.get_text())\n        for num in soupnum:\n            nextSib=num.find_next_siblings(&#39;em&#39;)\n            if (len(nextSib)==1):       \n                Nums.append(int(nextSib[0].get_text()))\n        return Title,Nums,link\n    except:\n        return &quot;Someting is Wrong!\n\n\n# 得到绘图的数据 Title 标题 Nums 数量 link 链接            \ndef getplotdata(Title,Nums,link):\n    for i in range(0,len(Title)):\n        plot_dirt={\n            &quot;value&quot;:Nums[i],\n            &quot;lable&quot;:Title[i],\n            &quot;xlink&quot;:&#39;http://www.ilovematlab.cn/&#39; + link[i],\n                }\n        plot_dirts.append(plot_dirt)\n    return plot_dirts\n\n# 绘图操作定义 Plot_dirt 绘图数据字典 Title 横坐标标题\ndef Plot_dirt(name,Plot_dirt,Title):\n    my_style = LS(&#39;#333366&#39;, base_style=LCS)\n# 定义类型\n    my_config = pygal.Config()\n    my_config.x_label_rotation = 45\n    my_config.show_legend = False\n    my_config.title_font_size = 24\n    my_config.label_font_size = 14\n    my_config.major_label_font_size = 18\n    my_config.truncate_label = 15\n    my_config.show_y_guides = False\n    my_config.width = 1000\n    chart1 = pygal.Bar(my_config, style=my_style)\n    chart1.title = &#39;Most-Read Python Projects on Matlab&#39;\n    chart1.x_labels = Title\n    chart1.add(&#39;&#39;,Plot_dirt)             \n    chart1.render_to_file(name) \n\n\n# 输出文件 定义样式 name 文件名 title 标题 num 阅读量 link 链接 \ndef Output_data(name,title,num,link,temp):\n    filename = name\n    with open(filename,&#39;w&#39;,encoding=&#39;utf-8&#39;) as file_object:\n        if temp==1:\n            for i in range(0,len(title)):\n                file_object.write(title[i] + &quot;\\t&quot; + str(num[i]) + &quot;\\t&quot; + &#39;http://www.ilovematlab.cn/&#39; + link[i] +  &quot;\\n&quot;)\n        else:\n            for i in range(0,len(title)):\n                file_object.write(title[i] + &quot;\\t&quot; + str(num[i]) + &quot;\\t&quot; + link[i] +  &quot;\\n&quot;)\n\n\nTitle,Nums,plot_dirts,plot_All,plot_numer,plot_title,link,plot_link=[],[],[],[],[],[],[],[]\nMaxReadNum=200000\nurls = [&#39;http://www.ilovematlab.cn/forum-6-{}.html&#39;.format(str(i)) for i in range(1,1001)]\nfor url in urls:\n    get_titles(url)\n# 输出所有网页的数据 标题 阅读量 链接   \nOutput_data(&#39;outputall.txt&#39;,Title,Nums,link,1)\n\n# 对得到的绘图数据进行字典处理 \ngetplotdata(Title,Nums,link)\n\n# 处理得到的数据，将大于MaxReadNum的数据提取出来\nfor i in range(0,len(plot_dirts)):\n    if plot_dirts[i][&#39;value&#39;] &gt; MaxReadNum:\n        plot_All.append(plot_dirts[i])\n        plot_title.append(plot_dirts[i][&#39;lable&#39;])\n        plot_numer.append(plot_dirts[i][&#39;value&#39;])\n        plot_link.append(plot_dirts[i][&#39;xlink&#39;])\n\nname1=&#39;1.svg&#39;        \nPlot_dirt(name1,plot_All,plot_title)\n\n# 输出绘图数据的文本文件\nOutput_data(&#39;outputpart.txt&#39;,plot_title,plot_numer,plot_link,2</code></pre>\n<h1 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1><div align=\"center\">\n<img src=\"https://img-blog.csdnimg.cn/20190410122225883.png\" height=\"500\" width=\"1000\"></div>"},{"title":"京东面试记录","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-29T10:41:19.000Z","password":null,"summary":"京东群面+HR面面试记录。","_content":"\n京东群面+HR面面试记录。\n\n\n\n\n\n## 京东面试复盘\n\n## 群面题：\n\n在智慧交通，智慧城市，云办公三个领域中选一个领域做一款产品，要求可以运营或者可以落地。\n\n14进3，还是蛮不错的结果，小伙伴们很给力。\n\n我们讨论的结果是：基于5G智慧调度的无人车车队\n\n最后从用户场景，可行性（政府政策，蓝海红海，技术可行性以及公司定位和目标），价值来进行阐述的。\n\n群面过程中有的小伙伴几乎没说话，有的说的很不是很让人理解。还是要多有一些有用的输出，其中11号小姐姐虽然说的不多，但是能够说的很有用。所以在这个过程中一要多说话，二要多输出有效的观点。\n\n## HR面\n\n### 拼积木，讲解你拼的积木\n\n主要从一下方面讲解:\n\n1. 拼积木的思路，先找好目标，再对现有积木进行分类。自己没有拼成功，达到自己的目标，联系到管理，每个人都要在自己合适的岗位，才能发挥最大的效用。没用到的积木，不一定是没用的，而是我们还么有找到他的位置。\n\n2. 京东现在从一体化组织成为积木型组织，也是希望在快速变化的市场内，可以快速创新，快速是错。\n\n3. 反思自己的思路，一方面，我是现有目标再去看资源，也可以看现有资源去订目标。联系到产品，产品经理不能凭自己的理解和需求去做产品，要看市场，用户的需求是什么样的。\n\n### 询问简历相关内容\n\n1. 介绍下研究生期间研究的项目\n\n目前，我主要做的是结构求解软件积分器部分的实现，做这款产品的目的有两个，第一中国虽然在计算方面做得比较好，但是都是国外的软件，建立中国芯十分有必要，第二是希望为国内开启新的方向，这和京东成为对社会最有价值的公司是一样的初衷。\n\n我主要负责的是积分求解器的实现，现在实现的有两个成果，一是开发了自己的算法，也发表了。第二，开发了一款非商业性开源软件。\n\n现在还在做这方面的工作。这是我研究生期间主要做的工作，\n\n2. 团队多少人，怎么协作，时间节点怎么安排？任务的安排。\n\n我们团队大概10来人，因为我们用的是C+V开发，所以采用GIT的方式，大家做各自相关的项目，然后提交修改bug。\n\n时间节点的安排主要我有两方面的考虑:一是学生自身的能力和任务难度的匹配数，第二是项目本身的时间限制。此外，导师就像一个产品经理，他也有自己的想法和考量，所以时间一般是大家讨论出来的。\n\n任务的安排主要由老师的安排，老师也会考虑我们的实际情况进行调整。\n\n在这个工作过程中，我们也会和市场上的相关人员接触确定我们工作的进度和节点。\n\n3. 介绍下广联达的实习经历？\n\n1在广联达的实习我主要参与了两个项目，第一个项目是我进入后由我和七个开发实习生一起做的，我是该款产品的PM master，对该产品的成果负责。公司做这款产品的目的主要有三个，1是基于现有平台为以后公司发展方向进行试错\n和探索，2是研究现在产品实现该功能的方法，进行分析客户的痛点，难点和关键点。3是研究市场的大小，进行商业上的预判。我们经过两个月的努力，完成了以上要求，最后得到了部门领导的认同。\n\n在第二个公司正式项目里，我主要负责的地方有三个方面，第一，负责起重机数据分析和拟合。在产品实现过程中需要实时显示负载率，我由于工科背景很适合这个工作。第二是，机械参数的配置，第三是客户拜访和需求调研，主要拜访了上安集团，北安集团。对产品进行验证和市场探索。\n\n4. 有没有碰到特别难以处理的事情？\n\n关于特别难处理的问题，我主要有两个事情比较有感触。第一件事是刚实习的时候，光有理论知识，到实操的时候有点束手无措。这个时候主要的解决思路是多个师傅沟通，多尝试，多问，然后根据师傅的建议去做，也很快适应过来了。\n\n第二件事是我加入公司正式项目小组的第一周，我一般以上的时间都在开会，如果处理开会和工作的时间问题是我最棘手的问题，我主要从三个方面来解决，一是加班做完自己的工作，二是提高效率，三是尽量自己少发出意义不大，人数众多的会议。\n\n5. 看你现在做的开发，现在为什么来做产品经理？\n\n为什么来做产品经理主要有以下原因：\n\n1.自己在研究生期间开发产品的过程中了解到产品经理这个岗位，在开发的过程中相应的也承担起了产品经理这个职责；\n\n2.通过自己的了解，包括报班系统的学习，进入互联网社区去做志愿者发现自己很喜欢这个行业；\n\n3.自己也适合这个行业，一方面我喜欢在生活中观察，比如美团点外卖的时候的处理，以及滴滴出行自己的想法；\n\n4.自己无论做摄影还是剪视频，都是一个创造，一个做产品的过程，我很享受这个过程。\n\n6. 你在三节课培训学到的内容？\n\n三节课的这段经历主要让我作为一个产品经理的基本知识和素养进行了系统的整合，让我更加系统和全面的了解到了产品经理的职责和解决的问题的流程。具体的内容可以从一下几个方面去说：1是需求调研，2.需求产出，3.需求落地，4.需求验证等方面。然后再具体的说各方面的内容的小点。\n\n7. 对工作城市的选择，为什么选择大城市？\n\n1.自身发展，个人性格，家庭原因。就业机会多。，资待遇高。个人进步快。拥有很高的创业成功率，创业空间广阔。\n\n2.城市发展\n\n3.公司发展\n\n大城市有更多的想象空间，而且，未来大都市会越来越智能化发展，提供给居民更多难以想象的便利，生活在大城市，是大多数人的未来。\n\n8. 职业规划问题\n\n1.职业定位： 互联网产品经理\n\n\n2.目标设置，短期目标：入职，转正。长期目标1-3年拿到多少，3-5年拿到多少？\n3.主要聚焦于自身能力的提升，1-3年做什么？基础理论的学习，架构能力的学习。3-5做什么？带领项目，和公司的安排。\n\n未来3年内做到什么目标；\n\n今年的目标是什么；\n\n\n进公司的话，试用期目标是什么？\n\n9.你和女朋友工作地点不一样怎么办？\n\n10.是不是党员？\n\n11.你有什么问题？\n\n\t请问这个岗位在公司内部的未来发展方向是怎样的？\n\t\n\t请问贵司对于我这样的应届毕业生的未来发展有怎样的预期？","source":"_posts/2019-second-interview.md","raw":"---\ntitle: 京东面试记录\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-29 18:41:19\npassword:\nsummary: 京东群面+HR面面试记录。\ntags:\n- 面试\ncategories:\n- 面试\n---\n\n京东群面+HR面面试记录。\n\n\n\n\n\n## 京东面试复盘\n\n## 群面题：\n\n在智慧交通，智慧城市，云办公三个领域中选一个领域做一款产品，要求可以运营或者可以落地。\n\n14进3，还是蛮不错的结果，小伙伴们很给力。\n\n我们讨论的结果是：基于5G智慧调度的无人车车队\n\n最后从用户场景，可行性（政府政策，蓝海红海，技术可行性以及公司定位和目标），价值来进行阐述的。\n\n群面过程中有的小伙伴几乎没说话，有的说的很不是很让人理解。还是要多有一些有用的输出，其中11号小姐姐虽然说的不多，但是能够说的很有用。所以在这个过程中一要多说话，二要多输出有效的观点。\n\n## HR面\n\n### 拼积木，讲解你拼的积木\n\n主要从一下方面讲解:\n\n1. 拼积木的思路，先找好目标，再对现有积木进行分类。自己没有拼成功，达到自己的目标，联系到管理，每个人都要在自己合适的岗位，才能发挥最大的效用。没用到的积木，不一定是没用的，而是我们还么有找到他的位置。\n\n2. 京东现在从一体化组织成为积木型组织，也是希望在快速变化的市场内，可以快速创新，快速是错。\n\n3. 反思自己的思路，一方面，我是现有目标再去看资源，也可以看现有资源去订目标。联系到产品，产品经理不能凭自己的理解和需求去做产品，要看市场，用户的需求是什么样的。\n\n### 询问简历相关内容\n\n1. 介绍下研究生期间研究的项目\n\n目前，我主要做的是结构求解软件积分器部分的实现，做这款产品的目的有两个，第一中国虽然在计算方面做得比较好，但是都是国外的软件，建立中国芯十分有必要，第二是希望为国内开启新的方向，这和京东成为对社会最有价值的公司是一样的初衷。\n\n我主要负责的是积分求解器的实现，现在实现的有两个成果，一是开发了自己的算法，也发表了。第二，开发了一款非商业性开源软件。\n\n现在还在做这方面的工作。这是我研究生期间主要做的工作，\n\n2. 团队多少人，怎么协作，时间节点怎么安排？任务的安排。\n\n我们团队大概10来人，因为我们用的是C+V开发，所以采用GIT的方式，大家做各自相关的项目，然后提交修改bug。\n\n时间节点的安排主要我有两方面的考虑:一是学生自身的能力和任务难度的匹配数，第二是项目本身的时间限制。此外，导师就像一个产品经理，他也有自己的想法和考量，所以时间一般是大家讨论出来的。\n\n任务的安排主要由老师的安排，老师也会考虑我们的实际情况进行调整。\n\n在这个工作过程中，我们也会和市场上的相关人员接触确定我们工作的进度和节点。\n\n3. 介绍下广联达的实习经历？\n\n1在广联达的实习我主要参与了两个项目，第一个项目是我进入后由我和七个开发实习生一起做的，我是该款产品的PM master，对该产品的成果负责。公司做这款产品的目的主要有三个，1是基于现有平台为以后公司发展方向进行试错\n和探索，2是研究现在产品实现该功能的方法，进行分析客户的痛点，难点和关键点。3是研究市场的大小，进行商业上的预判。我们经过两个月的努力，完成了以上要求，最后得到了部门领导的认同。\n\n在第二个公司正式项目里，我主要负责的地方有三个方面，第一，负责起重机数据分析和拟合。在产品实现过程中需要实时显示负载率，我由于工科背景很适合这个工作。第二是，机械参数的配置，第三是客户拜访和需求调研，主要拜访了上安集团，北安集团。对产品进行验证和市场探索。\n\n4. 有没有碰到特别难以处理的事情？\n\n关于特别难处理的问题，我主要有两个事情比较有感触。第一件事是刚实习的时候，光有理论知识，到实操的时候有点束手无措。这个时候主要的解决思路是多个师傅沟通，多尝试，多问，然后根据师傅的建议去做，也很快适应过来了。\n\n第二件事是我加入公司正式项目小组的第一周，我一般以上的时间都在开会，如果处理开会和工作的时间问题是我最棘手的问题，我主要从三个方面来解决，一是加班做完自己的工作，二是提高效率，三是尽量自己少发出意义不大，人数众多的会议。\n\n5. 看你现在做的开发，现在为什么来做产品经理？\n\n为什么来做产品经理主要有以下原因：\n\n1.自己在研究生期间开发产品的过程中了解到产品经理这个岗位，在开发的过程中相应的也承担起了产品经理这个职责；\n\n2.通过自己的了解，包括报班系统的学习，进入互联网社区去做志愿者发现自己很喜欢这个行业；\n\n3.自己也适合这个行业，一方面我喜欢在生活中观察，比如美团点外卖的时候的处理，以及滴滴出行自己的想法；\n\n4.自己无论做摄影还是剪视频，都是一个创造，一个做产品的过程，我很享受这个过程。\n\n6. 你在三节课培训学到的内容？\n\n三节课的这段经历主要让我作为一个产品经理的基本知识和素养进行了系统的整合，让我更加系统和全面的了解到了产品经理的职责和解决的问题的流程。具体的内容可以从一下几个方面去说：1是需求调研，2.需求产出，3.需求落地，4.需求验证等方面。然后再具体的说各方面的内容的小点。\n\n7. 对工作城市的选择，为什么选择大城市？\n\n1.自身发展，个人性格，家庭原因。就业机会多。，资待遇高。个人进步快。拥有很高的创业成功率，创业空间广阔。\n\n2.城市发展\n\n3.公司发展\n\n大城市有更多的想象空间，而且，未来大都市会越来越智能化发展，提供给居民更多难以想象的便利，生活在大城市，是大多数人的未来。\n\n8. 职业规划问题\n\n1.职业定位： 互联网产品经理\n\n\n2.目标设置，短期目标：入职，转正。长期目标1-3年拿到多少，3-5年拿到多少？\n3.主要聚焦于自身能力的提升，1-3年做什么？基础理论的学习，架构能力的学习。3-5做什么？带领项目，和公司的安排。\n\n未来3年内做到什么目标；\n\n今年的目标是什么；\n\n\n进公司的话，试用期目标是什么？\n\n9.你和女朋友工作地点不一样怎么办？\n\n10.是不是党员？\n\n11.你有什么问题？\n\n\t请问这个岗位在公司内部的未来发展方向是怎样的？\n\t\n\t请问贵司对于我这样的应届毕业生的未来发展有怎样的预期？","slug":"2019-second-interview","published":1,"updated":"2019-09-29T10:45:03.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbq00222wvc4hf4twat","content":"<p>京东群面+HR面面试记录。</p>\n<h2 id=\"京东面试复盘\"><a href=\"#京东面试复盘\" class=\"headerlink\" title=\"京东面试复盘\"></a>京东面试复盘</h2><h2 id=\"群面题：\"><a href=\"#群面题：\" class=\"headerlink\" title=\"群面题：\"></a>群面题：</h2><p>在智慧交通，智慧城市，云办公三个领域中选一个领域做一款产品，要求可以运营或者可以落地。</p>\n<p>14进3，还是蛮不错的结果，小伙伴们很给力。</p>\n<p>我们讨论的结果是：基于5G智慧调度的无人车车队</p>\n<p>最后从用户场景，可行性（政府政策，蓝海红海，技术可行性以及公司定位和目标），价值来进行阐述的。</p>\n<p>群面过程中有的小伙伴几乎没说话，有的说的很不是很让人理解。还是要多有一些有用的输出，其中11号小姐姐虽然说的不多，但是能够说的很有用。所以在这个过程中一要多说话，二要多输出有效的观点。</p>\n<h2 id=\"HR面\"><a href=\"#HR面\" class=\"headerlink\" title=\"HR面\"></a>HR面</h2><h3 id=\"拼积木，讲解你拼的积木\"><a href=\"#拼积木，讲解你拼的积木\" class=\"headerlink\" title=\"拼积木，讲解你拼的积木\"></a>拼积木，讲解你拼的积木</h3><p>主要从一下方面讲解:</p>\n<ol>\n<li><p>拼积木的思路，先找好目标，再对现有积木进行分类。自己没有拼成功，达到自己的目标，联系到管理，每个人都要在自己合适的岗位，才能发挥最大的效用。没用到的积木，不一定是没用的，而是我们还么有找到他的位置。</p>\n</li>\n<li><p>京东现在从一体化组织成为积木型组织，也是希望在快速变化的市场内，可以快速创新，快速是错。</p>\n</li>\n<li><p>反思自己的思路，一方面，我是现有目标再去看资源，也可以看现有资源去订目标。联系到产品，产品经理不能凭自己的理解和需求去做产品，要看市场，用户的需求是什么样的。</p>\n</li>\n</ol>\n<h3 id=\"询问简历相关内容\"><a href=\"#询问简历相关内容\" class=\"headerlink\" title=\"询问简历相关内容\"></a>询问简历相关内容</h3><ol>\n<li>介绍下研究生期间研究的项目</li>\n</ol>\n<p>目前，我主要做的是结构求解软件积分器部分的实现，做这款产品的目的有两个，第一中国虽然在计算方面做得比较好，但是都是国外的软件，建立中国芯十分有必要，第二是希望为国内开启新的方向，这和京东成为对社会最有价值的公司是一样的初衷。</p>\n<p>我主要负责的是积分求解器的实现，现在实现的有两个成果，一是开发了自己的算法，也发表了。第二，开发了一款非商业性开源软件。</p>\n<p>现在还在做这方面的工作。这是我研究生期间主要做的工作，</p>\n<ol start=\"2\">\n<li>团队多少人，怎么协作，时间节点怎么安排？任务的安排。</li>\n</ol>\n<p>我们团队大概10来人，因为我们用的是C+V开发，所以采用GIT的方式，大家做各自相关的项目，然后提交修改bug。</p>\n<p>时间节点的安排主要我有两方面的考虑:一是学生自身的能力和任务难度的匹配数，第二是项目本身的时间限制。此外，导师就像一个产品经理，他也有自己的想法和考量，所以时间一般是大家讨论出来的。</p>\n<p>任务的安排主要由老师的安排，老师也会考虑我们的实际情况进行调整。</p>\n<p>在这个工作过程中，我们也会和市场上的相关人员接触确定我们工作的进度和节点。</p>\n<ol start=\"3\">\n<li>介绍下广联达的实习经历？</li>\n</ol>\n<p>1在广联达的实习我主要参与了两个项目，第一个项目是我进入后由我和七个开发实习生一起做的，我是该款产品的PM master，对该产品的成果负责。公司做这款产品的目的主要有三个，1是基于现有平台为以后公司发展方向进行试错<br>和探索，2是研究现在产品实现该功能的方法，进行分析客户的痛点，难点和关键点。3是研究市场的大小，进行商业上的预判。我们经过两个月的努力，完成了以上要求，最后得到了部门领导的认同。</p>\n<p>在第二个公司正式项目里，我主要负责的地方有三个方面，第一，负责起重机数据分析和拟合。在产品实现过程中需要实时显示负载率，我由于工科背景很适合这个工作。第二是，机械参数的配置，第三是客户拜访和需求调研，主要拜访了上安集团，北安集团。对产品进行验证和市场探索。</p>\n<ol start=\"4\">\n<li>有没有碰到特别难以处理的事情？</li>\n</ol>\n<p>关于特别难处理的问题，我主要有两个事情比较有感触。第一件事是刚实习的时候，光有理论知识，到实操的时候有点束手无措。这个时候主要的解决思路是多个师傅沟通，多尝试，多问，然后根据师傅的建议去做，也很快适应过来了。</p>\n<p>第二件事是我加入公司正式项目小组的第一周，我一般以上的时间都在开会，如果处理开会和工作的时间问题是我最棘手的问题，我主要从三个方面来解决，一是加班做完自己的工作，二是提高效率，三是尽量自己少发出意义不大，人数众多的会议。</p>\n<ol start=\"5\">\n<li>看你现在做的开发，现在为什么来做产品经理？</li>\n</ol>\n<p>为什么来做产品经理主要有以下原因：</p>\n<p>1.自己在研究生期间开发产品的过程中了解到产品经理这个岗位，在开发的过程中相应的也承担起了产品经理这个职责；</p>\n<p>2.通过自己的了解，包括报班系统的学习，进入互联网社区去做志愿者发现自己很喜欢这个行业；</p>\n<p>3.自己也适合这个行业，一方面我喜欢在生活中观察，比如美团点外卖的时候的处理，以及滴滴出行自己的想法；</p>\n<p>4.自己无论做摄影还是剪视频，都是一个创造，一个做产品的过程，我很享受这个过程。</p>\n<ol start=\"6\">\n<li>你在三节课培训学到的内容？</li>\n</ol>\n<p>三节课的这段经历主要让我作为一个产品经理的基本知识和素养进行了系统的整合，让我更加系统和全面的了解到了产品经理的职责和解决的问题的流程。具体的内容可以从一下几个方面去说：1是需求调研，2.需求产出，3.需求落地，4.需求验证等方面。然后再具体的说各方面的内容的小点。</p>\n<ol start=\"7\">\n<li>对工作城市的选择，为什么选择大城市？</li>\n</ol>\n<p>1.自身发展，个人性格，家庭原因。就业机会多。，资待遇高。个人进步快。拥有很高的创业成功率，创业空间广阔。</p>\n<p>2.城市发展</p>\n<p>3.公司发展</p>\n<p>大城市有更多的想象空间，而且，未来大都市会越来越智能化发展，提供给居民更多难以想象的便利，生活在大城市，是大多数人的未来。</p>\n<ol start=\"8\">\n<li>职业规划问题</li>\n</ol>\n<p>1.职业定位： 互联网产品经理</p>\n<p>2.目标设置，短期目标：入职，转正。长期目标1-3年拿到多少，3-5年拿到多少？<br>3.主要聚焦于自身能力的提升，1-3年做什么？基础理论的学习，架构能力的学习。3-5做什么？带领项目，和公司的安排。</p>\n<p>未来3年内做到什么目标；</p>\n<p>今年的目标是什么；</p>\n<p>进公司的话，试用期目标是什么？</p>\n<p>9.你和女朋友工作地点不一样怎么办？</p>\n<p>10.是不是党员？</p>\n<p>11.你有什么问题？</p>\n<pre><code>请问这个岗位在公司内部的未来发展方向是怎样的？\n\n请问贵司对于我这样的应届毕业生的未来发展有怎样的预期？</code></pre>","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<p>京东群面+HR面面试记录。</p>\n<h2 id=\"京东面试复盘\"><a href=\"#京东面试复盘\" class=\"headerlink\" title=\"京东面试复盘\"></a>京东面试复盘</h2><h2 id=\"群面题：\"><a href=\"#群面题：\" class=\"headerlink\" title=\"群面题：\"></a>群面题：</h2><p>在智慧交通，智慧城市，云办公三个领域中选一个领域做一款产品，要求可以运营或者可以落地。</p>\n<p>14进3，还是蛮不错的结果，小伙伴们很给力。</p>\n<p>我们讨论的结果是：基于5G智慧调度的无人车车队</p>\n<p>最后从用户场景，可行性（政府政策，蓝海红海，技术可行性以及公司定位和目标），价值来进行阐述的。</p>\n<p>群面过程中有的小伙伴几乎没说话，有的说的很不是很让人理解。还是要多有一些有用的输出，其中11号小姐姐虽然说的不多，但是能够说的很有用。所以在这个过程中一要多说话，二要多输出有效的观点。</p>\n<h2 id=\"HR面\"><a href=\"#HR面\" class=\"headerlink\" title=\"HR面\"></a>HR面</h2><h3 id=\"拼积木，讲解你拼的积木\"><a href=\"#拼积木，讲解你拼的积木\" class=\"headerlink\" title=\"拼积木，讲解你拼的积木\"></a>拼积木，讲解你拼的积木</h3><p>主要从一下方面讲解:</p>\n<ol>\n<li><p>拼积木的思路，先找好目标，再对现有积木进行分类。自己没有拼成功，达到自己的目标，联系到管理，每个人都要在自己合适的岗位，才能发挥最大的效用。没用到的积木，不一定是没用的，而是我们还么有找到他的位置。</p>\n</li>\n<li><p>京东现在从一体化组织成为积木型组织，也是希望在快速变化的市场内，可以快速创新，快速是错。</p>\n</li>\n<li><p>反思自己的思路，一方面，我是现有目标再去看资源，也可以看现有资源去订目标。联系到产品，产品经理不能凭自己的理解和需求去做产品，要看市场，用户的需求是什么样的。</p>\n</li>\n</ol>\n<h3 id=\"询问简历相关内容\"><a href=\"#询问简历相关内容\" class=\"headerlink\" title=\"询问简历相关内容\"></a>询问简历相关内容</h3><ol>\n<li>介绍下研究生期间研究的项目</li>\n</ol>\n<p>目前，我主要做的是结构求解软件积分器部分的实现，做这款产品的目的有两个，第一中国虽然在计算方面做得比较好，但是都是国外的软件，建立中国芯十分有必要，第二是希望为国内开启新的方向，这和京东成为对社会最有价值的公司是一样的初衷。</p>\n<p>我主要负责的是积分求解器的实现，现在实现的有两个成果，一是开发了自己的算法，也发表了。第二，开发了一款非商业性开源软件。</p>\n<p>现在还在做这方面的工作。这是我研究生期间主要做的工作，</p>\n<ol start=\"2\">\n<li>团队多少人，怎么协作，时间节点怎么安排？任务的安排。</li>\n</ol>\n<p>我们团队大概10来人，因为我们用的是C+V开发，所以采用GIT的方式，大家做各自相关的项目，然后提交修改bug。</p>\n<p>时间节点的安排主要我有两方面的考虑:一是学生自身的能力和任务难度的匹配数，第二是项目本身的时间限制。此外，导师就像一个产品经理，他也有自己的想法和考量，所以时间一般是大家讨论出来的。</p>\n<p>任务的安排主要由老师的安排，老师也会考虑我们的实际情况进行调整。</p>\n<p>在这个工作过程中，我们也会和市场上的相关人员接触确定我们工作的进度和节点。</p>\n<ol start=\"3\">\n<li>介绍下广联达的实习经历？</li>\n</ol>\n<p>1在广联达的实习我主要参与了两个项目，第一个项目是我进入后由我和七个开发实习生一起做的，我是该款产品的PM master，对该产品的成果负责。公司做这款产品的目的主要有三个，1是基于现有平台为以后公司发展方向进行试错<br>和探索，2是研究现在产品实现该功能的方法，进行分析客户的痛点，难点和关键点。3是研究市场的大小，进行商业上的预判。我们经过两个月的努力，完成了以上要求，最后得到了部门领导的认同。</p>\n<p>在第二个公司正式项目里，我主要负责的地方有三个方面，第一，负责起重机数据分析和拟合。在产品实现过程中需要实时显示负载率，我由于工科背景很适合这个工作。第二是，机械参数的配置，第三是客户拜访和需求调研，主要拜访了上安集团，北安集团。对产品进行验证和市场探索。</p>\n<ol start=\"4\">\n<li>有没有碰到特别难以处理的事情？</li>\n</ol>\n<p>关于特别难处理的问题，我主要有两个事情比较有感触。第一件事是刚实习的时候，光有理论知识，到实操的时候有点束手无措。这个时候主要的解决思路是多个师傅沟通，多尝试，多问，然后根据师傅的建议去做，也很快适应过来了。</p>\n<p>第二件事是我加入公司正式项目小组的第一周，我一般以上的时间都在开会，如果处理开会和工作的时间问题是我最棘手的问题，我主要从三个方面来解决，一是加班做完自己的工作，二是提高效率，三是尽量自己少发出意义不大，人数众多的会议。</p>\n<ol start=\"5\">\n<li>看你现在做的开发，现在为什么来做产品经理？</li>\n</ol>\n<p>为什么来做产品经理主要有以下原因：</p>\n<p>1.自己在研究生期间开发产品的过程中了解到产品经理这个岗位，在开发的过程中相应的也承担起了产品经理这个职责；</p>\n<p>2.通过自己的了解，包括报班系统的学习，进入互联网社区去做志愿者发现自己很喜欢这个行业；</p>\n<p>3.自己也适合这个行业，一方面我喜欢在生活中观察，比如美团点外卖的时候的处理，以及滴滴出行自己的想法；</p>\n<p>4.自己无论做摄影还是剪视频，都是一个创造，一个做产品的过程，我很享受这个过程。</p>\n<ol start=\"6\">\n<li>你在三节课培训学到的内容？</li>\n</ol>\n<p>三节课的这段经历主要让我作为一个产品经理的基本知识和素养进行了系统的整合，让我更加系统和全面的了解到了产品经理的职责和解决的问题的流程。具体的内容可以从一下几个方面去说：1是需求调研，2.需求产出，3.需求落地，4.需求验证等方面。然后再具体的说各方面的内容的小点。</p>\n<ol start=\"7\">\n<li>对工作城市的选择，为什么选择大城市？</li>\n</ol>\n<p>1.自身发展，个人性格，家庭原因。就业机会多。，资待遇高。个人进步快。拥有很高的创业成功率，创业空间广阔。</p>\n<p>2.城市发展</p>\n<p>3.公司发展</p>\n<p>大城市有更多的想象空间，而且，未来大都市会越来越智能化发展，提供给居民更多难以想象的便利，生活在大城市，是大多数人的未来。</p>\n<ol start=\"8\">\n<li>职业规划问题</li>\n</ol>\n<p>1.职业定位： 互联网产品经理</p>\n<p>2.目标设置，短期目标：入职，转正。长期目标1-3年拿到多少，3-5年拿到多少？<br>3.主要聚焦于自身能力的提升，1-3年做什么？基础理论的学习，架构能力的学习。3-5做什么？带领项目，和公司的安排。</p>\n<p>未来3年内做到什么目标；</p>\n<p>今年的目标是什么；</p>\n<p>进公司的话，试用期目标是什么？</p>\n<p>9.你和女朋友工作地点不一样怎么办？</p>\n<p>10.是不是党员？</p>\n<p>11.你有什么问题？</p>\n<pre><code>请问这个岗位在公司内部的未来发展方向是怎样的？\n\n请问贵司对于我这样的应届毕业生的未来发展有怎样的预期？</code></pre>"},{"title":"百度产品经理面试","top":false,"cover":false,"toc":true,"mathjax":true,"date":"2019-09-29T10:43:34.000Z","password":null,"summary":"百度产品经理面试群面","_content":"\n\n百度产品经理面试群面\n\n\n\n\n# 群面\n\n## 题目\n\n针对现有产品小红书，即刻，飞聊等社区，社交产品的兴起，结合百度搜索的功能，设计一款产品以应对这类社交社区产品的发展趋势。\n\n## 面试情况\n\n人数：18进4，据说有人霸面。\n\n谈论情况：十分糟糕，其中三个“大佬”一直在带节奏，最后做出了一款“增强版的百度”。\n\n## 个人理解\n\n1. 希望通过用户-场景-痛点-需求-功能才确定框架，但是被一位大佬带到了另外的方向；\n2. 希望利用百度搜索把用户引导进我们的APP\n3. 前期冷启动，内测\n4. 对内容创作者进行奖励，商业生态，版权保护机制，Vlog，直播形式，掘进下沉市场，利用百度AI附力。\n\n## 后续\n\n最后被莫名其妙的告知，上海HC已满，是否愿意面北京的岗位。哪位大佬能够讲解一下吗？\n\n# 二面\n\n## 面试形式\n电话面试\n楼主投递的是上海产品经理岗位，但是上海产品HC已满，调剂到北京岗位。\n预约的是10:00--12:00，等到了接近13：00才开始，体验极差。\n\n## 面试问题\n\n1. 自我介绍，说一下简历里没有的内容。\n\n2. 介绍下你在项目里学到了什么？\n\n3. 介绍下你的算法（论文）？\n\n4. 最成功的项目？\n\n5. 最失败的项目？\n\n6. 对百度有什么了解？\n\n7. 为什么做产品经理？\n\n8. 怎么学习产品经理的相关知识？\n\n9. 昨天的群面你回去后有什么反思，说说你的想法？\n\n9. 有什么想问的？\n\n## 感受\n主要就是深挖简历，结合你的简历去问你，好好准备简历相关的内容。\n\n不要当做一场面试，和面试官好好聊天即可\n\n\n","source":"_posts/2019-third-interview.md","raw":"---\ntitle: 百度产品经理面试\ntop: false\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-29 18:43:34\npassword:\nsummary: 百度产品经理面试群面\ntags:\n- 面试\ncategories: \n- 面试\n---\n\n\n百度产品经理面试群面\n\n\n\n\n# 群面\n\n## 题目\n\n针对现有产品小红书，即刻，飞聊等社区，社交产品的兴起，结合百度搜索的功能，设计一款产品以应对这类社交社区产品的发展趋势。\n\n## 面试情况\n\n人数：18进4，据说有人霸面。\n\n谈论情况：十分糟糕，其中三个“大佬”一直在带节奏，最后做出了一款“增强版的百度”。\n\n## 个人理解\n\n1. 希望通过用户-场景-痛点-需求-功能才确定框架，但是被一位大佬带到了另外的方向；\n2. 希望利用百度搜索把用户引导进我们的APP\n3. 前期冷启动，内测\n4. 对内容创作者进行奖励，商业生态，版权保护机制，Vlog，直播形式，掘进下沉市场，利用百度AI附力。\n\n## 后续\n\n最后被莫名其妙的告知，上海HC已满，是否愿意面北京的岗位。哪位大佬能够讲解一下吗？\n\n# 二面\n\n## 面试形式\n电话面试\n楼主投递的是上海产品经理岗位，但是上海产品HC已满，调剂到北京岗位。\n预约的是10:00--12:00，等到了接近13：00才开始，体验极差。\n\n## 面试问题\n\n1. 自我介绍，说一下简历里没有的内容。\n\n2. 介绍下你在项目里学到了什么？\n\n3. 介绍下你的算法（论文）？\n\n4. 最成功的项目？\n\n5. 最失败的项目？\n\n6. 对百度有什么了解？\n\n7. 为什么做产品经理？\n\n8. 怎么学习产品经理的相关知识？\n\n9. 昨天的群面你回去后有什么反思，说说你的想法？\n\n9. 有什么想问的？\n\n## 感受\n主要就是深挖简历，结合你的简历去问你，好好准备简历相关的内容。\n\n不要当做一场面试，和面试官好好聊天即可\n\n\n","slug":"2019-third-interview","published":1,"updated":"2019-09-29T10:44:49.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxbs00262wvcp9ufkraf","content":"<p>百度产品经理面试群面</p>\n<h1 id=\"群面\"><a href=\"#群面\" class=\"headerlink\" title=\"群面\"></a>群面</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>针对现有产品小红书，即刻，飞聊等社区，社交产品的兴起，结合百度搜索的功能，设计一款产品以应对这类社交社区产品的发展趋势。</p>\n<h2 id=\"面试情况\"><a href=\"#面试情况\" class=\"headerlink\" title=\"面试情况\"></a>面试情况</h2><p>人数：18进4，据说有人霸面。</p>\n<p>谈论情况：十分糟糕，其中三个“大佬”一直在带节奏，最后做出了一款“增强版的百度”。</p>\n<h2 id=\"个人理解\"><a href=\"#个人理解\" class=\"headerlink\" title=\"个人理解\"></a>个人理解</h2><ol>\n<li>希望通过用户-场景-痛点-需求-功能才确定框架，但是被一位大佬带到了另外的方向；</li>\n<li>希望利用百度搜索把用户引导进我们的APP</li>\n<li>前期冷启动，内测</li>\n<li>对内容创作者进行奖励，商业生态，版权保护机制，Vlog，直播形式，掘进下沉市场，利用百度AI附力。</li>\n</ol>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>最后被莫名其妙的告知，上海HC已满，是否愿意面北京的岗位。哪位大佬能够讲解一下吗？</p>\n<h1 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h1><h2 id=\"面试形式\"><a href=\"#面试形式\" class=\"headerlink\" title=\"面试形式\"></a>面试形式</h2><p>电话面试<br>楼主投递的是上海产品经理岗位，但是上海产品HC已满，调剂到北京岗位。<br>预约的是10:00–12:00，等到了接近13：00才开始，体验极差。</p>\n<h2 id=\"面试问题\"><a href=\"#面试问题\" class=\"headerlink\" title=\"面试问题\"></a>面试问题</h2><ol>\n<li><p>自我介绍，说一下简历里没有的内容。</p>\n</li>\n<li><p>介绍下你在项目里学到了什么？</p>\n</li>\n<li><p>介绍下你的算法（论文）？</p>\n</li>\n<li><p>最成功的项目？</p>\n</li>\n<li><p>最失败的项目？</p>\n</li>\n<li><p>对百度有什么了解？</p>\n</li>\n<li><p>为什么做产品经理？</p>\n</li>\n<li><p>怎么学习产品经理的相关知识？</p>\n</li>\n<li><p>昨天的群面你回去后有什么反思，说说你的想法？</p>\n</li>\n<li><p>有什么想问的？</p>\n</li>\n</ol>\n<h2 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"></a>感受</h2><p>主要就是深挖简历，结合你的简历去问你，好好准备简历相关的内容。</p>\n<p>不要当做一场面试，和面试官好好聊天即可</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<p>百度产品经理面试群面</p>\n<h1 id=\"群面\"><a href=\"#群面\" class=\"headerlink\" title=\"群面\"></a>群面</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>针对现有产品小红书，即刻，飞聊等社区，社交产品的兴起，结合百度搜索的功能，设计一款产品以应对这类社交社区产品的发展趋势。</p>\n<h2 id=\"面试情况\"><a href=\"#面试情况\" class=\"headerlink\" title=\"面试情况\"></a>面试情况</h2><p>人数：18进4，据说有人霸面。</p>\n<p>谈论情况：十分糟糕，其中三个“大佬”一直在带节奏，最后做出了一款“增强版的百度”。</p>\n<h2 id=\"个人理解\"><a href=\"#个人理解\" class=\"headerlink\" title=\"个人理解\"></a>个人理解</h2><ol>\n<li>希望通过用户-场景-痛点-需求-功能才确定框架，但是被一位大佬带到了另外的方向；</li>\n<li>希望利用百度搜索把用户引导进我们的APP</li>\n<li>前期冷启动，内测</li>\n<li>对内容创作者进行奖励，商业生态，版权保护机制，Vlog，直播形式，掘进下沉市场，利用百度AI附力。</li>\n</ol>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p>最后被莫名其妙的告知，上海HC已满，是否愿意面北京的岗位。哪位大佬能够讲解一下吗？</p>\n<h1 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h1><h2 id=\"面试形式\"><a href=\"#面试形式\" class=\"headerlink\" title=\"面试形式\"></a>面试形式</h2><p>电话面试<br>楼主投递的是上海产品经理岗位，但是上海产品HC已满，调剂到北京岗位。<br>预约的是10:00–12:00，等到了接近13：00才开始，体验极差。</p>\n<h2 id=\"面试问题\"><a href=\"#面试问题\" class=\"headerlink\" title=\"面试问题\"></a>面试问题</h2><ol>\n<li><p>自我介绍，说一下简历里没有的内容。</p>\n</li>\n<li><p>介绍下你在项目里学到了什么？</p>\n</li>\n<li><p>介绍下你的算法（论文）？</p>\n</li>\n<li><p>最成功的项目？</p>\n</li>\n<li><p>最失败的项目？</p>\n</li>\n<li><p>对百度有什么了解？</p>\n</li>\n<li><p>为什么做产品经理？</p>\n</li>\n<li><p>怎么学习产品经理的相关知识？</p>\n</li>\n<li><p>昨天的群面你回去后有什么反思，说说你的想法？</p>\n</li>\n<li><p>有什么想问的？</p>\n</li>\n</ol>\n<h2 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"></a>感受</h2><p>主要就是深挖简历，结合你的简历去问你，好好准备简历相关的内容。</p>\n<p>不要当做一场面试，和面试官好好聊天即可</p>\n"},{"title":"C语言学习笔记","top":"ture","cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T11:28:05.000Z","password":null,"summary":"C语言是20世纪70年代初期，在贝尔实验室开发出来的一种用途广泛的编程语言。","_content":"\n# 第一章 C语言概述\n\nC语言是20世纪70年代初期，在贝尔实验室开发出来的一种用途广泛的编程语言。\n\n---\n\n## C语言的历史\n\nC语言是Unix系统开发过程中的一个副产品。它被用来重写Unix系统。\n\n到20世纪80年代，许多计算机开始使用C语言开发程序，为了保证其程序的可移植性，建立标准成为了共识。\n\n1989年，通过C89标准。\n\n1999年，通过C99标准，但这个标准还没有被普遍使用。\n\n### C++ 语言\n\n虽然采纳了 ANSI/ISO 标准以后C语言自身不再发生变化。但是，从某种意义上说，随着基于C语言的新式语言的产生，C语言的演变还在继续。新式语言包括C++。它在许多方面对C语言进行了扩展，尤其是增加了面向对象编程的特性。\n\n随着C++语言的迅速普及，在不久的将来你很可能会用C++语言编写程序。果真如此，为何还要费心学习C语言呢？首先，C++语言比C语言更加难学，因此在掌握C++语言前，最好先精通C语言；其次，我们身边存在着大量的C语言代码，需要去维护和阅读；最后，不是每个人都喜欢改用C++编程，例如对于编写小规模的程序，使用C++反而不会获得多少好处。\n\n## C语言的优缺点\n\nC语言的优缺点都源于它最初的用途，以及其基础理论体系。\n\n- C语言是一种底层语言。它提供了对内存访问的功能。C程序的许多服务都依赖于操作系统提供的接口。\n\n- C语言是一种小型语言。C语言的特性不多，应用程序的绝大部分功能依赖于标准库。\n\n- C语言是一种包容性语言。C语言假设用户知道自己在做什么，因此有编写自由度。C语言不强制进行错误检查。\n\n### C语言的优点\n\n1. 高效。发明C语言的目的是为了替代汇编语言。\n\n2. 可移植。有标准库的存在。\n\n3. 功能强大、灵活。C语言的数据类型和运算符集合有足够强大的表达能力。\n\n4. 与Unix集成。\n\n### C语言的缺点\n\n1. C程序更容易隐藏错误。由于其灵活性，导致编写的代码令编译器很难检查错误。\n\n2. C程序可能会难以理解。\n\n3. C程序可能会难以修改。因为它设计时没考虑到维护的问题。C语言没有提供类，包等模块化概念。\n\n### 高效地使用C语言\n\n1. 学习规避C语言的缺陷。比如越界问题。\n2. 使用软件工具。\n3. 利用现有的代码库。\n4. 采用切合实际的编码规范。\n5. 避免“投机取巧”和极度复杂的代码。\n6. 使用标准C，少用经典C。标准C即是 ANSI C ，本书采用的是标准C。\n7. 避免不可以移植性。# 第二章 C语言基本概念\n\n---\n\n## 编写一个简单的C程序\n\n### 程序：显示双关语\n\n这是经典C的一个示例：\n\n```c\n// pun.c\n#include <stdio.h>\n\nmain()\n{\n    printf(\"To C, or not to C: that is the question.\\n\");\n}\n```\n\n### 编译和链接\n\n首先，需要一个.c文件保存程序代码，接下来需要把程序转换为机器可以执行的形式。通常包含下列三个步骤：\n\n- 预处理。首先会把程序送交给预处理器（ preprocessor ）。预处理器执行以#开头的命令。\n\n- 编译。修改后的程序现在可以进入编译器（ compiler ）了。编译器会把程序翻译成机器指令（即目标代码， object code ）。\n\n- 链接。链接器（ linker ）把由编译器产生的目标代码和任何其他附加代码整合在一起，产生完全可执行的程序。\n\n这个过程可以一步完成，即：\n\n```bash\ncc pun.c\n```\n\n在编译和链接好程序后，编译器 cc 会把可执行程序放到默认名为 a.out 的文件中。编译器 cc 有许多选项，其中 -o 允许给可执行程序选择一个名字：\n\n```bash\ncc -o pun pun.c\n```\n\n如果使用 gcc 进行编译，那么建议在编译时采用 -Wall 选项：\n\n```bash\ngcc -Wall -o pun pun.c\n```\n\n也可以手动分布完成：\n\n```bash\ncc -o main.i -E main.c # 预编译\ncc -o main.o -c main.i # 编译\ncc -o main main.o      # 链接\n```\n\n## 简单程序的一般形式\n\n形式如：\n\n```c\n指令\n\nint main()\n{\n    语句\n}\n```\n\n### 指令\n\n在编译C程序之前，预处理器会首先对C程序进行编辑。我们把预处理器执行的命令称为指令。这里只关注 #include 指令。\n\n```c\n#include <stdio.h>\n```\n\n这条指令说明，在编译前把 stdio.h 中的信息“包含”到程序中。这段程序中包含 stdio,h 的原因是：C语言没有内置的“读”和“写”命令。因此，进行输入/输出操作就需要用标准库中的函数来实现。\n\n这里是指预所有指令都是以#开头。一条指令必须占据一行，且不留分号结尾。\n\n### 函数\n\n函数是用来构建程序的一个构建块。C程序就是函数的集合。函数分为两大类：一类是程序员编写的函数，另一类则是由C语言的实现所提供的函数。后者可以称为库函数（ library function ）。\n\n在C语言中，函数仅仅是一系列组合在一起并且赋予了名字的语句。某些函数计算一个值，而某些函数不是。计算出一个值的函数可以用 return 语句来指定所“返回”的值。\n\n每个程序必须有一个 main 函数。 main 函数是非常特殊的：在执行程序时系统会自动调用 main 函数。\n\nmain 函数在程序终止时向操作系统返回一个状态码。 pun 程序始终让 main 函数返回0，0表明程序正常终止。\n\n建议加入 return 语句，如果不这样做，某些编译器可能会产生一条警告信息：\n\n```c\n// pun.c\n#include <stdio.h>\n\nmain()\n{\n    printf(\"To C, or not to C: that is the question.\\n\");\n    return 0;\n}\n```\n\n### 语句\n\n语句是程序运行时执行的命令。每条语句都要以分号结尾。\n\n一条语句可以占据多行。\n\n程序 pun.c 只用到了两种语句。一种是返回语句，一种则是函数调用（ function call ）语句。为了在屏幕上显示一条字符串就调用了 printf 函数。\n\n### 显示字符串\n\n我们用 printf 函数显示了一条字符串字面量（ string literal ）。字符串字面量是用一对双引号包围的一系列字符。\n\n当打印结束时， printf 函数不会自动跳转到下一输出行。为了让 printf 跳转到下一行，必须要在打印的字符串中包含一个 \\n （换行符）。写换行符就意味着终止当前行，然后把后续的输出转到下一行进行。\n\n换行符可以在一个字符串字面量中出现多次。比如：\n\n```c\nprintf(\"Brevity is the soul of wit.\\n -- Shakespeare\\n\");\n```\n\n### 注释\n\n注释就是代码的说明。在预编译后，注释会移除出代码。\n\n例如：\n\n```c\n/* This is a comment */\n```\n\n为 pun.c 增加注释：\n\n```c\n/*\tName: pun.c\n\tPurpose: Prints a bad pun.\n\tAuthor: K.N.King\n\tData written: 5/21/95\n*/\n```\n\n## 变量和赋值\n\n变量（ variable ）就是用来存储数据的存储单元。\n\n### 类型\n\n一个变量必须有一个类型。类型决定了存储单元的大小和对变量的操作方式。\n\nint 型变量可以存储整数，例如0、1、392或者-2553，但是，整数的取值范围是受限制的。某些计算机上，int型数值的最大取值仅仅是32767。\n\nfloat 型变量可以存储更大的数值，而且，float型变量可以存储带小数位的数据，例如379.125。但是，float 型变量有一些缺陷，即这类变量需要的存储空间要大于 int 型变量。而且，进行算术运算时 float 型变量通常比 int 型变量慢。另外， float 型变量所存储的数值往往只是实际数值的一个近似值。\n\n### 声明\n\n在使用变量前，必须对其进行声明，这也是为了便于编译器工作。例如，声明变量 height 的方式如：\n\n```c\nint height;\n```\n\n如果几个变量具有相同的类型，就可以把它们的声明合并：\n\n```c\nint height, length, width;\n```\n\n当 main 函数包含声明时，必须把声明放置在语句之前：\n\n```c\nmain()\n{\n    声明\n    语句\n}\n```\n\n### 赋值\n\n变量可以通过赋值（ assignment ）的方式获得一个值。例如：\n\n```c\nheight = 8;\nvolume = height * length * width;\n```\n\n赋值运算符的右侧可以是一个含有常量、变量和运算符的公式（表达式， expression ）。\n\n### 显示变量的值\n\n用 printf 可以显示当前变量的值。\n\n```c\nprintf(\"Height: %d\\n\", height);\n```\n\n占位符 %d 用来指明在打印过程中变量 height 的值的显示位置。 %d 仅用于 int 型变量，如果要打印 float 型变量，需要用 %f 来代替。默认情况下， %f 会显示小数点后6位数字，若需要显示小数点后n位数字，则可以把 .n 放置在%和f之间。\n\n```c\nprintf(\"Profit: $%.2f\\n\", profit);\n```\n\n### 初始化\n\n当程序开始执行时，某些变量会被自动设置为0，而大多数变量则不会。没有默认值并且尚未在程序中被赋值的变量是未初始化的（ uninitialized ）。\n\n使用初始化式对其变量进行初始化，如：\n\n```c\nint a = 0;\n```\n\n## 读入输入\n\n为了获取输入，就要用到 scanf 函数。 scanf 中的字母f和 printf 中的f含义相同，都是表示“格式化”的意思。 scanf 和 printf 函数都需要使用格式串（ format string ）来说明输入或输出的样式。\n\n为了读取一个 int 型数值，可以使用如下的 scanf 函数调用。\n\n```c\nscanf(\"%d\", &i);\n```\n\n字符串“%d”说明 scanf 读入的是一个整数，i是一个 int 型变量，用来存储读入的输入。\n\n读入一个 float 型数值时，需要这样的 scanf 调用：\n\n```c\nscanf(\"%f\", &x);\n```\n\n%f只适用于 float 型变量。\n\n## 定义常量\n\n常量（ constant ）是在程序执行过程中固定不变的量。当程序含有常量时，建议给这些常量命名。方式是使用宏定义（ macro defination ）。\n\n```c\n#define N 4\n```\n\n这里的 #define 是预处理指令。当程序进行编译时，预处理器会把每一个宏用其表示的值替换回来。\n\n此外，还可以利用宏来定义表达式：\n\n```c\n#define SCALE_FACTOR (5.0 / 9.0)\n```\n\n当宏包含运算时，必须用括号把表达式括起来。\n\n宏的名字一般用大写字母，这是大多数程序员遵守的规范。\n\n## 标识符\n\n标识符就是函数、变量、宏等实体的名字。\n\n标识符由字母、数字和下划线组成，且区分大小写。必须以字母或下划线开头。\n\n为了使名字清晰，可以使用两种命名风格：\n\n```c\nsymbol_table\nSymbolTable\n```\n\n**关键字**\n\n关键字（ keyword ）对编译器而言都有特殊的含义，因此标识符不能和关键字一样。\n\n所有的关键字见书本p19\n\n## C语言程序的布局\n\nC程序可以被看成一连串的**记号（ token ）**。记号就是无法分割的字符组。\n\n标识符、关键字、运算符、字符串等都是记号。\n\n记号之间可以有空格，换行等字符。\n\n有记号的概念后，C程序就可以这样书写：\n\n- 语句可以放到多行内。对于很长的语句这样很合适。\n\n- 记号间的空格可以更容易区分记号。比如运算符两边加空格方便阅读。\n\n- 缩进有助于识别程序嵌套。\n\n- 空行可以把程序划分为逻辑单元。# 第三章 格式化输入输出\n\nscanf 函数和 printf 函数是C语言使用最频繁的两个函数，它们用来支持格式化的读和写。\n\n---\n\n## printf 函数\n\nprintf 函数被设计用来显示格式串（ format string ）的内容，并且在字符串指定位置插入可能的值。\n\n```c\nprintf(格式串, 表达式1, 表达式2, ...);\n```\n\n格式串包含普通字符和转换说明（ conversion specification ），其中转换说明以字符%开头。\n\n!!!warning\n\tC语言编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配。\n\n### 转换说明\n\n在通用的情况下，转换说明可以有%m.pX格式或%-m.pX格式，这里的m和p都是整型常量，X是字母。m和p都是可选项。\n\n在转换说明%10.2f中，m是10，p是2，X是f。\n\n**最小字段宽度（ minimum field width ）** m指定了要显示的最小字符数量。如果要打印的数值比m个字符少，那么值在字段内是右对齐的。如果要多，那么字段宽度会自动扩展为需要的尺寸。\n\n**精度（ precision ）** p的含义依赖于**转换说明符X（ conversion specifier ）**的选择。对数来说，最常用的转换说明符有：\n\n- d，表示十进制形式的整数。p说明可以显示的数字的最少个数（如果需要，就在数前加上额外的零）；如果忽略掉p，默认它的值为1。\n\n- e，表示指数形式的浮点数。p说明小数点后应该出现的数字的个数（默认为6）。如果p为0，则不显示小数点。\n\n- f，表示“定点十进制”形式的浮点数，没有指数。p的含义与在说明符e中的一员。\n\n- g，表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。p可以说明显示的有效数字的最大数量。与转换说明符f不同，g的转换将不显示尾随零。\n\n### 转义序列\n\n我们经常把在格式串中用的代码`\\n`称为转义序列（ escape sequence ）。转义序列使字符串包含一些特殊字符而又不会使编译器引发问题。\n\n详细的说明：https://zh.cppreference.com/w/cpp/language/escape\n\n## scanf 函数\n\nscanf 函数也根据特定的格式读取输入， scanf 函数转换说明符的用法和 printf 函数转换说明符的用法本质上是一样的。\n\nscanf 函数有一些不易察觉的陷阱。使用 scanf 时，程序员必须检查转换说明的数量是否与输入变量的数量相匹配，并且检查每个转换是否适合相对应的变量。另一个陷阱涉及符号&，通常把符号&放在 scanf 函数调用的每个变量的前面。\n\n调用 scanf 函数是读取数据的一种有效但不理想的方法。许多专业C程序员避免用 scanf 函数，而是采用字符格式读取所有数据，然后再把它们转换成数值形式。\n\n### scanf 函数的工作方法\n\nscanf 函数本质上是一种“模式匹配”函数，也就是试图把输入的字符组与转换说明匹配成组。\n\nscanf 调用时，从左边开始处理字符串中的信息。对于格式串中的每一个转换说明， scanf 函数努力从输入的数据中定位适当类型的项，并且跳过必要的空格。然后， scanf 函数读入数据项，并且在遇到不可能属于此项的字符时停止。\n\n在寻找数的起始位置时， scanf 函数会忽略空白（ white-space ）字符（空格符、横向和纵向制表符、换页符、换行符）。\n\n### 格式串中的普通字符\n\n处理格式串中普通字符时， scanf 函数采取的动作依赖于这个字符是否为空白字符。\n\n- 空白字符。当在格式串中遇到一个或多个连续的空白字符时， scanf 函数从输入中重复读空白字符直到遇到一个非空白字符（把该字符“放回原处”）为止。\n\n- 其他字符。当在格式串中遇到一个非空白字符时， scanf 函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么 scanf 函数会放弃输入字符而继续处理格式串。如果两个字符不匹配，那么 scanf 函数会把不匹配的字符放回输入中，然后异常退出。# 第四章 表达式\n\n表达式是显示如何计算值的公式。最简单的表达式是变量和常量。变量表示程序运行时计算出的值；常量表示不变的值。\n\n运算符是构建表达式的基本工具。C语言提供了基本的运算符：\n\n- 算术运算符。\n- 关系运算符。\n- 逻辑运算符。\n\n---\n\n## 算术运算符\n\n算术运算符有：\n\n|一元运算符|二元运算符|\n|:-:|:-:|\n|+ -|+ - * / %|\n\n二元运算符要求有两个操作数，而一元运算符只要有一个操作数。\n\n一元运算符+无任何操作，它主要是为了强调某数值常量是正的。\n\n%被称之为 mod （求模）或 rem （取余）。 i % j 的数值是i除以j后的余数。\n\n除了%，二元运算符既允许操作数是整数也允许操作数是浮点数，或者允许两者的混合。当把 int 型操作数和 float 型操作数混合在一起时，运算结果是 float 型的。\n\n运算符/和%需要特别注意：\n\n- /可能产生意外的结果。当两个操作数都是整数时，运算符/通过丢掉分数部分的方法截取结果，因此1/2的结果是0。\n- %要求整数操作数；如果两个操作数中有一个不是整数，那么程序将无法通过编译。\n- 当/和%用于负数时，其结果与具体实现有关。如果操作数中有一个为负数，那么除法的结果既可以向上取整也可以向下取整。\n\n!!!note \"由实现定义\"\n\t术语由实现定义（ implementation-defined ）出现频率很高，意思是指软件在特定的平台上编译、链接和执行。根据实现的不同，程序的行为可能会稍有差异。\n\tC语言的目的之一是达到高效率，这经常意味着要与硬件行为相匹配。当-9除以7时，一些机器可能产生的结果是-1，而另一些机器的结果为-2，C标准简单地反映了这一现实。\n\t最好避免编写与实现定义的行为相关的程序。\n\n### 运算符的优先级和结合性\n\nC语言允许在所有表达式中用圆括号进行分组。但如果不使用圆括号，就采用运算符优先级（ operator precedence ）的规则来解决问题。算术运算符有下列相对优先级：\n\n- 最高优先级：+ -（一元运算符）\n- 中级优先级：* / %\n- 最低优先级：+ -（二元运算符）\n\n例如：\n\n```c\ni + j * k;    // 等价于 i + (j * k)\n```\n\n当一个表达式包含两个以上相同优先级的运算符时，单独的运算符优先级的规则是不够的。这种情况下，运算符的结合性（ associativity ）开始发挥作用。如果运算符是从左向右结合的，那么称这种运算符是左结合的（ left associative ）。二元算术运算符都是左结合的，所以：\n\n```c\ni - j - k;    // 等价于 (i - j) - k\n```\n\n如果运算符是从右向左结合的，那么称为右结合的（ right associative ）。一元运算符都是右结合的。\n\n## 赋值运算符\n\n一旦计算出表达式的值就常常需要把这个值存储在变量中，以便后面使用。C语言的=运算符（assignment）可以用于此目的。\n\n### 简单赋值\n\n表达式v = e的赋值效果是求出表达式e的值，并把此值复制给v。e可以是常量、变量或较为复杂的表达式：\n\n```c\ni = 5;\nj = i;\nk = 10 * i + j;\n```\n\n如果v和e的类型不同，那么赋值运算发生时会把e的值转化为v的类型：\n\n```c\nint i;\ni = 72.99; /* i is now 72 */\n```\n\n赋值操作产生结果，赋值表达式v=e的值就是赋值运算后v的值。因此，表达式i = 72.99的值是72。\n\n!!!note \"副作用\"\n\t大多数C语言运算符不会改变操作数的值，但是也有一些会改变。由于这类运算符所做的不再仅仅是计算出值，所以称它们有副作用（ side effect ）。简单的赋值运算符就是一个有副作用的运算符，它改变了运算符左边的操作数。表达式i=0产生的结果为0，作为副作用，把0赋值给i。\n\n运算符=是右结合的。所以：\n\n```c\ni = j = k = 0;\ni = (j = (k = 0)); // 等价\n```\n\n### 左值\n\n大多数C语言运算符允许它们的操作数是变量、常量或者包含其他运算符的表达式。然而，赋值运算符要求它左边的操作数必须是左值（ lvalue ）。左值表示存储在计算机内存中的对象，而不是常量或计算结果。变量是左值，而诸如10或2*i这样的表达式则不是左值。\n\n### 复合赋值\n\n利用变量原有值计算出新值并重新赋值给这个变量在C语言程序中是非常普遍的。例如：\n\n```c\ni = i + 2;\n```\n\nC语言的复合赋值运算符（ compound assignment operator ）允许缩短这种语句和其他类似的语句。\n\n```c\ni += 2;\n```\n\n+=运算符把右侧操作数的值加上左侧的变量，并把结果赋值给左侧的变量。还有另外的9种复合赋值运算符，包括：\n\n-= *= /= %=\n\n## 自增运算符和自减运算符\n\n++表示操作数加1，--表示操作数减1。++和--既可以作为前缀（ prefix ）运算符，也可以作为后缀（ postfix ）运算符使用。\n\n++和--也有副作用，它们会改变操作数的值。计算表达式++i的结果是i+1，副作用是自增i。计算表达式i++的结果是i，副作用是自增i。\n\n这个自增操作一定会在下一条语句执行前完成。\n\n## 表达式求值\n\n上述总结的运算符在下表列出了其优先级、结合性。更多讨论见书本p39。\n\n|优先级|类型名称|符号|结合性|\n|-|-|-|-|\n|1|后缀自增、自减|++ --|左结合|\n|2|前缀自增、自减，一元正负|++ -- + -|右结合|\n|3|乘法类|* / %|左结合|\n|4|加法类|+ -|左结合|\n|5|赋值|= *= /= %= += -=|右结合|\n\n**子表达式的求值顺序**\n\nC语言没有定义子表达式的求值顺序（除了含有逻辑与运算符及逻辑或运算符、条件运算符以及逗号运算符的子表达式）。# 第五章 选择语句\n\n根据语句执行过程中顺序所产生的影响方式，C语言的其他语句大多属于以下三类：\n\n- 选择语句（ selection statement ）。 if 语句和 switch 语句允许程序在一组可选项中选择一条特定的执行路径。\n\n- 循环语句（ iteration statement ）。 while 语句、 do 语句和 for 语句支持重复操作。\n\n- 跳转语句（ jump statement ）。 break 语句、 continue 语句和 goto 语句引起无条件地跳转到程序中的某个位置。（ return 语句也属于此类）\n\nC语言还有其他两类语句，一类是由几条语句组合成一条语句的复合语句，一类是不执行任何操作的空语句。\n\n---\n\n## 逻辑表达式\n\n包括 if 语句在内的某些C语句都必须测试表达式的值是“真”还是“假”。诸如`i<j`这样的比较运算会产生整数：0（假）或1（真）。\n\n### 关系运算符\n\nC语言的关系运算符（ relational operator ）用在C语言中时产生的结果是0（假）或1（真）。\n\n|符号|含义|\n|:-:|:-:|\n|<|小于|\n|>|大于|\n|<=|小于或等于|\n|>=|大于或等于|\n\n关系运算符的优先级低于算术运算符，关系运算符都是左结合的。表达式`i+j<k-1`意味着`(i+j)<(k-1)`。\n\n### 判等运算符\n\n|符号|含义|\n|:-:|:-:|\n|==|等于|\n|!=|不等于|\n\n判定运算符是左结合的，也是产生0或1作为结果。然而，判等运算符的优先级低于关系运算符。例如表达式`i<j == j<k`等价于表达式`(i<j) == (j<k)`。\n\n### 逻辑运算符\n\n|符号|含义|\n|:-:|:-:|\n|!|逻辑非|\n|&&|逻辑与|\n|\\|\\||逻辑或|\n\n逻辑运算符所产生的结果是0或1。逻辑运算符将任何非零值操作数作为真值来处理，同时将任何零值操作作为假值来处理。\n\n运算符&&和||都对操作数进行“短路”计算。\n\n运算符!的优先级和一元正号、负号的优先级相同。运算符&&和||的优先级低于关系运算符和判等运算符。运算符!是右结合的，而运算符&&和||是左结合的。\n\n## if 语句\n\nif 语句允许程序通过测试表达式的值从两种选项中选择一种。 if 语句的最简单的格式如下：\n\nif (表达式) 语句\n\n执行 if 语句时，先计算圆括号内的表达式的值。如果表达式的值非零，那么接着执行括号后面的语句，C语言把非零值解释为真值。\n\n### 复合语句\n\n如果想用 if 语句处理两条或更多语句，该怎么办呢？可以引入复合语句（ compound statement ）。复合语句有如下格式：\n\n{ 多条语句 }\n\n### else 子句\n\nif 语句可以有 else 子句：\n\nif (表达式) 语句 else 语句\n\n如果在圆括号内的表达式的值为0，那么就执行 else 后边的语句。\n\n### 条件表达式\n\nC语言提供了一种特殊的运算符，这种运算符允许表达式依据条件的值产生两个值中的一个。\n\n条件运算符（ conditional operator ）由符号?和符号:组成，两个符号必须按如下格式一起使用：\n\n表达式1 ? 表达式2 : 表达式3\n\n条件运算符是C运算符中唯一一个要求3个操作数的运算符。因此，经常把它称为三元运算符。\n\n条件表达式的求值步骤是：首先计算出表达式1的值，如果此值不为零，那么计算表达式2的值，并且计算出来的值就是整个条件表达式的值；如果表达式1的值为零，那么计算表达式3的值，并且此值就是整个条件表达式的值。\n\n### 布尔值\n\n因为许多程序需要变量能存储假值和真值，所以C语言缺少适当的布尔类型可能会很麻烦。可以使用 int 型变量来模拟布尔类型：\n\n```c\nint flag;\nflag = 0;\nflag = 1;\n```\n\n为了使程序更加便于理解，一个好的方法是用类似 TRUE 和 FALSE 这样的名字定义宏：\n\n```c\n#define TRUE 1\n#define FALSE 0\n\nflag = FALSE;\nflag = TRUE;\n```\n\n为了更进一步实现这个想法，甚至可以定义用作类型的宏：\n\n```c\n#define BOOL int\n\nBOOL flag;\n```\n\n## switch 语句\n\nC语言提供了 switch 语句作为级联式 if 语句的替换：\n\n```c\nswitch (grade) {\n\tcase 4: printf(\"Excellent\"); break;\n\n\tcase 3: printf(\"Good\"); break;\n\n\tcase 2: printf(\"Average\"); break;\n\n\tcase 1: printf(\"Poor\"); break;\n\n\tcase 0: printf(\"Failing\"); break;\n\n\tdefault: printf(\"Illegal grade\"); break;\n}\n```\n\nswitch 语句的最常用的格式如下：\n\n```c\nswitch (表达式) {\n\tcase 常量表达式: 多条语句\n\t...\n\tcase 常量表达式: 多条语句\n\n\tdefault: 多条语句\n}\n```\n\nswitch 语句的组成部分：\n\n- 控制表达式。 switch 后面必须跟着右圆括号括起来的整型表达式。C语言把字符当成整数来处理，因此可以在 switch 语句中对字符进行判定。但是，不能用浮点数和字符串。\n\n- 情况标号。常量表达式（ constant expression ）更像是普通的表达式，5是常量表达式，5 + 10也是，而n + 10不是（除非n是表示常量的宏）。\n\n- 语句。每个情况标号的后边可以跟任意数量的语句，不需要用大括号括起来。每组语句的最后通常是 break 语句。# 第六章 循环\n\n循环（ loop ）是重复执行某些语句（循环体）的一种语句。在C语言中，每个循环都有一个控制表达式（ controlling expression ）。每次执行循环体时都要对控制表达式进行计算。如果表达式为真，也就是值不为零，那么继续执行循环。\n\nC语言提供了3种循环语句： while 语句、 do 语句和 for 语句。\n\n---\n\n## while 语句\n\nwhile 语句的格式如下所示：\n\nwhile (表达式) 语句\n\n执行 while 语句时，首先计算控制表达式的值。如果值不为零（即真值），那么执行循环体，接着再次判定表达式。\n\n## do 语句\n\ndo 语句的格式如下所示：\n\ndo 语句 while (表达式);\n\n和处理 while 语句一样， do 语句的循环体也必须是一条语句（当然可以用复合语句）。\n\n执行 do 语句时，先执行循环体，再计算控制表达式的值。如果表达式的值是非零的，那么再次执行循环体。\n\n## for 语句\n\nfor 语句的格式如下所示：\n\nfor (表达式1; 表达式2; 表达式3) 语句\n\n循环开始执行前，表达式1是初始化步骤，并且只执行一次，表达式2用来控制循环的终止（只要表达式2不为零，那么将继续执行循环），而表达式3是在每次循环的最后被执行的一个操作。\n\n### 逗号运算符\n\n有些时候，我们可能喜欢编写有两个（或更多个）初始表达式的 for 语句，或者希望在每次循环时一次对几个变量进行自增操作。使用逗号表达式（ comma expression ）作为 for 语句中的第一个或第三个表达式可以实现这些想法。\n\n逗号表达式的格式如下所示：\n\n表达式1, 表达式2\n\n逗号表达式的计算要通过两步来实现：第一步，计算表达式1并且扔掉计算出的值。第二步，计算表达式2，把这个值作为整个表达式的值。计算表达式1始终会有副作用；如果没有，那么表达式1就没有了存在的意义。\n\n逗号运算符的优先级低于所有其他运算符。\n\n## 退出循环\n\n### break 语句\n\nbreak 语句还可以用于跳出 while、 do 或 for 循环。\n\n### continue 语句\n\ncontinue 语句无法跳出循环，它把程序控制正好转移到循环体结束之前的一点。 break 语句可以用于 switch 语句，而 continue 语句只能用于循环。\n\n### goto 语句\n\ngoto 语句可以跳转到函数中任何有标号的语句处。\n\n标号只是放置在语句开始处的标识符：\n\n标识符: 语句\n\ngoto 语句自身的格式如下：\n\ngoto 标识符;\n\n执行 goto 语句可以把控制转移到标号后的语句上，而且这些语句必须和 goto 语句本身在同一个函数中。\n\n## 空语句\n\n语句可以为空，也就是除了末尾处的分号以外什么符号也没有。# 第七章 基本类型\n\n---\n\n## 整型\n\nC语言支持两种根本不同的数值类型：整型和浮点型。整型的值都是数，而浮点型可能还有小数部分。整型还分为有符号的和无符号的。\n\n!!!note “有符号整数和无符号整数”\n\t在有符号数中，如果数为正数或零，那么最左边的位（符号位）为0，如果是负数，符号位则为1。默认情况下，C语言中的整型变量都是有符号的。\n\nC语言提供了不同尺寸的整型， int 是正常的尺寸。可以指明变量是 long 型或 short 型， signed 型或 unsigned 型。可以有这些类型组合：\n\nshort int, unsigned short int, int, unsigned int, long int, unsigned long int\n\n可以把 int 省略掉，即 short int 可以写成 short 。\n\n不同类型的整型表示的取值范围根据机器的不同而不同。\n\n### 整型常量\n\n这里说的常量表示在程序中以文本形式显示的数。C语言允许用十进制、八进制和十六进制形式书写整型常量。\n\n十进制常量包含数字`0~9`，但是一定不能以零开头：15 255 32767\n\n八进制常量只包含数字`0~7`，但是必须以零开头：017 0377 07777\n\n十六进制常量包含数字0~9和字母a~f，而且总是以0x开头：0xf 0xff 0xffff\n\n当程序中出现整型常量时，如果它属于 int 类型的取值范围，那么编译器会把此常量作为普通整数来处理，否则作为长整型处理。为了迫使编译器把常量作为长整型来处理，只需在后边加上一个字母L：15L\n\n为了指明是无符号常量，可以在常量后边加上字母U：15U\n\n还可以把UL写在一起：0xffffUL\n\n### 读写整数\n\n读写无符号、短的或长的整数需要一些新的转换说明符。\n\n- 读写无符号整数时，使用字母u、o或x代替转换说明符d。u代表十进制、o八进制、x十六进制。\n- 读写短整数时，在d、o、u或x前面加字母h。\n- 读写长整型时，在d、o、u或x前面加字母l。\n\n## 浮点型\n\n有时候需要变量存储带有小数的数，或者能存储极大数或极小数。这类数可以用浮点格式进行存储（因小数点是浮动的而得名）。C语言提供3种浮点型，它们对应不同的浮点格式：\n\n- float ：单精度浮点数\n- double ：双精度浮点数\n- long double ：扩展双精度浮点数\n\n### 浮点常量\n\n浮点常量有许多书写方式：57.0 57. 57E0 5.7E1\n\n用指数表示的是10的幂。\n\n默认情况下，浮点常量都以 double 的形式存储。为了表明只需要单精度，可以在常量的末尾处加上字母f，如 57.0f 。\n\n### 读写浮点数\n\n转换说明符 %e %f 和 %g 用于读写单精度浮点数，当读取 double 时，需要用 %lf ，而写 double 时，不需要加l。\n\n## 字符型\n\n给 char 类型的变量赋值：\n\n```c\nchar ch;\nch = 'a';\n```\n\nC语言会按小整数的方式处理字符。\n\n### 转义序列\n\n一些特殊的符号无法书写，比如换行符，这时候需要用C语言提供的特殊符号转义序列（ escape sequence ）。\n\n转义序列分成两种：字符转义序列和数字转义序列。\n\n### 字符处理函数\n\n可以使用 toupper 库函数把小写字母转成大写字母：\n\n```c\nch = toupper(ch);\n```\n\n被调用时，函数检查参数是否是小写字母，如果是，那么将它转换成大写字母，否则，函数返回参数的值。\n\n### 读写字符\n\n转换说明符 %c 允许 scanf 函数和 printf 函数对单独一个字符进行读写操作。\n\n```c\nchar c;\nscanf(\"%c\", &c);\nprintf(\"%c\", c);\n```\n\n在读入字符前， scanf 不会跳过空白字符。为了强制 scanf 函数在读入字符前跳过空白字符，需要在格式串转换说明符 %c 前面加上一个空格。\n\n```c\nchar c;\nscanf(\" %c\", &c);\n```\n\nC语言还提供了读写单独字符的其他方法。可以使用 getchar 和 putchar 函数来替代调用 scanf 函数和 printf 函数。每次调用 getchar 函数时，它会读入一个字符，并返回这个字符。\n\n```c\nch = getchar();\n```\n\nputchar 函数用来写单独一个字符：\n\n```c\nputchar(ch);\n```\n\ngetchar 和 putchar 会比较快，原因是它们的实现比较简单，并且通常用宏来实现。\n\n## sizeof 运算符\n\n运算符 sizeof 允许程序确定用来存储指定类型值所需的空间的大小。\n\nsizeof(类型名)\n\n上述表达式的值是无符号整数，这个整数表示用来存储属于类型名的值所需的字节数。\n\n表达式 sizeof(char) 的值始终为1。\n\n通常情况下， sizeof 运算符也可以应用于常量、变量和表达式。\n\n既然 sizeof 返回的是无符号的整型，所以最安全的做法是把 sizeof 表达式转换成 unsigned long 型。然后用转换说明符 %lu 进行。\n\n## 类型转换\n\n为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。\n\nC语言允许表达式中混合使用基本数据类型，这种情况下编译器可能需要生成一些指令将某些操作数转换成不同类型，使得硬件可以对表达式进行计算。这类转换是隐式转换（ implicit conversion ）。C语言还允许程序员通过强制运算符执行显式转换（ explicit conversion ）。\n\n当发生下列情况时会进行隐式转换：\n\n- 当算术表达式或逻辑表达式中操作数类型不同时。\n- 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。\n- 当函数调用中使用的参数类型与其对应的参数类型不匹配时。\n- 当 return 语句中表达式的类型和函数返回值的类型不匹配时。\n\n### 常用的算术转换\n\n常用的算术转换包括算术运算符、关系运算符和判等运算符。\n\n为了统一操作数的类型，通常把相对较狭小的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的是整型提升（integral promotion），它把字符或短整数转换成 int 。\n\n两种转换规则：\n\n- 任意操作数是浮点型的情况： float -> double -> long double\n- 两个操作数都不是浮点类型： int -> unsigned int -> long int -> unsigned long int\n\n### 赋值中的转换\n\nC语言遵循一个简单的规则：把赋值运算符右侧的表达式转换成左边变量的类型。把浮点数赋值给整型变量会丢掉小数点后的部分。如果取值在变量的类型范围之外，那么把值赋值给一个较小的类型变量将会得到无意义的结果（甚至更糟）。# 第八章 数组\n\n数组是一种聚合（aggregate）变量，可以存储数值的集合。C语言中一共有两种聚合类型：数组和结构。\n\n---\n\n## 一维数组\n\n数组是含有多个数据值的数据结构，并且每个数据值具有相同的数据类型。这些数据值被称为元素。\n\n一维数组中的元素一个接一个地编排在单独一行。\n\n声明一个一维数组：\n\n```c\n#define N 10\nint a[N];\n```\n\n### 数组下标\n\n长度为n的数组元素的索引范围是0到n-1。\n\n使用数组元素：\n\n```c\na[0] = 1;\n```\n\n!!!warning\n\tC语言不要求检查下标的范围，当下标超出范围时，程序可能执行不可预知的行为。\n\n### 数组初始化\n\n数组可以在声明时获得一个初始值。\n\n数组初始化式（ array initializer ）：\n\n```c\nint a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n/* initial value of a is {1, 2, 3, 4, 5, 6, 0, 0, 0, 0} */\nint a[10] = {1, 2, 3, 4, 5, 6};\n\n/* initial value of a is {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} */\nint a[10] = {0};\n\n/* 可以忽略数组长度，编译器自行确认 */\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n```\n\n### 对数组使用 sizeof 运算符\n\n运算符 sizeof 可以确定数组的大小（字节数）。\n\n利用 sizeof 来计算数组元素的大小：\n\n```c\n#define SIZE sizeof(a) / sizeof(a[0])\n```\n\n## 多维数组\n\n数组可以有任意维数。\n\n声明一个二维数组（或称为矩阵）：\n\n```c\nint m[5][9];\n```\n\n数组m有5行9列。\n\n为了在i行j列中存取数组m的元素，需要写成`m[i][j]`的形式。\n\nC语言按照行主序存储数组，也就是从第0行开始，接着第1行，如此下去。\n\n![](二维数组存储.jpg)\n\n### 多维数组初始化\n\n通过嵌套一维数组的方法可以产生二维数组的初始化式：\n\n```\nint a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n```\n\n## 常量数组\n\n在数组定义前加const使得数组变成一个常量数组，表示不能修改数组里面的元素的值。但这样的数组必须在程序运行前就定义好数组内容，一般用于字符串数组。\n\n```c\nconst int months[] = \n{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n```# 第九章 函数\n\n函数是C语言中的构建块，本质上就是一个由语句组成的小程序。有了函数，程序就可以被划分成许多小块。\n\n---\n\n## 函数的定义和调用\n\n由一个案例说明函数中的一些基本概念：\n\n```\ndouble average(double a, double b)\n{\n    return (a + b) / 2;\n}\n```\n\n**返回类型**：即函数开始处放置的double，表示每次调用该函数返回的类型。\n\n**形式参数（parameter）**：标识符a和b\n\n**函数体**：花括号里的内容。\n\n**实际参数（argument）**：调用函数时，传递给形式参数的表达式。\n\n### 函数定义\n\n函数定义的一般格式：\n\n```\n返回类型 函数名(形式参数)\n{\n    声明\n    语句\n}\n```\n\n如果返回类型很长，可以把它单独放到一行。\n\nC89标准中，声明必须放在语句之前。\n\n### 函数调用\n\n这样调用函数：\n\n```\naverage(x, y);\n```\n\n注意，圆括号不能省略，否则无法正确调用。\n\n返回类型若非void，则会返回一个临时值，这个值可以保存到变量里，也可以丢弃。\n\n## 实际参数\n\n形式参数（parameter）出现在函数的定义中，表示函数调用时要提供的值。\n\n实际参数（argument）是出现在函数调用中的表达式。\n\n实际参数是通过**值传递**的。形参是实参的副本。\n\n### 实际参数的转换\n\n形参和实参的类型不一致时，会发生转换。应该先声明函数原型，然后再执行调用。\n\n这种转换属于隐式转换。实际参数将会转换成形式参数的类型。\n\n### 数组型实际参数\n\n数组名可以作为函数的参数，但是函数无法得知数组的长度，只能传递第二个参数以表明长度。\n\n通过此数组名就可以访问数组元素了。\n\n如果形式参数是多维数组，那么必须指明列的长度：\n\n```\nvoid sum(arr[][LEN], int n);\n```\n\n但这种用法比较少见。\n\n## return语句\n\n非void的函数必须用return语句来指定要返回的值：\n\n```\nreturn 表达式;\n```\n\n如果表达式的值得类型与返回值的类型不一致，那么会把表达式的值转换成返回值的类型。\n\n## 程序终止\n\n在main函数中执行return可以终止程序。\n\nmain函数的返回值是状态码，用于提供给操作系统，以表明程序的执行结果。正常结束返回0，异常结束返回非0值。\n\n**exit函数**\n\n另一种终止程序的办法是使用exit函数。此函数属于`<stdlib.h>`头。\n\n传递给exit的参数就是程序结束的状态码：\n\n```\nexit(0); // 正常终止\nexit(EXIT_SUCCESS); // 正常终止，此值为0\nexit(EXIT_FAILURE); // 异常终止，此值为1\n```\n\n## 递归\n\n如果函数调用它自己，那么此函数就是递归的（recursive）。\n\n为了防止无限递归，一定要有一个终止递归的条件。# 第十章 程序结构\n\n---\n\n## 局部变量\n\n在函数体内或程序块内声明的变量叫局部变量。\n\n局部变量有如下性质：\n\n- 自动存储期限。局部变量的存储单元在函数被调用时分配的，在函数返回时收回。\n\n- 块作用域。作用域是可以引用该变量的代码文本部分。局部变量的作用域在程序块中，外部不可访问。\n\n### 静态局部变量\n\n使用static声明局部变量使其成为静态局部变量，它具有静态存储期限，而不再是自动存储期限。\n\n静态变量拥有永久的存储单元，在整个程序的执行期间都会保留。\n\n静态局部变量的作用域仍是块作用域。\n\n### 形式参数\n\n形式参数拥有和局部变量一样的性质，即自动存储期限和块作用域。\n\n其区别在于它是被实参赋值的。\n\n## 外部变量\n\n参数是给函数传递信息的一种方法。另一种方法就是使用外部变量（external variable）。\n\n外部变量声明于函数体外，也叫全局变量。它有如下性质：\n\n- 静态存储期限。如同在函数体内声明的static局部变量，静态存储期限的变量都会永久保留。\n\n- 文件作用域。外部变量的作用域为其声明处到文件末尾。\n\n### 外部变量的利弊\n\n使用外部变量容易引发的问题：\n\n- 在维护期间，如果改变了外部变量，那么就要检查引用了该外部变量的所有函数，以确认此变化对这些函数的影响\n\n- 如果外部变量的值错误，那么比较难定位是哪个函数赋予它错误的值\n\n- 使用了外部变量的函数难以复用，因为此函数不再独立，而是依赖于此外部变量\n\n要给外部变量起一个健全的名字，这样才不容易和其他变量混淆。\n\n## 程序块\n\n程序块就是这样的代码结构：\n\n```\n{ 多条声明 多条语句 }\n```\n\n在程序块中声明的变量具有自动存储期限，出块时收回存储单元，其作用域在块内。\n\n函数体就是一个程序块。\n\n## 作用域\n\n当程序块内的声明命名了一个标识符时，如果此标识符已经可见（被其它地方声明并且可引用），那么新的声明就会”隐藏“旧的声明。\n\n## 构建C程序\n\n一个可能的编排程序的顺序：\n\n- \\#include指令\n\n- \\#define指令\n\n- 类型定义\n\n- 外部变量的声明\n\n- 除main函数之外的函数的原型\n\n- main函数的定义\n\n- 其它函数的定义# 第十一章 指针\n\n---\n\n## 指针变量\n\n现代计算机把**内存分隔为字节（byte）**。每个字节都有唯一的地址（address）。\n\n变量占有一个或多个字节的内存，把第一个字节的地址称为变量的地址。\n\n地址是一个整数，用指针类型（pointer）的变量来存储。\n\n**指针变量的声明**\n\n在变量名前加星号，来声明一个指针变量。如：\n\n```\nint *p;\n```\n\n此声明说明p是指向int类型的对象。\n\n## 取地址运算符和间接寻址运算符\n\n### 取地址运算符\n\n得到一个变量的地址在它前面加'&'（取地址）。如：\n\n```\nint i;\nint *p = &i;\n```\n\n### 间接寻址运算符\n\n获取指针变量指向的存储空间首地址在它前面加`*`（间接寻址）。如：\n\n```\n*p = 10;\n```\n\n这个操作（\\*p）得到的就是变量的**别名**。该操作会修改变量的值。\n\n## 指针赋值\n\n只要是相同类型的指针，就可以相互赋值。这样它们就指向了相同的对象。\n\n## 指针作为参数\n\n指针可以做为函数的参数或返回值。\n\n这些情况，可能会用到指针类型的形参：\n\n0. 需要得到多个结果，故而用指针传出去\n\n0. 传入的对象太大，没有必要执行拷贝操作\n\n一般只有这些情况，返回一个指针类型才是安全的：\n\n0. 返回的是指针类型的参数\n\n0. 返回的是一个全局变量地址\n\n0. 返回的是一个static变量的地址# 第十二章 指针和数组\n\n---\n\n## 指针和数组\n\n当指针指向数组元素时，它可以操作数组元素。此时，可以对指针进行算术运算（加、减、比较）。\n\n数组名即是指向数组中第一个元素的指针。\n\n## 指针的算术运算\n\n指针指向了数组元素，之后对这个指针做算术运算就是合法的操作。但不要越界。\n\n- 指针加、减整数，代表移动元素指向\n\n- 指针相减，代表指针指向元素之间的距离\n\n- 指针比较，比较的是指针指向元素谁前谁后\n\n!!!warning\n\t不能相加两个指针。\n\n## 指针用于数组处理\n\n指针可以操作数组中的元素，比如遍历数组：\n\n```c\nint *p = 0;\nfor (p = &a[0]; p < &a[N]; ++p)\n{\n    // ...\n}\n```\n\n这里N是数组a的长度，虽然`a[N]`不存在，但对它取地址是合法且安全的操作。\n\n**使用\\*和++组合**\n\n如，`*p++`\n\n++操作的优先级高于\\*，所以这样的组合操作，会先操作指针p，然后获取其指向的内容。\n\n后置++会先返回p，然后对p递增，可以用这个操作遍历数组：\n\n```c\nint *p = &a[0];\nwhile (p < &a[LEN])\n{\n    int n = *p++;\n    // ...\n}\n```\n\n## 用数组名作为指针\n\n数组名即第一个元素的地址。即a与&a[0]等价。\n\n数组名是一个指针常量，不能改变其值，应该把它赋值给一个指针变量。\n\n因此可以这样遍历数组：\n\n```c\nint *p = 0;\nfor (p = a; p < a + LEN; ++p)\n{\n    // ...\n}\n```\n\n## 指针和多维数组\n\n二维数组在内存中实际上是一维的连续存储的。其首元素如果这样写：\n\n- `&a[0]`，代表第一行的首地址\n\n- `&a[0][0]`，代表第一个元素的首地址\n\n这俩地址的值是一样的，但意义不同，因为其指向元素的类型不一样。前者是`int*`，后者是`int`。\n\n### 多维数组名作为指针\n\n`int a[n][m]`这样的二维数组，其数组名a代表的是`a[0]`的地址，`a[i]`得到的是第i行的地址。\n\n这样的指针类型是：\n\n```c\nint (*p)[m] = a;\n```\n\n或\n```c\ntypedef int (*Line)[m];\nLine p = a;\n```\n\n这里定义了一个指向数组的指针，这个数组的元素有m个。# 第十三章 字符串\n\n---\n\n## 字符串字面量\n\n字符串字面量（ string literal ）是用一对双括号括起来的字符序列：\n\n```c\n\"Hello World\"\n```\n\n### 字符串字面量中的转义序列\n\n字符串字面量可以包含转义序列：\n\n```c\n\"Hello\\tWorld\\n\"\n```\n\n### 延续字符串字面量\n\n字符串字面量可能太长，以至于无法放置在单独一行内可以把第一行用字符\\结尾，那么C语言就允许在下一行延续字符串字面量：\n\n```c\nprintf(\"put a disk in drive A, then \\\npress any key to continue\");\n```\n\n不只是字符串，字符\\可以用来分割任何长的符号。\n\n但\\有一个缺陷：字符串字面量必须从下一行的起始位置继续，从而破坏了程序的缩进结构。\n\n一个更好的办法是通过C语言的标准解决这个问题，也就是当两个或更多字符串字面量相连时（仅用空白字符分割），编译器必须把它们合并成单独一条字符串：\n\n```c\nprintf(\"put a disk in drive A, then\"\n\t   \"press any key to continue\\n\");\n```\n\n### 如何存储字符串字面量\n\n从本质上而言，C语言把字符串字面量作为字符数组来处理。当C语言编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。+1存储的是额外的空字符，它用来标志字符串的末尾，用转义序列\\0来表示，其数值为0。\n\n例如，字符串字面量\"abc\"是一个有4个字符的字符数组：\n\n![字符串存储](字符串存储.jpg)\n\n字符串字面量可以为空。字符串\"\"表示一个空串，仅有一个空字符。\n\n既然字符串字面量是作为数组来存储的，那么编译器会把它看作是char\\*类型的指针。\n\n### 字符串字面量的操作\n\n通常情况下可以在任何C语言允许使用char\\*指针的地方使用字符串字面量。例如：\n\n```c\nchar *p;\np = \"abc\"; /* 并非复制abc中的字符，而仅仅是使p指向字符串的第一个字符 */\n\nchar ch;\nch = \"abc\"[1]; /* C语言允许对指针添加下标，因此可以给字符串字面量添加下标 */\n```\n\n!!!warning\n\t对于一些编译器而言，改变字符串字面量的内容可能会导致运行异常。因此不推荐这么做。\n\n### 字符串字面量与字符常量\n\n只包含一个字符的字符串串字面量不同于字符串常量。字符串字面量\"a\"是指针，指向存放字符a以及后续空字符的内存单元。字符常量'a'是一个整数。\n\n## 字符串变量\n\nC语言只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。\n\n定义字符串变量的惯用法：\n\n```c\n#define STR_LEN 80\nchar str[STR_LEN + 1]; /* 强调的事实是 str 可以存储最多80个字符 */\n```\n\n### 初始化字符串变量\n\n字符串变量可以在声明时进行初始化：\n\n```c\nchar date1[8] = \"June 14\";\n\nchar date2[8] = {'J', 'u', 'n', 'e', '1', '4', '\\0'};\n\nchar date3[] = \"June 14\"; /* 编译器自动计算长度 */\n```\n\n### 字符数组与字符指针\n\n比如：\n\n```c\nchar date1[] = \"June 14\"; /* 字符数组 */\nchar *date2 = \"June 14\"; /* 字符串字面量的指针 */\n```\n\n任何期望传递字符数组或字符指针的函数都将接受这两种声明的 date 作为参数。\n\n然而，需要注意，不能错误地认为上面两种 date 可以互换。两者之间有显著的差异：\n\n- 在声明为数组时，就像任意数组元素一样，可以修改存储在 date 中的字符。但不可以修改字符串字面量。\n\n- 在声明为数组时， date 是数组名。在声明为指针时， date 是变量，它可以指向其他字符串。\n\n## 字符串的读/写\n\n使用 printf 和 puts 函数来读写字符串。\n\n使用 scanf 和 gets 函数来读字符串。但 gets 函数不安全。\n\n## 使用C语言的字符串库\n\nC语言的运算符无法操作字符串，C语言的库函数为字符串的操作提供了丰富的函数集。这些函数的原型驻留在 string.h 头文件中。\n\nstrcpy 函数可以拷贝字符串。\n\nstrcat 函数可以追加字符串。\n\nstrcmp 函数可以比较字符串。\n\nstrlen 函数可以取得字符串的长度。\n\n## 字符串数组\n\n比如：\n\n```c\nchar *planets[] = {\n\t\"Mercury\",\n\t\"Venus\",\n\t\"Earth\",\n\t\"Mars\",\n\t\"Jupiter\",\n\t\"Saturn\",\n\t\"Uranus\",\n\t\"Neptune\",\n\t\"Pluto\",\n};\n```\n\nplanets 数组的每一个元素是一个字符串的指针。\n\n### 命令参数\n\n运行程序时，经常需要提供一些信息给程序，这是命令行参数（ command-line argument ）。必须把 main 函数定义为含有两个参数的函数：\n\n```c\nint main(int argc, char* argv[])\n{\n\n}\n```\n\nargc （参数计数）是命令行参数的数量（包括程序名本身，最少为1）。 argv (\"参数向量\")是指命令行参数的指针数组。 argv[0] 指向程序名， argv[n] 表示第n个参数。\n\nargv[argc] 始终是一个空指针。\n\n如果用户输入了下面的命令：\n\n```shell\nls -l remind.c\n```\n\n那么 argc 和 argv 是：\n\n- argc: 3\n\n- argv: {\"ls\", \"-l\", \"remind.c\", NULL}# 第十四章 预处理器\n\n---\n\n## 预处理器的工作方式\n\n预处理器的行为是由指令控制的。这些指令是由#字符开头的一些命令。比如 #define 和 #include 。\n\n`#define`定义了一个宏——用来代表其他东西的一个名字。当宏在后面的程序中用到时，预处理器扩展它，将宏替换为它所定义的值。\n\n`#include`指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分。\n\n!!!note \"my note\"\n\t可以使用`gcc -E src.c`指令来查看预编译结果。\n\n## 预处理指令\n\n常见预处理指令包括：\n\n- 宏定义。`#define`定义一个宏，`#undef`删除一个宏。\n\n- 文件包含。即`#include`\n\n- 条件编译。`#if #ifdef #ifndef #elif #else #endif`\n\n指令的通用规则有：\n\n- 都以#开始。\n\n- 在指令的符号之间可以插入任意数量的空格或横向制表符。\n\n- 指令总是在第一个换行符处结束，除非明确地指明要继续，用\\字符换行。\n\n- 指令可以出现在程序的任何地方。\n\n- 注释可以与指令放在同一行。\n\n[测试代码](../../codes/CProgramming/lab/test_precompiled_command.c)\n\n## 宏定义\n\n宏定义的作用范围从定义处开始到本文件末尾。\n\n### 简单宏定义\n\n简单宏定义的格式如：\n\n```c\n#define <宏名> [替换列表]\n```\n\n替换列表中可以有空格。甚至可以没有替换列表，此时宏替换后，就等于删除了这个宏一样。\n\n简单的宏定义一般用于：\n\n- 给字面量取一个别名\n- 辅助条件编译\n\n### 带参数的宏定义\n\n格式如：\n\n```c\n#define <宏名>(x1, x2, ..., xn) [替换列表]\n```\n\n注意点：\n\n- 宏名和参数列表的括号之间不能有空格，不然就是一个简单宏了\n\n- 参数列表可以为空，这样的宏使用起来就像一个函数\n\n- 参数只会替换记号，字符串内的同名单词并不会被替换\n\n带参数的宏一般用于：\n\n- 替代一些小的函数，这样程序的执行效率会高一些，并且函数可能更加通用，因为宏不必检查参数类型\n\n### \\#号和\\#\\#号\n\n宏替换列表中有两个特殊符号：\\#和\\#\\#，它们有如下的意义：\n\n- \\#号代表参数会被替换成一个字符串字面量，例如 :\n\n```c\n#define PRINT_INT(n) printf(#n \" = %d\\n\", n)\n```\n\n\\#n会被替换成\"n\"，相邻的字符串字面量可以连起来形成一个字符串字面量，所以PRINT_INT(a)的宏替换结果是：\n\n```c\nprintf(\"a = %d\\n\", a);\n```\n\n- \\#\\#代表将两边的记号连接在一起，成为一个记号，一个典型的例子：\n\n```c\n#define GENERIC_MAX(type)               \\\ntype type##_max(type x, type y)         \\\n{                                       \\\n        return x > y ? x : y;           \\\n};\n```\n\n这个宏定义定义了一个取最大值的函数，可以方便的为这个函数指定比较类型。\n\n值得注意的是，**#和##都在简单的宏替换后起作用**。\n\n### 宏定义中的圆括号\n\n如果宏定义的替换列表是一个表达式，那么为其增加圆括号是必不可少的工作。\n\n这是因为如果不加圆括号，在宏替换后，新的表达式可能会破坏替换列表表达式的运算优先级。\n\n**在替换列表表达式中使用圆括号有两条规则：**\n\n0. 用圆括号将替换列表括起来\n0. 用圆括号把每个宏参数括起来\n\n一个安全的宏的例子：\n\n```c\n#define SUM(x, y) ((x) + (y))\n```\n\n### 创建较长的宏\n\n一些废话：\n\n宏函数展开后，实际上只有一行。而编写的时候为了好看，可以用`\\`作为换行连接符号。\n\n另外，宏函数使用时看上去应该像普通函数一样：后面也要加分号。所以宏函数的替换列表的末尾应该没有分号。\n\n**直接上书上所给的解决方案：**\n\n```cpp\n#define ECHO(str)    \\\ndo                   \\\n{                    \\\n    gets(str);       \\\n    puts(str);       \\\n} while(0)\n\n// use\nECHO(str);\n```\n\n### 预定义宏\n\n常用预定义宏：\n\n|宏|说明|\n|-|-|\n|`__LINE__`|行号，十进制常数|\n|`__FILE__`|文件名|\n|`__DATE__`|文件编译时的日期|\n|`__TIME__`|文件编译时的时间|\n\n文件名，日期，时间的预定义宏展开后都是一个字符串变量。行号是一个整型变量。\n\n另外，不同的系统会定义不同的预定义宏，来标识其编译平台。如：\n\n- Linux下，`__unix`\n\n- Windows下，`_WIN32`\n\n这种预定义宏配合条件编译就可以做到跨平台编译代码。\n\n[测试代码](../../codes/CProgramming/lab/test_precompiled_macros.c)\n\n**特殊的预定义宏`__VA_ARGS__`**\n\nC99标准中，有一个特殊的预定义宏，它的作用是替换可变参数列表（...），但它要和##符号配合使用，此时##的意义不再是连接，而是：当可变参数列表为空的时候，去除`__VA_ARGS__`前面的逗号，从而避免编译错误。\n\n一个典型的例子：\n```c\n#define CONSOLE_DEBUG(fmt, ...)\\\n    printf(\"FILE: \"__FILE__\", LINE: %05d \"fmt\"\\n\", __LINE__, ##__VA_ARGS__);\n```\n\n`__FUNCTION__`\n\n这个宏代表了当前执行函数的函数名字符串。\n\n## 条件编译\n\n条件编译指令排除了不应该出现的文本。只有通过了条件编译的文本块才会被交给编译器编译。\n\n条件一般是一个普通的宏。\n\n书写格式如：\n\n```c\n#if MACRO\ncode\n#elif MACRO\ncode\n#else\ncode\n#endif\n```\n\n### defined 运算符\n\ndefined 运算符仅用于预处理器。\n\n```c\n#if defined(DEBUG)\n...\n#endif\n```\n\n如果标识符 DEBUG 是一个定义过的宏，则返回1，否则返回0。 defined 返回1意味着通过条件。\n\n指令说明：\n\n- \\#if, \\#elif可以判断这个宏的值，如果是0就不会通过条件编译\n\n- \\#ifdef, \\#ifndef可以判断这个宏是否被定义\n\n条件编译的作用一般是：\n\n- 为了支持跨平台编译\n\n- 排除一些调试代码\n\n## 其他指令\n\n**#error 指令**\n\n如果预处理器遇到一个`#error`指令，它会显示一个出错消息，大多数编译器会立即终止编译。\n\n```c\n#error You can not include this file\n```\n\n**#pragma指令**\n\n`#pragma`指令为要求编译器执行某些特殊操作提供了一种方法。\n\n使用#pragma pack预处理指令来设置字节对齐。具体用法如：\n\n```c\n#pragma pack(push)    // 保存现在的字节对齐状态\n#pragma pack(4)       // 设置4字节对齐\n// 这里定义的结构体最好以4字节对齐\n#pragma pack(pop)     // 恢复字节对齐状态\n```\n\n这里字节对齐的意思是，将结构体中最大内置类型的成员的长度与默认字节对齐数（比如是4）对比，如果谁小，那么就按谁来对齐。# 第十五章 编写大规模程序\n\n源文件包含函数的定义和外部变量，而头文件包含可以在源文件之间共享的信息。\n\n---\n\n## 源文件\n\n可以把程序分割成一定数量的源文件，源文件的扩展名为`.c`。源文件主要包含函数的定义和变量。其中一个源文件必须包含名为 main 的函数，作为程序的起始点。\n\n把程序分成多个源文件有许多显著的优点：\n\n- 把相关的函数和变量集合在单独一个文件中可以帮助明了程序的结构。\n\n- 可以单独对每一个源文件进行编译。如果程序规模很大而且需要频繁改变的话，这种方法可以极大地节约时间。\n\n- 利于复用。\n\n## 头文件\n\n当把程序分割成几个源文件时，问题也随之产生：某文件的函数如何能调用定义在其他文件中的函数？函数如何能访问其他文件中的外部变量？两个文件如何能共享同一个宏定义或类型定义？答案取决于`#include`指令。\n\n`#include`指令告诉预处理器打开指定的文件，并且把此文件的内容插入到当前文件中。这种打开的文件称为头文件，其扩展名为`.h`。\n\n### include 指令\n\n`#include`指令有两种书写格式：\n\n- `#include <文件名>` 搜索系统头文件所在目录，比如在 UNIX 系统中，通常是在 /usr/include\n\n- `#include \"文件名\"` 搜索当前目录，然后搜索系统目录\n\n利用加上诸如-I这样的命令行选项可以添加搜索头文件的位置。\n\n### 共享宏定义和类型定义\n\n大规模的程序包含用于几个源文件共享的宏定义和类型定义，这些定义应该放在头文件中。\n\n比如下图的例子：\n\n![宏定义和类型定义](宏定义和类型定义.png)\n\n有两个源文件包含了 boolean.h\n\n把宏定义和类型定义放到头文件中有如下的好处：\n\n1. 不必把定义复制到需要的源文件，节约时间。\n\n2. 程序变得更加容易修改，改变定义只需要改变头文件。\n\n3. 不用担心源文件包含了相同的宏或类型而其定义不同。\n\n### 共享函数原型\n\n没有原型依赖的函数调用是很危险的，编译器的假设可能是错误的。当调用定义在其他文件中的函数时，要始终确保编译器在调用之前看到函数f的原型。\n\n解决办法就是把函数的原型放进头文件中，然后在所有调用函数f的地方包含头文件。\n\n其包含的方式可能如图所示：\n\n![共享函数原型](共享函数原型.png)\n\n### 共享变量的声明\n\n变量可以在文件中共享。\n\n为了声明变量而不定义，需要在变量声明的开始处放置关键字 extern :\n\n```c\n/* in heaeder file */\nextern int i;\n```\n\n为了共享i，需要在一个源文件中定义i:\n\n```c\n/* in source file */\nint i;\n```\n\n### 保护头文件\n\n如果一个源文件同时包含一个头文件两次，那么可能产生编译错误（比如包含了两次相同的类型定义）。\n\n因此要用到一种保护头文件的方法：\n\n```c\n#ifndef BOOLEAN_H\n#define BOOLEAN_H\n\n/*\n real content\n*/\n\n#endif\n```\n\n如果再次包含此头文件，预处理器就不会再扩展真实的内容。\n\n### 头文件中的#error指令\n\n经常把#error指令放置在头文件中是用来检查不应该包含头文件的条件。例如：\n\n```c\n#ifndef DOS\n#error Graphics supported only under DOS\n#endif\n```\n\n如果非DOS的程序试图包含此头文件，那么编译将在#error指令处终止。\n\n## 构建多文件程序\n\n构建大程序的基本步骤：\n\n- 编译，必须对每一个源文件进行编译。不需要编译头文件。编译器产生一个文件，此文件包含来自源文件的目标代码，称为目标文件（object file）。\n\n- 链接，链接器把目标文件和库文件结合在一起生成一个可执行程序。\n\n大多数编译器允许用单独一步来构建程序：\n\n```c\ncc -m fmt fmt.c line.c word.c\n```\n\n### makefile\n\n使用 makefile 更易于构建大型程序。 makefile 列出了作为程序的部分文件，并描述了它们之间的依赖性。\n\n更多讨论见书本。\n\n!!!note \"my note\"\n\t一种自动生成依赖性的说明的方法是键入命令：`gcc -MM *.c`\n\n### 在程序外定义宏\n\n大多数 UNIX 编译器支持-D选项，允许在命令行指定一个宏定义：\n\n```c\ncc -DDEBUG=1 foo.c\n```\n\n定义了宏 Debug ，在 foo.c 程序中，且值为1。如同在 foo.c 中的开始出现：\n\n```c\n#define DEBUG 1\n```# 第十六章 结构、联合和枚举\n\n---\n\n## 结构变量\n\n结构的元素可能具有不同的类型，而且，每个成员都有名字。\n\n### 结构变量的声明\n\n一个声明结构变量的例子：\n\n```c\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1, part2;\n```\n\n每个结构变量都有三个成员：number, name, on_hand 。\n\n`struct {...}`指明了类型，而 part1 和 part2 则是具有这种类型的变量。\n\n结构的成员在内存中是按照声明的顺序存储的。第一个声明的变量放在存储位置的最前面。\n\n每个结构表示一种新的名字空间（ name space ）。 part1 的 number 和 part2 的 number 不会有冲突。\n\n### 结构变量的初始化\n\n结构变量可以在声明的同时进行初始化：\n\n```c\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1 = { 528, \"Disk drive\", 10 },\n  part2 = { 914, \"Printer cable\", 5 };\n```\n\n结构初始化式的表达式必须是常量。初始化式可以短于它所初始化的结构，这样任何“剩余”成员都用0作为它的初始值。\n\n### 对结构的操作\n\n为了访问结构内的成员，首先写出结构的名字，然后写出成员的名字：\n\n```c\nprintf(\"Part number: %d\\n\", part1.number);\n```\n\n结构成员的值是左值：\n\n```c\npart1.number = 258;\n```\n\n用于访问结构成员的句点是一个运算符，其优先级比较高：\n\n```c\n/* &计算的是 part1.on_hand 的地址 */\nscanf(\"%d\", &part1.on_hand);\n```\n\n另一种主要的结构操作是赋值运算：\n\n```c\npart2 = part1;\n/* 现在 par1 和 part2 每个成员的值都一样 */\n```\n\n可以用结构来复制数组：\n\n```c\nstruct { int a[10]; } a1, a2;\na1 = a2;\n```\n\n运算符=仅仅用于类型一致的结构。\n\n## 结构类型\n\n如果在两个地方编写了：\n\n```c\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1;\n\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part2;\n```\n\n那么 part1 和 part2 就不是同一个类型，这样就不能执行赋值操作。为了解决这个问题，需要为表示结构的类型定义名字。方法有两种：\n\n- 使用结构标记\n\n- 使用 typedef 定义类型名\n\n### 结构标记的声明\n\n结构标记（ structure tag ）即：\n\n```c\nstruct part {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n};\n\n/* 用标记 part 声明变量 */\nstruct part part1, part2;\n```\n\n### 结构类型的定义\n\n即：\n\n```c\ntypedef struct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} Part;\n\n/* 声明变量 */\nPart part1, part2;\n```\n\n## 联合\n\n联合（ union ）也是由一个或多个成员构成的，而且这些成员可能具有不同的数据类型。但是，编译器只为联合中最大的成员分配足够的内存空间，联合的成员在这个空间内彼此覆盖。\n\n对于：\n\n```c\nunion {\n    int i;\n    float f;\n} u;\n\nstruct {\n    int i;\n    float f;\n} s;\n```\n\n他们的存储如：\n\n![联合和结构的存储](联合和结构的存储.jpg)\n\n其中 u.i 和 u.f 具有相同的地址。\n\n## 枚举\n\n枚举（ enumeration ）是一种由程序员列出的值，而且程序员必须为每种值命名（枚举常量）：\n\n```c\nenum { CLUBS, DIAMONDS, HEARTS, SPADES } s1, s2;\n```\n\n虽然枚举和结构没什么共同的地方，但是它们的声明方式很类似。\n\n枚举常量的名字必须不同于闭合作用域内声明的其他标识符。\n\n### 枚举标记和枚举类型\n\n为了定义枚举标记，可以写成：\n\n```c\nenum suit { CLUBS, DIAMONDS, HEARTS, SPADES };\n\n/* 声明枚举变量 */\nenum suit s1, s2;\n```\n\n用 typedef 给枚举命名：\n\n```c\ntypedef enum { CLUBS, DIAMONDS, HEARTS, SPADES } Suit;\n\n/* 声明枚举变量 */\nSuit s1, s2;\n```\n\n### 枚举作为整数\n\n在系统内部，C语言会把枚举变量和常量作为整数来处理。枚举常量的值可以是任意整数：\n\n```c\nenum suit { CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4 };\n```\n\n两个或多个枚举常量具有相同的值甚至也是合法的。\n\n当没有为枚举常量指定值时，它的值是一个大于前一个常量的值的值（大1）。默认第一个枚举常量的值为0。# 第十七章 指针的高级应用\n\n---\n\n## 动态存储分配\n\n任何单纯的数据结构（各种内置类型，数组，结构体），其大小在程序开始时已经确定了，且不能改变。而一些数据结构可能需要动态的改变其数据长度，比如链表。这就要用到**动态存储分配**（dynamic storage allocation）。\n\n使用动态存储分配的数据块存放在“堆”上，和其它存储区域不同的是，“堆”里的数据应该让程序员来控制释放（free）时机。\n\n为了动态地分配存储空间，将需要调用3种内存分配函数中的一种，这些函数都是声明在stdlib.h中的：\n\n0. malloc，分配内存块，但是不初始化它\n\n0. calloc，分配内存块，并对其清零\n\n0. realloc，调整先前分配的内存块\n\n由于malloc函数不需要对分配的内存块进行清除，所以它比calloc函数更高效。\n\n### 空指针\n\n当调用内存分配函数时，无法定位满足我们需要的足够大的内存块，这种问题始终可能出现。如果真的发生了这类问题，函数会返回空指针。\n\n**空指针**（null pointer）是指一个区别于所有有效指针的特殊值。\n\n!!!warning\n    程序员的责任是测试任意内存分配函数的返回值，并且在返回空指针时采取适当的操作。通过空指针试图访问内存的效果是未定义的，程序可能会崩溃或者出现不可预测的行为。\n\n用名为NULL的宏来表示空指针，可用下列方式测试malloc函数的返回值：\n\n```c\np = malloc(10000);\nif (p == NULL) {\n    /* allocation failed; take appropriate action */\n}\n```\n\n## 动态分配字符串\n\n动态内存分配经常用于字符串操作。字符串始终存储在固定长度的数组中，而且可能很难预测这些数组需要的长度。通过动态地分配字符串，可以推迟到程序运行时才作决定。\n\n### 使用malloc函数为字符串分配内存\n\n函数原型：\n\n```c\nvoid *malloc(size_t size);\n```\n\nsize_t是无符号整型，malloc分配了一段size个字节的连续空间，并返回该空间首地址。如果分配失败就返回NULL。\n\n因为C语言保证char型值确切需要一个字节的内存，为了给n个字符的字符串分配内存空间，可以写成：\n\n```c\np = malloc(n + 1);\n```\n\n通常情况下，可以把void\\*型值赋给任何指针类型的变量。然而，一些程序员喜欢强制转换malloc函数的返回值：\n\n```c\nchar *p = (char*)malloc(n + 1);\n```\n\n由于使用malloc函数分配内存不需要清除或者以任何方式初始化，所以p指向带有n+1个字符的未初始化的数组。\n\n可以调用strcpy函数对上述数组进行初始化：\n\n```c\nstrcpy(p, \"abc\");\n```\n\n数组中前4个字符分别为a, b, c和空字符。\n\n## 动态分配数组\n\n编写程序时，常常为难数组估计合适的大小。较方便的做法是等到程序运行时再来确定数组的实际大小。\n\n虽然malloc函数可以为数组分配内存空间，但calloc函数确实是最常用的一种选择。因为calloc函数对分配的内存进行初始化。realloc函数允许根据需要对数组进行“扩展”或“缩减”。\n\n### 使用malloc函数为数组分配存储空间\n\n当使用malloc函数为数组分配存储空间时，需要使用sizeof运算符来计算出每个元素所需要的空间数量。\n\n使用sizeof计算是必须的，因为这样计算的结果在不同平台下都是正确的。\n\n```c\nint *a = malloc(n * sizeof(int));\n```\n\n这里的n可以在程序执行期间计算出来。\n\n一旦a指向了动态分配的内存块，就可以把它用作数组的名字。这都要感谢C语言中数组和指针的紧密关系。可以使用下列循环对此数组进行初始化：\n\n```c\nfor (i = 0; i < n; ++i)\n    a[i] = 0;\n```\n\n### calloc函数\n\n函数原型：\n\n```c\nvoid *calloc(size_t nmemb, size_t size);\n```\n\nnmemb是数据单元的个数， size是一个数据单元的大小。返回成功申请的数据块首地址，失败返回NULL。\n\ncalloc不仅会从“堆”申请存储区域，还会把这段区域清零。也因此其执行效率没有malloc高。\n\n下列calloc函数的调用为n个整数的数组分配存储空间，并且保证全部初始为0：\n\n```c\na = calloc(n, sizeof(int));\n```\n\n通过调用以1作为第一个实际参数的calloc函数，可以为任何类型的数据项分配空间：\n\n```c\nstruct point { int x, y; } *p;\np = calloc(1, sizeof(struct point));\n```\n\n此语句执行后，p指向结构，且此结构的成员x和y都会被设置为0。\n\n### realloc函数\n\n一旦为数组分配完内存，稍后可能会发现数组过大或过小。realloc函数可以调整数组的大小使它更适合需要。\n\n函数原型：\n\n```c\nvoid *realloc(void *ptr, size_t size);\n```\n\nptr必须指向内存块，且此内存块一定是先通过malloc函数、calloc函数或realloc函数的调用获得的。size表示内存块的新尺寸，新尺寸可能会大于或小于原有尺寸。\n\nC标准列出几条关于realloc函数的规则：\n\n- 当扩展内存块时，realloc函数不会对添加进内存块的字节进行初始化。\n\n- 如果realloc函数不能按要求扩大内存块，那么它会返回空指针，并且在原有内存块中的数据不会发生改变。\n\n- 如果realloc函数调用时以空指针作为第一个实际参数，那么它的行为就像malloc函数一样。\n\n- 如果realloc函数调用时以0作为第二个实际参数，那么它会释放掉内存块。\n\n!!!warning\n    一旦realloc函数返回，请一定要对指向内存块的所有指针进行更新，因为可能realloc函数移动了其他地方的内存块。\n\n实际使用时，realloc应该始终对ptr指向的存储区域进行扩展。\n\nrealloc不是一个好用的函数，要很小心才行。这是因为原来的存储区域会被释放掉（虽然新的存储区域会可能和原来的重叠），其指针很可能都变的无效。\n\n## 释放存储\n\nmalloc函数和其他内存分配函数所获得的内存块都来自一个称为**堆**（heap）的存储池。调用这些函数经常会耗尽堆，或者要求大的内存块也可能耗尽堆，这会导致函数返回空指针。\n\n更糟的是，程序可能分配了内存块，然后又丢失了这些块的追踪路径，因而浪费了空间。如下例子：\n\n```\np = malloc(...);\nq = malloc(...);\np = q;\n```\n\n由于没有指针指向第一个内存块，所以再也不能使用此内存块了。\n\n对于程序而言，不再访问到的内存块被称为是**垃圾**（garbage）。在后边留有垃圾的程序有**内存泄漏**（memory leak）。一些语言提供了**垃圾收集器**（garbage collector），但C语言不提供。每个C程序负责回收各自的垃圾，方法是调用free函数来释放不需要的内存。\n\n如上例子，就是一个内存泄漏。第一块内存再也访问不到了，这应该就是上文所说的留有垃圾。\n\n**free**\n\n只有一个方法释放由动态存储分配函数分配的内存空间。就是使用free函数，如果不释放，那么这块资源就一直放在“堆”里，直到程序退出。\n\n函数原型：\n\n```c\nvoid free(void *ptr);\n```\n\n使用free函数很容易，只是简单地把指向不再需要的内存块的指针传递给free函数就可以了：\n\n```c\np = malloc(...);\nfree(p);\n```\n\n调用free函数来释放p所指向的内存块。然后会把这个释放的内存返回给堆，使此内存块可以被复用。\n\n### “悬空指针”问题\n\nfree操作会生成**悬空指针**（dangling pointer）。即调用free(p)函数会释放p指向的内存块，但是不会改变p本身。如果忘记了p不再指向有效内存块（而使用它），后果很严重。\n\n悬空指针是很难发现的，因为几个指针可能指向相同的内存块。在释放内存块时，全部的指针都会留有悬空。\n\n## 指向函数的指针\n\n函数也有地址，所以就可以有指针指向。一些功能强大的函数（像模板一样）都是通过函数指针和`void*`实现的。\n\n### 函数指针\n\n函数指针主要被存放在：\n\n- 数组里，方便日后调用\n- 形参，成为模板函数的实现，比如qsort\n\n定义一个函数指针类型的例子：\n\n```c\ntypedef void (*Func)();\n```\n\n### 函数入口地址\n\n函数名就是函数地址，但通常会对函数名做&运算，其实得到的结果是一样的。同样对函数指针做`*`运算（解引用）和直接拿函数指针用也是一样的，都是代表了函数的入口地址。\n\n一般会对函数名做&操作，对函数指针做`*`操作，让它们看上去比较像指针的使用。# 第十八章 声明\n\n---\n\n## 什么是声明\n\n一个变量或者函数应该首先被声明，才会被使用。因为声明会告诉编译器这个变量或者函数的信息，然后编译器就可以检查其存储空间和作用域，以及使用时的语法是否正确。\n\n## 声明的语法\n\n声明的格式（声明式）是：\n\n**声明说明符 声明符**\n\n声明说明符描述了变量或者函数的性质，声明符代表变量名或者函数名，并且可以指明它的额外信息（如是一个数组or指针or函数）。\n\n声明说明符分为以下3类：\n\n0. 存储类型。四种：auto（块内默认存储类型，无需显示声明），static，extern和register（已经被现代编译器优化，一般不需要声明）\n\n0. 类型限定符，有const和volatile\n\n0. 类型说明符，诸如int，long，unsighed，或者自定义数据类型等，对于函数，类型说明符就是返回类型。\n\n声明符就是一个标识符，然后可以用星号（代表指针），方括号（代表数组），圆括号（代表函数）修饰。\n\n可以看到，声明没有赋值的内容。\n\n## 存储类型\n\n### 变量的性质\n\nC程序中，变量都有三种性质：\n\n0. 存储期限，决定了变量的生存周期。具有自动存储期限的变量在第一次执行时获得内存单元，出块时释放内存单元；具有静态存储期限的变量在程序的生命周期内都拥有内存单元。\n\n0. 作用域，拥有块作用域的变量只能在块内被使用；拥有文件作用域的变量从声明变量开始到文件结束的范围都可以使用。\n\n0. 链接，拥有外部链接的变量（内存单元）可以被程序的其它文件访问；拥有内部链接的变量只可以在文件内访问；无链接的变量只能在一个函数内访问。\n\n上述三种性质取决于变量的声明位置以及变量的存储类型，比如不指明存储类型的话：\n\n- 在块内声明的变量，具有自动存储期限，块作用域，无链接\n\n- 在程序的最外层声明的变量，具有静态存储期限，文件作用域，外部链接。\n\n### 作用域\n\n决定一个变量的作用域的，仅在于它的声明位置：\n\n1. 在块内声明的，具有块作用域\n\n2. 在文件最外层声明的，具有文件作用域\n\n作用域是编译级别的（非链接）语法，编译器根据变量的作用域检查其使用的位置是否正确。\n\n### static存储类型\n\n当static作用于一个块内声明的变量时，将改变它的存储期限为静态存储期限\n\n当static作用于一个最外层声明的变量时，将改变它的链接为内部链接，使这个变量的内存单元不能被其它文件所访问\n\n### extern存储类型\n\n用extern来声明一个变量，不会让编译器为它分配内存单元，它只是告诉编译器，这个变量是在别的地方定义的。因此：当extern作用于一个变量时，这个变量必须拥有静态存储期限且一般有外部链接。一般这个变量都是一个在最外层定义的变量。\n\n### 函数存储类型\n\n默认情况下，函数存储类型都是extern的，代表此函数的链接是外部链接，可以被其它文件访问。\n\n如果给函数加上static声明，那么这个函数的链接就会被修改成内部链接，只能在文件内访问。如果一个函数不需要被多个模块共享，那么就应该声明成static的。\n\n## const限定符\n\n声明一个编译器维度上的常量，但却不能看做一个常量表达式，从而不能定义一个数组的边界（应该用#define）。\n\nconst主要用于保护一个指针指向的对象不被修改，也就是定义一个常量指针，使其指向的空间不允许被修改。\n\n## 声明符\n\n声明符是由标识符和三个特殊符号组成的，这三个特殊符号是：\n\n- 放在标识符前面的`*`号\n\n- 放在标示符后面的`()`或者`[]`\n\n### 解释复杂声明\n\n有时候声明符包含了多个特殊符号，这就要通过两条规则进行解释才能理解。它们是：\n\n- 始终从内向外读声明符，也就是先定位标识符，然后往外读\n\n- `[]`和`()`始终优先于`*`，但`()`可以强制修改优先级\n\n## 初始化式\n\n在声明一个变量时，可以给它`=`一个初始值，这叫初始化式，而不是赋值。\n\n需要注意的几点：\n\n- 静态变量只能用常量表达式初始化，如果没有初始化，那么就是0\n\n- 拥有自动存储期限的变量如果没有初始化，其值就是未定义的（包括数组）\n\n- 数组的初始化（大括号闭合）必须用常量表达式初始化每一个元素# 第十九章 程序设计\n\n虽然C语言不是专门用来编写大规模程序的，但许多大规模程序的确是用C语言编写的。相对于小型程序，编写一个大规模的程序需要更仔细的设计和更详细的计划。\n\n---\n\n## 模块\n\n当设计一个C程序（或其他任何语言的程序）时，最好将它看作是一些独立的模块。模块是一组功能（服务）的集合，其中一些功能可以被程序的其他部分（称为客户）使用。每个模块都有一个接口来描述所提供的功能。模块的细节，包括这些功能自身的源代码，都包含在模块的实现中。\n\n在C语言环境下，这些“功能”就是函数，模块的接口就是头文件，头文件中包含那些可以被其他文件调用的函数的原型。模块的实现就是包含该模块中函数的定义的源文件。\n\n将程序分割成模块有一系列好处：\n\n- 抽象。我们知道模块会做什么，但不需要知道这些功能是如何被实现的。因为抽象的存在，使我们不必为了修改部分程序而了解整个程序是如何工作的。\n\n- 可复用性。每一个提供一定功能的模块，都有可能在另一个程序中复用。\n\n- 可维护性。将程序模块化后，程序中的错误通常只会影响一个模块，因为更容易找到并解决错误。在解决了错误后，重新编译程序只需要将该模块的实现进行编译即可。\n\n一旦我们已经认同了模块化程序设计是正确的方向，接下来的问题就是设计程序的过程中究竟应该定义哪些模块。\n\n### 内聚性与耦合性\n\n一个好的模块并不是随意的一组声明。好的模块应该具有下面两个性质：\n\n- 高内聚性。模块中的元素应该相互紧密相关。\n\n- 低耦合性。模块之间应该尽可能相互独立。低耦合性可以使程序更便于修改，并方便以后复用模块。\n\n### 模块的类型\n\n由于需要高内聚性、低耦合性，模块通常会属于下面几类：\n\n- 数据池。表示一些相关变量或常量的集合。通常这类模块是一些头文件。\n\n- 库。库是一组相关函数的集合。\n\n- 抽象对象。一个抽象对象是指对于隐藏的数据结构进行操作的一组函数的集合。\n\n- 抽象数据类型。将具体数据的实现方式隐藏起来的数据类型称为抽象数据类型。作为客户的模块可以使用该类型来声明变量，但不会知道这些变量的具体数据结构。如果客户模块需要对变量进行操作，则必须调用抽象数据类型所提供的函数。\n\n## 信息隐藏\n\n一个设计良好的模块经常对它的客户隐藏一些信息。例如我们的栈模块的使用者就不需要知道究竟栈是用数组实现的还是用链表。信息隐藏有两大优点：\n\n- 安全性。数据必须通过模块自身提供的函数来操作，而这些函数都是经过测试的。\n\n- 灵活性。无论对模块的内部机制进行多大的改动，都不会很复杂。不需要改变模块的接口。\n\n在C语言中，可以用于强行信息隐藏的工具是 static 存储类型。将一个函数声明成 static 类型可以使函数内部链接，从而阻止其他文件（包括模块的客户）调用这个函数。将一个带文件作用域的变量声明成 static 类型可以达到类似的效果，使该变量只能被同一个文件中的其他函数访问。\n\n## 抽象数据类型\n\n对于作为抽象对象的模块，有一个缺点：不可能对同一个对象有多个实例。为了达到这个目的，需要进一步创建一个新的类型。这就是抽象数据类型。然后模块的接口函数需要传入这个类型对象的指针对其进行操作。\n\n但C语言不提供封装的功能，客户可以访问抽象数据类型的成员。确实有技巧可以达到类似的目的，但使用起来笨拙。\n\n实现封装的最佳方法是使用C++语言。实际上，C++语言产生的原因之一就是因为C语言不能很好的支持抽象数据类型。\n\n## C++语言\n\n略。# 第二十章 低级程序设计\n\n前面几章中讨论的是C语言中高级的、与机器无关的特性。有一些程序需要进行位级别的操作。位操作和其他一些低级运算在编写系统程序、加密程序、图形程序以及一些需要高执行速度或高效地使用空间的程序时非常有用。\n\n本章描述的一些技术需要用到数据在内存中如何存储的知识，这对不同机器和编译器可能会不同。依赖于这些技术很可能会使程序丧失可移植性。\n\n---\n\n## 按位运算符\n\n### 移位运算符\n\n移位运算符可以改变数的二进制形式，将它的位向左或者向右移动。\n\n|符号|含义|\n|:-:|:-:|\n|<<|左移位|\n|>>|右移位|\n\n运算符`<<`和`>>`的操作数可以是任意整数型或字符型的。对两个操作数都会进行整数提升，返回值的类型是左边操作数提升后的类型。\n\n`i<<j`的值是将i中的位左移j位后的结果。每次从i的最左端溢出一位，在i的最右端补一个0位。`i>>j`的值是将i中的位右移j位后的结果。如果i是无符号数或非负数，则需要在i的最左端补0。如果i是负值，其结果是由实现定义的。一些补0，一些补1。\n\n!!!note\n    可移植性技巧：最好仅对无符号数进行移位运算。\n\n### 按位求反、按位与运算符、按位异或运算符和按位或运算符\n\n|符号|含义|\n|:-:|:-:|\n|~|按位求反|\n|&|按位与|\n|^|按位异或|\n|\\||按位或|\n\n上面的顺序也是运算符优先级的顺序。\n\n## 结构中的位域\n\nC语言提供了声明成员为位域的结构。\n\n比如：\n\n```c\nstruct file_date {\n    unsigned int day:5;\n    unsigned int month:4;\n    unsigned int year:7;\n};\n\nstruct file_data fd;\nfd.day = 28;\nfd.month = 12;\nfd.year = 8; /* represents 1988 */\n```\n\n这个结构占据32个比特，每个成员后面的数字指定了它所占用位的长度。\n\n位域有一个限制，C语言不允许将&运算符作用于位域。\n\n位域之间没有间隙，直到剩下的空间不够用来放下一个位域了，这时，一些编译器会跳到下一个存储单元继续存放位域，而另一些则会将位域拆开跨存储单元存放。位域的存放的顺序也是由实现定义的。# 第二十一章 标准库\n\n---\n\n## 标准库的使用\n\nC89标准库有15个部分，即15个头文件。\n\n标准头主要由函数原型、类型定义和宏定义组成。\n\n**`<assert.h>` 诊断**\n\n允许程序插入自我检查，一旦检查失败，程序就被终止。\n\n**`<ctype.h>` 字符处理**\n\n提供用于字符分类及大小写转换的函数。\n\n**`<errno.h>` 错误**\n\n提供了error number，它是一个左值，可以在调用特定库函数后进行检测，来判断调用过程中是否有错误发生。\n\n**`<float.h>` 浮点类型的特性**\n\n提供了用于描述浮点类型特定的宏，包括值得范围及精度。\n\n**`<limits.h>` 整数类型的大小**\n\n提供了用于描述整数类型特性的宏，包括他们的最大值和最小值。\n\n**`<locale.h>` 本地化**\n\n提供一些函数来帮助程序适应针对某个国家或地区的特定行为方式。包括显示数的方式、货币的格式、字符集以及日期和时间的表示形式。\n\n**`<math.h>` 数学计算**\n\n提供常见的数学函数。\n\n**`<setjmp.h>` 非本地跳转**\n\n提供了setjmp和longjmp函数，setjmp会标记程序中的一个位置，随后可以用longjmp返回标记的位置。可以实现从一个函数跳转到另一个函数中，绕过正常的函数返回机制。主要用来处理程序中的严重问题。\n\n**`<signal.h>` 信号处理**\n\n提供了用于处理异常的函数，包括中断和运行时错误。signal可以设置一个函数，使系统信号到达时自动调用该函数；raise函数用来产生信号。\n\n**`<stdarg.h>` 可变参数**\n\n提供一些工具用于编写参数个数可变的函数。\n\n**`<stddef.h>` 常用定义**\n\n提供经验使用的类型和宏定义。\n\n**`<stdio.h>` 输入与输出**\n\n提供大量的输入和输出函数，包括对文件的顺序访问和随机访问操作。\n\n**`<stdlib.h>` 常用实用程序**\n\n包含大量无法划归其它头的函数。包含函数：将字符串转换成数，产生伪随机数，执行内存管理任务，与操作系统通信，执行搜索与排序等。\n\n**`<string.h>` 字符串处理**\n\n包含操作字符串的函数。\n\n**`<time.h>` 日期和时间**\n\n提供相应的函数来获取时间，操纵时间，以及格式化时间。\n\n### 对标准库中所用名字的限制\n\n只要包含了标准头（没有不包含的情况吧？），必须遵循两条规则：\n\n1. 不用自己定义标准头已定义过的宏\n\n2. 具有文件作用域的库名也不可以在文件层次重定义\n\n还有一些命名规则，不要与标准库有冲突：\n\n- 由一个下划线和一个大写字母开头，或由两个下划线开头的标识符，是标准库保留的标识符\n\n- 由一个下划线开头的标识符，被保留用作具有文件作用域的标识符和标记，只可用于函数内部声明\n\n- 在标准库中所有具有外部链接的标识符被保留用作具有外部链接的标识符，比如printf\n\n### 使用宏隐藏的函数\n\nC语言允许在头中定义与库函数同名的宏。从而使得宏隐藏掉函数。\n\n使用宏可能会提高程序的运行速度。如果有不想使用宏的情况，可能是因为想缩小可执行代码的大小。\n\n若要删掉宏，可用如下方法：\n\n```\n#include <stdio.h>\n#undef getchar\n```\n\n还可以禁用宏：\n\n```\n(getchar)()\n```\n\n## stddef.h 常用定义\n\n此头提供了常用的类型和宏的定义。定义的类型包括以下几个：\n\n- ptrdiff_t，指针相减的结果类型，是有符号整数\n\n- size_t，sizeof运算符返回的类型，是无符号整数\n\n- wchar_t，一种足够大的，可以用来表示所有支持的地区的所有字符的类型\n\n其中一个宏是：offsetof，其意思是求得结构体的起点到指定成员间的字节数。\n\n比如，有下面的结构体：\n\n```c\nstruct s {\n    char c;\n    int b[2];\n    float c;\n};\n```\n\noffsetof(struct s, a)的值一定是0，因为结构体的首元素的地址一定是结构体的地址；\n\noffsetof(struct s, b)的值可能是1，但也可能是4（考虑到字节对齐）。# 第二十二章 输入 输出\n\n---\n\n## 流\n\n流意味着任意输入的源或任意输出的目的地。输入流通常和键盘相关，输出流通常和屏幕相关。\n\n流还可以表示为磁盘上的文件，以及其他设备。\n\n### 文件指针\n\n流的访问是通过 **文件指针（file pointer）** 实现的。此指针的类型为`FILE*`。\n\nstdio.h提供了3种标准流，这三个标准流是备用的，不能声明、打开、关闭它们。\n\n|文件指针|流|默认的含义|\n|:-:|:-:|:-:|\n|stdin|标准输入|键盘|\n|stdout|标准输出|屏幕|\n|stderr|标准错误|屏幕|\n\n**重定向（redirection）**\n\n操作系统允许通过重定向机制来改变标准流默认的含义。\n\n例如：\n\n```\ndemo < in.data\n```\n\n称为**输入重定向（input redirection）**，即把stdin流表示为文件in.dat，而非键盘。对于程序demo而言，它并不知道输入流是来自键盘还是文件。\n\n这样子是**输出重定向（output redirection）**：\n\n```\ndemo > out.dat\n```\n\n如此一来，写入stdout的内容将不再输出到屏幕，而是文件out.dat。\n\n### 文本文件与二进制文件\n\n文件就是字节的序列。\n\n文本文件中，字节表示字符。\n\n二进制文件中，字节就是字节，可以用于表示任意类型的数据。\n\nDOS系统中，这两种文件之间有如下差异：\n\n- 行的结尾。文本文件写入换行符时，换行符扩展成一对字符，即回行符和跟随的回车符。如果把换行符写入二进制文件时，它就是一个单独的字符（换行符）。\n\n- 文件末尾。文本文件中，文件的结束标记是CTRL+Z字符（\\x1a）。二进制文件中，此字符没有特别的含义，跟其它任何字符一样。\n\n在Unix操作系统中，二进制文件和文本文件不进行区分，其存储方式一样。\n\n## 文件操作\n\n**打开文件**\n\n使用 fopen 函数。\n\n**关闭文件**\n\n使用 fclose 函数。\n\n**从命令行获取文件名**\n\n当程序需要打开一个文件时，通常通过命令行参数把文件名传给程序，这样更具灵活性。\n\n主函数：\n\n```c\nint main(int argc, char *argv[]);\n```\n\nargc是命令行实际参数的数量（非数组长度），argv是参数字符串数组。\n\nargv[0]是程序名，argv[1] ~ argv[argc-1]是剩余参数。\n\nargv[argc]是空指针。\n\n**临时文件**\n\ntmpfile 函数生成临时文件。\n\ntmpnam 函数生成一个临时的文件名。\n\n**文件缓冲**\n\n向磁盘直接读写数据相对比内存读写慢。使用缓冲区（buffer）来解决这个问题。写入流的数据首先放到缓冲区里面，当缓冲区满了（或关闭流）时，刷新缓冲区，把数据写入文件。\n\n输入流可以使用类似的方法进行缓冲：缓冲区包含来自输入设备的数据。\n\n使用 fflush 函数刷新缓冲区。\n\n**其它文件操作**\n\nremove 函数删除文件，rename 函数重命名文件。如果是用 fopen 和 tmpnam 产生的临时文件，可以使用 remove 把它删除，或者用 rename 使其成为永久文件。\n\n## 格式化的输入与输出\n\n即 ...printf 类函数 和 ...scanf 类函数的使用。\n\n### 检测文件末尾和错误条件\n\n每个流都有与之相关的两个指示器：**错误指示器**（error indicator），**文件末尾指示器**（end-of-file indicator）。\n\n打开流时，会清除这些指示器；流上的操作失败时会设置某个指示器。\n\n遇到文件末尾就设置文件末尾指示器，遇到错误就设置错误指示器。\n\n一旦设置了指示器，它就会保持这种状态，直到可能由 clearerr 调用而引发的明确清除操作为止。 clearerr 可以清除文件末尾指示器和错误指示器。\n\n如果设置了文件末尾指示器， feof 返回非零值。\n\n如果设置了错误指示器， ferror 返回非零值。\n\n## 字符的输入/输出\n\n输入输出的字符类型应使用int，原因之一是由于函数通过返回EOF说明文件末尾or错误情况，EOF是一个负的整型常量。\n\n### 输出函数\n\n```c\nint fputc(int c, FILE *stream);\nint putc(int c, FILE *stream);\nint putchar(int c);\n```\n\n### 输入函数\n\n```c\nint fgetc(FILE *stream);\nint getc(FILE *stream);\nint getchar(void);\n```\n\n## 行的输入/输出\n\n### 输出函数\n\n```c\nint fputs(const char *s, FILE *stream);\nint puts(const char *s);\n```\n\nputs函数向标准输出输出一行字符串，会自动添加一个换行符。\n\nfputs不会自动添加换行符。\n\n### 输入函数\n\n```c\nchar *fgets(char *s, int size, FILE *stream);\nchar *gets(char *s);\n```\n\ngets函数逐个读取字符，存储到s中，直到读到换行符时停止，并把换行符丢弃。\n\nfgets当读入了size-1个字符时或读到换行符时停止，且会存储换行符。\n\n如果出现错误，或者在存储任何字符之前达到了输入流的末尾，函数返回空指针。否则返回第一个实参。\n\n函数会在字符串的末尾存储空字符。\n\n## 块的输入输出\n\n```c\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\n\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n```\n\nfread函数和fwrite函数允许程序在单步中读写大的数据块。\n\nfwrite函数被设计用来把数组复制给流。第一个参数是数组首元素的地址，第二个参数是每个数组元素的大小（以字节为单位），第三个参数是要写的元素的数量，第四个参数是文件指针，说明了要写的数据位置。\n\nfwrite返回实际写入的元素数量，如果写入错误，此数就会小于第三个参数。\n\nfread函数从流读入数组的元素。其参数类似fwrite。\n\nfread返回实际读入的元素数量，此数应该等于第三个参数。否则可能达到了文件末尾或者出现了错误。使用feof和ferror确定出问题的原因。\n\n检查fread的返回值是非常重要的。\n\n## 文件的定位\n\n每个流都有相关联的**文件位置（file position）**。打开文件时，根据模式可以在文件的起始处或者末尾处设置文件位置。\n\n在执行读或写操作时，文件位置会自动推进。\n\nstdio.h提供了一些函数，用于确定当前的文件位置或者改变文件位置：\n\n```c\nint fseek(FILE *stream, long offset, int whence);\n\nlong ftell(FILE *stream);\n\nvoid rewind(FILE *stream);\n\nint fgetpos(FILE *stream, fpos_t *pos);\nint fsetpos(FILE *stream, fpos_t *pos);\n```\n\n**fseek**函数改变第一个参数相关的文件的位置。第二个参数说明新位置是根据文件的起始处、当前位置还是文件末尾来计算，也就是第三个参数来计算。\n\n第三个参数可取值为：\n\n- SEEK_SET，文件的起始处。\n\n- SEEK_CUR，文件的当前位置。\n\n- SEEK_END，文件的末尾处。\n\n**ftell**函数返回当前文件位置。如果发生错误，ftell返回-1L，并且把错误码存储到errno。\n\n**rewind**函数会把文件位置设置到起始处。rewind还会为fp清除错误指示器。\n\n**fgetpos**和**fsetpos**用于处理大的文件，使用fpos_t表示文件位置，它可能是一个结构。函数成功返回0，失败返回非0值并把错误码存放到errno中。\n\n## 字符串的输入/输出\n\nsprintf和snprintf函数将按写到数据流一样的方式写字符到字符串。\n\nsscanf函数从字符串中读出数据就像从数据流中读数据一样。\n\n### 输出函数\n\n```c\nint sprintf(char *str, const char *format, ...);\nint snprintf(char *str, size_t size, const char *format, ...);\n```\n\n类似于printf函数，唯一不同是sprintf函数把输出写入字符数组而不是流。当完成向字符串写入的时候，sprintf函数会添加一个空字符，并返回所存储的字符数量（不计空字符）。如果遇到错误，返回负值。\n\nsnprintf写入的字符数量不会超过size-1，结尾空字符不计。只要size不是0，都会有空字符。\n\n### 输入函数\n\n```c\nint sscanf(const char *str, const char *format, ...);\n```\n\nsscanf与scanf类似，唯一的不同就是sscanf从字符数组中读取数据而不是流。\n\nsscanf函数返回成功读入并存储的数据项的数量，如果在找到第一个数据项之前到达了字符串的末尾，那么sscan函数返回EOF。# 第二十三章 库对数值和字符数据的支持\n\n---\n\n## float.h：浮点型的特性\n\n提供了用来定义浮点型的范围及精度的宏。\n\n## limits.h：整型取值范围\n\n仅定义了每种整数类型的取值范围的宏。\n\n## math.h：数学计算\n\nmath.h里的函数处理的都是浮点类型的数值。\n\n在 UNIX/Linux 下编译，需要指明连接 math 库：-lm\n\nmath.h中定义的函数包含下面5种类型：\n\n- 三角函数 sin cos tan acos asin atan atan2\n\n- 双曲函数 cosh sinh tanh\n\n- 指数和对数函数 exp log ...\n\n- 幂函数 pow sqrt\n\n- 就近去整函数，绝对值函数和取余函数 ceil fabs floor fmod\n\n### 错误\n\n在math.h里声明的函数，如果出现错误（可能是参数不对），会把错误码存到errno。且若函数返回值大于double的最大值，那么函数会返回一个特殊值HUGE_VAL（double类型表示无穷大，Linux下输出成inf）。\n\nerrno有两种可能值：\n\n1. EDOM：代表定义域错误（Linux下值为33），即参数取值不对，比如给sqrt传一个负数。\n2. ERANGE：代表取值范围错误（返回值）（Linux下值为34），无法用double来表示了。比如exp(1000)。（PS：不是所有的数学函数出现返回值为无穷大时都会置errno为ERANGE）\n\n## ctype.h：字符处理\n\nctype.h提供了两类对字符进行处理的：\n\n1. 测试字符性质\n2. 对字符进行大小写转换\n\n## string.h：字符串处理\n\n这些函数的参数的合法性需要程序员来保证。\n\n### 复制函数\n\n```c\nvoid *memcpy(void *dest, const void *src, size_t n);\nchar *strcpy(char *dest, const char *src);\nchar *strncpy(char *dest, const char *src, size_t n);\n```\n\n### 拼接函数\n\n```c\nchar *strcat(char *dest, const char *src);\nchar *strncat(char *dest, const char *src, size_t n);\n```\n\n### 比较函数\n\n```c\nint strcmp(const char *s1, const char *s2);\nint strncmp(const char *s1, const char *s2, size_t n);\n```\n\n### 搜索函数\n\n```c\nchar *strchr(const char *s, int c);\nvoid *memchr(const void *s, int c, size_t n);\nchar *strrchr(const char *s, int c);\nchar *strtok(char *str, const char *delim);\n```\n\n### 其它函数\n\n```c\nvoid *memset(void *s, int c, size_t n);\nsize_t strlen(const char *s);\n```# 第二十四章 错误处理\n\n---\n\n## assert.h: 诊断\n\n```c\nvoid assert(int expression);\n```\n\nassert声明在assert.h中，实际上是一个宏。其参数必须是一种“断言”，即被认为正常情况下一定为真的表达式。\n\n每次执行assert时，判断此断言，若为假（0），则显示一条错误信息，并调用abort函数终止程序执行。\n\n这条错误信息包含了：断言（以文本格式）、包含assert调用的文件名、assert调用所在的行号。\n\n**禁止assert调用**\n\n方法是：在包含assert.h之前，定义宏NDEBUG。如：\n\n```c\n#define NDEBUG\n#include <assert.h>\n```\n\n## errno.h: 错误\n\n标准库中的一些函数通过向errno.h中声明的errno变量存储一个错误代码来表示有错误发生。\n\n大部分使用errno变量的函数集中在math.h，但也有一些在标准库的其他部分。\n\n如果errno不为0，则说明函数调用过程中有错误发生。\n\nerrno在程序开始的时候值为0，通常在调用函数前把errno置为0，库函数不会将errno清零，这是程序员的责任。\n\n用法如：\n\n```c\ny = sqrt(x); // x为负数则出错\nif (errno != 0) {\n    fprintf(stderr, \"sqrt error, terminated. \\n\");\n    exit(EXIT_FAILURE);\n}\n```\n\n**perror函数和strerror函数**\n\n```c\nvoid perror(const char *s);\nchar *strerror(int errnum);\n```\n\n当库函数向errno存储了一个非零值时，通过perror函数和strerror函数可以得到描述这种错误的信息。\n\nperror函数声明在stdio.h中，它会按照如下顺序把错误信息输出到stderr：\n\n    调用perror的参数: 出错消息（内容根据errno的值决定）\n\nstrerror函数声明在string.h中，它传入errno，返回一个指针，指向描述出错消息的字符串。\n\n## signal.h: 信号处理\n\nsignal.h提供了处理异常的工具，即信号（signal）。信号有两种类型：运行时错误（例如除以0），程序以外导致的事件（例如用户输入了ctrl+c）。\n\n当有错误或外部事件发生时，我们称产生了一个信号。大多数信号是**异步的**：它们可以在程序执行过程中的任意时刻发生。\n\n### 信号宏\n\nsignal.h定义了一系列宏，用于表示不同的信号。参见书本。\n\n### signal函数\n\n```\ntypedef void (*sighandler_t)(int);\nsighandler_t signal(int signum, sighandler_t handler);\n```\n\nsignal函数安装一个信号处理函数。第一个参数是信号的代码，第二个参数是一个指向信号处理函数的指针。\n\n一旦随后在程序执行过程中出现了对应的信号，信号处理函数就会被自动调用，信号的代码作为参数传递给信号处理函数。\n\n除非信号是由调用abort函数或raise函数引发的，否则信号处理函数不应该调用任何库函数，或者试图使用一个静态存储期限的变量。\n\n一旦信号处理函数返回，程序会从信号发生点恢复并继续执行。但是，如果信号是SIGABRT，当处理函数返回时程序会异常终止。如果信号是SIGFPE，那么处理函数返回的结果是UB（即不要使用它）。\n\nsignal函数的返回值是指定信号的前一个处理函数的指针。\n\n### 预定义的信号处理函数\n\nsignal.h提供了两个预定义的信号处理函数（都用宏表示）：\n\n- SIG_DFL。表示按默认方式处理信号，大多数情况下会导致程序终止。\n\n- SIG_IGN，指明随后当信号SIGINT发生时，忽略该信号。\n\n当程序刚开始执行时，根据不同的实现，每个信号的处理函数都会被初始化为SIG_DFL和SIG_IGN。\n\n如果signal调用失败（即无法对指定信号安装处理函数），就返回SIG_ERR（不是一个函数），并在errno中存入错误代码。\n\nC语言要求，除了SIGILL以外，当一个信号的处理函数被调用时，该信号的处理函数要被重置为SIG_DFL，或者以其他方式加以封锁。\n\n### raise函数\n\n```c\nint raise(int sig);\n```\n\n通常信号都是自然产生的，但也可以通过raise函数触发。\n\nraise函数的返回值可以用来测试调用是否成功：0代表成功，非0代表失败。\n\n## setjmp.h: 非局部跳转\n\n```c\n#include <setjmp.h>\nint setjmp(jmp_buf env);\nvoid longjmp(jmp_buf env, int val);\n```\n\n通常情况下，函数会返回到它被调用的位置。setjmp.h可以使一个函数直接跳转到另一个函数，而不需要返回。\n\nsetjmp宏“标记”程序中的一个位置，随后可以用longjmp函数跳转到该位置。这一机制主要用于错误处理。\n\nsetjmp宏会将当前“环境”保存到一个jmp_buf类型的变量中，然后返回0。如果要返回setjmp宏所标记的位置，可以使用longjmp函数，调用的参数是调用setjmp宏时使用的同一个jmp_buf类型的变量。longjmp函数首先会根据jmp_buf变量的内容恢复当前环境，然后从setjmp宏调用中返回。这次setjmp宏的返回值是val，即调用longjmp函数时的第二个参数（如果val是0，那么返回1）。\n\n如果longjmp的参数未被setjmp初始化，调用longjmp的结果是UB。# 第二十五章 国际化特性\n\n---\n\n## locale.h 本地化\n\nlocale.h提供的函数用于控制标准库中对于不同的地区会不一样的部分。\n\n地区通常指一个国家，或者一个国家的不同区域。\n\n在标准库中，依赖地区的部分包括：\n\n- 数值的格式。比如一些地区的小数点是用逗号表示\n\n- 货币的格式。不同国家的货币符号不同。\n\n- 字符集。字符集依赖于地区使用的语言。亚洲国家通常比西方国家需要更大的字符集。\n\n- 日期和时间的表示格式。\n\n### 类别\n\n通过修改地区，程序可以改变它的行为来适应不同地区。\n\n可以使用一些宏来指定一个**类型**：\n\n- LC_COLLATE。影响两个字符串比较函数的行为（strcoll和strxfm）。\n\n- LC_CTYPE。影响ctype.h中函数的行为，除了isdigit和isxdigit。同时还影响stdlib.h中的多字节函数。\n\n- LC_MONETRAY。影响由localeconv函数返回的货币格式信息。\n\n- LC_NUMERIC。影响格式化输入/输出函数使用的小数点字符以及stdlib.h中的字符串转换函数（atof和strtod），还会影响localeconv函数返回的非货币格式信息。\n\n- LC_TIME。影响strftime函数的行为，该函数将时间转换成字符串。\n\n### setlocale函数\n\n```c\nchar *setlocale(int category, const char *locale);\n```\n\nsetlocale函数修改当前的地区。如果第一个参数是LC_ALL，就会影响所有的类型。C语言标准对第二个参数仅定义了两种可能值：\"c\"和\"\"。其余的由实现定义，比如， gcc 对于简体中文的地区，可以是\"zh_CN.UTF-8\"\n\n程序执行开始时，都会隐含调用：`setlocale(LC_ALL, \"C\");`\n\n如果用\"\"作为第二个参数，就切换到了本地模式（native locale），这种模式下程序会适应本地的环境。\n\n如果调用成功，返回一个关于地区名字的字符串指针。如果调用失败，返回空指针。\n\nsetlocale函数也可以当作搜索函数使用，如果第二个参数是空指针，setlocale函数会返回一个指向字符串的指针，这个字符串与当前地区类型的设置相关联。\n\n### localeconv函数\n\n```c\nstruct lconv *localeconv(void);\n```\n\n函数返回的struct lconv结构包含了当前地区的详细信息，此结构具有静态存储期限。\n\n详细信息参考书本。\n\n## 多字节字符和宽字符\n\n因为定义已经把char型值的大小限制为一个字节，所以通过改变char类型的含义来处理更大的字符集显然是不可能的。\n\nC语言提供了两种可扩展字符集的编码：**多字节字符**（multibyte character）和**宽字符**（wide character）。\n\nC标准要求0字节始终用来表示空字符。\n\n### 多字节字符\n\n在多字节字符编码中，一个或多个字节表示一个可扩展字符。C语言要求的基本字符是单字节的。\n\n一些多字节字符集依靠**依赖状态编码**（state-dependent encoding）。在这类编码中，每个多字节字符序列都以**初始移位状态**（initial shift state）开始。序列中稍后遇到的一些多字节字符会改变移位状态，并且影响后续字节的含义。\n\nMB_LEN_MAX和MB_CUR_MAX说明了多字节字符中字节的最大数量。MB_LEN_MAX定义在limits.h中，给出了任意支持地区的最大值。MB_CUR_MAX定义在stdlib.h中，给出了当前地区的最大值。\n\n### 宽字符\n\n宽字符是一种其值表示字符的整数，所有宽字符要求相同的字节数。\n\n宽字符具有wchar_t类型。\n\n一个宽字符常量可以写成：`L'a'`\n\n一个宽字符字符串可以写成：`L\"abc\"`\n\n即在普通字符常量前用字母L作为前缀。\n\n!!!note \"my note\"\n    注意，在使用宽字符前，需要设置好本地环境，比如，要使用简体中文的宽字符，那么要先执行 `setlocale(LC_ALL, \"zh_CN.UTF-8\")` ，这样才能正确地解析宽字符。\n\n### 多字节字符函数\n\n```c\n#include <stdlib.h>\nint mblen(const char *s, size_t n);\nint mbtowc(wchar_t *pwc, const char *s, size_t n);\nint wctomb(char *s, wchar_t wc);\n```\n\n### 多字节字符串函数\n\n```c\n#include <stdlib.h>\nsize_t mbstowcs(wchar_t *dest, const char *src, size_t n);\nsize_t wcstombs(char *dest, const wchar_t *src, size_t n);\n```\n\n## 三字符序列\n\n见书本简要介绍。\n\n!!!note\n    这就是一种字符替换方式，由于某些国家不支持C语言的标准的字符书写方式。# 其他库函数\n\n---\n\n## stdarg.h 可变长度实参\n\n```c\nvoid va_start(va_list ap, last);\ntype va_arg(va_list ap, type);\nvoid va_end(va_list ap);\n```\n\nstdarg.h提供了一种工具可以让我们自行编写的函数具有可变长的参数列表（varying number of arguments of varying types）。stdarg.h定义了一种va_list类型和三种宏，名为va_start, va_arg, va_end, 可以把这些宏看成是带有上述原型的函数。\n\n书中使用了此例进行讲解：\n\n```c\nint max_int(int n, ...)    // n must be at least 1\n{\n    va_list ap;\n    int i, current, largest;\n\n    va_start(ap, n);\n    largest = va_arg(ap, int);\n\n    for (i = 1; i < n; ++i) {\n        current = va_arg(ap, int);\n        if (current > largest)\n            largest = current;\n    }\n\n    va_end(ap);\n    return largest;\n}\n```\n\n函数的第一个实参n说明了跟随其后的其他参数的数量。\n\n形参列表中的...符号表示可变数量的参数。带有可变参数的函数必须至少有一个“正常的”形参，在最后一个正常的参数后边始终会有省略号出现在参数列表的末尾。\n\n`va_list ap`声明了一个变量，使得函数可以访问到可变参数。\n\n`va_start(ap, n)`指出了实参列表中可变长度开始的位置。\n\n`va_arg(ap, int)`把获取当前的可变参数，然后自动前进到下一个可变参数处。int说明希望此参数是int类型的。\n\n函数返回前，使用语句`va_end(ap)`进行清扫。\n\n### 调用带有可变实参列表的函数\n\n调用带有可变实参列表的函数是一个固有的风险提议。\n\n这里主要的难点就是带有可变实参列表的函数很难确定传递过来的参数的数量或类型。所以必须把这个信息传递给函数，并且函数假设知道了这个信息。上述max_int函数依靠第一个实参来指明跟随其后的其他参数的数量，并且它还设定参数是int类型的。\n\n另一个问题就是不得不处理NULL作为参数的情况，具体见书本。\n\n### v...printf类函数\n\n```c\nint vprintf(const char *format, va_list ap);\nint vfprintf(FILE *stream, const char *format, va_list ap);\nint vsprintf(char *str, const char *format, va_list ap);\n```\n\n不同于printf等函数，v...printf类函数具有固定数量的实参，每个v...printf类函数的最后一个实参都是一个va_list型值。这个类型的值意味着此函数可以由带有可变实参列表的函数调用。\n\n实际上，v...printf类函数主要用于编写“包装”函数。包装函数接收可变数量的实参，并稍后把这些参数传递给v...printf类函数（通过va_list）。\n\n这种包装函数的核心内容是：\n\n- va_start(ap, arg)\n\n- 把ap传递给v...printf\n\n- va_end(ap)\n\n## stdlib.h 通用的实用工具\n\n### 字符串转换函数\n\n```c\nint atoi(const char *nptr);\nlong long atoll(const char *nptr);\n\nlong int strtol(const char *nptr, char **endptr, int base);\nlong long int strtoll(const char *nptr, char **endptr, int base);\n```\n\n### 伪随机生成函数\n\n伪随机数的生成方法是：\n\n- 先设置一个随机种子（srand）\n\n- 调用rand函数根据随机种子生成一个伪随机数\n\n如果每次程序运行的随机种子都一样，那么rand出来的数就会一样。因此通常采用当前时间戳作为随机种子（但如果两次启动间隔不足一秒，时间戳也是一样滴）。\n\n```c\nvoid srand(unsigned int seed);\nint rand(void);\n```\n\n### 与环境的通信\n\n与外部通信的标准库函数可以：\n\n- 为操作系统返回一个程序结束的状态码\n\n- 获取环境变量\n\n- 执行操作系统的命令\n\n**返回状态码**\n\n在main中执行return语句，即返回了一个状态码给操作系统；或者在程序的任意处执行exit函数，也可以终止程序并返回一个状态码给操作系统。\n\nexit是正常性质的结束程序，可以清理程序打开的资源。\n\natexit函数还可以注册一个函数，在程序正常结束前，执行这个注册函数。可以注册多个atexit函数，调用顺序和注册顺序一致。\n\n```c\nvoid exit(int status);\nint atexit(void (*function)(void));\n```\n\n**获取环境变量**\n\n环境变量是一组存放到静态存储区的字符串，描述了操作系统的环境，比如PATH。使用getenv就可以获取它的值。\n\n```c\nchar *getenv(const char *name);\n```\n\n**执行命令**\n\n主要是通过system函数执行一个外部的命令。system函数返回该命令的终止状态码。\n\n```c\nint system(const char *command);\n```\n\n### 搜索和排序工具\n\n用于搜索的工具是：bsearch（实现为二分查找），用于排序的工具是：qsort（实现为快速排序）。\n\n```c\nvoid qsort(void *base, size_t nmemb, size_t size,\n                  int(*compar)(const void *, const void *));\n\nvoid *bsearch(const void *key, const void *base,\n                     size_t nmemb, size_t size,\n                     int (*compar)(const void *, const void *));\n```\n\n### 整数算术运算函数\n\n**abs求绝对值**\n\n函数原型：\n```c\nint abs(int j);\n```\n\n**div求除法运算结果**\n\n函数原型：\n```c\ndiv_t div(int numerator, int denominator);\n```\n\n结果是第一个实参除以第二个实参。结果是一个div_t类型，它包含了商和余数，定义如下：\n```c\ntypedef struct\n{\n    int quot;    /* Quotient.  */\n    int rem;     /* Remainder. */\n} div_t;\n```\n\n但第二个实参一定不能为0，不然就会出现段错误。因此判断除数是否合法的责任就交给了程序员。\n\n## time.h 日期和时间\n\n标准库提供了三种表示时间的类型：\n\n0. clock_t：按照“时钟滴答”进行测量的时间值\n\n0. time_t：日历时间（时间戳），由于这个类型在不同平台下定义不同（unsigned int or long），因此输出的时候应当做一个强制转换。\n\n0. struct tm：分解时间，一种适合人类理解的时间格式\n\nclock_t和time_t是支持算术运算的，但是它们具体是整型还是浮点型并没有被C标准说明。但struct tm的类型定义很清楚：\n\n|成员|说明|\n|-|-|\n|tm_sec|分后的秒，[0, 61]，允许两个额外的闰秒|\n|tm_min|时后面的分，[0, 59]|\n|tm_hour|午夜后的时，0到23|\n|tm_mday|月份中的第几天，[1,31]|\n|tm_mon|一月份以后的月，[0,11]|\n|tm_year|从1900年开始的年|\n|tm_wday|星期日以后的天，[0,6]|\n|tm_yday|一月一日后的天，[0,365]|\n|tm_isdst|夏令时标记，夏令时有效为正数，否则为0，如果未知，可为-1|\n\n**时钟滴答**\n\n```c\nclock_t clock(void);\n```\n\nclock函数返回处理器的时间（时钟滴答），即程序开始运行到执行到此的消耗的时间。但它的单位不是秒，为了将它转换成秒，可以给它除以宏CLOCK_PER_SEC。\n\nclock_t不能表示日期，只是善于表示时间区间（两个clock_t相减获得比较精准的时间差）。\n\n```c\n(clock() - start_clock) / (double)CLOCK_PER_SEC\n```\n\n加double强制转换的理由是，标准C没有指明宏CLOCK_PER_SEC的类型，也没有说明clock_t的类型，所以必须用强制转换明确一下类型。\n\n**日历时间**\n\n```c\ntime_t time(time_t *t);\ndouble difftime(time_t time1, time_t time0);\n```\n\ntime用来获取时间戳（UNIX从1970年为纪元），difftime获取两个时间戳的间隔，但这种计算间隔的方式没有用clock_t计算精准。\n\n**分解时间**\n\n```c\ntime_t mktime(struct tm *tm);\nstruct tm *localtime(const time_t *timep);\nchar *asctime(const struct tm *tm);\n```\n\n- mktime将分解时间转换成日历时间（时间戳）。但它有一个很好得到地方，除了转换成日历时间，它还会先修正分解时间，如果分解时间中的某些值不正确的话。修正的规则就是“进位”，把溢出的时间补给高位的时间。比如tm_mday超过了31，那么tm_mon就会增加至少1。可以利用这一个修正的规则来计算未来的日期。见代码案例。\n\n- localtime根据日历时间，获得本地的分解时间\n\n- asctime获取分解时间的字符串格式，末尾还会有一个换行符\n\n**时间转换函数**\n\n有 ctime strftime 等。","source":"_posts/2019-CProgramming.md","raw":"---\ntitle: C语言学习笔记\ntop: ture\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 19:28:05\npassword:\nsummary: C语言是20世纪70年代初期，在贝尔实验室开发出来的一种用途广泛的编程语言。\ntags:\n- C语言\ncategories:\n- C语言\n---\n\n# 第一章 C语言概述\n\nC语言是20世纪70年代初期，在贝尔实验室开发出来的一种用途广泛的编程语言。\n\n---\n\n## C语言的历史\n\nC语言是Unix系统开发过程中的一个副产品。它被用来重写Unix系统。\n\n到20世纪80年代，许多计算机开始使用C语言开发程序，为了保证其程序的可移植性，建立标准成为了共识。\n\n1989年，通过C89标准。\n\n1999年，通过C99标准，但这个标准还没有被普遍使用。\n\n### C++ 语言\n\n虽然采纳了 ANSI/ISO 标准以后C语言自身不再发生变化。但是，从某种意义上说，随着基于C语言的新式语言的产生，C语言的演变还在继续。新式语言包括C++。它在许多方面对C语言进行了扩展，尤其是增加了面向对象编程的特性。\n\n随着C++语言的迅速普及，在不久的将来你很可能会用C++语言编写程序。果真如此，为何还要费心学习C语言呢？首先，C++语言比C语言更加难学，因此在掌握C++语言前，最好先精通C语言；其次，我们身边存在着大量的C语言代码，需要去维护和阅读；最后，不是每个人都喜欢改用C++编程，例如对于编写小规模的程序，使用C++反而不会获得多少好处。\n\n## C语言的优缺点\n\nC语言的优缺点都源于它最初的用途，以及其基础理论体系。\n\n- C语言是一种底层语言。它提供了对内存访问的功能。C程序的许多服务都依赖于操作系统提供的接口。\n\n- C语言是一种小型语言。C语言的特性不多，应用程序的绝大部分功能依赖于标准库。\n\n- C语言是一种包容性语言。C语言假设用户知道自己在做什么，因此有编写自由度。C语言不强制进行错误检查。\n\n### C语言的优点\n\n1. 高效。发明C语言的目的是为了替代汇编语言。\n\n2. 可移植。有标准库的存在。\n\n3. 功能强大、灵活。C语言的数据类型和运算符集合有足够强大的表达能力。\n\n4. 与Unix集成。\n\n### C语言的缺点\n\n1. C程序更容易隐藏错误。由于其灵活性，导致编写的代码令编译器很难检查错误。\n\n2. C程序可能会难以理解。\n\n3. C程序可能会难以修改。因为它设计时没考虑到维护的问题。C语言没有提供类，包等模块化概念。\n\n### 高效地使用C语言\n\n1. 学习规避C语言的缺陷。比如越界问题。\n2. 使用软件工具。\n3. 利用现有的代码库。\n4. 采用切合实际的编码规范。\n5. 避免“投机取巧”和极度复杂的代码。\n6. 使用标准C，少用经典C。标准C即是 ANSI C ，本书采用的是标准C。\n7. 避免不可以移植性。# 第二章 C语言基本概念\n\n---\n\n## 编写一个简单的C程序\n\n### 程序：显示双关语\n\n这是经典C的一个示例：\n\n```c\n// pun.c\n#include <stdio.h>\n\nmain()\n{\n    printf(\"To C, or not to C: that is the question.\\n\");\n}\n```\n\n### 编译和链接\n\n首先，需要一个.c文件保存程序代码，接下来需要把程序转换为机器可以执行的形式。通常包含下列三个步骤：\n\n- 预处理。首先会把程序送交给预处理器（ preprocessor ）。预处理器执行以#开头的命令。\n\n- 编译。修改后的程序现在可以进入编译器（ compiler ）了。编译器会把程序翻译成机器指令（即目标代码， object code ）。\n\n- 链接。链接器（ linker ）把由编译器产生的目标代码和任何其他附加代码整合在一起，产生完全可执行的程序。\n\n这个过程可以一步完成，即：\n\n```bash\ncc pun.c\n```\n\n在编译和链接好程序后，编译器 cc 会把可执行程序放到默认名为 a.out 的文件中。编译器 cc 有许多选项，其中 -o 允许给可执行程序选择一个名字：\n\n```bash\ncc -o pun pun.c\n```\n\n如果使用 gcc 进行编译，那么建议在编译时采用 -Wall 选项：\n\n```bash\ngcc -Wall -o pun pun.c\n```\n\n也可以手动分布完成：\n\n```bash\ncc -o main.i -E main.c # 预编译\ncc -o main.o -c main.i # 编译\ncc -o main main.o      # 链接\n```\n\n## 简单程序的一般形式\n\n形式如：\n\n```c\n指令\n\nint main()\n{\n    语句\n}\n```\n\n### 指令\n\n在编译C程序之前，预处理器会首先对C程序进行编辑。我们把预处理器执行的命令称为指令。这里只关注 #include 指令。\n\n```c\n#include <stdio.h>\n```\n\n这条指令说明，在编译前把 stdio.h 中的信息“包含”到程序中。这段程序中包含 stdio,h 的原因是：C语言没有内置的“读”和“写”命令。因此，进行输入/输出操作就需要用标准库中的函数来实现。\n\n这里是指预所有指令都是以#开头。一条指令必须占据一行，且不留分号结尾。\n\n### 函数\n\n函数是用来构建程序的一个构建块。C程序就是函数的集合。函数分为两大类：一类是程序员编写的函数，另一类则是由C语言的实现所提供的函数。后者可以称为库函数（ library function ）。\n\n在C语言中，函数仅仅是一系列组合在一起并且赋予了名字的语句。某些函数计算一个值，而某些函数不是。计算出一个值的函数可以用 return 语句来指定所“返回”的值。\n\n每个程序必须有一个 main 函数。 main 函数是非常特殊的：在执行程序时系统会自动调用 main 函数。\n\nmain 函数在程序终止时向操作系统返回一个状态码。 pun 程序始终让 main 函数返回0，0表明程序正常终止。\n\n建议加入 return 语句，如果不这样做，某些编译器可能会产生一条警告信息：\n\n```c\n// pun.c\n#include <stdio.h>\n\nmain()\n{\n    printf(\"To C, or not to C: that is the question.\\n\");\n    return 0;\n}\n```\n\n### 语句\n\n语句是程序运行时执行的命令。每条语句都要以分号结尾。\n\n一条语句可以占据多行。\n\n程序 pun.c 只用到了两种语句。一种是返回语句，一种则是函数调用（ function call ）语句。为了在屏幕上显示一条字符串就调用了 printf 函数。\n\n### 显示字符串\n\n我们用 printf 函数显示了一条字符串字面量（ string literal ）。字符串字面量是用一对双引号包围的一系列字符。\n\n当打印结束时， printf 函数不会自动跳转到下一输出行。为了让 printf 跳转到下一行，必须要在打印的字符串中包含一个 \\n （换行符）。写换行符就意味着终止当前行，然后把后续的输出转到下一行进行。\n\n换行符可以在一个字符串字面量中出现多次。比如：\n\n```c\nprintf(\"Brevity is the soul of wit.\\n -- Shakespeare\\n\");\n```\n\n### 注释\n\n注释就是代码的说明。在预编译后，注释会移除出代码。\n\n例如：\n\n```c\n/* This is a comment */\n```\n\n为 pun.c 增加注释：\n\n```c\n/*\tName: pun.c\n\tPurpose: Prints a bad pun.\n\tAuthor: K.N.King\n\tData written: 5/21/95\n*/\n```\n\n## 变量和赋值\n\n变量（ variable ）就是用来存储数据的存储单元。\n\n### 类型\n\n一个变量必须有一个类型。类型决定了存储单元的大小和对变量的操作方式。\n\nint 型变量可以存储整数，例如0、1、392或者-2553，但是，整数的取值范围是受限制的。某些计算机上，int型数值的最大取值仅仅是32767。\n\nfloat 型变量可以存储更大的数值，而且，float型变量可以存储带小数位的数据，例如379.125。但是，float 型变量有一些缺陷，即这类变量需要的存储空间要大于 int 型变量。而且，进行算术运算时 float 型变量通常比 int 型变量慢。另外， float 型变量所存储的数值往往只是实际数值的一个近似值。\n\n### 声明\n\n在使用变量前，必须对其进行声明，这也是为了便于编译器工作。例如，声明变量 height 的方式如：\n\n```c\nint height;\n```\n\n如果几个变量具有相同的类型，就可以把它们的声明合并：\n\n```c\nint height, length, width;\n```\n\n当 main 函数包含声明时，必须把声明放置在语句之前：\n\n```c\nmain()\n{\n    声明\n    语句\n}\n```\n\n### 赋值\n\n变量可以通过赋值（ assignment ）的方式获得一个值。例如：\n\n```c\nheight = 8;\nvolume = height * length * width;\n```\n\n赋值运算符的右侧可以是一个含有常量、变量和运算符的公式（表达式， expression ）。\n\n### 显示变量的值\n\n用 printf 可以显示当前变量的值。\n\n```c\nprintf(\"Height: %d\\n\", height);\n```\n\n占位符 %d 用来指明在打印过程中变量 height 的值的显示位置。 %d 仅用于 int 型变量，如果要打印 float 型变量，需要用 %f 来代替。默认情况下， %f 会显示小数点后6位数字，若需要显示小数点后n位数字，则可以把 .n 放置在%和f之间。\n\n```c\nprintf(\"Profit: $%.2f\\n\", profit);\n```\n\n### 初始化\n\n当程序开始执行时，某些变量会被自动设置为0，而大多数变量则不会。没有默认值并且尚未在程序中被赋值的变量是未初始化的（ uninitialized ）。\n\n使用初始化式对其变量进行初始化，如：\n\n```c\nint a = 0;\n```\n\n## 读入输入\n\n为了获取输入，就要用到 scanf 函数。 scanf 中的字母f和 printf 中的f含义相同，都是表示“格式化”的意思。 scanf 和 printf 函数都需要使用格式串（ format string ）来说明输入或输出的样式。\n\n为了读取一个 int 型数值，可以使用如下的 scanf 函数调用。\n\n```c\nscanf(\"%d\", &i);\n```\n\n字符串“%d”说明 scanf 读入的是一个整数，i是一个 int 型变量，用来存储读入的输入。\n\n读入一个 float 型数值时，需要这样的 scanf 调用：\n\n```c\nscanf(\"%f\", &x);\n```\n\n%f只适用于 float 型变量。\n\n## 定义常量\n\n常量（ constant ）是在程序执行过程中固定不变的量。当程序含有常量时，建议给这些常量命名。方式是使用宏定义（ macro defination ）。\n\n```c\n#define N 4\n```\n\n这里的 #define 是预处理指令。当程序进行编译时，预处理器会把每一个宏用其表示的值替换回来。\n\n此外，还可以利用宏来定义表达式：\n\n```c\n#define SCALE_FACTOR (5.0 / 9.0)\n```\n\n当宏包含运算时，必须用括号把表达式括起来。\n\n宏的名字一般用大写字母，这是大多数程序员遵守的规范。\n\n## 标识符\n\n标识符就是函数、变量、宏等实体的名字。\n\n标识符由字母、数字和下划线组成，且区分大小写。必须以字母或下划线开头。\n\n为了使名字清晰，可以使用两种命名风格：\n\n```c\nsymbol_table\nSymbolTable\n```\n\n**关键字**\n\n关键字（ keyword ）对编译器而言都有特殊的含义，因此标识符不能和关键字一样。\n\n所有的关键字见书本p19\n\n## C语言程序的布局\n\nC程序可以被看成一连串的**记号（ token ）**。记号就是无法分割的字符组。\n\n标识符、关键字、运算符、字符串等都是记号。\n\n记号之间可以有空格，换行等字符。\n\n有记号的概念后，C程序就可以这样书写：\n\n- 语句可以放到多行内。对于很长的语句这样很合适。\n\n- 记号间的空格可以更容易区分记号。比如运算符两边加空格方便阅读。\n\n- 缩进有助于识别程序嵌套。\n\n- 空行可以把程序划分为逻辑单元。# 第三章 格式化输入输出\n\nscanf 函数和 printf 函数是C语言使用最频繁的两个函数，它们用来支持格式化的读和写。\n\n---\n\n## printf 函数\n\nprintf 函数被设计用来显示格式串（ format string ）的内容，并且在字符串指定位置插入可能的值。\n\n```c\nprintf(格式串, 表达式1, 表达式2, ...);\n```\n\n格式串包含普通字符和转换说明（ conversion specification ），其中转换说明以字符%开头。\n\n!!!warning\n\tC语言编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配。\n\n### 转换说明\n\n在通用的情况下，转换说明可以有%m.pX格式或%-m.pX格式，这里的m和p都是整型常量，X是字母。m和p都是可选项。\n\n在转换说明%10.2f中，m是10，p是2，X是f。\n\n**最小字段宽度（ minimum field width ）** m指定了要显示的最小字符数量。如果要打印的数值比m个字符少，那么值在字段内是右对齐的。如果要多，那么字段宽度会自动扩展为需要的尺寸。\n\n**精度（ precision ）** p的含义依赖于**转换说明符X（ conversion specifier ）**的选择。对数来说，最常用的转换说明符有：\n\n- d，表示十进制形式的整数。p说明可以显示的数字的最少个数（如果需要，就在数前加上额外的零）；如果忽略掉p，默认它的值为1。\n\n- e，表示指数形式的浮点数。p说明小数点后应该出现的数字的个数（默认为6）。如果p为0，则不显示小数点。\n\n- f，表示“定点十进制”形式的浮点数，没有指数。p的含义与在说明符e中的一员。\n\n- g，表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。p可以说明显示的有效数字的最大数量。与转换说明符f不同，g的转换将不显示尾随零。\n\n### 转义序列\n\n我们经常把在格式串中用的代码`\\n`称为转义序列（ escape sequence ）。转义序列使字符串包含一些特殊字符而又不会使编译器引发问题。\n\n详细的说明：https://zh.cppreference.com/w/cpp/language/escape\n\n## scanf 函数\n\nscanf 函数也根据特定的格式读取输入， scanf 函数转换说明符的用法和 printf 函数转换说明符的用法本质上是一样的。\n\nscanf 函数有一些不易察觉的陷阱。使用 scanf 时，程序员必须检查转换说明的数量是否与输入变量的数量相匹配，并且检查每个转换是否适合相对应的变量。另一个陷阱涉及符号&，通常把符号&放在 scanf 函数调用的每个变量的前面。\n\n调用 scanf 函数是读取数据的一种有效但不理想的方法。许多专业C程序员避免用 scanf 函数，而是采用字符格式读取所有数据，然后再把它们转换成数值形式。\n\n### scanf 函数的工作方法\n\nscanf 函数本质上是一种“模式匹配”函数，也就是试图把输入的字符组与转换说明匹配成组。\n\nscanf 调用时，从左边开始处理字符串中的信息。对于格式串中的每一个转换说明， scanf 函数努力从输入的数据中定位适当类型的项，并且跳过必要的空格。然后， scanf 函数读入数据项，并且在遇到不可能属于此项的字符时停止。\n\n在寻找数的起始位置时， scanf 函数会忽略空白（ white-space ）字符（空格符、横向和纵向制表符、换页符、换行符）。\n\n### 格式串中的普通字符\n\n处理格式串中普通字符时， scanf 函数采取的动作依赖于这个字符是否为空白字符。\n\n- 空白字符。当在格式串中遇到一个或多个连续的空白字符时， scanf 函数从输入中重复读空白字符直到遇到一个非空白字符（把该字符“放回原处”）为止。\n\n- 其他字符。当在格式串中遇到一个非空白字符时， scanf 函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么 scanf 函数会放弃输入字符而继续处理格式串。如果两个字符不匹配，那么 scanf 函数会把不匹配的字符放回输入中，然后异常退出。# 第四章 表达式\n\n表达式是显示如何计算值的公式。最简单的表达式是变量和常量。变量表示程序运行时计算出的值；常量表示不变的值。\n\n运算符是构建表达式的基本工具。C语言提供了基本的运算符：\n\n- 算术运算符。\n- 关系运算符。\n- 逻辑运算符。\n\n---\n\n## 算术运算符\n\n算术运算符有：\n\n|一元运算符|二元运算符|\n|:-:|:-:|\n|+ -|+ - * / %|\n\n二元运算符要求有两个操作数，而一元运算符只要有一个操作数。\n\n一元运算符+无任何操作，它主要是为了强调某数值常量是正的。\n\n%被称之为 mod （求模）或 rem （取余）。 i % j 的数值是i除以j后的余数。\n\n除了%，二元运算符既允许操作数是整数也允许操作数是浮点数，或者允许两者的混合。当把 int 型操作数和 float 型操作数混合在一起时，运算结果是 float 型的。\n\n运算符/和%需要特别注意：\n\n- /可能产生意外的结果。当两个操作数都是整数时，运算符/通过丢掉分数部分的方法截取结果，因此1/2的结果是0。\n- %要求整数操作数；如果两个操作数中有一个不是整数，那么程序将无法通过编译。\n- 当/和%用于负数时，其结果与具体实现有关。如果操作数中有一个为负数，那么除法的结果既可以向上取整也可以向下取整。\n\n!!!note \"由实现定义\"\n\t术语由实现定义（ implementation-defined ）出现频率很高，意思是指软件在特定的平台上编译、链接和执行。根据实现的不同，程序的行为可能会稍有差异。\n\tC语言的目的之一是达到高效率，这经常意味着要与硬件行为相匹配。当-9除以7时，一些机器可能产生的结果是-1，而另一些机器的结果为-2，C标准简单地反映了这一现实。\n\t最好避免编写与实现定义的行为相关的程序。\n\n### 运算符的优先级和结合性\n\nC语言允许在所有表达式中用圆括号进行分组。但如果不使用圆括号，就采用运算符优先级（ operator precedence ）的规则来解决问题。算术运算符有下列相对优先级：\n\n- 最高优先级：+ -（一元运算符）\n- 中级优先级：* / %\n- 最低优先级：+ -（二元运算符）\n\n例如：\n\n```c\ni + j * k;    // 等价于 i + (j * k)\n```\n\n当一个表达式包含两个以上相同优先级的运算符时，单独的运算符优先级的规则是不够的。这种情况下，运算符的结合性（ associativity ）开始发挥作用。如果运算符是从左向右结合的，那么称这种运算符是左结合的（ left associative ）。二元算术运算符都是左结合的，所以：\n\n```c\ni - j - k;    // 等价于 (i - j) - k\n```\n\n如果运算符是从右向左结合的，那么称为右结合的（ right associative ）。一元运算符都是右结合的。\n\n## 赋值运算符\n\n一旦计算出表达式的值就常常需要把这个值存储在变量中，以便后面使用。C语言的=运算符（assignment）可以用于此目的。\n\n### 简单赋值\n\n表达式v = e的赋值效果是求出表达式e的值，并把此值复制给v。e可以是常量、变量或较为复杂的表达式：\n\n```c\ni = 5;\nj = i;\nk = 10 * i + j;\n```\n\n如果v和e的类型不同，那么赋值运算发生时会把e的值转化为v的类型：\n\n```c\nint i;\ni = 72.99; /* i is now 72 */\n```\n\n赋值操作产生结果，赋值表达式v=e的值就是赋值运算后v的值。因此，表达式i = 72.99的值是72。\n\n!!!note \"副作用\"\n\t大多数C语言运算符不会改变操作数的值，但是也有一些会改变。由于这类运算符所做的不再仅仅是计算出值，所以称它们有副作用（ side effect ）。简单的赋值运算符就是一个有副作用的运算符，它改变了运算符左边的操作数。表达式i=0产生的结果为0，作为副作用，把0赋值给i。\n\n运算符=是右结合的。所以：\n\n```c\ni = j = k = 0;\ni = (j = (k = 0)); // 等价\n```\n\n### 左值\n\n大多数C语言运算符允许它们的操作数是变量、常量或者包含其他运算符的表达式。然而，赋值运算符要求它左边的操作数必须是左值（ lvalue ）。左值表示存储在计算机内存中的对象，而不是常量或计算结果。变量是左值，而诸如10或2*i这样的表达式则不是左值。\n\n### 复合赋值\n\n利用变量原有值计算出新值并重新赋值给这个变量在C语言程序中是非常普遍的。例如：\n\n```c\ni = i + 2;\n```\n\nC语言的复合赋值运算符（ compound assignment operator ）允许缩短这种语句和其他类似的语句。\n\n```c\ni += 2;\n```\n\n+=运算符把右侧操作数的值加上左侧的变量，并把结果赋值给左侧的变量。还有另外的9种复合赋值运算符，包括：\n\n-= *= /= %=\n\n## 自增运算符和自减运算符\n\n++表示操作数加1，--表示操作数减1。++和--既可以作为前缀（ prefix ）运算符，也可以作为后缀（ postfix ）运算符使用。\n\n++和--也有副作用，它们会改变操作数的值。计算表达式++i的结果是i+1，副作用是自增i。计算表达式i++的结果是i，副作用是自增i。\n\n这个自增操作一定会在下一条语句执行前完成。\n\n## 表达式求值\n\n上述总结的运算符在下表列出了其优先级、结合性。更多讨论见书本p39。\n\n|优先级|类型名称|符号|结合性|\n|-|-|-|-|\n|1|后缀自增、自减|++ --|左结合|\n|2|前缀自增、自减，一元正负|++ -- + -|右结合|\n|3|乘法类|* / %|左结合|\n|4|加法类|+ -|左结合|\n|5|赋值|= *= /= %= += -=|右结合|\n\n**子表达式的求值顺序**\n\nC语言没有定义子表达式的求值顺序（除了含有逻辑与运算符及逻辑或运算符、条件运算符以及逗号运算符的子表达式）。# 第五章 选择语句\n\n根据语句执行过程中顺序所产生的影响方式，C语言的其他语句大多属于以下三类：\n\n- 选择语句（ selection statement ）。 if 语句和 switch 语句允许程序在一组可选项中选择一条特定的执行路径。\n\n- 循环语句（ iteration statement ）。 while 语句、 do 语句和 for 语句支持重复操作。\n\n- 跳转语句（ jump statement ）。 break 语句、 continue 语句和 goto 语句引起无条件地跳转到程序中的某个位置。（ return 语句也属于此类）\n\nC语言还有其他两类语句，一类是由几条语句组合成一条语句的复合语句，一类是不执行任何操作的空语句。\n\n---\n\n## 逻辑表达式\n\n包括 if 语句在内的某些C语句都必须测试表达式的值是“真”还是“假”。诸如`i<j`这样的比较运算会产生整数：0（假）或1（真）。\n\n### 关系运算符\n\nC语言的关系运算符（ relational operator ）用在C语言中时产生的结果是0（假）或1（真）。\n\n|符号|含义|\n|:-:|:-:|\n|<|小于|\n|>|大于|\n|<=|小于或等于|\n|>=|大于或等于|\n\n关系运算符的优先级低于算术运算符，关系运算符都是左结合的。表达式`i+j<k-1`意味着`(i+j)<(k-1)`。\n\n### 判等运算符\n\n|符号|含义|\n|:-:|:-:|\n|==|等于|\n|!=|不等于|\n\n判定运算符是左结合的，也是产生0或1作为结果。然而，判等运算符的优先级低于关系运算符。例如表达式`i<j == j<k`等价于表达式`(i<j) == (j<k)`。\n\n### 逻辑运算符\n\n|符号|含义|\n|:-:|:-:|\n|!|逻辑非|\n|&&|逻辑与|\n|\\|\\||逻辑或|\n\n逻辑运算符所产生的结果是0或1。逻辑运算符将任何非零值操作数作为真值来处理，同时将任何零值操作作为假值来处理。\n\n运算符&&和||都对操作数进行“短路”计算。\n\n运算符!的优先级和一元正号、负号的优先级相同。运算符&&和||的优先级低于关系运算符和判等运算符。运算符!是右结合的，而运算符&&和||是左结合的。\n\n## if 语句\n\nif 语句允许程序通过测试表达式的值从两种选项中选择一种。 if 语句的最简单的格式如下：\n\nif (表达式) 语句\n\n执行 if 语句时，先计算圆括号内的表达式的值。如果表达式的值非零，那么接着执行括号后面的语句，C语言把非零值解释为真值。\n\n### 复合语句\n\n如果想用 if 语句处理两条或更多语句，该怎么办呢？可以引入复合语句（ compound statement ）。复合语句有如下格式：\n\n{ 多条语句 }\n\n### else 子句\n\nif 语句可以有 else 子句：\n\nif (表达式) 语句 else 语句\n\n如果在圆括号内的表达式的值为0，那么就执行 else 后边的语句。\n\n### 条件表达式\n\nC语言提供了一种特殊的运算符，这种运算符允许表达式依据条件的值产生两个值中的一个。\n\n条件运算符（ conditional operator ）由符号?和符号:组成，两个符号必须按如下格式一起使用：\n\n表达式1 ? 表达式2 : 表达式3\n\n条件运算符是C运算符中唯一一个要求3个操作数的运算符。因此，经常把它称为三元运算符。\n\n条件表达式的求值步骤是：首先计算出表达式1的值，如果此值不为零，那么计算表达式2的值，并且计算出来的值就是整个条件表达式的值；如果表达式1的值为零，那么计算表达式3的值，并且此值就是整个条件表达式的值。\n\n### 布尔值\n\n因为许多程序需要变量能存储假值和真值，所以C语言缺少适当的布尔类型可能会很麻烦。可以使用 int 型变量来模拟布尔类型：\n\n```c\nint flag;\nflag = 0;\nflag = 1;\n```\n\n为了使程序更加便于理解，一个好的方法是用类似 TRUE 和 FALSE 这样的名字定义宏：\n\n```c\n#define TRUE 1\n#define FALSE 0\n\nflag = FALSE;\nflag = TRUE;\n```\n\n为了更进一步实现这个想法，甚至可以定义用作类型的宏：\n\n```c\n#define BOOL int\n\nBOOL flag;\n```\n\n## switch 语句\n\nC语言提供了 switch 语句作为级联式 if 语句的替换：\n\n```c\nswitch (grade) {\n\tcase 4: printf(\"Excellent\"); break;\n\n\tcase 3: printf(\"Good\"); break;\n\n\tcase 2: printf(\"Average\"); break;\n\n\tcase 1: printf(\"Poor\"); break;\n\n\tcase 0: printf(\"Failing\"); break;\n\n\tdefault: printf(\"Illegal grade\"); break;\n}\n```\n\nswitch 语句的最常用的格式如下：\n\n```c\nswitch (表达式) {\n\tcase 常量表达式: 多条语句\n\t...\n\tcase 常量表达式: 多条语句\n\n\tdefault: 多条语句\n}\n```\n\nswitch 语句的组成部分：\n\n- 控制表达式。 switch 后面必须跟着右圆括号括起来的整型表达式。C语言把字符当成整数来处理，因此可以在 switch 语句中对字符进行判定。但是，不能用浮点数和字符串。\n\n- 情况标号。常量表达式（ constant expression ）更像是普通的表达式，5是常量表达式，5 + 10也是，而n + 10不是（除非n是表示常量的宏）。\n\n- 语句。每个情况标号的后边可以跟任意数量的语句，不需要用大括号括起来。每组语句的最后通常是 break 语句。# 第六章 循环\n\n循环（ loop ）是重复执行某些语句（循环体）的一种语句。在C语言中，每个循环都有一个控制表达式（ controlling expression ）。每次执行循环体时都要对控制表达式进行计算。如果表达式为真，也就是值不为零，那么继续执行循环。\n\nC语言提供了3种循环语句： while 语句、 do 语句和 for 语句。\n\n---\n\n## while 语句\n\nwhile 语句的格式如下所示：\n\nwhile (表达式) 语句\n\n执行 while 语句时，首先计算控制表达式的值。如果值不为零（即真值），那么执行循环体，接着再次判定表达式。\n\n## do 语句\n\ndo 语句的格式如下所示：\n\ndo 语句 while (表达式);\n\n和处理 while 语句一样， do 语句的循环体也必须是一条语句（当然可以用复合语句）。\n\n执行 do 语句时，先执行循环体，再计算控制表达式的值。如果表达式的值是非零的，那么再次执行循环体。\n\n## for 语句\n\nfor 语句的格式如下所示：\n\nfor (表达式1; 表达式2; 表达式3) 语句\n\n循环开始执行前，表达式1是初始化步骤，并且只执行一次，表达式2用来控制循环的终止（只要表达式2不为零，那么将继续执行循环），而表达式3是在每次循环的最后被执行的一个操作。\n\n### 逗号运算符\n\n有些时候，我们可能喜欢编写有两个（或更多个）初始表达式的 for 语句，或者希望在每次循环时一次对几个变量进行自增操作。使用逗号表达式（ comma expression ）作为 for 语句中的第一个或第三个表达式可以实现这些想法。\n\n逗号表达式的格式如下所示：\n\n表达式1, 表达式2\n\n逗号表达式的计算要通过两步来实现：第一步，计算表达式1并且扔掉计算出的值。第二步，计算表达式2，把这个值作为整个表达式的值。计算表达式1始终会有副作用；如果没有，那么表达式1就没有了存在的意义。\n\n逗号运算符的优先级低于所有其他运算符。\n\n## 退出循环\n\n### break 语句\n\nbreak 语句还可以用于跳出 while、 do 或 for 循环。\n\n### continue 语句\n\ncontinue 语句无法跳出循环，它把程序控制正好转移到循环体结束之前的一点。 break 语句可以用于 switch 语句，而 continue 语句只能用于循环。\n\n### goto 语句\n\ngoto 语句可以跳转到函数中任何有标号的语句处。\n\n标号只是放置在语句开始处的标识符：\n\n标识符: 语句\n\ngoto 语句自身的格式如下：\n\ngoto 标识符;\n\n执行 goto 语句可以把控制转移到标号后的语句上，而且这些语句必须和 goto 语句本身在同一个函数中。\n\n## 空语句\n\n语句可以为空，也就是除了末尾处的分号以外什么符号也没有。# 第七章 基本类型\n\n---\n\n## 整型\n\nC语言支持两种根本不同的数值类型：整型和浮点型。整型的值都是数，而浮点型可能还有小数部分。整型还分为有符号的和无符号的。\n\n!!!note “有符号整数和无符号整数”\n\t在有符号数中，如果数为正数或零，那么最左边的位（符号位）为0，如果是负数，符号位则为1。默认情况下，C语言中的整型变量都是有符号的。\n\nC语言提供了不同尺寸的整型， int 是正常的尺寸。可以指明变量是 long 型或 short 型， signed 型或 unsigned 型。可以有这些类型组合：\n\nshort int, unsigned short int, int, unsigned int, long int, unsigned long int\n\n可以把 int 省略掉，即 short int 可以写成 short 。\n\n不同类型的整型表示的取值范围根据机器的不同而不同。\n\n### 整型常量\n\n这里说的常量表示在程序中以文本形式显示的数。C语言允许用十进制、八进制和十六进制形式书写整型常量。\n\n十进制常量包含数字`0~9`，但是一定不能以零开头：15 255 32767\n\n八进制常量只包含数字`0~7`，但是必须以零开头：017 0377 07777\n\n十六进制常量包含数字0~9和字母a~f，而且总是以0x开头：0xf 0xff 0xffff\n\n当程序中出现整型常量时，如果它属于 int 类型的取值范围，那么编译器会把此常量作为普通整数来处理，否则作为长整型处理。为了迫使编译器把常量作为长整型来处理，只需在后边加上一个字母L：15L\n\n为了指明是无符号常量，可以在常量后边加上字母U：15U\n\n还可以把UL写在一起：0xffffUL\n\n### 读写整数\n\n读写无符号、短的或长的整数需要一些新的转换说明符。\n\n- 读写无符号整数时，使用字母u、o或x代替转换说明符d。u代表十进制、o八进制、x十六进制。\n- 读写短整数时，在d、o、u或x前面加字母h。\n- 读写长整型时，在d、o、u或x前面加字母l。\n\n## 浮点型\n\n有时候需要变量存储带有小数的数，或者能存储极大数或极小数。这类数可以用浮点格式进行存储（因小数点是浮动的而得名）。C语言提供3种浮点型，它们对应不同的浮点格式：\n\n- float ：单精度浮点数\n- double ：双精度浮点数\n- long double ：扩展双精度浮点数\n\n### 浮点常量\n\n浮点常量有许多书写方式：57.0 57. 57E0 5.7E1\n\n用指数表示的是10的幂。\n\n默认情况下，浮点常量都以 double 的形式存储。为了表明只需要单精度，可以在常量的末尾处加上字母f，如 57.0f 。\n\n### 读写浮点数\n\n转换说明符 %e %f 和 %g 用于读写单精度浮点数，当读取 double 时，需要用 %lf ，而写 double 时，不需要加l。\n\n## 字符型\n\n给 char 类型的变量赋值：\n\n```c\nchar ch;\nch = 'a';\n```\n\nC语言会按小整数的方式处理字符。\n\n### 转义序列\n\n一些特殊的符号无法书写，比如换行符，这时候需要用C语言提供的特殊符号转义序列（ escape sequence ）。\n\n转义序列分成两种：字符转义序列和数字转义序列。\n\n### 字符处理函数\n\n可以使用 toupper 库函数把小写字母转成大写字母：\n\n```c\nch = toupper(ch);\n```\n\n被调用时，函数检查参数是否是小写字母，如果是，那么将它转换成大写字母，否则，函数返回参数的值。\n\n### 读写字符\n\n转换说明符 %c 允许 scanf 函数和 printf 函数对单独一个字符进行读写操作。\n\n```c\nchar c;\nscanf(\"%c\", &c);\nprintf(\"%c\", c);\n```\n\n在读入字符前， scanf 不会跳过空白字符。为了强制 scanf 函数在读入字符前跳过空白字符，需要在格式串转换说明符 %c 前面加上一个空格。\n\n```c\nchar c;\nscanf(\" %c\", &c);\n```\n\nC语言还提供了读写单独字符的其他方法。可以使用 getchar 和 putchar 函数来替代调用 scanf 函数和 printf 函数。每次调用 getchar 函数时，它会读入一个字符，并返回这个字符。\n\n```c\nch = getchar();\n```\n\nputchar 函数用来写单独一个字符：\n\n```c\nputchar(ch);\n```\n\ngetchar 和 putchar 会比较快，原因是它们的实现比较简单，并且通常用宏来实现。\n\n## sizeof 运算符\n\n运算符 sizeof 允许程序确定用来存储指定类型值所需的空间的大小。\n\nsizeof(类型名)\n\n上述表达式的值是无符号整数，这个整数表示用来存储属于类型名的值所需的字节数。\n\n表达式 sizeof(char) 的值始终为1。\n\n通常情况下， sizeof 运算符也可以应用于常量、变量和表达式。\n\n既然 sizeof 返回的是无符号的整型，所以最安全的做法是把 sizeof 表达式转换成 unsigned long 型。然后用转换说明符 %lu 进行。\n\n## 类型转换\n\n为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。\n\nC语言允许表达式中混合使用基本数据类型，这种情况下编译器可能需要生成一些指令将某些操作数转换成不同类型，使得硬件可以对表达式进行计算。这类转换是隐式转换（ implicit conversion ）。C语言还允许程序员通过强制运算符执行显式转换（ explicit conversion ）。\n\n当发生下列情况时会进行隐式转换：\n\n- 当算术表达式或逻辑表达式中操作数类型不同时。\n- 当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。\n- 当函数调用中使用的参数类型与其对应的参数类型不匹配时。\n- 当 return 语句中表达式的类型和函数返回值的类型不匹配时。\n\n### 常用的算术转换\n\n常用的算术转换包括算术运算符、关系运算符和判等运算符。\n\n为了统一操作数的类型，通常把相对较狭小的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的是整型提升（integral promotion），它把字符或短整数转换成 int 。\n\n两种转换规则：\n\n- 任意操作数是浮点型的情况： float -> double -> long double\n- 两个操作数都不是浮点类型： int -> unsigned int -> long int -> unsigned long int\n\n### 赋值中的转换\n\nC语言遵循一个简单的规则：把赋值运算符右侧的表达式转换成左边变量的类型。把浮点数赋值给整型变量会丢掉小数点后的部分。如果取值在变量的类型范围之外，那么把值赋值给一个较小的类型变量将会得到无意义的结果（甚至更糟）。# 第八章 数组\n\n数组是一种聚合（aggregate）变量，可以存储数值的集合。C语言中一共有两种聚合类型：数组和结构。\n\n---\n\n## 一维数组\n\n数组是含有多个数据值的数据结构，并且每个数据值具有相同的数据类型。这些数据值被称为元素。\n\n一维数组中的元素一个接一个地编排在单独一行。\n\n声明一个一维数组：\n\n```c\n#define N 10\nint a[N];\n```\n\n### 数组下标\n\n长度为n的数组元素的索引范围是0到n-1。\n\n使用数组元素：\n\n```c\na[0] = 1;\n```\n\n!!!warning\n\tC语言不要求检查下标的范围，当下标超出范围时，程序可能执行不可预知的行为。\n\n### 数组初始化\n\n数组可以在声明时获得一个初始值。\n\n数组初始化式（ array initializer ）：\n\n```c\nint a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n/* initial value of a is {1, 2, 3, 4, 5, 6, 0, 0, 0, 0} */\nint a[10] = {1, 2, 3, 4, 5, 6};\n\n/* initial value of a is {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} */\nint a[10] = {0};\n\n/* 可以忽略数组长度，编译器自行确认 */\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n```\n\n### 对数组使用 sizeof 运算符\n\n运算符 sizeof 可以确定数组的大小（字节数）。\n\n利用 sizeof 来计算数组元素的大小：\n\n```c\n#define SIZE sizeof(a) / sizeof(a[0])\n```\n\n## 多维数组\n\n数组可以有任意维数。\n\n声明一个二维数组（或称为矩阵）：\n\n```c\nint m[5][9];\n```\n\n数组m有5行9列。\n\n为了在i行j列中存取数组m的元素，需要写成`m[i][j]`的形式。\n\nC语言按照行主序存储数组，也就是从第0行开始，接着第1行，如此下去。\n\n![](二维数组存储.jpg)\n\n### 多维数组初始化\n\n通过嵌套一维数组的方法可以产生二维数组的初始化式：\n\n```\nint a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n```\n\n## 常量数组\n\n在数组定义前加const使得数组变成一个常量数组，表示不能修改数组里面的元素的值。但这样的数组必须在程序运行前就定义好数组内容，一般用于字符串数组。\n\n```c\nconst int months[] = \n{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n```# 第九章 函数\n\n函数是C语言中的构建块，本质上就是一个由语句组成的小程序。有了函数，程序就可以被划分成许多小块。\n\n---\n\n## 函数的定义和调用\n\n由一个案例说明函数中的一些基本概念：\n\n```\ndouble average(double a, double b)\n{\n    return (a + b) / 2;\n}\n```\n\n**返回类型**：即函数开始处放置的double，表示每次调用该函数返回的类型。\n\n**形式参数（parameter）**：标识符a和b\n\n**函数体**：花括号里的内容。\n\n**实际参数（argument）**：调用函数时，传递给形式参数的表达式。\n\n### 函数定义\n\n函数定义的一般格式：\n\n```\n返回类型 函数名(形式参数)\n{\n    声明\n    语句\n}\n```\n\n如果返回类型很长，可以把它单独放到一行。\n\nC89标准中，声明必须放在语句之前。\n\n### 函数调用\n\n这样调用函数：\n\n```\naverage(x, y);\n```\n\n注意，圆括号不能省略，否则无法正确调用。\n\n返回类型若非void，则会返回一个临时值，这个值可以保存到变量里，也可以丢弃。\n\n## 实际参数\n\n形式参数（parameter）出现在函数的定义中，表示函数调用时要提供的值。\n\n实际参数（argument）是出现在函数调用中的表达式。\n\n实际参数是通过**值传递**的。形参是实参的副本。\n\n### 实际参数的转换\n\n形参和实参的类型不一致时，会发生转换。应该先声明函数原型，然后再执行调用。\n\n这种转换属于隐式转换。实际参数将会转换成形式参数的类型。\n\n### 数组型实际参数\n\n数组名可以作为函数的参数，但是函数无法得知数组的长度，只能传递第二个参数以表明长度。\n\n通过此数组名就可以访问数组元素了。\n\n如果形式参数是多维数组，那么必须指明列的长度：\n\n```\nvoid sum(arr[][LEN], int n);\n```\n\n但这种用法比较少见。\n\n## return语句\n\n非void的函数必须用return语句来指定要返回的值：\n\n```\nreturn 表达式;\n```\n\n如果表达式的值得类型与返回值的类型不一致，那么会把表达式的值转换成返回值的类型。\n\n## 程序终止\n\n在main函数中执行return可以终止程序。\n\nmain函数的返回值是状态码，用于提供给操作系统，以表明程序的执行结果。正常结束返回0，异常结束返回非0值。\n\n**exit函数**\n\n另一种终止程序的办法是使用exit函数。此函数属于`<stdlib.h>`头。\n\n传递给exit的参数就是程序结束的状态码：\n\n```\nexit(0); // 正常终止\nexit(EXIT_SUCCESS); // 正常终止，此值为0\nexit(EXIT_FAILURE); // 异常终止，此值为1\n```\n\n## 递归\n\n如果函数调用它自己，那么此函数就是递归的（recursive）。\n\n为了防止无限递归，一定要有一个终止递归的条件。# 第十章 程序结构\n\n---\n\n## 局部变量\n\n在函数体内或程序块内声明的变量叫局部变量。\n\n局部变量有如下性质：\n\n- 自动存储期限。局部变量的存储单元在函数被调用时分配的，在函数返回时收回。\n\n- 块作用域。作用域是可以引用该变量的代码文本部分。局部变量的作用域在程序块中，外部不可访问。\n\n### 静态局部变量\n\n使用static声明局部变量使其成为静态局部变量，它具有静态存储期限，而不再是自动存储期限。\n\n静态变量拥有永久的存储单元，在整个程序的执行期间都会保留。\n\n静态局部变量的作用域仍是块作用域。\n\n### 形式参数\n\n形式参数拥有和局部变量一样的性质，即自动存储期限和块作用域。\n\n其区别在于它是被实参赋值的。\n\n## 外部变量\n\n参数是给函数传递信息的一种方法。另一种方法就是使用外部变量（external variable）。\n\n外部变量声明于函数体外，也叫全局变量。它有如下性质：\n\n- 静态存储期限。如同在函数体内声明的static局部变量，静态存储期限的变量都会永久保留。\n\n- 文件作用域。外部变量的作用域为其声明处到文件末尾。\n\n### 外部变量的利弊\n\n使用外部变量容易引发的问题：\n\n- 在维护期间，如果改变了外部变量，那么就要检查引用了该外部变量的所有函数，以确认此变化对这些函数的影响\n\n- 如果外部变量的值错误，那么比较难定位是哪个函数赋予它错误的值\n\n- 使用了外部变量的函数难以复用，因为此函数不再独立，而是依赖于此外部变量\n\n要给外部变量起一个健全的名字，这样才不容易和其他变量混淆。\n\n## 程序块\n\n程序块就是这样的代码结构：\n\n```\n{ 多条声明 多条语句 }\n```\n\n在程序块中声明的变量具有自动存储期限，出块时收回存储单元，其作用域在块内。\n\n函数体就是一个程序块。\n\n## 作用域\n\n当程序块内的声明命名了一个标识符时，如果此标识符已经可见（被其它地方声明并且可引用），那么新的声明就会”隐藏“旧的声明。\n\n## 构建C程序\n\n一个可能的编排程序的顺序：\n\n- \\#include指令\n\n- \\#define指令\n\n- 类型定义\n\n- 外部变量的声明\n\n- 除main函数之外的函数的原型\n\n- main函数的定义\n\n- 其它函数的定义# 第十一章 指针\n\n---\n\n## 指针变量\n\n现代计算机把**内存分隔为字节（byte）**。每个字节都有唯一的地址（address）。\n\n变量占有一个或多个字节的内存，把第一个字节的地址称为变量的地址。\n\n地址是一个整数，用指针类型（pointer）的变量来存储。\n\n**指针变量的声明**\n\n在变量名前加星号，来声明一个指针变量。如：\n\n```\nint *p;\n```\n\n此声明说明p是指向int类型的对象。\n\n## 取地址运算符和间接寻址运算符\n\n### 取地址运算符\n\n得到一个变量的地址在它前面加'&'（取地址）。如：\n\n```\nint i;\nint *p = &i;\n```\n\n### 间接寻址运算符\n\n获取指针变量指向的存储空间首地址在它前面加`*`（间接寻址）。如：\n\n```\n*p = 10;\n```\n\n这个操作（\\*p）得到的就是变量的**别名**。该操作会修改变量的值。\n\n## 指针赋值\n\n只要是相同类型的指针，就可以相互赋值。这样它们就指向了相同的对象。\n\n## 指针作为参数\n\n指针可以做为函数的参数或返回值。\n\n这些情况，可能会用到指针类型的形参：\n\n0. 需要得到多个结果，故而用指针传出去\n\n0. 传入的对象太大，没有必要执行拷贝操作\n\n一般只有这些情况，返回一个指针类型才是安全的：\n\n0. 返回的是指针类型的参数\n\n0. 返回的是一个全局变量地址\n\n0. 返回的是一个static变量的地址# 第十二章 指针和数组\n\n---\n\n## 指针和数组\n\n当指针指向数组元素时，它可以操作数组元素。此时，可以对指针进行算术运算（加、减、比较）。\n\n数组名即是指向数组中第一个元素的指针。\n\n## 指针的算术运算\n\n指针指向了数组元素，之后对这个指针做算术运算就是合法的操作。但不要越界。\n\n- 指针加、减整数，代表移动元素指向\n\n- 指针相减，代表指针指向元素之间的距离\n\n- 指针比较，比较的是指针指向元素谁前谁后\n\n!!!warning\n\t不能相加两个指针。\n\n## 指针用于数组处理\n\n指针可以操作数组中的元素，比如遍历数组：\n\n```c\nint *p = 0;\nfor (p = &a[0]; p < &a[N]; ++p)\n{\n    // ...\n}\n```\n\n这里N是数组a的长度，虽然`a[N]`不存在，但对它取地址是合法且安全的操作。\n\n**使用\\*和++组合**\n\n如，`*p++`\n\n++操作的优先级高于\\*，所以这样的组合操作，会先操作指针p，然后获取其指向的内容。\n\n后置++会先返回p，然后对p递增，可以用这个操作遍历数组：\n\n```c\nint *p = &a[0];\nwhile (p < &a[LEN])\n{\n    int n = *p++;\n    // ...\n}\n```\n\n## 用数组名作为指针\n\n数组名即第一个元素的地址。即a与&a[0]等价。\n\n数组名是一个指针常量，不能改变其值，应该把它赋值给一个指针变量。\n\n因此可以这样遍历数组：\n\n```c\nint *p = 0;\nfor (p = a; p < a + LEN; ++p)\n{\n    // ...\n}\n```\n\n## 指针和多维数组\n\n二维数组在内存中实际上是一维的连续存储的。其首元素如果这样写：\n\n- `&a[0]`，代表第一行的首地址\n\n- `&a[0][0]`，代表第一个元素的首地址\n\n这俩地址的值是一样的，但意义不同，因为其指向元素的类型不一样。前者是`int*`，后者是`int`。\n\n### 多维数组名作为指针\n\n`int a[n][m]`这样的二维数组，其数组名a代表的是`a[0]`的地址，`a[i]`得到的是第i行的地址。\n\n这样的指针类型是：\n\n```c\nint (*p)[m] = a;\n```\n\n或\n```c\ntypedef int (*Line)[m];\nLine p = a;\n```\n\n这里定义了一个指向数组的指针，这个数组的元素有m个。# 第十三章 字符串\n\n---\n\n## 字符串字面量\n\n字符串字面量（ string literal ）是用一对双括号括起来的字符序列：\n\n```c\n\"Hello World\"\n```\n\n### 字符串字面量中的转义序列\n\n字符串字面量可以包含转义序列：\n\n```c\n\"Hello\\tWorld\\n\"\n```\n\n### 延续字符串字面量\n\n字符串字面量可能太长，以至于无法放置在单独一行内可以把第一行用字符\\结尾，那么C语言就允许在下一行延续字符串字面量：\n\n```c\nprintf(\"put a disk in drive A, then \\\npress any key to continue\");\n```\n\n不只是字符串，字符\\可以用来分割任何长的符号。\n\n但\\有一个缺陷：字符串字面量必须从下一行的起始位置继续，从而破坏了程序的缩进结构。\n\n一个更好的办法是通过C语言的标准解决这个问题，也就是当两个或更多字符串字面量相连时（仅用空白字符分割），编译器必须把它们合并成单独一条字符串：\n\n```c\nprintf(\"put a disk in drive A, then\"\n\t   \"press any key to continue\\n\");\n```\n\n### 如何存储字符串字面量\n\n从本质上而言，C语言把字符串字面量作为字符数组来处理。当C语言编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。+1存储的是额外的空字符，它用来标志字符串的末尾，用转义序列\\0来表示，其数值为0。\n\n例如，字符串字面量\"abc\"是一个有4个字符的字符数组：\n\n![字符串存储](字符串存储.jpg)\n\n字符串字面量可以为空。字符串\"\"表示一个空串，仅有一个空字符。\n\n既然字符串字面量是作为数组来存储的，那么编译器会把它看作是char\\*类型的指针。\n\n### 字符串字面量的操作\n\n通常情况下可以在任何C语言允许使用char\\*指针的地方使用字符串字面量。例如：\n\n```c\nchar *p;\np = \"abc\"; /* 并非复制abc中的字符，而仅仅是使p指向字符串的第一个字符 */\n\nchar ch;\nch = \"abc\"[1]; /* C语言允许对指针添加下标，因此可以给字符串字面量添加下标 */\n```\n\n!!!warning\n\t对于一些编译器而言，改变字符串字面量的内容可能会导致运行异常。因此不推荐这么做。\n\n### 字符串字面量与字符常量\n\n只包含一个字符的字符串串字面量不同于字符串常量。字符串字面量\"a\"是指针，指向存放字符a以及后续空字符的内存单元。字符常量'a'是一个整数。\n\n## 字符串变量\n\nC语言只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。\n\n定义字符串变量的惯用法：\n\n```c\n#define STR_LEN 80\nchar str[STR_LEN + 1]; /* 强调的事实是 str 可以存储最多80个字符 */\n```\n\n### 初始化字符串变量\n\n字符串变量可以在声明时进行初始化：\n\n```c\nchar date1[8] = \"June 14\";\n\nchar date2[8] = {'J', 'u', 'n', 'e', '1', '4', '\\0'};\n\nchar date3[] = \"June 14\"; /* 编译器自动计算长度 */\n```\n\n### 字符数组与字符指针\n\n比如：\n\n```c\nchar date1[] = \"June 14\"; /* 字符数组 */\nchar *date2 = \"June 14\"; /* 字符串字面量的指针 */\n```\n\n任何期望传递字符数组或字符指针的函数都将接受这两种声明的 date 作为参数。\n\n然而，需要注意，不能错误地认为上面两种 date 可以互换。两者之间有显著的差异：\n\n- 在声明为数组时，就像任意数组元素一样，可以修改存储在 date 中的字符。但不可以修改字符串字面量。\n\n- 在声明为数组时， date 是数组名。在声明为指针时， date 是变量，它可以指向其他字符串。\n\n## 字符串的读/写\n\n使用 printf 和 puts 函数来读写字符串。\n\n使用 scanf 和 gets 函数来读字符串。但 gets 函数不安全。\n\n## 使用C语言的字符串库\n\nC语言的运算符无法操作字符串，C语言的库函数为字符串的操作提供了丰富的函数集。这些函数的原型驻留在 string.h 头文件中。\n\nstrcpy 函数可以拷贝字符串。\n\nstrcat 函数可以追加字符串。\n\nstrcmp 函数可以比较字符串。\n\nstrlen 函数可以取得字符串的长度。\n\n## 字符串数组\n\n比如：\n\n```c\nchar *planets[] = {\n\t\"Mercury\",\n\t\"Venus\",\n\t\"Earth\",\n\t\"Mars\",\n\t\"Jupiter\",\n\t\"Saturn\",\n\t\"Uranus\",\n\t\"Neptune\",\n\t\"Pluto\",\n};\n```\n\nplanets 数组的每一个元素是一个字符串的指针。\n\n### 命令参数\n\n运行程序时，经常需要提供一些信息给程序，这是命令行参数（ command-line argument ）。必须把 main 函数定义为含有两个参数的函数：\n\n```c\nint main(int argc, char* argv[])\n{\n\n}\n```\n\nargc （参数计数）是命令行参数的数量（包括程序名本身，最少为1）。 argv (\"参数向量\")是指命令行参数的指针数组。 argv[0] 指向程序名， argv[n] 表示第n个参数。\n\nargv[argc] 始终是一个空指针。\n\n如果用户输入了下面的命令：\n\n```shell\nls -l remind.c\n```\n\n那么 argc 和 argv 是：\n\n- argc: 3\n\n- argv: {\"ls\", \"-l\", \"remind.c\", NULL}# 第十四章 预处理器\n\n---\n\n## 预处理器的工作方式\n\n预处理器的行为是由指令控制的。这些指令是由#字符开头的一些命令。比如 #define 和 #include 。\n\n`#define`定义了一个宏——用来代表其他东西的一个名字。当宏在后面的程序中用到时，预处理器扩展它，将宏替换为它所定义的值。\n\n`#include`指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分。\n\n!!!note \"my note\"\n\t可以使用`gcc -E src.c`指令来查看预编译结果。\n\n## 预处理指令\n\n常见预处理指令包括：\n\n- 宏定义。`#define`定义一个宏，`#undef`删除一个宏。\n\n- 文件包含。即`#include`\n\n- 条件编译。`#if #ifdef #ifndef #elif #else #endif`\n\n指令的通用规则有：\n\n- 都以#开始。\n\n- 在指令的符号之间可以插入任意数量的空格或横向制表符。\n\n- 指令总是在第一个换行符处结束，除非明确地指明要继续，用\\字符换行。\n\n- 指令可以出现在程序的任何地方。\n\n- 注释可以与指令放在同一行。\n\n[测试代码](../../codes/CProgramming/lab/test_precompiled_command.c)\n\n## 宏定义\n\n宏定义的作用范围从定义处开始到本文件末尾。\n\n### 简单宏定义\n\n简单宏定义的格式如：\n\n```c\n#define <宏名> [替换列表]\n```\n\n替换列表中可以有空格。甚至可以没有替换列表，此时宏替换后，就等于删除了这个宏一样。\n\n简单的宏定义一般用于：\n\n- 给字面量取一个别名\n- 辅助条件编译\n\n### 带参数的宏定义\n\n格式如：\n\n```c\n#define <宏名>(x1, x2, ..., xn) [替换列表]\n```\n\n注意点：\n\n- 宏名和参数列表的括号之间不能有空格，不然就是一个简单宏了\n\n- 参数列表可以为空，这样的宏使用起来就像一个函数\n\n- 参数只会替换记号，字符串内的同名单词并不会被替换\n\n带参数的宏一般用于：\n\n- 替代一些小的函数，这样程序的执行效率会高一些，并且函数可能更加通用，因为宏不必检查参数类型\n\n### \\#号和\\#\\#号\n\n宏替换列表中有两个特殊符号：\\#和\\#\\#，它们有如下的意义：\n\n- \\#号代表参数会被替换成一个字符串字面量，例如 :\n\n```c\n#define PRINT_INT(n) printf(#n \" = %d\\n\", n)\n```\n\n\\#n会被替换成\"n\"，相邻的字符串字面量可以连起来形成一个字符串字面量，所以PRINT_INT(a)的宏替换结果是：\n\n```c\nprintf(\"a = %d\\n\", a);\n```\n\n- \\#\\#代表将两边的记号连接在一起，成为一个记号，一个典型的例子：\n\n```c\n#define GENERIC_MAX(type)               \\\ntype type##_max(type x, type y)         \\\n{                                       \\\n        return x > y ? x : y;           \\\n};\n```\n\n这个宏定义定义了一个取最大值的函数，可以方便的为这个函数指定比较类型。\n\n值得注意的是，**#和##都在简单的宏替换后起作用**。\n\n### 宏定义中的圆括号\n\n如果宏定义的替换列表是一个表达式，那么为其增加圆括号是必不可少的工作。\n\n这是因为如果不加圆括号，在宏替换后，新的表达式可能会破坏替换列表表达式的运算优先级。\n\n**在替换列表表达式中使用圆括号有两条规则：**\n\n0. 用圆括号将替换列表括起来\n0. 用圆括号把每个宏参数括起来\n\n一个安全的宏的例子：\n\n```c\n#define SUM(x, y) ((x) + (y))\n```\n\n### 创建较长的宏\n\n一些废话：\n\n宏函数展开后，实际上只有一行。而编写的时候为了好看，可以用`\\`作为换行连接符号。\n\n另外，宏函数使用时看上去应该像普通函数一样：后面也要加分号。所以宏函数的替换列表的末尾应该没有分号。\n\n**直接上书上所给的解决方案：**\n\n```cpp\n#define ECHO(str)    \\\ndo                   \\\n{                    \\\n    gets(str);       \\\n    puts(str);       \\\n} while(0)\n\n// use\nECHO(str);\n```\n\n### 预定义宏\n\n常用预定义宏：\n\n|宏|说明|\n|-|-|\n|`__LINE__`|行号，十进制常数|\n|`__FILE__`|文件名|\n|`__DATE__`|文件编译时的日期|\n|`__TIME__`|文件编译时的时间|\n\n文件名，日期，时间的预定义宏展开后都是一个字符串变量。行号是一个整型变量。\n\n另外，不同的系统会定义不同的预定义宏，来标识其编译平台。如：\n\n- Linux下，`__unix`\n\n- Windows下，`_WIN32`\n\n这种预定义宏配合条件编译就可以做到跨平台编译代码。\n\n[测试代码](../../codes/CProgramming/lab/test_precompiled_macros.c)\n\n**特殊的预定义宏`__VA_ARGS__`**\n\nC99标准中，有一个特殊的预定义宏，它的作用是替换可变参数列表（...），但它要和##符号配合使用，此时##的意义不再是连接，而是：当可变参数列表为空的时候，去除`__VA_ARGS__`前面的逗号，从而避免编译错误。\n\n一个典型的例子：\n```c\n#define CONSOLE_DEBUG(fmt, ...)\\\n    printf(\"FILE: \"__FILE__\", LINE: %05d \"fmt\"\\n\", __LINE__, ##__VA_ARGS__);\n```\n\n`__FUNCTION__`\n\n这个宏代表了当前执行函数的函数名字符串。\n\n## 条件编译\n\n条件编译指令排除了不应该出现的文本。只有通过了条件编译的文本块才会被交给编译器编译。\n\n条件一般是一个普通的宏。\n\n书写格式如：\n\n```c\n#if MACRO\ncode\n#elif MACRO\ncode\n#else\ncode\n#endif\n```\n\n### defined 运算符\n\ndefined 运算符仅用于预处理器。\n\n```c\n#if defined(DEBUG)\n...\n#endif\n```\n\n如果标识符 DEBUG 是一个定义过的宏，则返回1，否则返回0。 defined 返回1意味着通过条件。\n\n指令说明：\n\n- \\#if, \\#elif可以判断这个宏的值，如果是0就不会通过条件编译\n\n- \\#ifdef, \\#ifndef可以判断这个宏是否被定义\n\n条件编译的作用一般是：\n\n- 为了支持跨平台编译\n\n- 排除一些调试代码\n\n## 其他指令\n\n**#error 指令**\n\n如果预处理器遇到一个`#error`指令，它会显示一个出错消息，大多数编译器会立即终止编译。\n\n```c\n#error You can not include this file\n```\n\n**#pragma指令**\n\n`#pragma`指令为要求编译器执行某些特殊操作提供了一种方法。\n\n使用#pragma pack预处理指令来设置字节对齐。具体用法如：\n\n```c\n#pragma pack(push)    // 保存现在的字节对齐状态\n#pragma pack(4)       // 设置4字节对齐\n// 这里定义的结构体最好以4字节对齐\n#pragma pack(pop)     // 恢复字节对齐状态\n```\n\n这里字节对齐的意思是，将结构体中最大内置类型的成员的长度与默认字节对齐数（比如是4）对比，如果谁小，那么就按谁来对齐。# 第十五章 编写大规模程序\n\n源文件包含函数的定义和外部变量，而头文件包含可以在源文件之间共享的信息。\n\n---\n\n## 源文件\n\n可以把程序分割成一定数量的源文件，源文件的扩展名为`.c`。源文件主要包含函数的定义和变量。其中一个源文件必须包含名为 main 的函数，作为程序的起始点。\n\n把程序分成多个源文件有许多显著的优点：\n\n- 把相关的函数和变量集合在单独一个文件中可以帮助明了程序的结构。\n\n- 可以单独对每一个源文件进行编译。如果程序规模很大而且需要频繁改变的话，这种方法可以极大地节约时间。\n\n- 利于复用。\n\n## 头文件\n\n当把程序分割成几个源文件时，问题也随之产生：某文件的函数如何能调用定义在其他文件中的函数？函数如何能访问其他文件中的外部变量？两个文件如何能共享同一个宏定义或类型定义？答案取决于`#include`指令。\n\n`#include`指令告诉预处理器打开指定的文件，并且把此文件的内容插入到当前文件中。这种打开的文件称为头文件，其扩展名为`.h`。\n\n### include 指令\n\n`#include`指令有两种书写格式：\n\n- `#include <文件名>` 搜索系统头文件所在目录，比如在 UNIX 系统中，通常是在 /usr/include\n\n- `#include \"文件名\"` 搜索当前目录，然后搜索系统目录\n\n利用加上诸如-I这样的命令行选项可以添加搜索头文件的位置。\n\n### 共享宏定义和类型定义\n\n大规模的程序包含用于几个源文件共享的宏定义和类型定义，这些定义应该放在头文件中。\n\n比如下图的例子：\n\n![宏定义和类型定义](宏定义和类型定义.png)\n\n有两个源文件包含了 boolean.h\n\n把宏定义和类型定义放到头文件中有如下的好处：\n\n1. 不必把定义复制到需要的源文件，节约时间。\n\n2. 程序变得更加容易修改，改变定义只需要改变头文件。\n\n3. 不用担心源文件包含了相同的宏或类型而其定义不同。\n\n### 共享函数原型\n\n没有原型依赖的函数调用是很危险的，编译器的假设可能是错误的。当调用定义在其他文件中的函数时，要始终确保编译器在调用之前看到函数f的原型。\n\n解决办法就是把函数的原型放进头文件中，然后在所有调用函数f的地方包含头文件。\n\n其包含的方式可能如图所示：\n\n![共享函数原型](共享函数原型.png)\n\n### 共享变量的声明\n\n变量可以在文件中共享。\n\n为了声明变量而不定义，需要在变量声明的开始处放置关键字 extern :\n\n```c\n/* in heaeder file */\nextern int i;\n```\n\n为了共享i，需要在一个源文件中定义i:\n\n```c\n/* in source file */\nint i;\n```\n\n### 保护头文件\n\n如果一个源文件同时包含一个头文件两次，那么可能产生编译错误（比如包含了两次相同的类型定义）。\n\n因此要用到一种保护头文件的方法：\n\n```c\n#ifndef BOOLEAN_H\n#define BOOLEAN_H\n\n/*\n real content\n*/\n\n#endif\n```\n\n如果再次包含此头文件，预处理器就不会再扩展真实的内容。\n\n### 头文件中的#error指令\n\n经常把#error指令放置在头文件中是用来检查不应该包含头文件的条件。例如：\n\n```c\n#ifndef DOS\n#error Graphics supported only under DOS\n#endif\n```\n\n如果非DOS的程序试图包含此头文件，那么编译将在#error指令处终止。\n\n## 构建多文件程序\n\n构建大程序的基本步骤：\n\n- 编译，必须对每一个源文件进行编译。不需要编译头文件。编译器产生一个文件，此文件包含来自源文件的目标代码，称为目标文件（object file）。\n\n- 链接，链接器把目标文件和库文件结合在一起生成一个可执行程序。\n\n大多数编译器允许用单独一步来构建程序：\n\n```c\ncc -m fmt fmt.c line.c word.c\n```\n\n### makefile\n\n使用 makefile 更易于构建大型程序。 makefile 列出了作为程序的部分文件，并描述了它们之间的依赖性。\n\n更多讨论见书本。\n\n!!!note \"my note\"\n\t一种自动生成依赖性的说明的方法是键入命令：`gcc -MM *.c`\n\n### 在程序外定义宏\n\n大多数 UNIX 编译器支持-D选项，允许在命令行指定一个宏定义：\n\n```c\ncc -DDEBUG=1 foo.c\n```\n\n定义了宏 Debug ，在 foo.c 程序中，且值为1。如同在 foo.c 中的开始出现：\n\n```c\n#define DEBUG 1\n```# 第十六章 结构、联合和枚举\n\n---\n\n## 结构变量\n\n结构的元素可能具有不同的类型，而且，每个成员都有名字。\n\n### 结构变量的声明\n\n一个声明结构变量的例子：\n\n```c\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1, part2;\n```\n\n每个结构变量都有三个成员：number, name, on_hand 。\n\n`struct {...}`指明了类型，而 part1 和 part2 则是具有这种类型的变量。\n\n结构的成员在内存中是按照声明的顺序存储的。第一个声明的变量放在存储位置的最前面。\n\n每个结构表示一种新的名字空间（ name space ）。 part1 的 number 和 part2 的 number 不会有冲突。\n\n### 结构变量的初始化\n\n结构变量可以在声明的同时进行初始化：\n\n```c\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1 = { 528, \"Disk drive\", 10 },\n  part2 = { 914, \"Printer cable\", 5 };\n```\n\n结构初始化式的表达式必须是常量。初始化式可以短于它所初始化的结构，这样任何“剩余”成员都用0作为它的初始值。\n\n### 对结构的操作\n\n为了访问结构内的成员，首先写出结构的名字，然后写出成员的名字：\n\n```c\nprintf(\"Part number: %d\\n\", part1.number);\n```\n\n结构成员的值是左值：\n\n```c\npart1.number = 258;\n```\n\n用于访问结构成员的句点是一个运算符，其优先级比较高：\n\n```c\n/* &计算的是 part1.on_hand 的地址 */\nscanf(\"%d\", &part1.on_hand);\n```\n\n另一种主要的结构操作是赋值运算：\n\n```c\npart2 = part1;\n/* 现在 par1 和 part2 每个成员的值都一样 */\n```\n\n可以用结构来复制数组：\n\n```c\nstruct { int a[10]; } a1, a2;\na1 = a2;\n```\n\n运算符=仅仅用于类型一致的结构。\n\n## 结构类型\n\n如果在两个地方编写了：\n\n```c\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1;\n\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part2;\n```\n\n那么 part1 和 part2 就不是同一个类型，这样就不能执行赋值操作。为了解决这个问题，需要为表示结构的类型定义名字。方法有两种：\n\n- 使用结构标记\n\n- 使用 typedef 定义类型名\n\n### 结构标记的声明\n\n结构标记（ structure tag ）即：\n\n```c\nstruct part {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n};\n\n/* 用标记 part 声明变量 */\nstruct part part1, part2;\n```\n\n### 结构类型的定义\n\n即：\n\n```c\ntypedef struct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} Part;\n\n/* 声明变量 */\nPart part1, part2;\n```\n\n## 联合\n\n联合（ union ）也是由一个或多个成员构成的，而且这些成员可能具有不同的数据类型。但是，编译器只为联合中最大的成员分配足够的内存空间，联合的成员在这个空间内彼此覆盖。\n\n对于：\n\n```c\nunion {\n    int i;\n    float f;\n} u;\n\nstruct {\n    int i;\n    float f;\n} s;\n```\n\n他们的存储如：\n\n![联合和结构的存储](联合和结构的存储.jpg)\n\n其中 u.i 和 u.f 具有相同的地址。\n\n## 枚举\n\n枚举（ enumeration ）是一种由程序员列出的值，而且程序员必须为每种值命名（枚举常量）：\n\n```c\nenum { CLUBS, DIAMONDS, HEARTS, SPADES } s1, s2;\n```\n\n虽然枚举和结构没什么共同的地方，但是它们的声明方式很类似。\n\n枚举常量的名字必须不同于闭合作用域内声明的其他标识符。\n\n### 枚举标记和枚举类型\n\n为了定义枚举标记，可以写成：\n\n```c\nenum suit { CLUBS, DIAMONDS, HEARTS, SPADES };\n\n/* 声明枚举变量 */\nenum suit s1, s2;\n```\n\n用 typedef 给枚举命名：\n\n```c\ntypedef enum { CLUBS, DIAMONDS, HEARTS, SPADES } Suit;\n\n/* 声明枚举变量 */\nSuit s1, s2;\n```\n\n### 枚举作为整数\n\n在系统内部，C语言会把枚举变量和常量作为整数来处理。枚举常量的值可以是任意整数：\n\n```c\nenum suit { CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4 };\n```\n\n两个或多个枚举常量具有相同的值甚至也是合法的。\n\n当没有为枚举常量指定值时，它的值是一个大于前一个常量的值的值（大1）。默认第一个枚举常量的值为0。# 第十七章 指针的高级应用\n\n---\n\n## 动态存储分配\n\n任何单纯的数据结构（各种内置类型，数组，结构体），其大小在程序开始时已经确定了，且不能改变。而一些数据结构可能需要动态的改变其数据长度，比如链表。这就要用到**动态存储分配**（dynamic storage allocation）。\n\n使用动态存储分配的数据块存放在“堆”上，和其它存储区域不同的是，“堆”里的数据应该让程序员来控制释放（free）时机。\n\n为了动态地分配存储空间，将需要调用3种内存分配函数中的一种，这些函数都是声明在stdlib.h中的：\n\n0. malloc，分配内存块，但是不初始化它\n\n0. calloc，分配内存块，并对其清零\n\n0. realloc，调整先前分配的内存块\n\n由于malloc函数不需要对分配的内存块进行清除，所以它比calloc函数更高效。\n\n### 空指针\n\n当调用内存分配函数时，无法定位满足我们需要的足够大的内存块，这种问题始终可能出现。如果真的发生了这类问题，函数会返回空指针。\n\n**空指针**（null pointer）是指一个区别于所有有效指针的特殊值。\n\n!!!warning\n    程序员的责任是测试任意内存分配函数的返回值，并且在返回空指针时采取适当的操作。通过空指针试图访问内存的效果是未定义的，程序可能会崩溃或者出现不可预测的行为。\n\n用名为NULL的宏来表示空指针，可用下列方式测试malloc函数的返回值：\n\n```c\np = malloc(10000);\nif (p == NULL) {\n    /* allocation failed; take appropriate action */\n}\n```\n\n## 动态分配字符串\n\n动态内存分配经常用于字符串操作。字符串始终存储在固定长度的数组中，而且可能很难预测这些数组需要的长度。通过动态地分配字符串，可以推迟到程序运行时才作决定。\n\n### 使用malloc函数为字符串分配内存\n\n函数原型：\n\n```c\nvoid *malloc(size_t size);\n```\n\nsize_t是无符号整型，malloc分配了一段size个字节的连续空间，并返回该空间首地址。如果分配失败就返回NULL。\n\n因为C语言保证char型值确切需要一个字节的内存，为了给n个字符的字符串分配内存空间，可以写成：\n\n```c\np = malloc(n + 1);\n```\n\n通常情况下，可以把void\\*型值赋给任何指针类型的变量。然而，一些程序员喜欢强制转换malloc函数的返回值：\n\n```c\nchar *p = (char*)malloc(n + 1);\n```\n\n由于使用malloc函数分配内存不需要清除或者以任何方式初始化，所以p指向带有n+1个字符的未初始化的数组。\n\n可以调用strcpy函数对上述数组进行初始化：\n\n```c\nstrcpy(p, \"abc\");\n```\n\n数组中前4个字符分别为a, b, c和空字符。\n\n## 动态分配数组\n\n编写程序时，常常为难数组估计合适的大小。较方便的做法是等到程序运行时再来确定数组的实际大小。\n\n虽然malloc函数可以为数组分配内存空间，但calloc函数确实是最常用的一种选择。因为calloc函数对分配的内存进行初始化。realloc函数允许根据需要对数组进行“扩展”或“缩减”。\n\n### 使用malloc函数为数组分配存储空间\n\n当使用malloc函数为数组分配存储空间时，需要使用sizeof运算符来计算出每个元素所需要的空间数量。\n\n使用sizeof计算是必须的，因为这样计算的结果在不同平台下都是正确的。\n\n```c\nint *a = malloc(n * sizeof(int));\n```\n\n这里的n可以在程序执行期间计算出来。\n\n一旦a指向了动态分配的内存块，就可以把它用作数组的名字。这都要感谢C语言中数组和指针的紧密关系。可以使用下列循环对此数组进行初始化：\n\n```c\nfor (i = 0; i < n; ++i)\n    a[i] = 0;\n```\n\n### calloc函数\n\n函数原型：\n\n```c\nvoid *calloc(size_t nmemb, size_t size);\n```\n\nnmemb是数据单元的个数， size是一个数据单元的大小。返回成功申请的数据块首地址，失败返回NULL。\n\ncalloc不仅会从“堆”申请存储区域，还会把这段区域清零。也因此其执行效率没有malloc高。\n\n下列calloc函数的调用为n个整数的数组分配存储空间，并且保证全部初始为0：\n\n```c\na = calloc(n, sizeof(int));\n```\n\n通过调用以1作为第一个实际参数的calloc函数，可以为任何类型的数据项分配空间：\n\n```c\nstruct point { int x, y; } *p;\np = calloc(1, sizeof(struct point));\n```\n\n此语句执行后，p指向结构，且此结构的成员x和y都会被设置为0。\n\n### realloc函数\n\n一旦为数组分配完内存，稍后可能会发现数组过大或过小。realloc函数可以调整数组的大小使它更适合需要。\n\n函数原型：\n\n```c\nvoid *realloc(void *ptr, size_t size);\n```\n\nptr必须指向内存块，且此内存块一定是先通过malloc函数、calloc函数或realloc函数的调用获得的。size表示内存块的新尺寸，新尺寸可能会大于或小于原有尺寸。\n\nC标准列出几条关于realloc函数的规则：\n\n- 当扩展内存块时，realloc函数不会对添加进内存块的字节进行初始化。\n\n- 如果realloc函数不能按要求扩大内存块，那么它会返回空指针，并且在原有内存块中的数据不会发生改变。\n\n- 如果realloc函数调用时以空指针作为第一个实际参数，那么它的行为就像malloc函数一样。\n\n- 如果realloc函数调用时以0作为第二个实际参数，那么它会释放掉内存块。\n\n!!!warning\n    一旦realloc函数返回，请一定要对指向内存块的所有指针进行更新，因为可能realloc函数移动了其他地方的内存块。\n\n实际使用时，realloc应该始终对ptr指向的存储区域进行扩展。\n\nrealloc不是一个好用的函数，要很小心才行。这是因为原来的存储区域会被释放掉（虽然新的存储区域会可能和原来的重叠），其指针很可能都变的无效。\n\n## 释放存储\n\nmalloc函数和其他内存分配函数所获得的内存块都来自一个称为**堆**（heap）的存储池。调用这些函数经常会耗尽堆，或者要求大的内存块也可能耗尽堆，这会导致函数返回空指针。\n\n更糟的是，程序可能分配了内存块，然后又丢失了这些块的追踪路径，因而浪费了空间。如下例子：\n\n```\np = malloc(...);\nq = malloc(...);\np = q;\n```\n\n由于没有指针指向第一个内存块，所以再也不能使用此内存块了。\n\n对于程序而言，不再访问到的内存块被称为是**垃圾**（garbage）。在后边留有垃圾的程序有**内存泄漏**（memory leak）。一些语言提供了**垃圾收集器**（garbage collector），但C语言不提供。每个C程序负责回收各自的垃圾，方法是调用free函数来释放不需要的内存。\n\n如上例子，就是一个内存泄漏。第一块内存再也访问不到了，这应该就是上文所说的留有垃圾。\n\n**free**\n\n只有一个方法释放由动态存储分配函数分配的内存空间。就是使用free函数，如果不释放，那么这块资源就一直放在“堆”里，直到程序退出。\n\n函数原型：\n\n```c\nvoid free(void *ptr);\n```\n\n使用free函数很容易，只是简单地把指向不再需要的内存块的指针传递给free函数就可以了：\n\n```c\np = malloc(...);\nfree(p);\n```\n\n调用free函数来释放p所指向的内存块。然后会把这个释放的内存返回给堆，使此内存块可以被复用。\n\n### “悬空指针”问题\n\nfree操作会生成**悬空指针**（dangling pointer）。即调用free(p)函数会释放p指向的内存块，但是不会改变p本身。如果忘记了p不再指向有效内存块（而使用它），后果很严重。\n\n悬空指针是很难发现的，因为几个指针可能指向相同的内存块。在释放内存块时，全部的指针都会留有悬空。\n\n## 指向函数的指针\n\n函数也有地址，所以就可以有指针指向。一些功能强大的函数（像模板一样）都是通过函数指针和`void*`实现的。\n\n### 函数指针\n\n函数指针主要被存放在：\n\n- 数组里，方便日后调用\n- 形参，成为模板函数的实现，比如qsort\n\n定义一个函数指针类型的例子：\n\n```c\ntypedef void (*Func)();\n```\n\n### 函数入口地址\n\n函数名就是函数地址，但通常会对函数名做&运算，其实得到的结果是一样的。同样对函数指针做`*`运算（解引用）和直接拿函数指针用也是一样的，都是代表了函数的入口地址。\n\n一般会对函数名做&操作，对函数指针做`*`操作，让它们看上去比较像指针的使用。# 第十八章 声明\n\n---\n\n## 什么是声明\n\n一个变量或者函数应该首先被声明，才会被使用。因为声明会告诉编译器这个变量或者函数的信息，然后编译器就可以检查其存储空间和作用域，以及使用时的语法是否正确。\n\n## 声明的语法\n\n声明的格式（声明式）是：\n\n**声明说明符 声明符**\n\n声明说明符描述了变量或者函数的性质，声明符代表变量名或者函数名，并且可以指明它的额外信息（如是一个数组or指针or函数）。\n\n声明说明符分为以下3类：\n\n0. 存储类型。四种：auto（块内默认存储类型，无需显示声明），static，extern和register（已经被现代编译器优化，一般不需要声明）\n\n0. 类型限定符，有const和volatile\n\n0. 类型说明符，诸如int，long，unsighed，或者自定义数据类型等，对于函数，类型说明符就是返回类型。\n\n声明符就是一个标识符，然后可以用星号（代表指针），方括号（代表数组），圆括号（代表函数）修饰。\n\n可以看到，声明没有赋值的内容。\n\n## 存储类型\n\n### 变量的性质\n\nC程序中，变量都有三种性质：\n\n0. 存储期限，决定了变量的生存周期。具有自动存储期限的变量在第一次执行时获得内存单元，出块时释放内存单元；具有静态存储期限的变量在程序的生命周期内都拥有内存单元。\n\n0. 作用域，拥有块作用域的变量只能在块内被使用；拥有文件作用域的变量从声明变量开始到文件结束的范围都可以使用。\n\n0. 链接，拥有外部链接的变量（内存单元）可以被程序的其它文件访问；拥有内部链接的变量只可以在文件内访问；无链接的变量只能在一个函数内访问。\n\n上述三种性质取决于变量的声明位置以及变量的存储类型，比如不指明存储类型的话：\n\n- 在块内声明的变量，具有自动存储期限，块作用域，无链接\n\n- 在程序的最外层声明的变量，具有静态存储期限，文件作用域，外部链接。\n\n### 作用域\n\n决定一个变量的作用域的，仅在于它的声明位置：\n\n1. 在块内声明的，具有块作用域\n\n2. 在文件最外层声明的，具有文件作用域\n\n作用域是编译级别的（非链接）语法，编译器根据变量的作用域检查其使用的位置是否正确。\n\n### static存储类型\n\n当static作用于一个块内声明的变量时，将改变它的存储期限为静态存储期限\n\n当static作用于一个最外层声明的变量时，将改变它的链接为内部链接，使这个变量的内存单元不能被其它文件所访问\n\n### extern存储类型\n\n用extern来声明一个变量，不会让编译器为它分配内存单元，它只是告诉编译器，这个变量是在别的地方定义的。因此：当extern作用于一个变量时，这个变量必须拥有静态存储期限且一般有外部链接。一般这个变量都是一个在最外层定义的变量。\n\n### 函数存储类型\n\n默认情况下，函数存储类型都是extern的，代表此函数的链接是外部链接，可以被其它文件访问。\n\n如果给函数加上static声明，那么这个函数的链接就会被修改成内部链接，只能在文件内访问。如果一个函数不需要被多个模块共享，那么就应该声明成static的。\n\n## const限定符\n\n声明一个编译器维度上的常量，但却不能看做一个常量表达式，从而不能定义一个数组的边界（应该用#define）。\n\nconst主要用于保护一个指针指向的对象不被修改，也就是定义一个常量指针，使其指向的空间不允许被修改。\n\n## 声明符\n\n声明符是由标识符和三个特殊符号组成的，这三个特殊符号是：\n\n- 放在标识符前面的`*`号\n\n- 放在标示符后面的`()`或者`[]`\n\n### 解释复杂声明\n\n有时候声明符包含了多个特殊符号，这就要通过两条规则进行解释才能理解。它们是：\n\n- 始终从内向外读声明符，也就是先定位标识符，然后往外读\n\n- `[]`和`()`始终优先于`*`，但`()`可以强制修改优先级\n\n## 初始化式\n\n在声明一个变量时，可以给它`=`一个初始值，这叫初始化式，而不是赋值。\n\n需要注意的几点：\n\n- 静态变量只能用常量表达式初始化，如果没有初始化，那么就是0\n\n- 拥有自动存储期限的变量如果没有初始化，其值就是未定义的（包括数组）\n\n- 数组的初始化（大括号闭合）必须用常量表达式初始化每一个元素# 第十九章 程序设计\n\n虽然C语言不是专门用来编写大规模程序的，但许多大规模程序的确是用C语言编写的。相对于小型程序，编写一个大规模的程序需要更仔细的设计和更详细的计划。\n\n---\n\n## 模块\n\n当设计一个C程序（或其他任何语言的程序）时，最好将它看作是一些独立的模块。模块是一组功能（服务）的集合，其中一些功能可以被程序的其他部分（称为客户）使用。每个模块都有一个接口来描述所提供的功能。模块的细节，包括这些功能自身的源代码，都包含在模块的实现中。\n\n在C语言环境下，这些“功能”就是函数，模块的接口就是头文件，头文件中包含那些可以被其他文件调用的函数的原型。模块的实现就是包含该模块中函数的定义的源文件。\n\n将程序分割成模块有一系列好处：\n\n- 抽象。我们知道模块会做什么，但不需要知道这些功能是如何被实现的。因为抽象的存在，使我们不必为了修改部分程序而了解整个程序是如何工作的。\n\n- 可复用性。每一个提供一定功能的模块，都有可能在另一个程序中复用。\n\n- 可维护性。将程序模块化后，程序中的错误通常只会影响一个模块，因为更容易找到并解决错误。在解决了错误后，重新编译程序只需要将该模块的实现进行编译即可。\n\n一旦我们已经认同了模块化程序设计是正确的方向，接下来的问题就是设计程序的过程中究竟应该定义哪些模块。\n\n### 内聚性与耦合性\n\n一个好的模块并不是随意的一组声明。好的模块应该具有下面两个性质：\n\n- 高内聚性。模块中的元素应该相互紧密相关。\n\n- 低耦合性。模块之间应该尽可能相互独立。低耦合性可以使程序更便于修改，并方便以后复用模块。\n\n### 模块的类型\n\n由于需要高内聚性、低耦合性，模块通常会属于下面几类：\n\n- 数据池。表示一些相关变量或常量的集合。通常这类模块是一些头文件。\n\n- 库。库是一组相关函数的集合。\n\n- 抽象对象。一个抽象对象是指对于隐藏的数据结构进行操作的一组函数的集合。\n\n- 抽象数据类型。将具体数据的实现方式隐藏起来的数据类型称为抽象数据类型。作为客户的模块可以使用该类型来声明变量，但不会知道这些变量的具体数据结构。如果客户模块需要对变量进行操作，则必须调用抽象数据类型所提供的函数。\n\n## 信息隐藏\n\n一个设计良好的模块经常对它的客户隐藏一些信息。例如我们的栈模块的使用者就不需要知道究竟栈是用数组实现的还是用链表。信息隐藏有两大优点：\n\n- 安全性。数据必须通过模块自身提供的函数来操作，而这些函数都是经过测试的。\n\n- 灵活性。无论对模块的内部机制进行多大的改动，都不会很复杂。不需要改变模块的接口。\n\n在C语言中，可以用于强行信息隐藏的工具是 static 存储类型。将一个函数声明成 static 类型可以使函数内部链接，从而阻止其他文件（包括模块的客户）调用这个函数。将一个带文件作用域的变量声明成 static 类型可以达到类似的效果，使该变量只能被同一个文件中的其他函数访问。\n\n## 抽象数据类型\n\n对于作为抽象对象的模块，有一个缺点：不可能对同一个对象有多个实例。为了达到这个目的，需要进一步创建一个新的类型。这就是抽象数据类型。然后模块的接口函数需要传入这个类型对象的指针对其进行操作。\n\n但C语言不提供封装的功能，客户可以访问抽象数据类型的成员。确实有技巧可以达到类似的目的，但使用起来笨拙。\n\n实现封装的最佳方法是使用C++语言。实际上，C++语言产生的原因之一就是因为C语言不能很好的支持抽象数据类型。\n\n## C++语言\n\n略。# 第二十章 低级程序设计\n\n前面几章中讨论的是C语言中高级的、与机器无关的特性。有一些程序需要进行位级别的操作。位操作和其他一些低级运算在编写系统程序、加密程序、图形程序以及一些需要高执行速度或高效地使用空间的程序时非常有用。\n\n本章描述的一些技术需要用到数据在内存中如何存储的知识，这对不同机器和编译器可能会不同。依赖于这些技术很可能会使程序丧失可移植性。\n\n---\n\n## 按位运算符\n\n### 移位运算符\n\n移位运算符可以改变数的二进制形式，将它的位向左或者向右移动。\n\n|符号|含义|\n|:-:|:-:|\n|<<|左移位|\n|>>|右移位|\n\n运算符`<<`和`>>`的操作数可以是任意整数型或字符型的。对两个操作数都会进行整数提升，返回值的类型是左边操作数提升后的类型。\n\n`i<<j`的值是将i中的位左移j位后的结果。每次从i的最左端溢出一位，在i的最右端补一个0位。`i>>j`的值是将i中的位右移j位后的结果。如果i是无符号数或非负数，则需要在i的最左端补0。如果i是负值，其结果是由实现定义的。一些补0，一些补1。\n\n!!!note\n    可移植性技巧：最好仅对无符号数进行移位运算。\n\n### 按位求反、按位与运算符、按位异或运算符和按位或运算符\n\n|符号|含义|\n|:-:|:-:|\n|~|按位求反|\n|&|按位与|\n|^|按位异或|\n|\\||按位或|\n\n上面的顺序也是运算符优先级的顺序。\n\n## 结构中的位域\n\nC语言提供了声明成员为位域的结构。\n\n比如：\n\n```c\nstruct file_date {\n    unsigned int day:5;\n    unsigned int month:4;\n    unsigned int year:7;\n};\n\nstruct file_data fd;\nfd.day = 28;\nfd.month = 12;\nfd.year = 8; /* represents 1988 */\n```\n\n这个结构占据32个比特，每个成员后面的数字指定了它所占用位的长度。\n\n位域有一个限制，C语言不允许将&运算符作用于位域。\n\n位域之间没有间隙，直到剩下的空间不够用来放下一个位域了，这时，一些编译器会跳到下一个存储单元继续存放位域，而另一些则会将位域拆开跨存储单元存放。位域的存放的顺序也是由实现定义的。# 第二十一章 标准库\n\n---\n\n## 标准库的使用\n\nC89标准库有15个部分，即15个头文件。\n\n标准头主要由函数原型、类型定义和宏定义组成。\n\n**`<assert.h>` 诊断**\n\n允许程序插入自我检查，一旦检查失败，程序就被终止。\n\n**`<ctype.h>` 字符处理**\n\n提供用于字符分类及大小写转换的函数。\n\n**`<errno.h>` 错误**\n\n提供了error number，它是一个左值，可以在调用特定库函数后进行检测，来判断调用过程中是否有错误发生。\n\n**`<float.h>` 浮点类型的特性**\n\n提供了用于描述浮点类型特定的宏，包括值得范围及精度。\n\n**`<limits.h>` 整数类型的大小**\n\n提供了用于描述整数类型特性的宏，包括他们的最大值和最小值。\n\n**`<locale.h>` 本地化**\n\n提供一些函数来帮助程序适应针对某个国家或地区的特定行为方式。包括显示数的方式、货币的格式、字符集以及日期和时间的表示形式。\n\n**`<math.h>` 数学计算**\n\n提供常见的数学函数。\n\n**`<setjmp.h>` 非本地跳转**\n\n提供了setjmp和longjmp函数，setjmp会标记程序中的一个位置，随后可以用longjmp返回标记的位置。可以实现从一个函数跳转到另一个函数中，绕过正常的函数返回机制。主要用来处理程序中的严重问题。\n\n**`<signal.h>` 信号处理**\n\n提供了用于处理异常的函数，包括中断和运行时错误。signal可以设置一个函数，使系统信号到达时自动调用该函数；raise函数用来产生信号。\n\n**`<stdarg.h>` 可变参数**\n\n提供一些工具用于编写参数个数可变的函数。\n\n**`<stddef.h>` 常用定义**\n\n提供经验使用的类型和宏定义。\n\n**`<stdio.h>` 输入与输出**\n\n提供大量的输入和输出函数，包括对文件的顺序访问和随机访问操作。\n\n**`<stdlib.h>` 常用实用程序**\n\n包含大量无法划归其它头的函数。包含函数：将字符串转换成数，产生伪随机数，执行内存管理任务，与操作系统通信，执行搜索与排序等。\n\n**`<string.h>` 字符串处理**\n\n包含操作字符串的函数。\n\n**`<time.h>` 日期和时间**\n\n提供相应的函数来获取时间，操纵时间，以及格式化时间。\n\n### 对标准库中所用名字的限制\n\n只要包含了标准头（没有不包含的情况吧？），必须遵循两条规则：\n\n1. 不用自己定义标准头已定义过的宏\n\n2. 具有文件作用域的库名也不可以在文件层次重定义\n\n还有一些命名规则，不要与标准库有冲突：\n\n- 由一个下划线和一个大写字母开头，或由两个下划线开头的标识符，是标准库保留的标识符\n\n- 由一个下划线开头的标识符，被保留用作具有文件作用域的标识符和标记，只可用于函数内部声明\n\n- 在标准库中所有具有外部链接的标识符被保留用作具有外部链接的标识符，比如printf\n\n### 使用宏隐藏的函数\n\nC语言允许在头中定义与库函数同名的宏。从而使得宏隐藏掉函数。\n\n使用宏可能会提高程序的运行速度。如果有不想使用宏的情况，可能是因为想缩小可执行代码的大小。\n\n若要删掉宏，可用如下方法：\n\n```\n#include <stdio.h>\n#undef getchar\n```\n\n还可以禁用宏：\n\n```\n(getchar)()\n```\n\n## stddef.h 常用定义\n\n此头提供了常用的类型和宏的定义。定义的类型包括以下几个：\n\n- ptrdiff_t，指针相减的结果类型，是有符号整数\n\n- size_t，sizeof运算符返回的类型，是无符号整数\n\n- wchar_t，一种足够大的，可以用来表示所有支持的地区的所有字符的类型\n\n其中一个宏是：offsetof，其意思是求得结构体的起点到指定成员间的字节数。\n\n比如，有下面的结构体：\n\n```c\nstruct s {\n    char c;\n    int b[2];\n    float c;\n};\n```\n\noffsetof(struct s, a)的值一定是0，因为结构体的首元素的地址一定是结构体的地址；\n\noffsetof(struct s, b)的值可能是1，但也可能是4（考虑到字节对齐）。# 第二十二章 输入 输出\n\n---\n\n## 流\n\n流意味着任意输入的源或任意输出的目的地。输入流通常和键盘相关，输出流通常和屏幕相关。\n\n流还可以表示为磁盘上的文件，以及其他设备。\n\n### 文件指针\n\n流的访问是通过 **文件指针（file pointer）** 实现的。此指针的类型为`FILE*`。\n\nstdio.h提供了3种标准流，这三个标准流是备用的，不能声明、打开、关闭它们。\n\n|文件指针|流|默认的含义|\n|:-:|:-:|:-:|\n|stdin|标准输入|键盘|\n|stdout|标准输出|屏幕|\n|stderr|标准错误|屏幕|\n\n**重定向（redirection）**\n\n操作系统允许通过重定向机制来改变标准流默认的含义。\n\n例如：\n\n```\ndemo < in.data\n```\n\n称为**输入重定向（input redirection）**，即把stdin流表示为文件in.dat，而非键盘。对于程序demo而言，它并不知道输入流是来自键盘还是文件。\n\n这样子是**输出重定向（output redirection）**：\n\n```\ndemo > out.dat\n```\n\n如此一来，写入stdout的内容将不再输出到屏幕，而是文件out.dat。\n\n### 文本文件与二进制文件\n\n文件就是字节的序列。\n\n文本文件中，字节表示字符。\n\n二进制文件中，字节就是字节，可以用于表示任意类型的数据。\n\nDOS系统中，这两种文件之间有如下差异：\n\n- 行的结尾。文本文件写入换行符时，换行符扩展成一对字符，即回行符和跟随的回车符。如果把换行符写入二进制文件时，它就是一个单独的字符（换行符）。\n\n- 文件末尾。文本文件中，文件的结束标记是CTRL+Z字符（\\x1a）。二进制文件中，此字符没有特别的含义，跟其它任何字符一样。\n\n在Unix操作系统中，二进制文件和文本文件不进行区分，其存储方式一样。\n\n## 文件操作\n\n**打开文件**\n\n使用 fopen 函数。\n\n**关闭文件**\n\n使用 fclose 函数。\n\n**从命令行获取文件名**\n\n当程序需要打开一个文件时，通常通过命令行参数把文件名传给程序，这样更具灵活性。\n\n主函数：\n\n```c\nint main(int argc, char *argv[]);\n```\n\nargc是命令行实际参数的数量（非数组长度），argv是参数字符串数组。\n\nargv[0]是程序名，argv[1] ~ argv[argc-1]是剩余参数。\n\nargv[argc]是空指针。\n\n**临时文件**\n\ntmpfile 函数生成临时文件。\n\ntmpnam 函数生成一个临时的文件名。\n\n**文件缓冲**\n\n向磁盘直接读写数据相对比内存读写慢。使用缓冲区（buffer）来解决这个问题。写入流的数据首先放到缓冲区里面，当缓冲区满了（或关闭流）时，刷新缓冲区，把数据写入文件。\n\n输入流可以使用类似的方法进行缓冲：缓冲区包含来自输入设备的数据。\n\n使用 fflush 函数刷新缓冲区。\n\n**其它文件操作**\n\nremove 函数删除文件，rename 函数重命名文件。如果是用 fopen 和 tmpnam 产生的临时文件，可以使用 remove 把它删除，或者用 rename 使其成为永久文件。\n\n## 格式化的输入与输出\n\n即 ...printf 类函数 和 ...scanf 类函数的使用。\n\n### 检测文件末尾和错误条件\n\n每个流都有与之相关的两个指示器：**错误指示器**（error indicator），**文件末尾指示器**（end-of-file indicator）。\n\n打开流时，会清除这些指示器；流上的操作失败时会设置某个指示器。\n\n遇到文件末尾就设置文件末尾指示器，遇到错误就设置错误指示器。\n\n一旦设置了指示器，它就会保持这种状态，直到可能由 clearerr 调用而引发的明确清除操作为止。 clearerr 可以清除文件末尾指示器和错误指示器。\n\n如果设置了文件末尾指示器， feof 返回非零值。\n\n如果设置了错误指示器， ferror 返回非零值。\n\n## 字符的输入/输出\n\n输入输出的字符类型应使用int，原因之一是由于函数通过返回EOF说明文件末尾or错误情况，EOF是一个负的整型常量。\n\n### 输出函数\n\n```c\nint fputc(int c, FILE *stream);\nint putc(int c, FILE *stream);\nint putchar(int c);\n```\n\n### 输入函数\n\n```c\nint fgetc(FILE *stream);\nint getc(FILE *stream);\nint getchar(void);\n```\n\n## 行的输入/输出\n\n### 输出函数\n\n```c\nint fputs(const char *s, FILE *stream);\nint puts(const char *s);\n```\n\nputs函数向标准输出输出一行字符串，会自动添加一个换行符。\n\nfputs不会自动添加换行符。\n\n### 输入函数\n\n```c\nchar *fgets(char *s, int size, FILE *stream);\nchar *gets(char *s);\n```\n\ngets函数逐个读取字符，存储到s中，直到读到换行符时停止，并把换行符丢弃。\n\nfgets当读入了size-1个字符时或读到换行符时停止，且会存储换行符。\n\n如果出现错误，或者在存储任何字符之前达到了输入流的末尾，函数返回空指针。否则返回第一个实参。\n\n函数会在字符串的末尾存储空字符。\n\n## 块的输入输出\n\n```c\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\n\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n```\n\nfread函数和fwrite函数允许程序在单步中读写大的数据块。\n\nfwrite函数被设计用来把数组复制给流。第一个参数是数组首元素的地址，第二个参数是每个数组元素的大小（以字节为单位），第三个参数是要写的元素的数量，第四个参数是文件指针，说明了要写的数据位置。\n\nfwrite返回实际写入的元素数量，如果写入错误，此数就会小于第三个参数。\n\nfread函数从流读入数组的元素。其参数类似fwrite。\n\nfread返回实际读入的元素数量，此数应该等于第三个参数。否则可能达到了文件末尾或者出现了错误。使用feof和ferror确定出问题的原因。\n\n检查fread的返回值是非常重要的。\n\n## 文件的定位\n\n每个流都有相关联的**文件位置（file position）**。打开文件时，根据模式可以在文件的起始处或者末尾处设置文件位置。\n\n在执行读或写操作时，文件位置会自动推进。\n\nstdio.h提供了一些函数，用于确定当前的文件位置或者改变文件位置：\n\n```c\nint fseek(FILE *stream, long offset, int whence);\n\nlong ftell(FILE *stream);\n\nvoid rewind(FILE *stream);\n\nint fgetpos(FILE *stream, fpos_t *pos);\nint fsetpos(FILE *stream, fpos_t *pos);\n```\n\n**fseek**函数改变第一个参数相关的文件的位置。第二个参数说明新位置是根据文件的起始处、当前位置还是文件末尾来计算，也就是第三个参数来计算。\n\n第三个参数可取值为：\n\n- SEEK_SET，文件的起始处。\n\n- SEEK_CUR，文件的当前位置。\n\n- SEEK_END，文件的末尾处。\n\n**ftell**函数返回当前文件位置。如果发生错误，ftell返回-1L，并且把错误码存储到errno。\n\n**rewind**函数会把文件位置设置到起始处。rewind还会为fp清除错误指示器。\n\n**fgetpos**和**fsetpos**用于处理大的文件，使用fpos_t表示文件位置，它可能是一个结构。函数成功返回0，失败返回非0值并把错误码存放到errno中。\n\n## 字符串的输入/输出\n\nsprintf和snprintf函数将按写到数据流一样的方式写字符到字符串。\n\nsscanf函数从字符串中读出数据就像从数据流中读数据一样。\n\n### 输出函数\n\n```c\nint sprintf(char *str, const char *format, ...);\nint snprintf(char *str, size_t size, const char *format, ...);\n```\n\n类似于printf函数，唯一不同是sprintf函数把输出写入字符数组而不是流。当完成向字符串写入的时候，sprintf函数会添加一个空字符，并返回所存储的字符数量（不计空字符）。如果遇到错误，返回负值。\n\nsnprintf写入的字符数量不会超过size-1，结尾空字符不计。只要size不是0，都会有空字符。\n\n### 输入函数\n\n```c\nint sscanf(const char *str, const char *format, ...);\n```\n\nsscanf与scanf类似，唯一的不同就是sscanf从字符数组中读取数据而不是流。\n\nsscanf函数返回成功读入并存储的数据项的数量，如果在找到第一个数据项之前到达了字符串的末尾，那么sscan函数返回EOF。# 第二十三章 库对数值和字符数据的支持\n\n---\n\n## float.h：浮点型的特性\n\n提供了用来定义浮点型的范围及精度的宏。\n\n## limits.h：整型取值范围\n\n仅定义了每种整数类型的取值范围的宏。\n\n## math.h：数学计算\n\nmath.h里的函数处理的都是浮点类型的数值。\n\n在 UNIX/Linux 下编译，需要指明连接 math 库：-lm\n\nmath.h中定义的函数包含下面5种类型：\n\n- 三角函数 sin cos tan acos asin atan atan2\n\n- 双曲函数 cosh sinh tanh\n\n- 指数和对数函数 exp log ...\n\n- 幂函数 pow sqrt\n\n- 就近去整函数，绝对值函数和取余函数 ceil fabs floor fmod\n\n### 错误\n\n在math.h里声明的函数，如果出现错误（可能是参数不对），会把错误码存到errno。且若函数返回值大于double的最大值，那么函数会返回一个特殊值HUGE_VAL（double类型表示无穷大，Linux下输出成inf）。\n\nerrno有两种可能值：\n\n1. EDOM：代表定义域错误（Linux下值为33），即参数取值不对，比如给sqrt传一个负数。\n2. ERANGE：代表取值范围错误（返回值）（Linux下值为34），无法用double来表示了。比如exp(1000)。（PS：不是所有的数学函数出现返回值为无穷大时都会置errno为ERANGE）\n\n## ctype.h：字符处理\n\nctype.h提供了两类对字符进行处理的：\n\n1. 测试字符性质\n2. 对字符进行大小写转换\n\n## string.h：字符串处理\n\n这些函数的参数的合法性需要程序员来保证。\n\n### 复制函数\n\n```c\nvoid *memcpy(void *dest, const void *src, size_t n);\nchar *strcpy(char *dest, const char *src);\nchar *strncpy(char *dest, const char *src, size_t n);\n```\n\n### 拼接函数\n\n```c\nchar *strcat(char *dest, const char *src);\nchar *strncat(char *dest, const char *src, size_t n);\n```\n\n### 比较函数\n\n```c\nint strcmp(const char *s1, const char *s2);\nint strncmp(const char *s1, const char *s2, size_t n);\n```\n\n### 搜索函数\n\n```c\nchar *strchr(const char *s, int c);\nvoid *memchr(const void *s, int c, size_t n);\nchar *strrchr(const char *s, int c);\nchar *strtok(char *str, const char *delim);\n```\n\n### 其它函数\n\n```c\nvoid *memset(void *s, int c, size_t n);\nsize_t strlen(const char *s);\n```# 第二十四章 错误处理\n\n---\n\n## assert.h: 诊断\n\n```c\nvoid assert(int expression);\n```\n\nassert声明在assert.h中，实际上是一个宏。其参数必须是一种“断言”，即被认为正常情况下一定为真的表达式。\n\n每次执行assert时，判断此断言，若为假（0），则显示一条错误信息，并调用abort函数终止程序执行。\n\n这条错误信息包含了：断言（以文本格式）、包含assert调用的文件名、assert调用所在的行号。\n\n**禁止assert调用**\n\n方法是：在包含assert.h之前，定义宏NDEBUG。如：\n\n```c\n#define NDEBUG\n#include <assert.h>\n```\n\n## errno.h: 错误\n\n标准库中的一些函数通过向errno.h中声明的errno变量存储一个错误代码来表示有错误发生。\n\n大部分使用errno变量的函数集中在math.h，但也有一些在标准库的其他部分。\n\n如果errno不为0，则说明函数调用过程中有错误发生。\n\nerrno在程序开始的时候值为0，通常在调用函数前把errno置为0，库函数不会将errno清零，这是程序员的责任。\n\n用法如：\n\n```c\ny = sqrt(x); // x为负数则出错\nif (errno != 0) {\n    fprintf(stderr, \"sqrt error, terminated. \\n\");\n    exit(EXIT_FAILURE);\n}\n```\n\n**perror函数和strerror函数**\n\n```c\nvoid perror(const char *s);\nchar *strerror(int errnum);\n```\n\n当库函数向errno存储了一个非零值时，通过perror函数和strerror函数可以得到描述这种错误的信息。\n\nperror函数声明在stdio.h中，它会按照如下顺序把错误信息输出到stderr：\n\n    调用perror的参数: 出错消息（内容根据errno的值决定）\n\nstrerror函数声明在string.h中，它传入errno，返回一个指针，指向描述出错消息的字符串。\n\n## signal.h: 信号处理\n\nsignal.h提供了处理异常的工具，即信号（signal）。信号有两种类型：运行时错误（例如除以0），程序以外导致的事件（例如用户输入了ctrl+c）。\n\n当有错误或外部事件发生时，我们称产生了一个信号。大多数信号是**异步的**：它们可以在程序执行过程中的任意时刻发生。\n\n### 信号宏\n\nsignal.h定义了一系列宏，用于表示不同的信号。参见书本。\n\n### signal函数\n\n```\ntypedef void (*sighandler_t)(int);\nsighandler_t signal(int signum, sighandler_t handler);\n```\n\nsignal函数安装一个信号处理函数。第一个参数是信号的代码，第二个参数是一个指向信号处理函数的指针。\n\n一旦随后在程序执行过程中出现了对应的信号，信号处理函数就会被自动调用，信号的代码作为参数传递给信号处理函数。\n\n除非信号是由调用abort函数或raise函数引发的，否则信号处理函数不应该调用任何库函数，或者试图使用一个静态存储期限的变量。\n\n一旦信号处理函数返回，程序会从信号发生点恢复并继续执行。但是，如果信号是SIGABRT，当处理函数返回时程序会异常终止。如果信号是SIGFPE，那么处理函数返回的结果是UB（即不要使用它）。\n\nsignal函数的返回值是指定信号的前一个处理函数的指针。\n\n### 预定义的信号处理函数\n\nsignal.h提供了两个预定义的信号处理函数（都用宏表示）：\n\n- SIG_DFL。表示按默认方式处理信号，大多数情况下会导致程序终止。\n\n- SIG_IGN，指明随后当信号SIGINT发生时，忽略该信号。\n\n当程序刚开始执行时，根据不同的实现，每个信号的处理函数都会被初始化为SIG_DFL和SIG_IGN。\n\n如果signal调用失败（即无法对指定信号安装处理函数），就返回SIG_ERR（不是一个函数），并在errno中存入错误代码。\n\nC语言要求，除了SIGILL以外，当一个信号的处理函数被调用时，该信号的处理函数要被重置为SIG_DFL，或者以其他方式加以封锁。\n\n### raise函数\n\n```c\nint raise(int sig);\n```\n\n通常信号都是自然产生的，但也可以通过raise函数触发。\n\nraise函数的返回值可以用来测试调用是否成功：0代表成功，非0代表失败。\n\n## setjmp.h: 非局部跳转\n\n```c\n#include <setjmp.h>\nint setjmp(jmp_buf env);\nvoid longjmp(jmp_buf env, int val);\n```\n\n通常情况下，函数会返回到它被调用的位置。setjmp.h可以使一个函数直接跳转到另一个函数，而不需要返回。\n\nsetjmp宏“标记”程序中的一个位置，随后可以用longjmp函数跳转到该位置。这一机制主要用于错误处理。\n\nsetjmp宏会将当前“环境”保存到一个jmp_buf类型的变量中，然后返回0。如果要返回setjmp宏所标记的位置，可以使用longjmp函数，调用的参数是调用setjmp宏时使用的同一个jmp_buf类型的变量。longjmp函数首先会根据jmp_buf变量的内容恢复当前环境，然后从setjmp宏调用中返回。这次setjmp宏的返回值是val，即调用longjmp函数时的第二个参数（如果val是0，那么返回1）。\n\n如果longjmp的参数未被setjmp初始化，调用longjmp的结果是UB。# 第二十五章 国际化特性\n\n---\n\n## locale.h 本地化\n\nlocale.h提供的函数用于控制标准库中对于不同的地区会不一样的部分。\n\n地区通常指一个国家，或者一个国家的不同区域。\n\n在标准库中，依赖地区的部分包括：\n\n- 数值的格式。比如一些地区的小数点是用逗号表示\n\n- 货币的格式。不同国家的货币符号不同。\n\n- 字符集。字符集依赖于地区使用的语言。亚洲国家通常比西方国家需要更大的字符集。\n\n- 日期和时间的表示格式。\n\n### 类别\n\n通过修改地区，程序可以改变它的行为来适应不同地区。\n\n可以使用一些宏来指定一个**类型**：\n\n- LC_COLLATE。影响两个字符串比较函数的行为（strcoll和strxfm）。\n\n- LC_CTYPE。影响ctype.h中函数的行为，除了isdigit和isxdigit。同时还影响stdlib.h中的多字节函数。\n\n- LC_MONETRAY。影响由localeconv函数返回的货币格式信息。\n\n- LC_NUMERIC。影响格式化输入/输出函数使用的小数点字符以及stdlib.h中的字符串转换函数（atof和strtod），还会影响localeconv函数返回的非货币格式信息。\n\n- LC_TIME。影响strftime函数的行为，该函数将时间转换成字符串。\n\n### setlocale函数\n\n```c\nchar *setlocale(int category, const char *locale);\n```\n\nsetlocale函数修改当前的地区。如果第一个参数是LC_ALL，就会影响所有的类型。C语言标准对第二个参数仅定义了两种可能值：\"c\"和\"\"。其余的由实现定义，比如， gcc 对于简体中文的地区，可以是\"zh_CN.UTF-8\"\n\n程序执行开始时，都会隐含调用：`setlocale(LC_ALL, \"C\");`\n\n如果用\"\"作为第二个参数，就切换到了本地模式（native locale），这种模式下程序会适应本地的环境。\n\n如果调用成功，返回一个关于地区名字的字符串指针。如果调用失败，返回空指针。\n\nsetlocale函数也可以当作搜索函数使用，如果第二个参数是空指针，setlocale函数会返回一个指向字符串的指针，这个字符串与当前地区类型的设置相关联。\n\n### localeconv函数\n\n```c\nstruct lconv *localeconv(void);\n```\n\n函数返回的struct lconv结构包含了当前地区的详细信息，此结构具有静态存储期限。\n\n详细信息参考书本。\n\n## 多字节字符和宽字符\n\n因为定义已经把char型值的大小限制为一个字节，所以通过改变char类型的含义来处理更大的字符集显然是不可能的。\n\nC语言提供了两种可扩展字符集的编码：**多字节字符**（multibyte character）和**宽字符**（wide character）。\n\nC标准要求0字节始终用来表示空字符。\n\n### 多字节字符\n\n在多字节字符编码中，一个或多个字节表示一个可扩展字符。C语言要求的基本字符是单字节的。\n\n一些多字节字符集依靠**依赖状态编码**（state-dependent encoding）。在这类编码中，每个多字节字符序列都以**初始移位状态**（initial shift state）开始。序列中稍后遇到的一些多字节字符会改变移位状态，并且影响后续字节的含义。\n\nMB_LEN_MAX和MB_CUR_MAX说明了多字节字符中字节的最大数量。MB_LEN_MAX定义在limits.h中，给出了任意支持地区的最大值。MB_CUR_MAX定义在stdlib.h中，给出了当前地区的最大值。\n\n### 宽字符\n\n宽字符是一种其值表示字符的整数，所有宽字符要求相同的字节数。\n\n宽字符具有wchar_t类型。\n\n一个宽字符常量可以写成：`L'a'`\n\n一个宽字符字符串可以写成：`L\"abc\"`\n\n即在普通字符常量前用字母L作为前缀。\n\n!!!note \"my note\"\n    注意，在使用宽字符前，需要设置好本地环境，比如，要使用简体中文的宽字符，那么要先执行 `setlocale(LC_ALL, \"zh_CN.UTF-8\")` ，这样才能正确地解析宽字符。\n\n### 多字节字符函数\n\n```c\n#include <stdlib.h>\nint mblen(const char *s, size_t n);\nint mbtowc(wchar_t *pwc, const char *s, size_t n);\nint wctomb(char *s, wchar_t wc);\n```\n\n### 多字节字符串函数\n\n```c\n#include <stdlib.h>\nsize_t mbstowcs(wchar_t *dest, const char *src, size_t n);\nsize_t wcstombs(char *dest, const wchar_t *src, size_t n);\n```\n\n## 三字符序列\n\n见书本简要介绍。\n\n!!!note\n    这就是一种字符替换方式，由于某些国家不支持C语言的标准的字符书写方式。# 其他库函数\n\n---\n\n## stdarg.h 可变长度实参\n\n```c\nvoid va_start(va_list ap, last);\ntype va_arg(va_list ap, type);\nvoid va_end(va_list ap);\n```\n\nstdarg.h提供了一种工具可以让我们自行编写的函数具有可变长的参数列表（varying number of arguments of varying types）。stdarg.h定义了一种va_list类型和三种宏，名为va_start, va_arg, va_end, 可以把这些宏看成是带有上述原型的函数。\n\n书中使用了此例进行讲解：\n\n```c\nint max_int(int n, ...)    // n must be at least 1\n{\n    va_list ap;\n    int i, current, largest;\n\n    va_start(ap, n);\n    largest = va_arg(ap, int);\n\n    for (i = 1; i < n; ++i) {\n        current = va_arg(ap, int);\n        if (current > largest)\n            largest = current;\n    }\n\n    va_end(ap);\n    return largest;\n}\n```\n\n函数的第一个实参n说明了跟随其后的其他参数的数量。\n\n形参列表中的...符号表示可变数量的参数。带有可变参数的函数必须至少有一个“正常的”形参，在最后一个正常的参数后边始终会有省略号出现在参数列表的末尾。\n\n`va_list ap`声明了一个变量，使得函数可以访问到可变参数。\n\n`va_start(ap, n)`指出了实参列表中可变长度开始的位置。\n\n`va_arg(ap, int)`把获取当前的可变参数，然后自动前进到下一个可变参数处。int说明希望此参数是int类型的。\n\n函数返回前，使用语句`va_end(ap)`进行清扫。\n\n### 调用带有可变实参列表的函数\n\n调用带有可变实参列表的函数是一个固有的风险提议。\n\n这里主要的难点就是带有可变实参列表的函数很难确定传递过来的参数的数量或类型。所以必须把这个信息传递给函数，并且函数假设知道了这个信息。上述max_int函数依靠第一个实参来指明跟随其后的其他参数的数量，并且它还设定参数是int类型的。\n\n另一个问题就是不得不处理NULL作为参数的情况，具体见书本。\n\n### v...printf类函数\n\n```c\nint vprintf(const char *format, va_list ap);\nint vfprintf(FILE *stream, const char *format, va_list ap);\nint vsprintf(char *str, const char *format, va_list ap);\n```\n\n不同于printf等函数，v...printf类函数具有固定数量的实参，每个v...printf类函数的最后一个实参都是一个va_list型值。这个类型的值意味着此函数可以由带有可变实参列表的函数调用。\n\n实际上，v...printf类函数主要用于编写“包装”函数。包装函数接收可变数量的实参，并稍后把这些参数传递给v...printf类函数（通过va_list）。\n\n这种包装函数的核心内容是：\n\n- va_start(ap, arg)\n\n- 把ap传递给v...printf\n\n- va_end(ap)\n\n## stdlib.h 通用的实用工具\n\n### 字符串转换函数\n\n```c\nint atoi(const char *nptr);\nlong long atoll(const char *nptr);\n\nlong int strtol(const char *nptr, char **endptr, int base);\nlong long int strtoll(const char *nptr, char **endptr, int base);\n```\n\n### 伪随机生成函数\n\n伪随机数的生成方法是：\n\n- 先设置一个随机种子（srand）\n\n- 调用rand函数根据随机种子生成一个伪随机数\n\n如果每次程序运行的随机种子都一样，那么rand出来的数就会一样。因此通常采用当前时间戳作为随机种子（但如果两次启动间隔不足一秒，时间戳也是一样滴）。\n\n```c\nvoid srand(unsigned int seed);\nint rand(void);\n```\n\n### 与环境的通信\n\n与外部通信的标准库函数可以：\n\n- 为操作系统返回一个程序结束的状态码\n\n- 获取环境变量\n\n- 执行操作系统的命令\n\n**返回状态码**\n\n在main中执行return语句，即返回了一个状态码给操作系统；或者在程序的任意处执行exit函数，也可以终止程序并返回一个状态码给操作系统。\n\nexit是正常性质的结束程序，可以清理程序打开的资源。\n\natexit函数还可以注册一个函数，在程序正常结束前，执行这个注册函数。可以注册多个atexit函数，调用顺序和注册顺序一致。\n\n```c\nvoid exit(int status);\nint atexit(void (*function)(void));\n```\n\n**获取环境变量**\n\n环境变量是一组存放到静态存储区的字符串，描述了操作系统的环境，比如PATH。使用getenv就可以获取它的值。\n\n```c\nchar *getenv(const char *name);\n```\n\n**执行命令**\n\n主要是通过system函数执行一个外部的命令。system函数返回该命令的终止状态码。\n\n```c\nint system(const char *command);\n```\n\n### 搜索和排序工具\n\n用于搜索的工具是：bsearch（实现为二分查找），用于排序的工具是：qsort（实现为快速排序）。\n\n```c\nvoid qsort(void *base, size_t nmemb, size_t size,\n                  int(*compar)(const void *, const void *));\n\nvoid *bsearch(const void *key, const void *base,\n                     size_t nmemb, size_t size,\n                     int (*compar)(const void *, const void *));\n```\n\n### 整数算术运算函数\n\n**abs求绝对值**\n\n函数原型：\n```c\nint abs(int j);\n```\n\n**div求除法运算结果**\n\n函数原型：\n```c\ndiv_t div(int numerator, int denominator);\n```\n\n结果是第一个实参除以第二个实参。结果是一个div_t类型，它包含了商和余数，定义如下：\n```c\ntypedef struct\n{\n    int quot;    /* Quotient.  */\n    int rem;     /* Remainder. */\n} div_t;\n```\n\n但第二个实参一定不能为0，不然就会出现段错误。因此判断除数是否合法的责任就交给了程序员。\n\n## time.h 日期和时间\n\n标准库提供了三种表示时间的类型：\n\n0. clock_t：按照“时钟滴答”进行测量的时间值\n\n0. time_t：日历时间（时间戳），由于这个类型在不同平台下定义不同（unsigned int or long），因此输出的时候应当做一个强制转换。\n\n0. struct tm：分解时间，一种适合人类理解的时间格式\n\nclock_t和time_t是支持算术运算的，但是它们具体是整型还是浮点型并没有被C标准说明。但struct tm的类型定义很清楚：\n\n|成员|说明|\n|-|-|\n|tm_sec|分后的秒，[0, 61]，允许两个额外的闰秒|\n|tm_min|时后面的分，[0, 59]|\n|tm_hour|午夜后的时，0到23|\n|tm_mday|月份中的第几天，[1,31]|\n|tm_mon|一月份以后的月，[0,11]|\n|tm_year|从1900年开始的年|\n|tm_wday|星期日以后的天，[0,6]|\n|tm_yday|一月一日后的天，[0,365]|\n|tm_isdst|夏令时标记，夏令时有效为正数，否则为0，如果未知，可为-1|\n\n**时钟滴答**\n\n```c\nclock_t clock(void);\n```\n\nclock函数返回处理器的时间（时钟滴答），即程序开始运行到执行到此的消耗的时间。但它的单位不是秒，为了将它转换成秒，可以给它除以宏CLOCK_PER_SEC。\n\nclock_t不能表示日期，只是善于表示时间区间（两个clock_t相减获得比较精准的时间差）。\n\n```c\n(clock() - start_clock) / (double)CLOCK_PER_SEC\n```\n\n加double强制转换的理由是，标准C没有指明宏CLOCK_PER_SEC的类型，也没有说明clock_t的类型，所以必须用强制转换明确一下类型。\n\n**日历时间**\n\n```c\ntime_t time(time_t *t);\ndouble difftime(time_t time1, time_t time0);\n```\n\ntime用来获取时间戳（UNIX从1970年为纪元），difftime获取两个时间戳的间隔，但这种计算间隔的方式没有用clock_t计算精准。\n\n**分解时间**\n\n```c\ntime_t mktime(struct tm *tm);\nstruct tm *localtime(const time_t *timep);\nchar *asctime(const struct tm *tm);\n```\n\n- mktime将分解时间转换成日历时间（时间戳）。但它有一个很好得到地方，除了转换成日历时间，它还会先修正分解时间，如果分解时间中的某些值不正确的话。修正的规则就是“进位”，把溢出的时间补给高位的时间。比如tm_mday超过了31，那么tm_mon就会增加至少1。可以利用这一个修正的规则来计算未来的日期。见代码案例。\n\n- localtime根据日历时间，获得本地的分解时间\n\n- asctime获取分解时间的字符串格式，末尾还会有一个换行符\n\n**时间转换函数**\n\n有 ctime strftime 等。","slug":"2019-CProgramming","published":1,"updated":"2019-09-30T11:29:46.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxdb002y2wvcicf1jiyv","content":"<h1 id=\"第一章-C语言概述\"><a href=\"#第一章-C语言概述\" class=\"headerlink\" title=\"第一章 C语言概述\"></a>第一章 C语言概述</h1><p>C语言是20世纪70年代初期，在贝尔实验室开发出来的一种用途广泛的编程语言。</p>\n<hr>\n<h2 id=\"C语言的历史\"><a href=\"#C语言的历史\" class=\"headerlink\" title=\"C语言的历史\"></a>C语言的历史</h2><p>C语言是Unix系统开发过程中的一个副产品。它被用来重写Unix系统。</p>\n<p>到20世纪80年代，许多计算机开始使用C语言开发程序，为了保证其程序的可移植性，建立标准成为了共识。</p>\n<p>1989年，通过C89标准。</p>\n<p>1999年，通过C99标准，但这个标准还没有被普遍使用。</p>\n<h3 id=\"C-语言\"><a href=\"#C-语言\" class=\"headerlink\" title=\"C++ 语言\"></a>C++ 语言</h3><p>虽然采纳了 ANSI/ISO 标准以后C语言自身不再发生变化。但是，从某种意义上说，随着基于C语言的新式语言的产生，C语言的演变还在继续。新式语言包括C++。它在许多方面对C语言进行了扩展，尤其是增加了面向对象编程的特性。</p>\n<p>随着C++语言的迅速普及，在不久的将来你很可能会用C++语言编写程序。果真如此，为何还要费心学习C语言呢？首先，C++语言比C语言更加难学，因此在掌握C++语言前，最好先精通C语言；其次，我们身边存在着大量的C语言代码，需要去维护和阅读；最后，不是每个人都喜欢改用C++编程，例如对于编写小规模的程序，使用C++反而不会获得多少好处。</p>\n<h2 id=\"C语言的优缺点\"><a href=\"#C语言的优缺点\" class=\"headerlink\" title=\"C语言的优缺点\"></a>C语言的优缺点</h2><p>C语言的优缺点都源于它最初的用途，以及其基础理论体系。</p>\n<ul>\n<li><p>C语言是一种底层语言。它提供了对内存访问的功能。C程序的许多服务都依赖于操作系统提供的接口。</p>\n</li>\n<li><p>C语言是一种小型语言。C语言的特性不多，应用程序的绝大部分功能依赖于标准库。</p>\n</li>\n<li><p>C语言是一种包容性语言。C语言假设用户知道自己在做什么，因此有编写自由度。C语言不强制进行错误检查。</p>\n</li>\n</ul>\n<h3 id=\"C语言的优点\"><a href=\"#C语言的优点\" class=\"headerlink\" title=\"C语言的优点\"></a>C语言的优点</h3><ol>\n<li><p>高效。发明C语言的目的是为了替代汇编语言。</p>\n</li>\n<li><p>可移植。有标准库的存在。</p>\n</li>\n<li><p>功能强大、灵活。C语言的数据类型和运算符集合有足够强大的表达能力。</p>\n</li>\n<li><p>与Unix集成。</p>\n</li>\n</ol>\n<h3 id=\"C语言的缺点\"><a href=\"#C语言的缺点\" class=\"headerlink\" title=\"C语言的缺点\"></a>C语言的缺点</h3><ol>\n<li><p>C程序更容易隐藏错误。由于其灵活性，导致编写的代码令编译器很难检查错误。</p>\n</li>\n<li><p>C程序可能会难以理解。</p>\n</li>\n<li><p>C程序可能会难以修改。因为它设计时没考虑到维护的问题。C语言没有提供类，包等模块化概念。</p>\n</li>\n</ol>\n<h3 id=\"高效地使用C语言\"><a href=\"#高效地使用C语言\" class=\"headerlink\" title=\"高效地使用C语言\"></a>高效地使用C语言</h3><ol>\n<li>学习规避C语言的缺陷。比如越界问题。</li>\n<li>使用软件工具。</li>\n<li>利用现有的代码库。</li>\n<li>采用切合实际的编码规范。</li>\n<li>避免“投机取巧”和极度复杂的代码。</li>\n<li>使用标准C，少用经典C。标准C即是 ANSI C ，本书采用的是标准C。</li>\n<li>避免不可以移植性。# 第二章 C语言基本概念</li>\n</ol>\n<hr>\n<h2 id=\"编写一个简单的C程序\"><a href=\"#编写一个简单的C程序\" class=\"headerlink\" title=\"编写一个简单的C程序\"></a>编写一个简单的C程序</h2><h3 id=\"程序：显示双关语\"><a href=\"#程序：显示双关语\" class=\"headerlink\" title=\"程序：显示双关语\"></a>程序：显示双关语</h3><p>这是经典C的一个示例：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">// pun.c</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"To C, or not to C: that is the question.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"编译和链接\"><a href=\"#编译和链接\" class=\"headerlink\" title=\"编译和链接\"></a>编译和链接</h3><p>首先，需要一个.c文件保存程序代码，接下来需要把程序转换为机器可以执行的形式。通常包含下列三个步骤：</p>\n<ul>\n<li><p>预处理。首先会把程序送交给预处理器（ preprocessor ）。预处理器执行以#开头的命令。</p>\n</li>\n<li><p>编译。修改后的程序现在可以进入编译器（ compiler ）了。编译器会把程序翻译成机器指令（即目标代码， object code ）。</p>\n</li>\n<li><p>链接。链接器（ linker ）把由编译器产生的目标代码和任何其他附加代码整合在一起，产生完全可执行的程序。</p>\n</li>\n</ul>\n<p>这个过程可以一步完成，即：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">cc pun.c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在编译和链接好程序后，编译器 cc 会把可执行程序放到默认名为 a.out 的文件中。编译器 cc 有许多选项，其中 -o 允许给可执行程序选择一个名字：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">cc -o pun pun.c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果使用 gcc 进行编译，那么建议在编译时采用 -Wall 选项：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">gcc -Wall -o pun pun.c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>也可以手动分布完成：</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">cc -o main.i -E main.c <span class=\"token comment\" spellcheck=\"true\"># 预编译</span>\ncc -o main.o -c main.i <span class=\"token comment\" spellcheck=\"true\"># 编译</span>\ncc -o main main.o      <span class=\"token comment\" spellcheck=\"true\"># 链接</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"简单程序的一般形式\"><a href=\"#简单程序的一般形式\" class=\"headerlink\" title=\"简单程序的一般形式\"></a>简单程序的一般形式</h2><p>形式如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">指令\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    语句\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>在编译C程序之前，预处理器会首先对C程序进行编辑。我们把预处理器执行的命令称为指令。这里只关注 #include 指令。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这条指令说明，在编译前把 stdio.h 中的信息“包含”到程序中。这段程序中包含 stdio,h 的原因是：C语言没有内置的“读”和“写”命令。因此，进行输入/输出操作就需要用标准库中的函数来实现。</p>\n<p>这里是指预所有指令都是以#开头。一条指令必须占据一行，且不留分号结尾。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数是用来构建程序的一个构建块。C程序就是函数的集合。函数分为两大类：一类是程序员编写的函数，另一类则是由C语言的实现所提供的函数。后者可以称为库函数（ library function ）。</p>\n<p>在C语言中，函数仅仅是一系列组合在一起并且赋予了名字的语句。某些函数计算一个值，而某些函数不是。计算出一个值的函数可以用 return 语句来指定所“返回”的值。</p>\n<p>每个程序必须有一个 main 函数。 main 函数是非常特殊的：在执行程序时系统会自动调用 main 函数。</p>\n<p>main 函数在程序终止时向操作系统返回一个状态码。 pun 程序始终让 main 函数返回0，0表明程序正常终止。</p>\n<p>建议加入 return 语句，如果不这样做，某些编译器可能会产生一条警告信息：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">// pun.c</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"To C, or not to C: that is the question.\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h3><p>语句是程序运行时执行的命令。每条语句都要以分号结尾。</p>\n<p>一条语句可以占据多行。</p>\n<p>程序 pun.c 只用到了两种语句。一种是返回语句，一种则是函数调用（ function call ）语句。为了在屏幕上显示一条字符串就调用了 printf 函数。</p>\n<h3 id=\"显示字符串\"><a href=\"#显示字符串\" class=\"headerlink\" title=\"显示字符串\"></a>显示字符串</h3><p>我们用 printf 函数显示了一条字符串字面量（ string literal ）。字符串字面量是用一对双引号包围的一系列字符。</p>\n<p>当打印结束时， printf 函数不会自动跳转到下一输出行。为了让 printf 跳转到下一行，必须要在打印的字符串中包含一个 \\n （换行符）。写换行符就意味着终止当前行，然后把后续的输出转到下一行进行。</p>\n<p>换行符可以在一个字符串字面量中出现多次。比如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Brevity is the soul of wit.\\n -- Shakespeare\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>注释就是代码的说明。在预编译后，注释会移除出代码。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* This is a comment */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>为 pun.c 增加注释：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/*    Name: pun.c\n    Purpose: Prints a bad pun.\n    Author: K.N.King\n    Data written: 5/21/95\n*/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"变量和赋值\"><a href=\"#变量和赋值\" class=\"headerlink\" title=\"变量和赋值\"></a>变量和赋值</h2><p>变量（ variable ）就是用来存储数据的存储单元。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>一个变量必须有一个类型。类型决定了存储单元的大小和对变量的操作方式。</p>\n<p>int 型变量可以存储整数，例如0、1、392或者-2553，但是，整数的取值范围是受限制的。某些计算机上，int型数值的最大取值仅仅是32767。</p>\n<p>float 型变量可以存储更大的数值，而且，float型变量可以存储带小数位的数据，例如379.125。但是，float 型变量有一些缺陷，即这类变量需要的存储空间要大于 int 型变量。而且，进行算术运算时 float 型变量通常比 int 型变量慢。另外， float 型变量所存储的数值往往只是实际数值的一个近似值。</p>\n<h3 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h3><p>在使用变量前，必须对其进行声明，这也是为了便于编译器工作。例如，声明变量 height 的方式如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> height<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果几个变量具有相同的类型，就可以把它们的声明合并：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> height<span class=\"token punctuation\">,</span> length<span class=\"token punctuation\">,</span> width<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>当 main 函数包含声明时，必须把声明放置在语句之前：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    声明\n    语句\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><p>变量可以通过赋值（ assignment ）的方式获得一个值。例如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">height <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\nvolume <span class=\"token operator\">=</span> height <span class=\"token operator\">*</span> length <span class=\"token operator\">*</span> width<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>赋值运算符的右侧可以是一个含有常量、变量和运算符的公式（表达式， expression ）。</p>\n<h3 id=\"显示变量的值\"><a href=\"#显示变量的值\" class=\"headerlink\" title=\"显示变量的值\"></a>显示变量的值</h3><p>用 printf 可以显示当前变量的值。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Height: %d\\n\"</span><span class=\"token punctuation\">,</span> height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>占位符 %d 用来指明在打印过程中变量 height 的值的显示位置。 %d 仅用于 int 型变量，如果要打印 float 型变量，需要用 %f 来代替。默认情况下， %f 会显示小数点后6位数字，若需要显示小数点后n位数字，则可以把 .n 放置在%和f之间。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Profit: $%.2f\\n\"</span><span class=\"token punctuation\">,</span> profit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>当程序开始执行时，某些变量会被自动设置为0，而大多数变量则不会。没有默认值并且尚未在程序中被赋值的变量是未初始化的（ uninitialized ）。</p>\n<p>使用初始化式对其变量进行初始化，如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"读入输入\"><a href=\"#读入输入\" class=\"headerlink\" title=\"读入输入\"></a>读入输入</h2><p>为了获取输入，就要用到 scanf 函数。 scanf 中的字母f和 printf 中的f含义相同，都是表示“格式化”的意思。 scanf 和 printf 函数都需要使用格式串（ format string ）来说明输入或输出的样式。</p>\n<p>为了读取一个 int 型数值，可以使用如下的 scanf 函数调用。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>字符串“%d”说明 scanf 读入的是一个整数，i是一个 int 型变量，用来存储读入的输入。</p>\n<p>读入一个 float 型数值时，需要这样的 scanf 调用：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%f\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>%f只适用于 float 型变量。</p>\n<h2 id=\"定义常量\"><a href=\"#定义常量\" class=\"headerlink\" title=\"定义常量\"></a>定义常量</h2><p>常量（ constant ）是在程序执行过程中固定不变的量。当程序含有常量时，建议给这些常量命名。方式是使用宏定义（ macro defination ）。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> N 4</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这里的 #define 是预处理指令。当程序进行编译时，预处理器会把每一个宏用其表示的值替换回来。</p>\n<p>此外，还可以利用宏来定义表达式：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> SCALE_FACTOR (5.0 / 9.0)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>当宏包含运算时，必须用括号把表达式括起来。</p>\n<p>宏的名字一般用大写字母，这是大多数程序员遵守的规范。</p>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p>标识符就是函数、变量、宏等实体的名字。</p>\n<p>标识符由字母、数字和下划线组成，且区分大小写。必须以字母或下划线开头。</p>\n<p>为了使名字清晰，可以使用两种命名风格：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">symbol_table\nSymbolTable<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>关键字</strong></p>\n<p>关键字（ keyword ）对编译器而言都有特殊的含义，因此标识符不能和关键字一样。</p>\n<p>所有的关键字见书本p19</p>\n<h2 id=\"C语言程序的布局\"><a href=\"#C语言程序的布局\" class=\"headerlink\" title=\"C语言程序的布局\"></a>C语言程序的布局</h2><p>C程序可以被看成一连串的<strong>记号（ token ）</strong>。记号就是无法分割的字符组。</p>\n<p>标识符、关键字、运算符、字符串等都是记号。</p>\n<p>记号之间可以有空格，换行等字符。</p>\n<p>有记号的概念后，C程序就可以这样书写：</p>\n<ul>\n<li><p>语句可以放到多行内。对于很长的语句这样很合适。</p>\n</li>\n<li><p>记号间的空格可以更容易区分记号。比如运算符两边加空格方便阅读。</p>\n</li>\n<li><p>缩进有助于识别程序嵌套。</p>\n</li>\n<li><p>空行可以把程序划分为逻辑单元。# 第三章 格式化输入输出</p>\n</li>\n</ul>\n<p>scanf 函数和 printf 函数是C语言使用最频繁的两个函数，它们用来支持格式化的读和写。</p>\n<hr>\n<h2 id=\"printf-函数\"><a href=\"#printf-函数\" class=\"headerlink\" title=\"printf 函数\"></a>printf 函数</h2><p>printf 函数被设计用来显示格式串（ format string ）的内容，并且在字符串指定位置插入可能的值。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span>格式串<span class=\"token punctuation\">,</span> 表达式<span class=\"token number\">1</span><span class=\"token punctuation\">,</span> 表达式<span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>格式串包含普通字符和转换说明（ conversion specification ），其中转换说明以字符%开头。</p>\n<p>!!!warning<br>    C语言编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配。</p>\n<h3 id=\"转换说明\"><a href=\"#转换说明\" class=\"headerlink\" title=\"转换说明\"></a>转换说明</h3><p>在通用的情况下，转换说明可以有%m.pX格式或%-m.pX格式，这里的m和p都是整型常量，X是字母。m和p都是可选项。</p>\n<p>在转换说明%10.2f中，m是10，p是2，X是f。</p>\n<p><strong>最小字段宽度（ minimum field width ）</strong> m指定了要显示的最小字符数量。如果要打印的数值比m个字符少，那么值在字段内是右对齐的。如果要多，那么字段宽度会自动扩展为需要的尺寸。</p>\n<p><strong>精度（ precision ）</strong> p的含义依赖于<strong>转换说明符X（ conversion specifier ）</strong>的选择。对数来说，最常用的转换说明符有：</p>\n<ul>\n<li><p>d，表示十进制形式的整数。p说明可以显示的数字的最少个数（如果需要，就在数前加上额外的零）；如果忽略掉p，默认它的值为1。</p>\n</li>\n<li><p>e，表示指数形式的浮点数。p说明小数点后应该出现的数字的个数（默认为6）。如果p为0，则不显示小数点。</p>\n</li>\n<li><p>f，表示“定点十进制”形式的浮点数，没有指数。p的含义与在说明符e中的一员。</p>\n</li>\n<li><p>g，表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。p可以说明显示的有效数字的最大数量。与转换说明符f不同，g的转换将不显示尾随零。</p>\n</li>\n</ul>\n<h3 id=\"转义序列\"><a href=\"#转义序列\" class=\"headerlink\" title=\"转义序列\"></a>转义序列</h3><p>我们经常把在格式串中用的代码<code>\\n</code>称为转义序列（ escape sequence ）。转义序列使字符串包含一些特殊字符而又不会使编译器引发问题。</p>\n<p>详细的说明：<a href=\"https://zh.cppreference.com/w/cpp/language/escape\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/escape</a></p>\n<h2 id=\"scanf-函数\"><a href=\"#scanf-函数\" class=\"headerlink\" title=\"scanf 函数\"></a>scanf 函数</h2><p>scanf 函数也根据特定的格式读取输入， scanf 函数转换说明符的用法和 printf 函数转换说明符的用法本质上是一样的。</p>\n<p>scanf 函数有一些不易察觉的陷阱。使用 scanf 时，程序员必须检查转换说明的数量是否与输入变量的数量相匹配，并且检查每个转换是否适合相对应的变量。另一个陷阱涉及符号&amp;，通常把符号&amp;放在 scanf 函数调用的每个变量的前面。</p>\n<p>调用 scanf 函数是读取数据的一种有效但不理想的方法。许多专业C程序员避免用 scanf 函数，而是采用字符格式读取所有数据，然后再把它们转换成数值形式。</p>\n<h3 id=\"scanf-函数的工作方法\"><a href=\"#scanf-函数的工作方法\" class=\"headerlink\" title=\"scanf 函数的工作方法\"></a>scanf 函数的工作方法</h3><p>scanf 函数本质上是一种“模式匹配”函数，也就是试图把输入的字符组与转换说明匹配成组。</p>\n<p>scanf 调用时，从左边开始处理字符串中的信息。对于格式串中的每一个转换说明， scanf 函数努力从输入的数据中定位适当类型的项，并且跳过必要的空格。然后， scanf 函数读入数据项，并且在遇到不可能属于此项的字符时停止。</p>\n<p>在寻找数的起始位置时， scanf 函数会忽略空白（ white-space ）字符（空格符、横向和纵向制表符、换页符、换行符）。</p>\n<h3 id=\"格式串中的普通字符\"><a href=\"#格式串中的普通字符\" class=\"headerlink\" title=\"格式串中的普通字符\"></a>格式串中的普通字符</h3><p>处理格式串中普通字符时， scanf 函数采取的动作依赖于这个字符是否为空白字符。</p>\n<ul>\n<li><p>空白字符。当在格式串中遇到一个或多个连续的空白字符时， scanf 函数从输入中重复读空白字符直到遇到一个非空白字符（把该字符“放回原处”）为止。</p>\n</li>\n<li><p>其他字符。当在格式串中遇到一个非空白字符时， scanf 函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么 scanf 函数会放弃输入字符而继续处理格式串。如果两个字符不匹配，那么 scanf 函数会把不匹配的字符放回输入中，然后异常退出。# 第四章 表达式</p>\n</li>\n</ul>\n<p>表达式是显示如何计算值的公式。最简单的表达式是变量和常量。变量表示程序运行时计算出的值；常量表示不变的值。</p>\n<p>运算符是构建表达式的基本工具。C语言提供了基本的运算符：</p>\n<ul>\n<li>算术运算符。</li>\n<li>关系运算符。</li>\n<li>逻辑运算符。</li>\n</ul>\n<hr>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><p>算术运算符有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">一元运算符</th>\n<th align=\"center\">二元运算符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">+ -</td>\n<td align=\"center\">+ - * / %</td>\n</tr>\n</tbody></table>\n<p>二元运算符要求有两个操作数，而一元运算符只要有一个操作数。</p>\n<p>一元运算符+无任何操作，它主要是为了强调某数值常量是正的。</p>\n<p>%被称之为 mod （求模）或 rem （取余）。 i % j 的数值是i除以j后的余数。</p>\n<p>除了%，二元运算符既允许操作数是整数也允许操作数是浮点数，或者允许两者的混合。当把 int 型操作数和 float 型操作数混合在一起时，运算结果是 float 型的。</p>\n<p>运算符/和%需要特别注意：</p>\n<ul>\n<li>/可能产生意外的结果。当两个操作数都是整数时，运算符/通过丢掉分数部分的方法截取结果，因此1/2的结果是0。</li>\n<li>%要求整数操作数；如果两个操作数中有一个不是整数，那么程序将无法通过编译。</li>\n<li>当/和%用于负数时，其结果与具体实现有关。如果操作数中有一个为负数，那么除法的结果既可以向上取整也可以向下取整。</li>\n</ul>\n<p>!!!note “由实现定义”<br>    术语由实现定义（ implementation-defined ）出现频率很高，意思是指软件在特定的平台上编译、链接和执行。根据实现的不同，程序的行为可能会稍有差异。<br>    C语言的目的之一是达到高效率，这经常意味着要与硬件行为相匹配。当-9除以7时，一些机器可能产生的结果是-1，而另一些机器的结果为-2，C标准简单地反映了这一现实。<br>    最好避免编写与实现定义的行为相关的程序。</p>\n<h3 id=\"运算符的优先级和结合性\"><a href=\"#运算符的优先级和结合性\" class=\"headerlink\" title=\"运算符的优先级和结合性\"></a>运算符的优先级和结合性</h3><p>C语言允许在所有表达式中用圆括号进行分组。但如果不使用圆括号，就采用运算符优先级（ operator precedence ）的规则来解决问题。算术运算符有下列相对优先级：</p>\n<ul>\n<li>最高优先级：+ -（一元运算符）</li>\n<li>中级优先级：* / %</li>\n<li>最低优先级：+ -（二元运算符）</li>\n</ul>\n<p>例如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">i <span class=\"token operator\">+</span> j <span class=\"token operator\">*</span> k<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 等价于 i + (j * k)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>当一个表达式包含两个以上相同优先级的运算符时，单独的运算符优先级的规则是不够的。这种情况下，运算符的结合性（ associativity ）开始发挥作用。如果运算符是从左向右结合的，那么称这种运算符是左结合的（ left associative ）。二元算术运算符都是左结合的，所以：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">i <span class=\"token operator\">-</span> j <span class=\"token operator\">-</span> k<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 等价于 (i - j) - k</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果运算符是从右向左结合的，那么称为右结合的（ right associative ）。一元运算符都是右结合的。</p>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>一旦计算出表达式的值就常常需要把这个值存储在变量中，以便后面使用。C语言的=运算符（assignment）可以用于此目的。</p>\n<h3 id=\"简单赋值\"><a href=\"#简单赋值\" class=\"headerlink\" title=\"简单赋值\"></a>简单赋值</h3><p>表达式v = e的赋值效果是求出表达式e的值，并把此值复制给v。e可以是常量、变量或较为复杂的表达式：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">i <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\nj <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\nk <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token operator\">*</span> i <span class=\"token operator\">+</span> j<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>如果v和e的类型不同，那么赋值运算发生时会把e的值转化为v的类型：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\ni <span class=\"token operator\">=</span> <span class=\"token number\">72.99</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* i is now 72 */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>赋值操作产生结果，赋值表达式v=e的值就是赋值运算后v的值。因此，表达式i = 72.99的值是72。</p>\n<p>!!!note “副作用”<br>    大多数C语言运算符不会改变操作数的值，但是也有一些会改变。由于这类运算符所做的不再仅仅是计算出值，所以称它们有副作用（ side effect ）。简单的赋值运算符就是一个有副作用的运算符，它改变了运算符左边的操作数。表达式i=0产生的结果为0，作为副作用，把0赋值给i。</p>\n<p>运算符=是右结合的。所以：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">i <span class=\"token operator\">=</span> j <span class=\"token operator\">=</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\ni <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 等价</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"左值\"><a href=\"#左值\" class=\"headerlink\" title=\"左值\"></a>左值</h3><p>大多数C语言运算符允许它们的操作数是变量、常量或者包含其他运算符的表达式。然而，赋值运算符要求它左边的操作数必须是左值（ lvalue ）。左值表示存储在计算机内存中的对象，而不是常量或计算结果。变量是左值，而诸如10或2*i这样的表达式则不是左值。</p>\n<h3 id=\"复合赋值\"><a href=\"#复合赋值\" class=\"headerlink\" title=\"复合赋值\"></a>复合赋值</h3><p>利用变量原有值计算出新值并重新赋值给这个变量在C语言程序中是非常普遍的。例如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">i <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>C语言的复合赋值运算符（ compound assignment operator ）允许缩短这种语句和其他类似的语句。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">i <span class=\"token operator\">+</span><span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>+=运算符把右侧操作数的值加上左侧的变量，并把结果赋值给左侧的变量。还有另外的9种复合赋值运算符，包括：</p>\n<p>-= *= /= %=</p>\n<h2 id=\"自增运算符和自减运算符\"><a href=\"#自增运算符和自减运算符\" class=\"headerlink\" title=\"自增运算符和自减运算符\"></a>自增运算符和自减运算符</h2><p>++表示操作数加1，–表示操作数减1。++和–既可以作为前缀（ prefix ）运算符，也可以作为后缀（ postfix ）运算符使用。</p>\n<p>++和–也有副作用，它们会改变操作数的值。计算表达式++i的结果是i+1，副作用是自增i。计算表达式i++的结果是i，副作用是自增i。</p>\n<p>这个自增操作一定会在下一条语句执行前完成。</p>\n<h2 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h2><p>上述总结的运算符在下表列出了其优先级、结合性。更多讨论见书本p39。</p>\n<table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>类型名称</th>\n<th>符号</th>\n<th>结合性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>后缀自增、自减</td>\n<td>++ –</td>\n<td>左结合</td>\n</tr>\n<tr>\n<td>2</td>\n<td>前缀自增、自减，一元正负</td>\n<td>++ – + -</td>\n<td>右结合</td>\n</tr>\n<tr>\n<td>3</td>\n<td>乘法类</td>\n<td>* / %</td>\n<td>左结合</td>\n</tr>\n<tr>\n<td>4</td>\n<td>加法类</td>\n<td>+ -</td>\n<td>左结合</td>\n</tr>\n<tr>\n<td>5</td>\n<td>赋值</td>\n<td>= *= /= %= += -=</td>\n<td>右结合</td>\n</tr>\n</tbody></table>\n<p><strong>子表达式的求值顺序</strong></p>\n<p>C语言没有定义子表达式的求值顺序（除了含有逻辑与运算符及逻辑或运算符、条件运算符以及逗号运算符的子表达式）。# 第五章 选择语句</p>\n<p>根据语句执行过程中顺序所产生的影响方式，C语言的其他语句大多属于以下三类：</p>\n<ul>\n<li><p>选择语句（ selection statement ）。 if 语句和 switch 语句允许程序在一组可选项中选择一条特定的执行路径。</p>\n</li>\n<li><p>循环语句（ iteration statement ）。 while 语句、 do 语句和 for 语句支持重复操作。</p>\n</li>\n<li><p>跳转语句（ jump statement ）。 break 语句、 continue 语句和 goto 语句引起无条件地跳转到程序中的某个位置。（ return 语句也属于此类）</p>\n</li>\n</ul>\n<p>C语言还有其他两类语句，一类是由几条语句组合成一条语句的复合语句，一类是不执行任何操作的空语句。</p>\n<hr>\n<h2 id=\"逻辑表达式\"><a href=\"#逻辑表达式\" class=\"headerlink\" title=\"逻辑表达式\"></a>逻辑表达式</h2><p>包括 if 语句在内的某些C语句都必须测试表达式的值是“真”还是“假”。诸如<code>i&lt;j</code>这样的比较运算会产生整数：0（假）或1（真）。</p>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>C语言的关系运算符（ relational operator ）用在C语言中时产生的结果是0（假）或1（真）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&lt;</td>\n<td align=\"center\">小于</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;</td>\n<td align=\"center\">大于</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;=</td>\n<td align=\"center\">小于或等于</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;=</td>\n<td align=\"center\">大于或等于</td>\n</tr>\n</tbody></table>\n<p>关系运算符的优先级低于算术运算符，关系运算符都是左结合的。表达式<code>i+j&lt;k-1</code>意味着<code>(i+j)&lt;(k-1)</code>。</p>\n<h3 id=\"判等运算符\"><a href=\"#判等运算符\" class=\"headerlink\" title=\"判等运算符\"></a>判等运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">==</td>\n<td align=\"center\">等于</td>\n</tr>\n<tr>\n<td align=\"center\">!=</td>\n<td align=\"center\">不等于</td>\n</tr>\n</tbody></table>\n<p>判定运算符是左结合的，也是产生0或1作为结果。然而，判等运算符的优先级低于关系运算符。例如表达式<code>i&lt;j == j&lt;k</code>等价于表达式<code>(i&lt;j) == (j&lt;k)</code>。</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">!</td>\n<td align=\"center\">逻辑非</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;&amp;</td>\n<td align=\"center\">逻辑与</td>\n</tr>\n<tr>\n<td align=\"center\">||</td>\n<td align=\"center\">逻辑或</td>\n</tr>\n</tbody></table>\n<p>逻辑运算符所产生的结果是0或1。逻辑运算符将任何非零值操作数作为真值来处理，同时将任何零值操作作为假值来处理。</p>\n<p>运算符&amp;&amp;和||都对操作数进行“短路”计算。</p>\n<p>运算符!的优先级和一元正号、负号的优先级相同。运算符&amp;&amp;和||的优先级低于关系运算符和判等运算符。运算符!是右结合的，而运算符&amp;&amp;和||是左结合的。</p>\n<h2 id=\"if-语句\"><a href=\"#if-语句\" class=\"headerlink\" title=\"if 语句\"></a>if 语句</h2><p>if 语句允许程序通过测试表达式的值从两种选项中选择一种。 if 语句的最简单的格式如下：</p>\n<p>if (表达式) 语句</p>\n<p>执行 if 语句时，先计算圆括号内的表达式的值。如果表达式的值非零，那么接着执行括号后面的语句，C语言把非零值解释为真值。</p>\n<h3 id=\"复合语句\"><a href=\"#复合语句\" class=\"headerlink\" title=\"复合语句\"></a>复合语句</h3><p>如果想用 if 语句处理两条或更多语句，该怎么办呢？可以引入复合语句（ compound statement ）。复合语句有如下格式：</p>\n<p>{ 多条语句 }</p>\n<h3 id=\"else-子句\"><a href=\"#else-子句\" class=\"headerlink\" title=\"else 子句\"></a>else 子句</h3><p>if 语句可以有 else 子句：</p>\n<p>if (表达式) 语句 else 语句</p>\n<p>如果在圆括号内的表达式的值为0，那么就执行 else 后边的语句。</p>\n<h3 id=\"条件表达式\"><a href=\"#条件表达式\" class=\"headerlink\" title=\"条件表达式\"></a>条件表达式</h3><p>C语言提供了一种特殊的运算符，这种运算符允许表达式依据条件的值产生两个值中的一个。</p>\n<p>条件运算符（ conditional operator ）由符号?和符号:组成，两个符号必须按如下格式一起使用：</p>\n<p>表达式1 ? 表达式2 : 表达式3</p>\n<p>条件运算符是C运算符中唯一一个要求3个操作数的运算符。因此，经常把它称为三元运算符。</p>\n<p>条件表达式的求值步骤是：首先计算出表达式1的值，如果此值不为零，那么计算表达式2的值，并且计算出来的值就是整个条件表达式的值；如果表达式1的值为零，那么计算表达式3的值，并且此值就是整个条件表达式的值。</p>\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>因为许多程序需要变量能存储假值和真值，所以C语言缺少适当的布尔类型可能会很麻烦。可以使用 int 型变量来模拟布尔类型：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> flag<span class=\"token punctuation\">;</span>\nflag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\nflag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>为了使程序更加便于理解，一个好的方法是用类似 TRUE 和 FALSE 这样的名字定义宏：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> TRUE 1</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> FALSE 0</span>\n\nflag <span class=\"token operator\">=</span> FALSE<span class=\"token punctuation\">;</span>\nflag <span class=\"token operator\">=</span> TRUE<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>为了更进一步实现这个想法，甚至可以定义用作类型的宏：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> BOOL int</span>\n\nBOOL flag<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"switch-语句\"><a href=\"#switch-语句\" class=\"headerlink\" title=\"switch 语句\"></a>switch 语句</h2><p>C语言提供了 switch 语句作为级联式 if 语句的替换：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>grade<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> <span class=\"token number\">4</span><span class=\"token punctuation\">:</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Excellent\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">case</span> <span class=\"token number\">3</span><span class=\"token punctuation\">:</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Good\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Average\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Poor\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">case</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Failing\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span> <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Illegal grade\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>switch 语句的最常用的格式如下：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>表达式<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> 常量表达式<span class=\"token punctuation\">:</span> 多条语句\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token keyword\">case</span> 常量表达式<span class=\"token punctuation\">:</span> 多条语句\n\n    <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span> 多条语句\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>switch 语句的组成部分：</p>\n<ul>\n<li><p>控制表达式。 switch 后面必须跟着右圆括号括起来的整型表达式。C语言把字符当成整数来处理，因此可以在 switch 语句中对字符进行判定。但是，不能用浮点数和字符串。</p>\n</li>\n<li><p>情况标号。常量表达式（ constant expression ）更像是普通的表达式，5是常量表达式，5 + 10也是，而n + 10不是（除非n是表示常量的宏）。</p>\n</li>\n<li><p>语句。每个情况标号的后边可以跟任意数量的语句，不需要用大括号括起来。每组语句的最后通常是 break 语句。# 第六章 循环</p>\n</li>\n</ul>\n<p>循环（ loop ）是重复执行某些语句（循环体）的一种语句。在C语言中，每个循环都有一个控制表达式（ controlling expression ）。每次执行循环体时都要对控制表达式进行计算。如果表达式为真，也就是值不为零，那么继续执行循环。</p>\n<p>C语言提供了3种循环语句： while 语句、 do 语句和 for 语句。</p>\n<hr>\n<h2 id=\"while-语句\"><a href=\"#while-语句\" class=\"headerlink\" title=\"while 语句\"></a>while 语句</h2><p>while 语句的格式如下所示：</p>\n<p>while (表达式) 语句</p>\n<p>执行 while 语句时，首先计算控制表达式的值。如果值不为零（即真值），那么执行循环体，接着再次判定表达式。</p>\n<h2 id=\"do-语句\"><a href=\"#do-语句\" class=\"headerlink\" title=\"do 语句\"></a>do 语句</h2><p>do 语句的格式如下所示：</p>\n<p>do 语句 while (表达式);</p>\n<p>和处理 while 语句一样， do 语句的循环体也必须是一条语句（当然可以用复合语句）。</p>\n<p>执行 do 语句时，先执行循环体，再计算控制表达式的值。如果表达式的值是非零的，那么再次执行循环体。</p>\n<h2 id=\"for-语句\"><a href=\"#for-语句\" class=\"headerlink\" title=\"for 语句\"></a>for 语句</h2><p>for 语句的格式如下所示：</p>\n<p>for (表达式1; 表达式2; 表达式3) 语句</p>\n<p>循环开始执行前，表达式1是初始化步骤，并且只执行一次，表达式2用来控制循环的终止（只要表达式2不为零，那么将继续执行循环），而表达式3是在每次循环的最后被执行的一个操作。</p>\n<h3 id=\"逗号运算符\"><a href=\"#逗号运算符\" class=\"headerlink\" title=\"逗号运算符\"></a>逗号运算符</h3><p>有些时候，我们可能喜欢编写有两个（或更多个）初始表达式的 for 语句，或者希望在每次循环时一次对几个变量进行自增操作。使用逗号表达式（ comma expression ）作为 for 语句中的第一个或第三个表达式可以实现这些想法。</p>\n<p>逗号表达式的格式如下所示：</p>\n<p>表达式1, 表达式2</p>\n<p>逗号表达式的计算要通过两步来实现：第一步，计算表达式1并且扔掉计算出的值。第二步，计算表达式2，把这个值作为整个表达式的值。计算表达式1始终会有副作用；如果没有，那么表达式1就没有了存在的意义。</p>\n<p>逗号运算符的优先级低于所有其他运算符。</p>\n<h2 id=\"退出循环\"><a href=\"#退出循环\" class=\"headerlink\" title=\"退出循环\"></a>退出循环</h2><h3 id=\"break-语句\"><a href=\"#break-语句\" class=\"headerlink\" title=\"break 语句\"></a>break 语句</h3><p>break 语句还可以用于跳出 while、 do 或 for 循环。</p>\n<h3 id=\"continue-语句\"><a href=\"#continue-语句\" class=\"headerlink\" title=\"continue 语句\"></a>continue 语句</h3><p>continue 语句无法跳出循环，它把程序控制正好转移到循环体结束之前的一点。 break 语句可以用于 switch 语句，而 continue 语句只能用于循环。</p>\n<h3 id=\"goto-语句\"><a href=\"#goto-语句\" class=\"headerlink\" title=\"goto 语句\"></a>goto 语句</h3><p>goto 语句可以跳转到函数中任何有标号的语句处。</p>\n<p>标号只是放置在语句开始处的标识符：</p>\n<p>标识符: 语句</p>\n<p>goto 语句自身的格式如下：</p>\n<p>goto 标识符;</p>\n<p>执行 goto 语句可以把控制转移到标号后的语句上，而且这些语句必须和 goto 语句本身在同一个函数中。</p>\n<h2 id=\"空语句\"><a href=\"#空语句\" class=\"headerlink\" title=\"空语句\"></a>空语句</h2><p>语句可以为空，也就是除了末尾处的分号以外什么符号也没有。# 第七章 基本类型</p>\n<hr>\n<h2 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h2><p>C语言支持两种根本不同的数值类型：整型和浮点型。整型的值都是数，而浮点型可能还有小数部分。整型还分为有符号的和无符号的。</p>\n<p>!!!note “有符号整数和无符号整数”<br>    在有符号数中，如果数为正数或零，那么最左边的位（符号位）为0，如果是负数，符号位则为1。默认情况下，C语言中的整型变量都是有符号的。</p>\n<p>C语言提供了不同尺寸的整型， int 是正常的尺寸。可以指明变量是 long 型或 short 型， signed 型或 unsigned 型。可以有这些类型组合：</p>\n<p>short int, unsigned short int, int, unsigned int, long int, unsigned long int</p>\n<p>可以把 int 省略掉，即 short int 可以写成 short 。</p>\n<p>不同类型的整型表示的取值范围根据机器的不同而不同。</p>\n<h3 id=\"整型常量\"><a href=\"#整型常量\" class=\"headerlink\" title=\"整型常量\"></a>整型常量</h3><p>这里说的常量表示在程序中以文本形式显示的数。C语言允许用十进制、八进制和十六进制形式书写整型常量。</p>\n<p>十进制常量包含数字<code>0~9</code>，但是一定不能以零开头：15 255 32767</p>\n<p>八进制常量只包含数字<code>0~7</code>，但是必须以零开头：017 0377 07777</p>\n<p>十六进制常量包含数字0<del>9和字母a</del>f，而且总是以0x开头：0xf 0xff 0xffff</p>\n<p>当程序中出现整型常量时，如果它属于 int 类型的取值范围，那么编译器会把此常量作为普通整数来处理，否则作为长整型处理。为了迫使编译器把常量作为长整型来处理，只需在后边加上一个字母L：15L</p>\n<p>为了指明是无符号常量，可以在常量后边加上字母U：15U</p>\n<p>还可以把UL写在一起：0xffffUL</p>\n<h3 id=\"读写整数\"><a href=\"#读写整数\" class=\"headerlink\" title=\"读写整数\"></a>读写整数</h3><p>读写无符号、短的或长的整数需要一些新的转换说明符。</p>\n<ul>\n<li>读写无符号整数时，使用字母u、o或x代替转换说明符d。u代表十进制、o八进制、x十六进制。</li>\n<li>读写短整数时，在d、o、u或x前面加字母h。</li>\n<li>读写长整型时，在d、o、u或x前面加字母l。</li>\n</ul>\n<h2 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h2><p>有时候需要变量存储带有小数的数，或者能存储极大数或极小数。这类数可以用浮点格式进行存储（因小数点是浮动的而得名）。C语言提供3种浮点型，它们对应不同的浮点格式：</p>\n<ul>\n<li>float ：单精度浮点数</li>\n<li>double ：双精度浮点数</li>\n<li>long double ：扩展双精度浮点数</li>\n</ul>\n<h3 id=\"浮点常量\"><a href=\"#浮点常量\" class=\"headerlink\" title=\"浮点常量\"></a>浮点常量</h3><p>浮点常量有许多书写方式：57.0 57. 57E0 5.7E1</p>\n<p>用指数表示的是10的幂。</p>\n<p>默认情况下，浮点常量都以 double 的形式存储。为了表明只需要单精度，可以在常量的末尾处加上字母f，如 57.0f 。</p>\n<h3 id=\"读写浮点数\"><a href=\"#读写浮点数\" class=\"headerlink\" title=\"读写浮点数\"></a>读写浮点数</h3><p>转换说明符 %e %f 和 %g 用于读写单精度浮点数，当读取 double 时，需要用 %lf ，而写 double 时，不需要加l。</p>\n<h2 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h2><p>给 char 类型的变量赋值：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> ch<span class=\"token punctuation\">;</span>\nch <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>C语言会按小整数的方式处理字符。</p>\n<h3 id=\"转义序列-1\"><a href=\"#转义序列-1\" class=\"headerlink\" title=\"转义序列\"></a>转义序列</h3><p>一些特殊的符号无法书写，比如换行符，这时候需要用C语言提供的特殊符号转义序列（ escape sequence ）。</p>\n<p>转义序列分成两种：字符转义序列和数字转义序列。</p>\n<h3 id=\"字符处理函数\"><a href=\"#字符处理函数\" class=\"headerlink\" title=\"字符处理函数\"></a>字符处理函数</h3><p>可以使用 toupper 库函数把小写字母转成大写字母：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">ch <span class=\"token operator\">=</span> <span class=\"token function\">toupper</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>被调用时，函数检查参数是否是小写字母，如果是，那么将它转换成大写字母，否则，函数返回参数的值。</p>\n<h3 id=\"读写字符\"><a href=\"#读写字符\" class=\"headerlink\" title=\"读写字符\"></a>读写字符</h3><p>转换说明符 %c 允许 scanf 函数和 printf 函数对单独一个字符进行读写操作。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%c\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%c\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>在读入字符前， scanf 不会跳过空白字符。为了强制 scanf 函数在读入字符前跳过空白字符，需要在格式串转换说明符 %c 前面加上一个空格。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" %c\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>C语言还提供了读写单独字符的其他方法。可以使用 getchar 和 putchar 函数来替代调用 scanf 函数和 printf 函数。每次调用 getchar 函数时，它会读入一个字符，并返回这个字符。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">ch <span class=\"token operator\">=</span> <span class=\"token function\">getchar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>putchar 函数用来写单独一个字符：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span>ch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>getchar 和 putchar 会比较快，原因是它们的实现比较简单，并且通常用宏来实现。</p>\n<h2 id=\"sizeof-运算符\"><a href=\"#sizeof-运算符\" class=\"headerlink\" title=\"sizeof 运算符\"></a>sizeof 运算符</h2><p>运算符 sizeof 允许程序确定用来存储指定类型值所需的空间的大小。</p>\n<p>sizeof(类型名)</p>\n<p>上述表达式的值是无符号整数，这个整数表示用来存储属于类型名的值所需的字节数。</p>\n<p>表达式 sizeof(char) 的值始终为1。</p>\n<p>通常情况下， sizeof 运算符也可以应用于常量、变量和表达式。</p>\n<p>既然 sizeof 返回的是无符号的整型，所以最安全的做法是把 sizeof 表达式转换成 unsigned long 型。然后用转换说明符 %lu 进行。</p>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。</p>\n<p>C语言允许表达式中混合使用基本数据类型，这种情况下编译器可能需要生成一些指令将某些操作数转换成不同类型，使得硬件可以对表达式进行计算。这类转换是隐式转换（ implicit conversion ）。C语言还允许程序员通过强制运算符执行显式转换（ explicit conversion ）。</p>\n<p>当发生下列情况时会进行隐式转换：</p>\n<ul>\n<li>当算术表达式或逻辑表达式中操作数类型不同时。</li>\n<li>当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。</li>\n<li>当函数调用中使用的参数类型与其对应的参数类型不匹配时。</li>\n<li>当 return 语句中表达式的类型和函数返回值的类型不匹配时。</li>\n</ul>\n<h3 id=\"常用的算术转换\"><a href=\"#常用的算术转换\" class=\"headerlink\" title=\"常用的算术转换\"></a>常用的算术转换</h3><p>常用的算术转换包括算术运算符、关系运算符和判等运算符。</p>\n<p>为了统一操作数的类型，通常把相对较狭小的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的是整型提升（integral promotion），它把字符或短整数转换成 int 。</p>\n<p>两种转换规则：</p>\n<ul>\n<li>任意操作数是浮点型的情况： float -&gt; double -&gt; long double</li>\n<li>两个操作数都不是浮点类型： int -&gt; unsigned int -&gt; long int -&gt; unsigned long int</li>\n</ul>\n<h3 id=\"赋值中的转换\"><a href=\"#赋值中的转换\" class=\"headerlink\" title=\"赋值中的转换\"></a>赋值中的转换</h3><p>C语言遵循一个简单的规则：把赋值运算符右侧的表达式转换成左边变量的类型。把浮点数赋值给整型变量会丢掉小数点后的部分。如果取值在变量的类型范围之外，那么把值赋值给一个较小的类型变量将会得到无意义的结果（甚至更糟）。# 第八章 数组</p>\n<p>数组是一种聚合（aggregate）变量，可以存储数值的集合。C语言中一共有两种聚合类型：数组和结构。</p>\n<hr>\n<h2 id=\"一维数组\"><a href=\"#一维数组\" class=\"headerlink\" title=\"一维数组\"></a>一维数组</h2><p>数组是含有多个数据值的数据结构，并且每个数据值具有相同的数据类型。这些数据值被称为元素。</p>\n<p>一维数组中的元素一个接一个地编排在单独一行。</p>\n<p>声明一个一维数组：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> N 10</span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"数组下标\"><a href=\"#数组下标\" class=\"headerlink\" title=\"数组下标\"></a>数组下标</h3><p>长度为n的数组元素的索引范围是0到n-1。</p>\n<p>使用数组元素：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>!!!warning<br>    C语言不要求检查下标的范围，当下标超出范围时，程序可能执行不可预知的行为。</p>\n<h3 id=\"数组初始化\"><a href=\"#数组初始化\" class=\"headerlink\" title=\"数组初始化\"></a>数组初始化</h3><p>数组可以在声明时获得一个初始值。</p>\n<p>数组初始化式（ array initializer ）：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* initial value of a is {1, 2, 3, 4, 5, 6, 0, 0, 0, 0} */</span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* initial value of a is {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} */</span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* 可以忽略数组长度，编译器自行确认 */</span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"对数组使用-sizeof-运算符\"><a href=\"#对数组使用-sizeof-运算符\" class=\"headerlink\" title=\"对数组使用 sizeof 运算符\"></a>对数组使用 sizeof 运算符</h3><p>运算符 sizeof 可以确定数组的大小（字节数）。</p>\n<p>利用 sizeof 来计算数组元素的大小：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> SIZE sizeof(a) / sizeof(a[0])</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><p>数组可以有任意维数。</p>\n<p>声明一个二维数组（或称为矩阵）：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> m<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>数组m有5行9列。</p>\n<p>为了在i行j列中存取数组m的元素，需要写成<code>m[i][j]</code>的形式。</p>\n<p>C语言按照行主序存储数组，也就是从第0行开始，接着第1行，如此下去。</p>\n<p><img src=\"%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8.jpg\" alt></p>\n<h3 id=\"多维数组初始化\"><a href=\"#多维数组初始化\" class=\"headerlink\" title=\"多维数组初始化\"></a>多维数组初始化</h3><p>通过嵌套一维数组的方法可以产生二维数组的初始化式：</p>\n<pre><code>int a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};</code></pre><h2 id=\"常量数组\"><a href=\"#常量数组\" class=\"headerlink\" title=\"常量数组\"></a>常量数组</h2><p>在数组定义前加const使得数组变成一个常量数组，表示不能修改数组里面的元素的值。但这样的数组必须在程序运行前就定义好数组内容，一般用于字符串数组。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> months<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> \n<span class=\"token punctuation\">{</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28</span><span class=\"token punctuation\">,</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">31</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">31</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n```# 第九章 函数\n\n函数是C语言中的构建块，本质上就是一个由语句组成的小程序。有了函数，程序就可以被划分成许多小块。\n\n<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n\n## 函数的定义和调用\n\n由一个案例说明函数中的一些基本概念：\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>double average(double a, double b)<br>{<br>    return (a + b) / 2;<br>}</p>\n<pre><code>\n**返回类型**：即函数开始处放置的double，表示每次调用该函数返回的类型。\n\n**形式参数（parameter）**：标识符a和b\n\n**函数体**：花括号里的内容。\n\n**实际参数（argument）**：调用函数时，传递给形式参数的表达式。\n\n### 函数定义\n\n函数定义的一般格式：\n</code></pre><p>返回类型 函数名(形式参数)<br>{<br>    声明<br>    语句<br>}</p>\n<pre><code>\n如果返回类型很长，可以把它单独放到一行。\n\nC89标准中，声明必须放在语句之前。\n\n### 函数调用\n\n这样调用函数：\n</code></pre><p>average(x, y);</p>\n<pre><code>\n注意，圆括号不能省略，否则无法正确调用。\n\n返回类型若非void，则会返回一个临时值，这个值可以保存到变量里，也可以丢弃。\n\n## 实际参数\n\n形式参数（parameter）出现在函数的定义中，表示函数调用时要提供的值。\n\n实际参数（argument）是出现在函数调用中的表达式。\n\n实际参数是通过**值传递**的。形参是实参的副本。\n\n### 实际参数的转换\n\n形参和实参的类型不一致时，会发生转换。应该先声明函数原型，然后再执行调用。\n\n这种转换属于隐式转换。实际参数将会转换成形式参数的类型。\n\n### 数组型实际参数\n\n数组名可以作为函数的参数，但是函数无法得知数组的长度，只能传递第二个参数以表明长度。\n\n通过此数组名就可以访问数组元素了。\n\n如果形式参数是多维数组，那么必须指明列的长度：\n</code></pre><p>void sum(arr[][LEN], int n);</p>\n<pre><code>\n但这种用法比较少见。\n\n## return语句\n\n非void的函数必须用return语句来指定要返回的值：\n</code></pre><p>return 表达式;</p>\n<pre><code>\n如果表达式的值得类型与返回值的类型不一致，那么会把表达式的值转换成返回值的类型。\n\n## 程序终止\n\n在main函数中执行return可以终止程序。\n\nmain函数的返回值是状态码，用于提供给操作系统，以表明程序的执行结果。正常结束返回0，异常结束返回非0值。\n\n**exit函数**\n\n另一种终止程序的办法是使用exit函数。此函数属于`&lt;stdlib.h&gt;`头。\n\n传递给exit的参数就是程序结束的状态码：\n</code></pre><p>exit(0); // 正常终止<br>exit(EXIT_SUCCESS); // 正常终止，此值为0<br>exit(EXIT_FAILURE); // 异常终止，此值为1</p>\n<pre><code>\n## 递归\n\n如果函数调用它自己，那么此函数就是递归的（recursive）。\n\n为了防止无限递归，一定要有一个终止递归的条件。# 第十章 程序结构\n\n---\n\n## 局部变量\n\n在函数体内或程序块内声明的变量叫局部变量。\n\n局部变量有如下性质：\n\n- 自动存储期限。局部变量的存储单元在函数被调用时分配的，在函数返回时收回。\n\n- 块作用域。作用域是可以引用该变量的代码文本部分。局部变量的作用域在程序块中，外部不可访问。\n\n### 静态局部变量\n\n使用static声明局部变量使其成为静态局部变量，它具有静态存储期限，而不再是自动存储期限。\n\n静态变量拥有永久的存储单元，在整个程序的执行期间都会保留。\n\n静态局部变量的作用域仍是块作用域。\n\n### 形式参数\n\n形式参数拥有和局部变量一样的性质，即自动存储期限和块作用域。\n\n其区别在于它是被实参赋值的。\n\n## 外部变量\n\n参数是给函数传递信息的一种方法。另一种方法就是使用外部变量（external variable）。\n\n外部变量声明于函数体外，也叫全局变量。它有如下性质：\n\n- 静态存储期限。如同在函数体内声明的static局部变量，静态存储期限的变量都会永久保留。\n\n- 文件作用域。外部变量的作用域为其声明处到文件末尾。\n\n### 外部变量的利弊\n\n使用外部变量容易引发的问题：\n\n- 在维护期间，如果改变了外部变量，那么就要检查引用了该外部变量的所有函数，以确认此变化对这些函数的影响\n\n- 如果外部变量的值错误，那么比较难定位是哪个函数赋予它错误的值\n\n- 使用了外部变量的函数难以复用，因为此函数不再独立，而是依赖于此外部变量\n\n要给外部变量起一个健全的名字，这样才不容易和其他变量混淆。\n\n## 程序块\n\n程序块就是这样的代码结构：\n</code></pre><p>{ 多条声明 多条语句 }</p>\n<pre><code>\n在程序块中声明的变量具有自动存储期限，出块时收回存储单元，其作用域在块内。\n\n函数体就是一个程序块。\n\n## 作用域\n\n当程序块内的声明命名了一个标识符时，如果此标识符已经可见（被其它地方声明并且可引用），那么新的声明就会”隐藏“旧的声明。\n\n## 构建C程序\n\n一个可能的编排程序的顺序：\n\n- \\#include指令\n\n- \\#define指令\n\n- 类型定义\n\n- 外部变量的声明\n\n- 除main函数之外的函数的原型\n\n- main函数的定义\n\n- 其它函数的定义# 第十一章 指针\n\n---\n\n## 指针变量\n\n现代计算机把**内存分隔为字节（byte）**。每个字节都有唯一的地址（address）。\n\n变量占有一个或多个字节的内存，把第一个字节的地址称为变量的地址。\n\n地址是一个整数，用指针类型（pointer）的变量来存储。\n\n**指针变量的声明**\n\n在变量名前加星号，来声明一个指针变量。如：\n</code></pre><p>int *p;</p>\n<pre><code>\n此声明说明p是指向int类型的对象。\n\n## 取地址运算符和间接寻址运算符\n\n### 取地址运算符\n\n得到一个变量的地址在它前面加&#39;&amp;&#39;（取地址）。如：\n</code></pre><p>int i;<br>int *p = &i;</p>\n<pre><code>\n### 间接寻址运算符\n\n获取指针变量指向的存储空间首地址在它前面加`*`（间接寻址）。如：\n</code></pre><p>*p = 10;</p>\n<pre><code>\n这个操作（\\*p）得到的就是变量的**别名**。该操作会修改变量的值。\n\n## 指针赋值\n\n只要是相同类型的指针，就可以相互赋值。这样它们就指向了相同的对象。\n\n## 指针作为参数\n\n指针可以做为函数的参数或返回值。\n\n这些情况，可能会用到指针类型的形参：\n\n0. 需要得到多个结果，故而用指针传出去\n\n0. 传入的对象太大，没有必要执行拷贝操作\n\n一般只有这些情况，返回一个指针类型才是安全的：\n\n0. 返回的是指针类型的参数\n\n0. 返回的是一个全局变量地址\n\n0. 返回的是一个static变量的地址# 第十二章 指针和数组\n\n---\n\n## 指针和数组\n\n当指针指向数组元素时，它可以操作数组元素。此时，可以对指针进行算术运算（加、减、比较）。\n\n数组名即是指向数组中第一个元素的指针。\n\n## 指针的算术运算\n\n指针指向了数组元素，之后对这个指针做算术运算就是合法的操作。但不要越界。\n\n- 指针加、减整数，代表移动元素指向\n\n- 指针相减，代表指针指向元素之间的距离\n\n- 指针比较，比较的是指针指向元素谁前谁后\n\n!!!warning\n    不能相加两个指针。\n\n## 指针用于数组处理\n\n指针可以操作数组中的元素，比如遍历数组：\n\n```c\nint *p = 0;\nfor (p = &amp;a[0]; p &lt; &amp;a[N]; ++p)\n{\n    // ...\n}</code></pre><p>这里N是数组a的长度，虽然<code>a[N]</code>不存在，但对它取地址是合法且安全的操作。</p>\n<p><strong>使用*和++组合</strong></p>\n<p>如，<code>*p++</code></p>\n<p>++操作的优先级高于*，所以这样的组合操作，会先操作指针p，然后获取其指向的内容。</p>\n<p>后置++会先返回p，然后对p递增，可以用这个操作遍历数组：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">&lt;</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>LEN<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token operator\">*</span>p<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"用数组名作为指针\"><a href=\"#用数组名作为指针\" class=\"headerlink\" title=\"用数组名作为指针\"></a>用数组名作为指针</h2><p>数组名即第一个元素的地址。即a与&amp;a[0]等价。</p>\n<p>数组名是一个指针常量，不能改变其值，应该把它赋值给一个指针变量。</p>\n<p>因此可以这样遍历数组：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span> p <span class=\"token operator\">&lt;</span> a <span class=\"token operator\">+</span> LEN<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>p<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"指针和多维数组\"><a href=\"#指针和多维数组\" class=\"headerlink\" title=\"指针和多维数组\"></a>指针和多维数组</h2><p>二维数组在内存中实际上是一维的连续存储的。其首元素如果这样写：</p>\n<ul>\n<li><p><code>&amp;a[0]</code>，代表第一行的首地址</p>\n</li>\n<li><p><code>&amp;a[0][0]</code>，代表第一个元素的首地址</p>\n</li>\n</ul>\n<p>这俩地址的值是一样的，但意义不同，因为其指向元素的类型不一样。前者是<code>int*</code>，后者是<code>int</code>。</p>\n<h3 id=\"多维数组名作为指针\"><a href=\"#多维数组名作为指针\" class=\"headerlink\" title=\"多维数组名作为指针\"></a>多维数组名作为指针</h3><p><code>int a[n][m]</code>这样的二维数组，其数组名a代表的是<code>a[0]</code>的地址，<code>a[i]</code>得到的是第i行的地址。</p>\n<p>这样的指针类型是：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>或</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>Line<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nLine p <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这里定义了一个指向数组的指针，这个数组的元素有m个。# 第十三章 字符串</p>\n<hr>\n<h2 id=\"字符串字面量\"><a href=\"#字符串字面量\" class=\"headerlink\" title=\"字符串字面量\"></a>字符串字面量</h2><p>字符串字面量（ string literal ）是用一对双括号括起来的字符序列：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token string\">\"Hello World\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"字符串字面量中的转义序列\"><a href=\"#字符串字面量中的转义序列\" class=\"headerlink\" title=\"字符串字面量中的转义序列\"></a>字符串字面量中的转义序列</h3><p>字符串字面量可以包含转义序列：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token string\">\"Hello\\tWorld\\n\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"延续字符串字面量\"><a href=\"#延续字符串字面量\" class=\"headerlink\" title=\"延续字符串字面量\"></a>延续字符串字面量</h3><p>字符串字面量可能太长，以至于无法放置在单独一行内可以把第一行用字符\\结尾，那么C语言就允许在下一行延续字符串字面量：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"put a disk in drive A, then \\\npress any key to continue\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>不只是字符串，字符\\可以用来分割任何长的符号。</p>\n<p>但\\有一个缺陷：字符串字面量必须从下一行的起始位置继续，从而破坏了程序的缩进结构。</p>\n<p>一个更好的办法是通过C语言的标准解决这个问题，也就是当两个或更多字符串字面量相连时（仅用空白字符分割），编译器必须把它们合并成单独一条字符串：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"put a disk in drive A, then\"</span>\n       <span class=\"token string\">\"press any key to continue\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"如何存储字符串字面量\"><a href=\"#如何存储字符串字面量\" class=\"headerlink\" title=\"如何存储字符串字面量\"></a>如何存储字符串字面量</h3><p>从本质上而言，C语言把字符串字面量作为字符数组来处理。当C语言编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。+1存储的是额外的空字符，它用来标志字符串的末尾，用转义序列\\0来表示，其数值为0。</p>\n<p>例如，字符串字面量”abc”是一个有4个字符的字符数组：</p>\n<p><img src=\"%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8.jpg\" alt=\"字符串存储\"></p>\n<p>字符串字面量可以为空。字符串””表示一个空串，仅有一个空字符。</p>\n<p>既然字符串字面量是作为数组来存储的，那么编译器会把它看作是char*类型的指针。</p>\n<h3 id=\"字符串字面量的操作\"><a href=\"#字符串字面量的操作\" class=\"headerlink\" title=\"字符串字面量的操作\"></a>字符串字面量的操作</h3><p>通常情况下可以在任何C语言允许使用char*指针的地方使用字符串字面量。例如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\np <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* 并非复制abc中的字符，而仅仅是使p指向字符串的第一个字符 */</span>\n\n<span class=\"token keyword\">char</span> ch<span class=\"token punctuation\">;</span>\nch <span class=\"token operator\">=</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* C语言允许对指针添加下标，因此可以给字符串字面量添加下标 */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>!!!warning<br>    对于一些编译器而言，改变字符串字面量的内容可能会导致运行异常。因此不推荐这么做。</p>\n<h3 id=\"字符串字面量与字符常量\"><a href=\"#字符串字面量与字符常量\" class=\"headerlink\" title=\"字符串字面量与字符常量\"></a>字符串字面量与字符常量</h3><p>只包含一个字符的字符串串字面量不同于字符串常量。字符串字面量”a”是指针，指向存放字符a以及后续空字符的内存单元。字符常量’a’是一个整数。</p>\n<h2 id=\"字符串变量\"><a href=\"#字符串变量\" class=\"headerlink\" title=\"字符串变量\"></a>字符串变量</h2><p>C语言只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。</p>\n<p>定义字符串变量的惯用法：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> STR_LEN 80</span>\n<span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span>STR_LEN <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* 强调的事实是 str 可以存储最多80个字符 */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"初始化字符串变量\"><a href=\"#初始化字符串变量\" class=\"headerlink\" title=\"初始化字符串变量\"></a>初始化字符串变量</h3><p>字符串变量可以在声明时进行初始化：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> date1<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"June 14\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">char</span> date2<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'J'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'u'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'n'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'e'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'4'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'\\0'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">char</span> date3<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"June 14\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* 编译器自动计算长度 */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"字符数组与字符指针\"><a href=\"#字符数组与字符指针\" class=\"headerlink\" title=\"字符数组与字符指针\"></a>字符数组与字符指针</h3><p>比如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> date1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"June 14\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* 字符数组 */</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>date2 <span class=\"token operator\">=</span> <span class=\"token string\">\"June 14\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* 字符串字面量的指针 */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>任何期望传递字符数组或字符指针的函数都将接受这两种声明的 date 作为参数。</p>\n<p>然而，需要注意，不能错误地认为上面两种 date 可以互换。两者之间有显著的差异：</p>\n<ul>\n<li><p>在声明为数组时，就像任意数组元素一样，可以修改存储在 date 中的字符。但不可以修改字符串字面量。</p>\n</li>\n<li><p>在声明为数组时， date 是数组名。在声明为指针时， date 是变量，它可以指向其他字符串。</p>\n</li>\n</ul>\n<h2 id=\"字符串的读-写\"><a href=\"#字符串的读-写\" class=\"headerlink\" title=\"字符串的读/写\"></a>字符串的读/写</h2><p>使用 printf 和 puts 函数来读写字符串。</p>\n<p>使用 scanf 和 gets 函数来读字符串。但 gets 函数不安全。</p>\n<h2 id=\"使用C语言的字符串库\"><a href=\"#使用C语言的字符串库\" class=\"headerlink\" title=\"使用C语言的字符串库\"></a>使用C语言的字符串库</h2><p>C语言的运算符无法操作字符串，C语言的库函数为字符串的操作提供了丰富的函数集。这些函数的原型驻留在 string.h 头文件中。</p>\n<p>strcpy 函数可以拷贝字符串。</p>\n<p>strcat 函数可以追加字符串。</p>\n<p>strcmp 函数可以比较字符串。</p>\n<p>strlen 函数可以取得字符串的长度。</p>\n<h2 id=\"字符串数组\"><a href=\"#字符串数组\" class=\"headerlink\" title=\"字符串数组\"></a>字符串数组</h2><p>比如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>planets<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"Mercury\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Venus\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Earth\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Mars\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Jupiter\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Saturn\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Uranus\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Neptune\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Pluto\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>planets 数组的每一个元素是一个字符串的指针。</p>\n<h3 id=\"命令参数\"><a href=\"#命令参数\" class=\"headerlink\" title=\"命令参数\"></a>命令参数</h3><p>运行程序时，经常需要提供一些信息给程序，这是命令行参数（ command-line argument ）。必须把 main 函数定义为含有两个参数的函数：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>argc （参数计数）是命令行参数的数量（包括程序名本身，最少为1）。 argv (“参数向量”)是指命令行参数的指针数组。 argv[0] 指向程序名， argv[n] 表示第n个参数。</p>\n<p>argv[argc] 始终是一个空指针。</p>\n<p>如果用户输入了下面的命令：</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">ls -l remind.c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>那么 argc 和 argv 是：</p>\n<ul>\n<li><p>argc: 3</p>\n</li>\n<li><p>argv: {“ls”, “-l”, “remind.c”, NULL}# 第十四章 预处理器</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"预处理器的工作方式\"><a href=\"#预处理器的工作方式\" class=\"headerlink\" title=\"预处理器的工作方式\"></a>预处理器的工作方式</h2><p>预处理器的行为是由指令控制的。这些指令是由#字符开头的一些命令。比如 #define 和 #include 。</p>\n<p><code>#define</code>定义了一个宏——用来代表其他东西的一个名字。当宏在后面的程序中用到时，预处理器扩展它，将宏替换为它所定义的值。</p>\n<p><code>#include</code>指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分。</p>\n<p>!!!note “my note”<br>    可以使用<code>gcc -E src.c</code>指令来查看预编译结果。</p>\n<h2 id=\"预处理指令\"><a href=\"#预处理指令\" class=\"headerlink\" title=\"预处理指令\"></a>预处理指令</h2><p>常见预处理指令包括：</p>\n<ul>\n<li><p>宏定义。<code>#define</code>定义一个宏，<code>#undef</code>删除一个宏。</p>\n</li>\n<li><p>文件包含。即<code>#include</code></p>\n</li>\n<li><p>条件编译。<code>#if #ifdef #ifndef #elif #else #endif</code></p>\n</li>\n</ul>\n<p>指令的通用规则有：</p>\n<ul>\n<li><p>都以#开始。</p>\n</li>\n<li><p>在指令的符号之间可以插入任意数量的空格或横向制表符。</p>\n</li>\n<li><p>指令总是在第一个换行符处结束，除非明确地指明要继续，用\\字符换行。</p>\n</li>\n<li><p>指令可以出现在程序的任何地方。</p>\n</li>\n<li><p>注释可以与指令放在同一行。</p>\n</li>\n</ul>\n<p><a href=\"../../codes/CProgramming/lab/test_precompiled_command.c\">测试代码</a></p>\n<h2 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h2><p>宏定义的作用范围从定义处开始到本文件末尾。</p>\n<h3 id=\"简单宏定义\"><a href=\"#简单宏定义\" class=\"headerlink\" title=\"简单宏定义\"></a>简单宏定义</h3><p>简单宏定义的格式如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> &lt;宏名> [替换列表]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>替换列表中可以有空格。甚至可以没有替换列表，此时宏替换后，就等于删除了这个宏一样。</p>\n<p>简单的宏定义一般用于：</p>\n<ul>\n<li>给字面量取一个别名</li>\n<li>辅助条件编译</li>\n</ul>\n<h3 id=\"带参数的宏定义\"><a href=\"#带参数的宏定义\" class=\"headerlink\" title=\"带参数的宏定义\"></a>带参数的宏定义</h3><p>格式如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> &lt;宏名>(x1, x2, ..., xn) [替换列表]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>注意点：</p>\n<ul>\n<li><p>宏名和参数列表的括号之间不能有空格，不然就是一个简单宏了</p>\n</li>\n<li><p>参数列表可以为空，这样的宏使用起来就像一个函数</p>\n</li>\n<li><p>参数只会替换记号，字符串内的同名单词并不会被替换</p>\n</li>\n</ul>\n<p>带参数的宏一般用于：</p>\n<ul>\n<li>替代一些小的函数，这样程序的执行效率会高一些，并且函数可能更加通用，因为宏不必检查参数类型</li>\n</ul>\n<h3 id=\"号和-号\"><a href=\"#号和-号\" class=\"headerlink\" title=\"#号和##号\"></a>#号和##号</h3><p>宏替换列表中有两个特殊符号：#和##，它们有如下的意义：</p>\n<ul>\n<li>#号代表参数会被替换成一个字符串字面量，例如 :</li>\n</ul>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> PRINT_INT(n) printf(#n \" = %d\\n\", n)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>#n会被替换成”n”，相邻的字符串字面量可以连起来形成一个字符串字面量，所以PRINT_INT(a)的宏替换结果是：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a = %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li>##代表将两边的记号连接在一起，成为一个记号，一个典型的例子：</li>\n</ul>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> GENERIC_MAX(type)               \\\ntype type##_max(type x, type y)         \\\n{                                       \\\n        return x > y ? x : y;           \\\n};</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个宏定义定义了一个取最大值的函数，可以方便的为这个函数指定比较类型。</p>\n<p>值得注意的是，<strong>#和##都在简单的宏替换后起作用</strong>。</p>\n<h3 id=\"宏定义中的圆括号\"><a href=\"#宏定义中的圆括号\" class=\"headerlink\" title=\"宏定义中的圆括号\"></a>宏定义中的圆括号</h3><p>如果宏定义的替换列表是一个表达式，那么为其增加圆括号是必不可少的工作。</p>\n<p>这是因为如果不加圆括号，在宏替换后，新的表达式可能会破坏替换列表表达式的运算优先级。</p>\n<p><strong>在替换列表表达式中使用圆括号有两条规则：</strong></p>\n<ol start=\"0\">\n<li>用圆括号将替换列表括起来</li>\n<li>用圆括号把每个宏参数括起来</li>\n</ol>\n<p>一个安全的宏的例子：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> SUM(x, y) ((x) + (y))</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"创建较长的宏\"><a href=\"#创建较长的宏\" class=\"headerlink\" title=\"创建较长的宏\"></a>创建较长的宏</h3><p>一些废话：</p>\n<p>宏函数展开后，实际上只有一行。而编写的时候为了好看，可以用<code>\\</code>作为换行连接符号。</p>\n<p>另外，宏函数使用时看上去应该像普通函数一样：后面也要加分号。所以宏函数的替换列表的末尾应该没有分号。</p>\n<p><strong>直接上书上所给的解决方案：</strong></p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> ECHO(str)    \\\ndo                   \\\n{                    \\\n    gets(str);       \\\n    puts(str);       \\\n} while(0)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// use</span>\n<span class=\"token function\">ECHO</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"预定义宏\"><a href=\"#预定义宏\" class=\"headerlink\" title=\"预定义宏\"></a>预定义宏</h3><p>常用预定义宏：</p>\n<table>\n<thead>\n<tr>\n<th>宏</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__LINE__</code></td>\n<td>行号，十进制常数</td>\n</tr>\n<tr>\n<td><code>__FILE__</code></td>\n<td>文件名</td>\n</tr>\n<tr>\n<td><code>__DATE__</code></td>\n<td>文件编译时的日期</td>\n</tr>\n<tr>\n<td><code>__TIME__</code></td>\n<td>文件编译时的时间</td>\n</tr>\n</tbody></table>\n<p>文件名，日期，时间的预定义宏展开后都是一个字符串变量。行号是一个整型变量。</p>\n<p>另外，不同的系统会定义不同的预定义宏，来标识其编译平台。如：</p>\n<ul>\n<li><p>Linux下，<code>__unix</code></p>\n</li>\n<li><p>Windows下，<code>_WIN32</code></p>\n</li>\n</ul>\n<p>这种预定义宏配合条件编译就可以做到跨平台编译代码。</p>\n<p><a href=\"../../codes/CProgramming/lab/test_precompiled_macros.c\">测试代码</a></p>\n<p><strong>特殊的预定义宏<code>__VA_ARGS__</code></strong></p>\n<p>C99标准中，有一个特殊的预定义宏，它的作用是替换可变参数列表（…），但它要和##符号配合使用，此时##的意义不再是连接，而是：当可变参数列表为空的时候，去除<code>__VA_ARGS__</code>前面的逗号，从而避免编译错误。</p>\n<p>一个典型的例子：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> CONSOLE_DEBUG(fmt, ...)\\\n    printf(\"FILE: \"__FILE__\", LINE: %05d \"fmt\"\\n\", __LINE__, ##__VA_ARGS__);</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><code>__FUNCTION__</code></p>\n<p>这个宏代表了当前执行函数的函数名字符串。</p>\n<h2 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h2><p>条件编译指令排除了不应该出现的文本。只有通过了条件编译的文本块才会被交给编译器编译。</p>\n<p>条件一般是一个普通的宏。</p>\n<p>书写格式如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">if</span> MACRO</span>\ncode\n<span class=\"token macro property\">#<span class=\"token directive keyword\">elif</span> MACRO</span>\ncode\n<span class=\"token macro property\">#<span class=\"token directive keyword\">else</span></span>\ncode\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"defined-运算符\"><a href=\"#defined-运算符\" class=\"headerlink\" title=\"defined 运算符\"></a>defined 运算符</h3><p>defined 运算符仅用于预处理器。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">if</span> defined(DEBUG)</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>如果标识符 DEBUG 是一个定义过的宏，则返回1，否则返回0。 defined 返回1意味着通过条件。</p>\n<p>指令说明：</p>\n<ul>\n<li><p>#if, #elif可以判断这个宏的值，如果是0就不会通过条件编译</p>\n</li>\n<li><p>#ifdef, #ifndef可以判断这个宏是否被定义</p>\n</li>\n</ul>\n<p>条件编译的作用一般是：</p>\n<ul>\n<li><p>为了支持跨平台编译</p>\n</li>\n<li><p>排除一些调试代码</p>\n</li>\n</ul>\n<h2 id=\"其他指令\"><a href=\"#其他指令\" class=\"headerlink\" title=\"其他指令\"></a>其他指令</h2><p><strong>#error 指令</strong></p>\n<p>如果预处理器遇到一个<code>#error</code>指令，它会显示一个出错消息，大多数编译器会立即终止编译。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">error</span> You can not include this file</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>#pragma指令</strong></p>\n<p><code>#pragma</code>指令为要求编译器执行某些特殊操作提供了一种方法。</p>\n<p>使用#pragma pack预处理指令来设置字节对齐。具体用法如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> pack(push)    </span><span class=\"token comment\" spellcheck=\"true\">// 保存现在的字节对齐状态</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> pack(4)       </span><span class=\"token comment\" spellcheck=\"true\">// 设置4字节对齐</span>\n<span class=\"token comment\" spellcheck=\"true\">// 这里定义的结构体最好以4字节对齐</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">pragma</span> pack(pop)     </span><span class=\"token comment\" spellcheck=\"true\">// 恢复字节对齐状态</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里字节对齐的意思是，将结构体中最大内置类型的成员的长度与默认字节对齐数（比如是4）对比，如果谁小，那么就按谁来对齐。# 第十五章 编写大规模程序</p>\n<p>源文件包含函数的定义和外部变量，而头文件包含可以在源文件之间共享的信息。</p>\n<hr>\n<h2 id=\"源文件\"><a href=\"#源文件\" class=\"headerlink\" title=\"源文件\"></a>源文件</h2><p>可以把程序分割成一定数量的源文件，源文件的扩展名为<code>.c</code>。源文件主要包含函数的定义和变量。其中一个源文件必须包含名为 main 的函数，作为程序的起始点。</p>\n<p>把程序分成多个源文件有许多显著的优点：</p>\n<ul>\n<li><p>把相关的函数和变量集合在单独一个文件中可以帮助明了程序的结构。</p>\n</li>\n<li><p>可以单独对每一个源文件进行编译。如果程序规模很大而且需要频繁改变的话，这种方法可以极大地节约时间。</p>\n</li>\n<li><p>利于复用。</p>\n</li>\n</ul>\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><p>当把程序分割成几个源文件时，问题也随之产生：某文件的函数如何能调用定义在其他文件中的函数？函数如何能访问其他文件中的外部变量？两个文件如何能共享同一个宏定义或类型定义？答案取决于<code>#include</code>指令。</p>\n<p><code>#include</code>指令告诉预处理器打开指定的文件，并且把此文件的内容插入到当前文件中。这种打开的文件称为头文件，其扩展名为<code>.h</code>。</p>\n<h3 id=\"include-指令\"><a href=\"#include-指令\" class=\"headerlink\" title=\"include 指令\"></a>include 指令</h3><p><code>#include</code>指令有两种书写格式：</p>\n<ul>\n<li><p><code>#include &lt;文件名&gt;</code> 搜索系统头文件所在目录，比如在 UNIX 系统中，通常是在 /usr/include</p>\n</li>\n<li><p><code>#include &quot;文件名&quot;</code> 搜索当前目录，然后搜索系统目录</p>\n</li>\n</ul>\n<p>利用加上诸如-I这样的命令行选项可以添加搜索头文件的位置。</p>\n<h3 id=\"共享宏定义和类型定义\"><a href=\"#共享宏定义和类型定义\" class=\"headerlink\" title=\"共享宏定义和类型定义\"></a>共享宏定义和类型定义</h3><p>大规模的程序包含用于几个源文件共享的宏定义和类型定义，这些定义应该放在头文件中。</p>\n<p>比如下图的例子：</p>\n<p><img src=\"%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89.png\" alt=\"宏定义和类型定义\"></p>\n<p>有两个源文件包含了 boolean.h</p>\n<p>把宏定义和类型定义放到头文件中有如下的好处：</p>\n<ol>\n<li><p>不必把定义复制到需要的源文件，节约时间。</p>\n</li>\n<li><p>程序变得更加容易修改，改变定义只需要改变头文件。</p>\n</li>\n<li><p>不用担心源文件包含了相同的宏或类型而其定义不同。</p>\n</li>\n</ol>\n<h3 id=\"共享函数原型\"><a href=\"#共享函数原型\" class=\"headerlink\" title=\"共享函数原型\"></a>共享函数原型</h3><p>没有原型依赖的函数调用是很危险的，编译器的假设可能是错误的。当调用定义在其他文件中的函数时，要始终确保编译器在调用之前看到函数f的原型。</p>\n<p>解决办法就是把函数的原型放进头文件中，然后在所有调用函数f的地方包含头文件。</p>\n<p>其包含的方式可能如图所示：</p>\n<p><img src=\"%E5%85%B1%E4%BA%AB%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B.png\" alt=\"共享函数原型\"></p>\n<h3 id=\"共享变量的声明\"><a href=\"#共享变量的声明\" class=\"headerlink\" title=\"共享变量的声明\"></a>共享变量的声明</h3><p>变量可以在文件中共享。</p>\n<p>为了声明变量而不定义，需要在变量声明的开始处放置关键字 extern :</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* in heaeder file */</span>\n<span class=\"token keyword\">extern</span> <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>为了共享i，需要在一个源文件中定义i:</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* in source file */</span>\n<span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"保护头文件\"><a href=\"#保护头文件\" class=\"headerlink\" title=\"保护头文件\"></a>保护头文件</h3><p>如果一个源文件同时包含一个头文件两次，那么可能产生编译错误（比如包含了两次相同的类型定义）。</p>\n<p>因此要用到一种保护头文件的方法：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> BOOLEAN_H</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> BOOLEAN_H</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/*\n real content\n*/</span>\n\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果再次包含此头文件，预处理器就不会再扩展真实的内容。</p>\n<h3 id=\"头文件中的-error指令\"><a href=\"#头文件中的-error指令\" class=\"headerlink\" title=\"头文件中的#error指令\"></a>头文件中的#error指令</h3><p>经常把#error指令放置在头文件中是用来检查不应该包含头文件的条件。例如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">ifndef</span> DOS</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">error</span> Graphics supported only under DOS</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">endif</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>如果非DOS的程序试图包含此头文件，那么编译将在#error指令处终止。</p>\n<h2 id=\"构建多文件程序\"><a href=\"#构建多文件程序\" class=\"headerlink\" title=\"构建多文件程序\"></a>构建多文件程序</h2><p>构建大程序的基本步骤：</p>\n<ul>\n<li><p>编译，必须对每一个源文件进行编译。不需要编译头文件。编译器产生一个文件，此文件包含来自源文件的目标代码，称为目标文件（object file）。</p>\n</li>\n<li><p>链接，链接器把目标文件和库文件结合在一起生成一个可执行程序。</p>\n</li>\n</ul>\n<p>大多数编译器允许用单独一步来构建程序：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">cc <span class=\"token operator\">-</span>m fmt fmt<span class=\"token punctuation\">.</span>c line<span class=\"token punctuation\">.</span>c word<span class=\"token punctuation\">.</span>c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h3><p>使用 makefile 更易于构建大型程序。 makefile 列出了作为程序的部分文件，并描述了它们之间的依赖性。</p>\n<p>更多讨论见书本。</p>\n<p>!!!note “my note”<br>    一种自动生成依赖性的说明的方法是键入命令：<code>gcc -MM *.c</code></p>\n<h3 id=\"在程序外定义宏\"><a href=\"#在程序外定义宏\" class=\"headerlink\" title=\"在程序外定义宏\"></a>在程序外定义宏</h3><p>大多数 UNIX 编译器支持-D选项，允许在命令行指定一个宏定义：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">cc <span class=\"token operator\">-</span>DDEBUG<span class=\"token operator\">=</span><span class=\"token number\">1</span> foo<span class=\"token punctuation\">.</span>c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>定义了宏 Debug ，在 foo.c 程序中，且值为1。如同在 foo.c 中的开始出现：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> DEBUG 1</span>\n```# 第十六章 结构、联合和枚举\n\n<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n\n## 结构变量\n\n结构的元素可能具有不同的类型，而且，每个成员都有名字。\n\n### 结构变量的声明\n\n一个声明结构变量的例子：\n\n```c\n<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span>NAME_LEN <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> on_hand<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> part1<span class=\"token punctuation\">,</span> part2<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>每个结构变量都有三个成员：number, name, on_hand 。</p>\n<p><code>struct {...}</code>指明了类型，而 part1 和 part2 则是具有这种类型的变量。</p>\n<p>结构的成员在内存中是按照声明的顺序存储的。第一个声明的变量放在存储位置的最前面。</p>\n<p>每个结构表示一种新的名字空间（ name space ）。 part1 的 number 和 part2 的 number 不会有冲突。</p>\n<h3 id=\"结构变量的初始化\"><a href=\"#结构变量的初始化\" class=\"headerlink\" title=\"结构变量的初始化\"></a>结构变量的初始化</h3><p>结构变量可以在声明的同时进行初始化：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span>NAME_LEN <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> on_hand<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> part1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">528</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Disk drive\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  part2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">914</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Printer cable\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>结构初始化式的表达式必须是常量。初始化式可以短于它所初始化的结构，这样任何“剩余”成员都用0作为它的初始值。</p>\n<h3 id=\"对结构的操作\"><a href=\"#对结构的操作\" class=\"headerlink\" title=\"对结构的操作\"></a>对结构的操作</h3><p>为了访问结构内的成员，首先写出结构的名字，然后写出成员的名字：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Part number: %d\\n\"</span><span class=\"token punctuation\">,</span> part1<span class=\"token punctuation\">.</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>结构成员的值是左值：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">part1<span class=\"token punctuation\">.</span>number <span class=\"token operator\">=</span> <span class=\"token number\">258</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>用于访问结构成员的句点是一个运算符，其优先级比较高：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token comment\" spellcheck=\"true\">/* &amp;计算的是 part1.on_hand 的地址 */</span>\n<span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>part1<span class=\"token punctuation\">.</span>on_hand<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>另一种主要的结构操作是赋值运算：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">part2 <span class=\"token operator\">=</span> part1<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/* 现在 par1 和 part2 每个成员的值都一样 */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>可以用结构来复制数组：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> a1<span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">;</span>\na1 <span class=\"token operator\">=</span> a2<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>运算符=仅仅用于类型一致的结构。</p>\n<h2 id=\"结构类型\"><a href=\"#结构类型\" class=\"headerlink\" title=\"结构类型\"></a>结构类型</h2><p>如果在两个地方编写了：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span>NAME_LEN <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> on_hand<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> part1<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span>NAME_LEN <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> on_hand<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> part2<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>那么 part1 和 part2 就不是同一个类型，这样就不能执行赋值操作。为了解决这个问题，需要为表示结构的类型定义名字。方法有两种：</p>\n<ul>\n<li><p>使用结构标记</p>\n</li>\n<li><p>使用 typedef 定义类型名</p>\n</li>\n</ul>\n<h3 id=\"结构标记的声明\"><a href=\"#结构标记的声明\" class=\"headerlink\" title=\"结构标记的声明\"></a>结构标记的声明</h3><p>结构标记（ structure tag ）即：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> part <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span>NAME_LEN <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> on_hand<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* 用标记 part 声明变量 */</span>\n<span class=\"token keyword\">struct</span> part part1<span class=\"token punctuation\">,</span> part2<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"结构类型的定义\"><a href=\"#结构类型的定义\" class=\"headerlink\" title=\"结构类型的定义\"></a>结构类型的定义</h3><p>即：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> number<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> name<span class=\"token punctuation\">[</span>NAME_LEN <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> on_hand<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> Part<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* 声明变量 */</span>\nPart part1<span class=\"token punctuation\">,</span> part2<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"联合\"><a href=\"#联合\" class=\"headerlink\" title=\"联合\"></a>联合</h2><p>联合（ union ）也是由一个或多个成员构成的，而且这些成员可能具有不同的数据类型。但是，编译器只为联合中最大的成员分配足够的内存空间，联合的成员在这个空间内彼此覆盖。</p>\n<p>对于：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">float</span> f<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> u<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">float</span> f<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> s<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>他们的存储如：</p>\n<p><img src=\"%E8%81%94%E5%90%88%E5%92%8C%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8.jpg\" alt=\"联合和结构的存储\"></p>\n<p>其中 u.i 和 u.f 具有相同的地址。</p>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>枚举（ enumeration ）是一种由程序员列出的值，而且程序员必须为每种值命名（枚举常量）：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span> CLUBS<span class=\"token punctuation\">,</span> DIAMONDS<span class=\"token punctuation\">,</span> HEARTS<span class=\"token punctuation\">,</span> SPADES <span class=\"token punctuation\">}</span> s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>虽然枚举和结构没什么共同的地方，但是它们的声明方式很类似。</p>\n<p>枚举常量的名字必须不同于闭合作用域内声明的其他标识符。</p>\n<h3 id=\"枚举标记和枚举类型\"><a href=\"#枚举标记和枚举类型\" class=\"headerlink\" title=\"枚举标记和枚举类型\"></a>枚举标记和枚举类型</h3><p>为了定义枚举标记，可以写成：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">enum</span> suit <span class=\"token punctuation\">{</span> CLUBS<span class=\"token punctuation\">,</span> DIAMONDS<span class=\"token punctuation\">,</span> HEARTS<span class=\"token punctuation\">,</span> SPADES <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* 声明枚举变量 */</span>\n<span class=\"token keyword\">enum</span> suit s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>用 typedef 给枚举命名：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">enum</span> <span class=\"token punctuation\">{</span> CLUBS<span class=\"token punctuation\">,</span> DIAMONDS<span class=\"token punctuation\">,</span> HEARTS<span class=\"token punctuation\">,</span> SPADES <span class=\"token punctuation\">}</span> Suit<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/* 声明枚举变量 */</span>\nSuit s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"枚举作为整数\"><a href=\"#枚举作为整数\" class=\"headerlink\" title=\"枚举作为整数\"></a>枚举作为整数</h3><p>在系统内部，C语言会把枚举变量和常量作为整数来处理。枚举常量的值可以是任意整数：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">enum</span> suit <span class=\"token punctuation\">{</span> CLUBS <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> DIAMONDS <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> HEARTS <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> SPADES <span class=\"token operator\">=</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>两个或多个枚举常量具有相同的值甚至也是合法的。</p>\n<p>当没有为枚举常量指定值时，它的值是一个大于前一个常量的值的值（大1）。默认第一个枚举常量的值为0。# 第十七章 指针的高级应用</p>\n<hr>\n<h2 id=\"动态存储分配\"><a href=\"#动态存储分配\" class=\"headerlink\" title=\"动态存储分配\"></a>动态存储分配</h2><p>任何单纯的数据结构（各种内置类型，数组，结构体），其大小在程序开始时已经确定了，且不能改变。而一些数据结构可能需要动态的改变其数据长度，比如链表。这就要用到<strong>动态存储分配</strong>（dynamic storage allocation）。</p>\n<p>使用动态存储分配的数据块存放在“堆”上，和其它存储区域不同的是，“堆”里的数据应该让程序员来控制释放（free）时机。</p>\n<p>为了动态地分配存储空间，将需要调用3种内存分配函数中的一种，这些函数都是声明在stdlib.h中的：</p>\n<ol start=\"0\">\n<li><p>malloc，分配内存块，但是不初始化它</p>\n</li>\n<li><p>calloc，分配内存块，并对其清零</p>\n</li>\n<li><p>realloc，调整先前分配的内存块</p>\n</li>\n</ol>\n<p>由于malloc函数不需要对分配的内存块进行清除，所以它比calloc函数更高效。</p>\n<h3 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h3><p>当调用内存分配函数时，无法定位满足我们需要的足够大的内存块，这种问题始终可能出现。如果真的发生了这类问题，函数会返回空指针。</p>\n<p><strong>空指针</strong>（null pointer）是指一个区别于所有有效指针的特殊值。</p>\n<p>!!!warning<br>    程序员的责任是测试任意内存分配函数的返回值，并且在返回空指针时采取适当的操作。通过空指针试图访问内存的效果是未定义的，程序可能会崩溃或者出现不可预测的行为。</p>\n<p>用名为NULL的宏来表示空指针，可用下列方式测试malloc函数的返回值：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">p <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/* allocation failed; take appropriate action */</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"动态分配字符串\"><a href=\"#动态分配字符串\" class=\"headerlink\" title=\"动态分配字符串\"></a>动态分配字符串</h2><p>动态内存分配经常用于字符串操作。字符串始终存储在固定长度的数组中，而且可能很难预测这些数组需要的长度。通过动态地分配字符串，可以推迟到程序运行时才作决定。</p>\n<h3 id=\"使用malloc函数为字符串分配内存\"><a href=\"#使用malloc函数为字符串分配内存\" class=\"headerlink\" title=\"使用malloc函数为字符串分配内存\"></a>使用malloc函数为字符串分配内存</h3><p>函数原型：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>size_t size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>size_t是无符号整型，malloc分配了一段size个字节的连续空间，并返回该空间首地址。如果分配失败就返回NULL。</p>\n<p>因为C语言保证char型值确切需要一个字节的内存，为了给n个字符的字符串分配内存空间，可以写成：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">p <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>通常情况下，可以把void*型值赋给任何指针类型的变量。然而，一些程序员喜欢强制转换malloc函数的返回值：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>p <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>由于使用malloc函数分配内存不需要清除或者以任何方式初始化，所以p指向带有n+1个字符的未初始化的数组。</p>\n<p>可以调用strcpy函数对上述数组进行初始化：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>数组中前4个字符分别为a, b, c和空字符。</p>\n<h2 id=\"动态分配数组\"><a href=\"#动态分配数组\" class=\"headerlink\" title=\"动态分配数组\"></a>动态分配数组</h2><p>编写程序时，常常为难数组估计合适的大小。较方便的做法是等到程序运行时再来确定数组的实际大小。</p>\n<p>虽然malloc函数可以为数组分配内存空间，但calloc函数确实是最常用的一种选择。因为calloc函数对分配的内存进行初始化。realloc函数允许根据需要对数组进行“扩展”或“缩减”。</p>\n<h3 id=\"使用malloc函数为数组分配存储空间\"><a href=\"#使用malloc函数为数组分配存储空间\" class=\"headerlink\" title=\"使用malloc函数为数组分配存储空间\"></a>使用malloc函数为数组分配存储空间</h3><p>当使用malloc函数为数组分配存储空间时，需要使用sizeof运算符来计算出每个元素所需要的空间数量。</p>\n<p>使用sizeof计算是必须的，因为这样计算的结果在不同平台下都是正确的。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>a <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">*</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这里的n可以在程序执行期间计算出来。</p>\n<p>一旦a指向了动态分配的内存块，就可以把它用作数组的名字。这都要感谢C语言中数组和指针的紧密关系。可以使用下列循环对此数组进行初始化：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span>\n    a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"calloc函数\"><a href=\"#calloc函数\" class=\"headerlink\" title=\"calloc函数\"></a>calloc函数</h3><p>函数原型：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span>size_t nmemb<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>nmemb是数据单元的个数， size是一个数据单元的大小。返回成功申请的数据块首地址，失败返回NULL。</p>\n<p>calloc不仅会从“堆”申请存储区域，还会把这段区域清零。也因此其执行效率没有malloc高。</p>\n<p>下列calloc函数的调用为n个整数的数组分配存储空间，并且保证全部初始为0：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">a <span class=\"token operator\">=</span> <span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>通过调用以1作为第一个实际参数的calloc函数，可以为任何类型的数据项分配空间：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> point <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">;</span>\np <span class=\"token operator\">=</span> <span class=\"token function\">calloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> point<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>此语句执行后，p指向结构，且此结构的成员x和y都会被设置为0。</p>\n<h3 id=\"realloc函数\"><a href=\"#realloc函数\" class=\"headerlink\" title=\"realloc函数\"></a>realloc函数</h3><p>一旦为数组分配完内存，稍后可能会发现数组过大或过小。realloc函数可以调整数组的大小使它更适合需要。</p>\n<p>函数原型：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">realloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>ptr必须指向内存块，且此内存块一定是先通过malloc函数、calloc函数或realloc函数的调用获得的。size表示内存块的新尺寸，新尺寸可能会大于或小于原有尺寸。</p>\n<p>C标准列出几条关于realloc函数的规则：</p>\n<ul>\n<li><p>当扩展内存块时，realloc函数不会对添加进内存块的字节进行初始化。</p>\n</li>\n<li><p>如果realloc函数不能按要求扩大内存块，那么它会返回空指针，并且在原有内存块中的数据不会发生改变。</p>\n</li>\n<li><p>如果realloc函数调用时以空指针作为第一个实际参数，那么它的行为就像malloc函数一样。</p>\n</li>\n<li><p>如果realloc函数调用时以0作为第二个实际参数，那么它会释放掉内存块。</p>\n</li>\n</ul>\n<p>!!!warning<br>    一旦realloc函数返回，请一定要对指向内存块的所有指针进行更新，因为可能realloc函数移动了其他地方的内存块。</p>\n<p>实际使用时，realloc应该始终对ptr指向的存储区域进行扩展。</p>\n<p>realloc不是一个好用的函数，要很小心才行。这是因为原来的存储区域会被释放掉（虽然新的存储区域会可能和原来的重叠），其指针很可能都变的无效。</p>\n<h2 id=\"释放存储\"><a href=\"#释放存储\" class=\"headerlink\" title=\"释放存储\"></a>释放存储</h2><p>malloc函数和其他内存分配函数所获得的内存块都来自一个称为<strong>堆</strong>（heap）的存储池。调用这些函数经常会耗尽堆，或者要求大的内存块也可能耗尽堆，这会导致函数返回空指针。</p>\n<p>更糟的是，程序可能分配了内存块，然后又丢失了这些块的追踪路径，因而浪费了空间。如下例子：</p>\n<pre><code>p = malloc(...);\nq = malloc(...);\np = q;</code></pre><p>由于没有指针指向第一个内存块，所以再也不能使用此内存块了。</p>\n<p>对于程序而言，不再访问到的内存块被称为是<strong>垃圾</strong>（garbage）。在后边留有垃圾的程序有<strong>内存泄漏</strong>（memory leak）。一些语言提供了<strong>垃圾收集器</strong>（garbage collector），但C语言不提供。每个C程序负责回收各自的垃圾，方法是调用free函数来释放不需要的内存。</p>\n<p>如上例子，就是一个内存泄漏。第一块内存再也访问不到了，这应该就是上文所说的留有垃圾。</p>\n<p><strong>free</strong></p>\n<p>只有一个方法释放由动态存储分配函数分配的内存空间。就是使用free函数，如果不释放，那么这块资源就一直放在“堆”里，直到程序退出。</p>\n<p>函数原型：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">free</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>使用free函数很容易，只是简单地把指向不再需要的内存块的指针传递给free函数就可以了：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">p <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>调用free函数来释放p所指向的内存块。然后会把这个释放的内存返回给堆，使此内存块可以被复用。</p>\n<h3 id=\"“悬空指针”问题\"><a href=\"#“悬空指针”问题\" class=\"headerlink\" title=\"“悬空指针”问题\"></a>“悬空指针”问题</h3><p>free操作会生成<strong>悬空指针</strong>（dangling pointer）。即调用free(p)函数会释放p指向的内存块，但是不会改变p本身。如果忘记了p不再指向有效内存块（而使用它），后果很严重。</p>\n<p>悬空指针是很难发现的，因为几个指针可能指向相同的内存块。在释放内存块时，全部的指针都会留有悬空。</p>\n<h2 id=\"指向函数的指针\"><a href=\"#指向函数的指针\" class=\"headerlink\" title=\"指向函数的指针\"></a>指向函数的指针</h2><p>函数也有地址，所以就可以有指针指向。一些功能强大的函数（像模板一样）都是通过函数指针和<code>void*</code>实现的。</p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><p>函数指针主要被存放在：</p>\n<ul>\n<li>数组里，方便日后调用</li>\n<li>形参，成为模板函数的实现，比如qsort</li>\n</ul>\n<p>定义一个函数指针类型的例子：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>Func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"函数入口地址\"><a href=\"#函数入口地址\" class=\"headerlink\" title=\"函数入口地址\"></a>函数入口地址</h3><p>函数名就是函数地址，但通常会对函数名做&amp;运算，其实得到的结果是一样的。同样对函数指针做<code>*</code>运算（解引用）和直接拿函数指针用也是一样的，都是代表了函数的入口地址。</p>\n<p>一般会对函数名做&amp;操作，对函数指针做<code>*</code>操作，让它们看上去比较像指针的使用。# 第十八章 声明</p>\n<hr>\n<h2 id=\"什么是声明\"><a href=\"#什么是声明\" class=\"headerlink\" title=\"什么是声明\"></a>什么是声明</h2><p>一个变量或者函数应该首先被声明，才会被使用。因为声明会告诉编译器这个变量或者函数的信息，然后编译器就可以检查其存储空间和作用域，以及使用时的语法是否正确。</p>\n<h2 id=\"声明的语法\"><a href=\"#声明的语法\" class=\"headerlink\" title=\"声明的语法\"></a>声明的语法</h2><p>声明的格式（声明式）是：</p>\n<p><strong>声明说明符 声明符</strong></p>\n<p>声明说明符描述了变量或者函数的性质，声明符代表变量名或者函数名，并且可以指明它的额外信息（如是一个数组or指针or函数）。</p>\n<p>声明说明符分为以下3类：</p>\n<ol start=\"0\">\n<li><p>存储类型。四种：auto（块内默认存储类型，无需显示声明），static，extern和register（已经被现代编译器优化，一般不需要声明）</p>\n</li>\n<li><p>类型限定符，有const和volatile</p>\n</li>\n<li><p>类型说明符，诸如int，long，unsighed，或者自定义数据类型等，对于函数，类型说明符就是返回类型。</p>\n</li>\n</ol>\n<p>声明符就是一个标识符，然后可以用星号（代表指针），方括号（代表数组），圆括号（代表函数）修饰。</p>\n<p>可以看到，声明没有赋值的内容。</p>\n<h2 id=\"存储类型\"><a href=\"#存储类型\" class=\"headerlink\" title=\"存储类型\"></a>存储类型</h2><h3 id=\"变量的性质\"><a href=\"#变量的性质\" class=\"headerlink\" title=\"变量的性质\"></a>变量的性质</h3><p>C程序中，变量都有三种性质：</p>\n<ol start=\"0\">\n<li><p>存储期限，决定了变量的生存周期。具有自动存储期限的变量在第一次执行时获得内存单元，出块时释放内存单元；具有静态存储期限的变量在程序的生命周期内都拥有内存单元。</p>\n</li>\n<li><p>作用域，拥有块作用域的变量只能在块内被使用；拥有文件作用域的变量从声明变量开始到文件结束的范围都可以使用。</p>\n</li>\n<li><p>链接，拥有外部链接的变量（内存单元）可以被程序的其它文件访问；拥有内部链接的变量只可以在文件内访问；无链接的变量只能在一个函数内访问。</p>\n</li>\n</ol>\n<p>上述三种性质取决于变量的声明位置以及变量的存储类型，比如不指明存储类型的话：</p>\n<ul>\n<li><p>在块内声明的变量，具有自动存储期限，块作用域，无链接</p>\n</li>\n<li><p>在程序的最外层声明的变量，具有静态存储期限，文件作用域，外部链接。</p>\n</li>\n</ul>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>决定一个变量的作用域的，仅在于它的声明位置：</p>\n<ol>\n<li><p>在块内声明的，具有块作用域</p>\n</li>\n<li><p>在文件最外层声明的，具有文件作用域</p>\n</li>\n</ol>\n<p>作用域是编译级别的（非链接）语法，编译器根据变量的作用域检查其使用的位置是否正确。</p>\n<h3 id=\"static存储类型\"><a href=\"#static存储类型\" class=\"headerlink\" title=\"static存储类型\"></a>static存储类型</h3><p>当static作用于一个块内声明的变量时，将改变它的存储期限为静态存储期限</p>\n<p>当static作用于一个最外层声明的变量时，将改变它的链接为内部链接，使这个变量的内存单元不能被其它文件所访问</p>\n<h3 id=\"extern存储类型\"><a href=\"#extern存储类型\" class=\"headerlink\" title=\"extern存储类型\"></a>extern存储类型</h3><p>用extern来声明一个变量，不会让编译器为它分配内存单元，它只是告诉编译器，这个变量是在别的地方定义的。因此：当extern作用于一个变量时，这个变量必须拥有静态存储期限且一般有外部链接。一般这个变量都是一个在最外层定义的变量。</p>\n<h3 id=\"函数存储类型\"><a href=\"#函数存储类型\" class=\"headerlink\" title=\"函数存储类型\"></a>函数存储类型</h3><p>默认情况下，函数存储类型都是extern的，代表此函数的链接是外部链接，可以被其它文件访问。</p>\n<p>如果给函数加上static声明，那么这个函数的链接就会被修改成内部链接，只能在文件内访问。如果一个函数不需要被多个模块共享，那么就应该声明成static的。</p>\n<h2 id=\"const限定符\"><a href=\"#const限定符\" class=\"headerlink\" title=\"const限定符\"></a>const限定符</h2><p>声明一个编译器维度上的常量，但却不能看做一个常量表达式，从而不能定义一个数组的边界（应该用#define）。</p>\n<p>const主要用于保护一个指针指向的对象不被修改，也就是定义一个常量指针，使其指向的空间不允许被修改。</p>\n<h2 id=\"声明符\"><a href=\"#声明符\" class=\"headerlink\" title=\"声明符\"></a>声明符</h2><p>声明符是由标识符和三个特殊符号组成的，这三个特殊符号是：</p>\n<ul>\n<li><p>放在标识符前面的<code>*</code>号</p>\n</li>\n<li><p>放在标示符后面的<code>()</code>或者<code>[]</code></p>\n</li>\n</ul>\n<h3 id=\"解释复杂声明\"><a href=\"#解释复杂声明\" class=\"headerlink\" title=\"解释复杂声明\"></a>解释复杂声明</h3><p>有时候声明符包含了多个特殊符号，这就要通过两条规则进行解释才能理解。它们是：</p>\n<ul>\n<li><p>始终从内向外读声明符，也就是先定位标识符，然后往外读</p>\n</li>\n<li><p><code>[]</code>和<code>()</code>始终优先于<code>*</code>，但<code>()</code>可以强制修改优先级</p>\n</li>\n</ul>\n<h2 id=\"初始化式\"><a href=\"#初始化式\" class=\"headerlink\" title=\"初始化式\"></a>初始化式</h2><p>在声明一个变量时，可以给它<code>=</code>一个初始值，这叫初始化式，而不是赋值。</p>\n<p>需要注意的几点：</p>\n<ul>\n<li><p>静态变量只能用常量表达式初始化，如果没有初始化，那么就是0</p>\n</li>\n<li><p>拥有自动存储期限的变量如果没有初始化，其值就是未定义的（包括数组）</p>\n</li>\n<li><p>数组的初始化（大括号闭合）必须用常量表达式初始化每一个元素# 第十九章 程序设计</p>\n</li>\n</ul>\n<p>虽然C语言不是专门用来编写大规模程序的，但许多大规模程序的确是用C语言编写的。相对于小型程序，编写一个大规模的程序需要更仔细的设计和更详细的计划。</p>\n<hr>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>当设计一个C程序（或其他任何语言的程序）时，最好将它看作是一些独立的模块。模块是一组功能（服务）的集合，其中一些功能可以被程序的其他部分（称为客户）使用。每个模块都有一个接口来描述所提供的功能。模块的细节，包括这些功能自身的源代码，都包含在模块的实现中。</p>\n<p>在C语言环境下，这些“功能”就是函数，模块的接口就是头文件，头文件中包含那些可以被其他文件调用的函数的原型。模块的实现就是包含该模块中函数的定义的源文件。</p>\n<p>将程序分割成模块有一系列好处：</p>\n<ul>\n<li><p>抽象。我们知道模块会做什么，但不需要知道这些功能是如何被实现的。因为抽象的存在，使我们不必为了修改部分程序而了解整个程序是如何工作的。</p>\n</li>\n<li><p>可复用性。每一个提供一定功能的模块，都有可能在另一个程序中复用。</p>\n</li>\n<li><p>可维护性。将程序模块化后，程序中的错误通常只会影响一个模块，因为更容易找到并解决错误。在解决了错误后，重新编译程序只需要将该模块的实现进行编译即可。</p>\n</li>\n</ul>\n<p>一旦我们已经认同了模块化程序设计是正确的方向，接下来的问题就是设计程序的过程中究竟应该定义哪些模块。</p>\n<h3 id=\"内聚性与耦合性\"><a href=\"#内聚性与耦合性\" class=\"headerlink\" title=\"内聚性与耦合性\"></a>内聚性与耦合性</h3><p>一个好的模块并不是随意的一组声明。好的模块应该具有下面两个性质：</p>\n<ul>\n<li><p>高内聚性。模块中的元素应该相互紧密相关。</p>\n</li>\n<li><p>低耦合性。模块之间应该尽可能相互独立。低耦合性可以使程序更便于修改，并方便以后复用模块。</p>\n</li>\n</ul>\n<h3 id=\"模块的类型\"><a href=\"#模块的类型\" class=\"headerlink\" title=\"模块的类型\"></a>模块的类型</h3><p>由于需要高内聚性、低耦合性，模块通常会属于下面几类：</p>\n<ul>\n<li><p>数据池。表示一些相关变量或常量的集合。通常这类模块是一些头文件。</p>\n</li>\n<li><p>库。库是一组相关函数的集合。</p>\n</li>\n<li><p>抽象对象。一个抽象对象是指对于隐藏的数据结构进行操作的一组函数的集合。</p>\n</li>\n<li><p>抽象数据类型。将具体数据的实现方式隐藏起来的数据类型称为抽象数据类型。作为客户的模块可以使用该类型来声明变量，但不会知道这些变量的具体数据结构。如果客户模块需要对变量进行操作，则必须调用抽象数据类型所提供的函数。</p>\n</li>\n</ul>\n<h2 id=\"信息隐藏\"><a href=\"#信息隐藏\" class=\"headerlink\" title=\"信息隐藏\"></a>信息隐藏</h2><p>一个设计良好的模块经常对它的客户隐藏一些信息。例如我们的栈模块的使用者就不需要知道究竟栈是用数组实现的还是用链表。信息隐藏有两大优点：</p>\n<ul>\n<li><p>安全性。数据必须通过模块自身提供的函数来操作，而这些函数都是经过测试的。</p>\n</li>\n<li><p>灵活性。无论对模块的内部机制进行多大的改动，都不会很复杂。不需要改变模块的接口。</p>\n</li>\n</ul>\n<p>在C语言中，可以用于强行信息隐藏的工具是 static 存储类型。将一个函数声明成 static 类型可以使函数内部链接，从而阻止其他文件（包括模块的客户）调用这个函数。将一个带文件作用域的变量声明成 static 类型可以达到类似的效果，使该变量只能被同一个文件中的其他函数访问。</p>\n<h2 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h2><p>对于作为抽象对象的模块，有一个缺点：不可能对同一个对象有多个实例。为了达到这个目的，需要进一步创建一个新的类型。这就是抽象数据类型。然后模块的接口函数需要传入这个类型对象的指针对其进行操作。</p>\n<p>但C语言不提供封装的功能，客户可以访问抽象数据类型的成员。确实有技巧可以达到类似的目的，但使用起来笨拙。</p>\n<p>实现封装的最佳方法是使用C++语言。实际上，C++语言产生的原因之一就是因为C语言不能很好的支持抽象数据类型。</p>\n<h2 id=\"C-语言-1\"><a href=\"#C-语言-1\" class=\"headerlink\" title=\"C++语言\"></a>C++语言</h2><p>略。# 第二十章 低级程序设计</p>\n<p>前面几章中讨论的是C语言中高级的、与机器无关的特性。有一些程序需要进行位级别的操作。位操作和其他一些低级运算在编写系统程序、加密程序、图形程序以及一些需要高执行速度或高效地使用空间的程序时非常有用。</p>\n<p>本章描述的一些技术需要用到数据在内存中如何存储的知识，这对不同机器和编译器可能会不同。依赖于这些技术很可能会使程序丧失可移植性。</p>\n<hr>\n<h2 id=\"按位运算符\"><a href=\"#按位运算符\" class=\"headerlink\" title=\"按位运算符\"></a>按位运算符</h2><h3 id=\"移位运算符\"><a href=\"#移位运算符\" class=\"headerlink\" title=\"移位运算符\"></a>移位运算符</h3><p>移位运算符可以改变数的二进制形式，将它的位向左或者向右移动。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&lt;&lt;</td>\n<td align=\"center\">左移位</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;&gt;</td>\n<td align=\"center\">右移位</td>\n</tr>\n</tbody></table>\n<p>运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>的操作数可以是任意整数型或字符型的。对两个操作数都会进行整数提升，返回值的类型是左边操作数提升后的类型。</p>\n<p><code>i&lt;&lt;j</code>的值是将i中的位左移j位后的结果。每次从i的最左端溢出一位，在i的最右端补一个0位。<code>i&gt;&gt;j</code>的值是将i中的位右移j位后的结果。如果i是无符号数或非负数，则需要在i的最左端补0。如果i是负值，其结果是由实现定义的。一些补0，一些补1。</p>\n<p>!!!note<br>    可移植性技巧：最好仅对无符号数进行移位运算。</p>\n<h3 id=\"按位求反、按位与运算符、按位异或运算符和按位或运算符\"><a href=\"#按位求反、按位与运算符、按位异或运算符和按位或运算符\" class=\"headerlink\" title=\"按位求反、按位与运算符、按位异或运算符和按位或运算符\"></a>按位求反、按位与运算符、按位异或运算符和按位或运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">~</td>\n<td align=\"center\">按位求反</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;</td>\n<td align=\"center\">按位与</td>\n</tr>\n<tr>\n<td align=\"center\">^</td>\n<td align=\"center\">按位异或</td>\n</tr>\n<tr>\n<td align=\"center\">|</td>\n<td align=\"center\">按位或</td>\n</tr>\n</tbody></table>\n<p>上面的顺序也是运算符优先级的顺序。</p>\n<h2 id=\"结构中的位域\"><a href=\"#结构中的位域\" class=\"headerlink\" title=\"结构中的位域\"></a>结构中的位域</h2><p>C语言提供了声明成员为位域的结构。</p>\n<p>比如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> file_date <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> day<span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> month<span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> year<span class=\"token punctuation\">:</span><span class=\"token number\">7</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">struct</span> file_data fd<span class=\"token punctuation\">;</span>\nfd<span class=\"token punctuation\">.</span>day <span class=\"token operator\">=</span> <span class=\"token number\">28</span><span class=\"token punctuation\">;</span>\nfd<span class=\"token punctuation\">.</span>month <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span>\nfd<span class=\"token punctuation\">.</span>year <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">/* represents 1988 */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个结构占据32个比特，每个成员后面的数字指定了它所占用位的长度。</p>\n<p>位域有一个限制，C语言不允许将&amp;运算符作用于位域。</p>\n<p>位域之间没有间隙，直到剩下的空间不够用来放下一个位域了，这时，一些编译器会跳到下一个存储单元继续存放位域，而另一些则会将位域拆开跨存储单元存放。位域的存放的顺序也是由实现定义的。# 第二十一章 标准库</p>\n<hr>\n<h2 id=\"标准库的使用\"><a href=\"#标准库的使用\" class=\"headerlink\" title=\"标准库的使用\"></a>标准库的使用</h2><p>C89标准库有15个部分，即15个头文件。</p>\n<p>标准头主要由函数原型、类型定义和宏定义组成。</p>\n<p><strong><code>&lt;assert.h&gt;</code> 诊断</strong></p>\n<p>允许程序插入自我检查，一旦检查失败，程序就被终止。</p>\n<p><strong><code>&lt;ctype.h&gt;</code> 字符处理</strong></p>\n<p>提供用于字符分类及大小写转换的函数。</p>\n<p><strong><code>&lt;errno.h&gt;</code> 错误</strong></p>\n<p>提供了error number，它是一个左值，可以在调用特定库函数后进行检测，来判断调用过程中是否有错误发生。</p>\n<p><strong><code>&lt;float.h&gt;</code> 浮点类型的特性</strong></p>\n<p>提供了用于描述浮点类型特定的宏，包括值得范围及精度。</p>\n<p><strong><code>&lt;limits.h&gt;</code> 整数类型的大小</strong></p>\n<p>提供了用于描述整数类型特性的宏，包括他们的最大值和最小值。</p>\n<p><strong><code>&lt;locale.h&gt;</code> 本地化</strong></p>\n<p>提供一些函数来帮助程序适应针对某个国家或地区的特定行为方式。包括显示数的方式、货币的格式、字符集以及日期和时间的表示形式。</p>\n<p><strong><code>&lt;math.h&gt;</code> 数学计算</strong></p>\n<p>提供常见的数学函数。</p>\n<p><strong><code>&lt;setjmp.h&gt;</code> 非本地跳转</strong></p>\n<p>提供了setjmp和longjmp函数，setjmp会标记程序中的一个位置，随后可以用longjmp返回标记的位置。可以实现从一个函数跳转到另一个函数中，绕过正常的函数返回机制。主要用来处理程序中的严重问题。</p>\n<p><strong><code>&lt;signal.h&gt;</code> 信号处理</strong></p>\n<p>提供了用于处理异常的函数，包括中断和运行时错误。signal可以设置一个函数，使系统信号到达时自动调用该函数；raise函数用来产生信号。</p>\n<p><strong><code>&lt;stdarg.h&gt;</code> 可变参数</strong></p>\n<p>提供一些工具用于编写参数个数可变的函数。</p>\n<p><strong><code>&lt;stddef.h&gt;</code> 常用定义</strong></p>\n<p>提供经验使用的类型和宏定义。</p>\n<p><strong><code>&lt;stdio.h&gt;</code> 输入与输出</strong></p>\n<p>提供大量的输入和输出函数，包括对文件的顺序访问和随机访问操作。</p>\n<p><strong><code>&lt;stdlib.h&gt;</code> 常用实用程序</strong></p>\n<p>包含大量无法划归其它头的函数。包含函数：将字符串转换成数，产生伪随机数，执行内存管理任务，与操作系统通信，执行搜索与排序等。</p>\n<p><strong><code>&lt;string.h&gt;</code> 字符串处理</strong></p>\n<p>包含操作字符串的函数。</p>\n<p><strong><code>&lt;time.h&gt;</code> 日期和时间</strong></p>\n<p>提供相应的函数来获取时间，操纵时间，以及格式化时间。</p>\n<h3 id=\"对标准库中所用名字的限制\"><a href=\"#对标准库中所用名字的限制\" class=\"headerlink\" title=\"对标准库中所用名字的限制\"></a>对标准库中所用名字的限制</h3><p>只要包含了标准头（没有不包含的情况吧？），必须遵循两条规则：</p>\n<ol>\n<li><p>不用自己定义标准头已定义过的宏</p>\n</li>\n<li><p>具有文件作用域的库名也不可以在文件层次重定义</p>\n</li>\n</ol>\n<p>还有一些命名规则，不要与标准库有冲突：</p>\n<ul>\n<li><p>由一个下划线和一个大写字母开头，或由两个下划线开头的标识符，是标准库保留的标识符</p>\n</li>\n<li><p>由一个下划线开头的标识符，被保留用作具有文件作用域的标识符和标记，只可用于函数内部声明</p>\n</li>\n<li><p>在标准库中所有具有外部链接的标识符被保留用作具有外部链接的标识符，比如printf</p>\n</li>\n</ul>\n<h3 id=\"使用宏隐藏的函数\"><a href=\"#使用宏隐藏的函数\" class=\"headerlink\" title=\"使用宏隐藏的函数\"></a>使用宏隐藏的函数</h3><p>C语言允许在头中定义与库函数同名的宏。从而使得宏隐藏掉函数。</p>\n<p>使用宏可能会提高程序的运行速度。如果有不想使用宏的情况，可能是因为想缩小可执行代码的大小。</p>\n<p>若要删掉宏，可用如下方法：</p>\n<pre><code>#include &lt;stdio.h&gt;\n#undef getchar</code></pre><p>还可以禁用宏：</p>\n<pre><code>(getchar)()</code></pre><h2 id=\"stddef-h-常用定义\"><a href=\"#stddef-h-常用定义\" class=\"headerlink\" title=\"stddef.h 常用定义\"></a>stddef.h 常用定义</h2><p>此头提供了常用的类型和宏的定义。定义的类型包括以下几个：</p>\n<ul>\n<li><p>ptrdiff_t，指针相减的结果类型，是有符号整数</p>\n</li>\n<li><p>size_t，sizeof运算符返回的类型，是无符号整数</p>\n</li>\n<li><p>wchar_t，一种足够大的，可以用来表示所有支持的地区的所有字符的类型</p>\n</li>\n</ul>\n<p>其中一个宏是：offsetof，其意思是求得结构体的起点到指定成员间的字节数。</p>\n<p>比如，有下面的结构体：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> s <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">float</span> c<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>offsetof(struct s, a)的值一定是0，因为结构体的首元素的地址一定是结构体的地址；</p>\n<p>offsetof(struct s, b)的值可能是1，但也可能是4（考虑到字节对齐）。# 第二十二章 输入 输出</p>\n<hr>\n<h2 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h2><p>流意味着任意输入的源或任意输出的目的地。输入流通常和键盘相关，输出流通常和屏幕相关。</p>\n<p>流还可以表示为磁盘上的文件，以及其他设备。</p>\n<h3 id=\"文件指针\"><a href=\"#文件指针\" class=\"headerlink\" title=\"文件指针\"></a>文件指针</h3><p>流的访问是通过 <strong>文件指针（file pointer）</strong> 实现的。此指针的类型为<code>FILE*</code>。</p>\n<p>stdio.h提供了3种标准流，这三个标准流是备用的，不能声明、打开、关闭它们。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文件指针</th>\n<th align=\"center\">流</th>\n<th align=\"center\">默认的含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">stdin</td>\n<td align=\"center\">标准输入</td>\n<td align=\"center\">键盘</td>\n</tr>\n<tr>\n<td align=\"center\">stdout</td>\n<td align=\"center\">标准输出</td>\n<td align=\"center\">屏幕</td>\n</tr>\n<tr>\n<td align=\"center\">stderr</td>\n<td align=\"center\">标准错误</td>\n<td align=\"center\">屏幕</td>\n</tr>\n</tbody></table>\n<p><strong>重定向（redirection）</strong></p>\n<p>操作系统允许通过重定向机制来改变标准流默认的含义。</p>\n<p>例如：</p>\n<pre><code>demo &lt; in.data</code></pre><p>称为<strong>输入重定向（input redirection）</strong>，即把stdin流表示为文件in.dat，而非键盘。对于程序demo而言，它并不知道输入流是来自键盘还是文件。</p>\n<p>这样子是<strong>输出重定向（output redirection）</strong>：</p>\n<pre><code>demo &gt; out.dat</code></pre><p>如此一来，写入stdout的内容将不再输出到屏幕，而是文件out.dat。</p>\n<h3 id=\"文本文件与二进制文件\"><a href=\"#文本文件与二进制文件\" class=\"headerlink\" title=\"文本文件与二进制文件\"></a>文本文件与二进制文件</h3><p>文件就是字节的序列。</p>\n<p>文本文件中，字节表示字符。</p>\n<p>二进制文件中，字节就是字节，可以用于表示任意类型的数据。</p>\n<p>DOS系统中，这两种文件之间有如下差异：</p>\n<ul>\n<li><p>行的结尾。文本文件写入换行符时，换行符扩展成一对字符，即回行符和跟随的回车符。如果把换行符写入二进制文件时，它就是一个单独的字符（换行符）。</p>\n</li>\n<li><p>文件末尾。文本文件中，文件的结束标记是CTRL+Z字符（\\x1a）。二进制文件中，此字符没有特别的含义，跟其它任何字符一样。</p>\n</li>\n</ul>\n<p>在Unix操作系统中，二进制文件和文本文件不进行区分，其存储方式一样。</p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p><strong>打开文件</strong></p>\n<p>使用 fopen 函数。</p>\n<p><strong>关闭文件</strong></p>\n<p>使用 fclose 函数。</p>\n<p><strong>从命令行获取文件名</strong></p>\n<p>当程序需要打开一个文件时，通常通过命令行参数把文件名传给程序，这样更具灵活性。</p>\n<p>主函数：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>argv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>argc是命令行实际参数的数量（非数组长度），argv是参数字符串数组。</p>\n<p>argv[0]是程序名，argv[1] ~ argv[argc-1]是剩余参数。</p>\n<p>argv[argc]是空指针。</p>\n<p><strong>临时文件</strong></p>\n<p>tmpfile 函数生成临时文件。</p>\n<p>tmpnam 函数生成一个临时的文件名。</p>\n<p><strong>文件缓冲</strong></p>\n<p>向磁盘直接读写数据相对比内存读写慢。使用缓冲区（buffer）来解决这个问题。写入流的数据首先放到缓冲区里面，当缓冲区满了（或关闭流）时，刷新缓冲区，把数据写入文件。</p>\n<p>输入流可以使用类似的方法进行缓冲：缓冲区包含来自输入设备的数据。</p>\n<p>使用 fflush 函数刷新缓冲区。</p>\n<p><strong>其它文件操作</strong></p>\n<p>remove 函数删除文件，rename 函数重命名文件。如果是用 fopen 和 tmpnam 产生的临时文件，可以使用 remove 把它删除，或者用 rename 使其成为永久文件。</p>\n<h2 id=\"格式化的输入与输出\"><a href=\"#格式化的输入与输出\" class=\"headerlink\" title=\"格式化的输入与输出\"></a>格式化的输入与输出</h2><p>即 …printf 类函数 和 …scanf 类函数的使用。</p>\n<h3 id=\"检测文件末尾和错误条件\"><a href=\"#检测文件末尾和错误条件\" class=\"headerlink\" title=\"检测文件末尾和错误条件\"></a>检测文件末尾和错误条件</h3><p>每个流都有与之相关的两个指示器：<strong>错误指示器</strong>（error indicator），<strong>文件末尾指示器</strong>（end-of-file indicator）。</p>\n<p>打开流时，会清除这些指示器；流上的操作失败时会设置某个指示器。</p>\n<p>遇到文件末尾就设置文件末尾指示器，遇到错误就设置错误指示器。</p>\n<p>一旦设置了指示器，它就会保持这种状态，直到可能由 clearerr 调用而引发的明确清除操作为止。 clearerr 可以清除文件末尾指示器和错误指示器。</p>\n<p>如果设置了文件末尾指示器， feof 返回非零值。</p>\n<p>如果设置了错误指示器， ferror 返回非零值。</p>\n<h2 id=\"字符的输入-输出\"><a href=\"#字符的输入-输出\" class=\"headerlink\" title=\"字符的输入/输出\"></a>字符的输入/输出</h2><p>输入输出的字符类型应使用int，原因之一是由于函数通过返回EOF说明文件末尾or错误情况，EOF是一个负的整型常量。</p>\n<h3 id=\"输出函数\"><a href=\"#输出函数\" class=\"headerlink\" title=\"输出函数\"></a>输出函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">fputc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">putc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">putchar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"输入函数\"><a href=\"#输入函数\" class=\"headerlink\" title=\"输入函数\"></a>输入函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">fgetc</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">getc</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">getchar</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"行的输入-输出\"><a href=\"#行的输入-输出\" class=\"headerlink\" title=\"行的输入/输出\"></a>行的输入/输出</h2><h3 id=\"输出函数-1\"><a href=\"#输出函数-1\" class=\"headerlink\" title=\"输出函数\"></a>输出函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">fputs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">puts</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>puts函数向标准输出输出一行字符串，会自动添加一个换行符。</p>\n<p>fputs不会自动添加换行符。</p>\n<h3 id=\"输入函数-1\"><a href=\"#输入函数-1\" class=\"headerlink\" title=\"输入函数\"></a>输入函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">fgets</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">,</span> FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">gets</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>gets函数逐个读取字符，存储到s中，直到读到换行符时停止，并把换行符丢弃。</p>\n<p>fgets当读入了size-1个字符时或读到换行符时停止，且会存储换行符。</p>\n<p>如果出现错误，或者在存储任何字符之前达到了输入流的末尾，函数返回空指针。否则返回第一个实参。</p>\n<p>函数会在字符串的末尾存储空字符。</p>\n<h2 id=\"块的输入输出\"><a href=\"#块的输入输出\" class=\"headerlink\" title=\"块的输入输出\"></a>块的输入输出</h2><pre class=\"line-numbers language-c\"><code class=\"language-c\">size_t <span class=\"token function\">fread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">,</span> size_t nmemb<span class=\"token punctuation\">,</span> FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsize_t <span class=\"token function\">fwrite</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">,</span> size_t nmemb<span class=\"token punctuation\">,</span> FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>fread函数和fwrite函数允许程序在单步中读写大的数据块。</p>\n<p>fwrite函数被设计用来把数组复制给流。第一个参数是数组首元素的地址，第二个参数是每个数组元素的大小（以字节为单位），第三个参数是要写的元素的数量，第四个参数是文件指针，说明了要写的数据位置。</p>\n<p>fwrite返回实际写入的元素数量，如果写入错误，此数就会小于第三个参数。</p>\n<p>fread函数从流读入数组的元素。其参数类似fwrite。</p>\n<p>fread返回实际读入的元素数量，此数应该等于第三个参数。否则可能达到了文件末尾或者出现了错误。使用feof和ferror确定出问题的原因。</p>\n<p>检查fread的返回值是非常重要的。</p>\n<h2 id=\"文件的定位\"><a href=\"#文件的定位\" class=\"headerlink\" title=\"文件的定位\"></a>文件的定位</h2><p>每个流都有相关联的<strong>文件位置（file position）</strong>。打开文件时，根据模式可以在文件的起始处或者末尾处设置文件位置。</p>\n<p>在执行读或写操作时，文件位置会自动推进。</p>\n<p>stdio.h提供了一些函数，用于确定当前的文件位置或者改变文件位置：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">fseek</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> offset<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> whence<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">long</span> <span class=\"token function\">ftell</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">rewind</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">fgetpos</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">,</span> fpos_t <span class=\"token operator\">*</span>pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">fsetpos</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">,</span> fpos_t <span class=\"token operator\">*</span>pos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>fseek</strong>函数改变第一个参数相关的文件的位置。第二个参数说明新位置是根据文件的起始处、当前位置还是文件末尾来计算，也就是第三个参数来计算。</p>\n<p>第三个参数可取值为：</p>\n<ul>\n<li><p>SEEK_SET，文件的起始处。</p>\n</li>\n<li><p>SEEK_CUR，文件的当前位置。</p>\n</li>\n<li><p>SEEK_END，文件的末尾处。</p>\n</li>\n</ul>\n<p><strong>ftell</strong>函数返回当前文件位置。如果发生错误，ftell返回-1L，并且把错误码存储到errno。</p>\n<p><strong>rewind</strong>函数会把文件位置设置到起始处。rewind还会为fp清除错误指示器。</p>\n<p><strong>fgetpos</strong>和<strong>fsetpos</strong>用于处理大的文件，使用fpos_t表示文件位置，它可能是一个结构。函数成功返回0，失败返回非0值并把错误码存放到errno中。</p>\n<h2 id=\"字符串的输入-输出\"><a href=\"#字符串的输入-输出\" class=\"headerlink\" title=\"字符串的输入/输出\"></a>字符串的输入/输出</h2><p>sprintf和snprintf函数将按写到数据流一样的方式写字符到字符串。</p>\n<p>sscanf函数从字符串中读出数据就像从数据流中读数据一样。</p>\n<h3 id=\"输出函数-2\"><a href=\"#输出函数-2\" class=\"headerlink\" title=\"输出函数\"></a>输出函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">sprintf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">snprintf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>类似于printf函数，唯一不同是sprintf函数把输出写入字符数组而不是流。当完成向字符串写入的时候，sprintf函数会添加一个空字符，并返回所存储的字符数量（不计空字符）。如果遇到错误，返回负值。</p>\n<p>snprintf写入的字符数量不会超过size-1，结尾空字符不计。只要size不是0，都会有空字符。</p>\n<h3 id=\"输入函数-2\"><a href=\"#输入函数-2\" class=\"headerlink\" title=\"输入函数\"></a>输入函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">sscanf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>sscanf与scanf类似，唯一的不同就是sscanf从字符数组中读取数据而不是流。</p>\n<p>sscanf函数返回成功读入并存储的数据项的数量，如果在找到第一个数据项之前到达了字符串的末尾，那么sscan函数返回EOF。# 第二十三章 库对数值和字符数据的支持</p>\n<hr>\n<h2 id=\"float-h：浮点型的特性\"><a href=\"#float-h：浮点型的特性\" class=\"headerlink\" title=\"float.h：浮点型的特性\"></a>float.h：浮点型的特性</h2><p>提供了用来定义浮点型的范围及精度的宏。</p>\n<h2 id=\"limits-h：整型取值范围\"><a href=\"#limits-h：整型取值范围\" class=\"headerlink\" title=\"limits.h：整型取值范围\"></a>limits.h：整型取值范围</h2><p>仅定义了每种整数类型的取值范围的宏。</p>\n<h2 id=\"math-h：数学计算\"><a href=\"#math-h：数学计算\" class=\"headerlink\" title=\"math.h：数学计算\"></a>math.h：数学计算</h2><p>math.h里的函数处理的都是浮点类型的数值。</p>\n<p>在 UNIX/Linux 下编译，需要指明连接 math 库：-lm</p>\n<p>math.h中定义的函数包含下面5种类型：</p>\n<ul>\n<li><p>三角函数 sin cos tan acos asin atan atan2</p>\n</li>\n<li><p>双曲函数 cosh sinh tanh</p>\n</li>\n<li><p>指数和对数函数 exp log …</p>\n</li>\n<li><p>幂函数 pow sqrt</p>\n</li>\n<li><p>就近去整函数，绝对值函数和取余函数 ceil fabs floor fmod</p>\n</li>\n</ul>\n<h3 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h3><p>在math.h里声明的函数，如果出现错误（可能是参数不对），会把错误码存到errno。且若函数返回值大于double的最大值，那么函数会返回一个特殊值HUGE_VAL（double类型表示无穷大，Linux下输出成inf）。</p>\n<p>errno有两种可能值：</p>\n<ol>\n<li>EDOM：代表定义域错误（Linux下值为33），即参数取值不对，比如给sqrt传一个负数。</li>\n<li>ERANGE：代表取值范围错误（返回值）（Linux下值为34），无法用double来表示了。比如exp(1000)。（PS：不是所有的数学函数出现返回值为无穷大时都会置errno为ERANGE）</li>\n</ol>\n<h2 id=\"ctype-h：字符处理\"><a href=\"#ctype-h：字符处理\" class=\"headerlink\" title=\"ctype.h：字符处理\"></a>ctype.h：字符处理</h2><p>ctype.h提供了两类对字符进行处理的：</p>\n<ol>\n<li>测试字符性质</li>\n<li>对字符进行大小写转换</li>\n</ol>\n<h2 id=\"string-h：字符串处理\"><a href=\"#string-h：字符串处理\" class=\"headerlink\" title=\"string.h：字符串处理\"></a>string.h：字符串处理</h2><p>这些函数的参数的合法性需要程序员来保证。</p>\n<h3 id=\"复制函数\"><a href=\"#复制函数\" class=\"headerlink\" title=\"复制函数\"></a>复制函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strcpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strncpy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"拼接函数\"><a href=\"#拼接函数\" class=\"headerlink\" title=\"拼接函数\"></a>拼接函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strcat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strncat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"比较函数\"><a href=\"#比较函数\" class=\"headerlink\" title=\"比较函数\"></a>比较函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">strcmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">strncmp</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s2<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"搜索函数\"><a href=\"#搜索函数\" class=\"headerlink\" title=\"搜索函数\"></a>搜索函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strchr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memchr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strrchr</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strtok</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>delim<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"其它函数\"><a href=\"#其它函数\" class=\"headerlink\" title=\"其它函数\"></a>其它函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">memset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsize_t <span class=\"token function\">strlen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n```# 第二十四章 错误处理\n\n<span class=\"token operator\">--</span><span class=\"token operator\">-</span>\n\n## assert<span class=\"token punctuation\">.</span>h<span class=\"token punctuation\">:</span> 诊断\n\n```c\n<span class=\"token keyword\">void</span> <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> expression<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>assert声明在assert.h中，实际上是一个宏。其参数必须是一种“断言”，即被认为正常情况下一定为真的表达式。</p>\n<p>每次执行assert时，判断此断言，若为假（0），则显示一条错误信息，并调用abort函数终止程序执行。</p>\n<p>这条错误信息包含了：断言（以文本格式）、包含assert调用的文件名、assert调用所在的行号。</p>\n<p><strong>禁止assert调用</strong></p>\n<p>方法是：在包含assert.h之前，定义宏NDEBUG。如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">define</span> NDEBUG</span>\n<span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;assert.h></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"errno-h-错误\"><a href=\"#errno-h-错误\" class=\"headerlink\" title=\"errno.h: 错误\"></a>errno.h: 错误</h2><p>标准库中的一些函数通过向errno.h中声明的errno变量存储一个错误代码来表示有错误发生。</p>\n<p>大部分使用errno变量的函数集中在math.h，但也有一些在标准库的其他部分。</p>\n<p>如果errno不为0，则说明函数调用过程中有错误发生。</p>\n<p>errno在程序开始的时候值为0，通常在调用函数前把errno置为0，库函数不会将errno清零，这是程序员的责任。</p>\n<p>用法如：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">y <span class=\"token operator\">=</span> <span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// x为负数则出错</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>errno <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">fprintf</span><span class=\"token punctuation\">(</span><span class=\"token constant\">stderr</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"sqrt error, terminated. \\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span>EXIT_FAILURE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>perror函数和strerror函数</strong></p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">perror</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">strerror</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> errnum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>当库函数向errno存储了一个非零值时，通过perror函数和strerror函数可以得到描述这种错误的信息。</p>\n<p>perror函数声明在stdio.h中，它会按照如下顺序把错误信息输出到stderr：</p>\n<pre><code>调用perror的参数: 出错消息（内容根据errno的值决定）</code></pre><p>strerror函数声明在string.h中，它传入errno，返回一个指针，指向描述出错消息的字符串。</p>\n<h2 id=\"signal-h-信号处理\"><a href=\"#signal-h-信号处理\" class=\"headerlink\" title=\"signal.h: 信号处理\"></a>signal.h: 信号处理</h2><p>signal.h提供了处理异常的工具，即信号（signal）。信号有两种类型：运行时错误（例如除以0），程序以外导致的事件（例如用户输入了ctrl+c）。</p>\n<p>当有错误或外部事件发生时，我们称产生了一个信号。大多数信号是<strong>异步的</strong>：它们可以在程序执行过程中的任意时刻发生。</p>\n<h3 id=\"信号宏\"><a href=\"#信号宏\" class=\"headerlink\" title=\"信号宏\"></a>信号宏</h3><p>signal.h定义了一系列宏，用于表示不同的信号。参见书本。</p>\n<h3 id=\"signal函数\"><a href=\"#signal函数\" class=\"headerlink\" title=\"signal函数\"></a>signal函数</h3><pre><code>typedef void (*sighandler_t)(int);\nsighandler_t signal(int signum, sighandler_t handler);</code></pre><p>signal函数安装一个信号处理函数。第一个参数是信号的代码，第二个参数是一个指向信号处理函数的指针。</p>\n<p>一旦随后在程序执行过程中出现了对应的信号，信号处理函数就会被自动调用，信号的代码作为参数传递给信号处理函数。</p>\n<p>除非信号是由调用abort函数或raise函数引发的，否则信号处理函数不应该调用任何库函数，或者试图使用一个静态存储期限的变量。</p>\n<p>一旦信号处理函数返回，程序会从信号发生点恢复并继续执行。但是，如果信号是SIGABRT，当处理函数返回时程序会异常终止。如果信号是SIGFPE，那么处理函数返回的结果是UB（即不要使用它）。</p>\n<p>signal函数的返回值是指定信号的前一个处理函数的指针。</p>\n<h3 id=\"预定义的信号处理函数\"><a href=\"#预定义的信号处理函数\" class=\"headerlink\" title=\"预定义的信号处理函数\"></a>预定义的信号处理函数</h3><p>signal.h提供了两个预定义的信号处理函数（都用宏表示）：</p>\n<ul>\n<li><p>SIG_DFL。表示按默认方式处理信号，大多数情况下会导致程序终止。</p>\n</li>\n<li><p>SIG_IGN，指明随后当信号SIGINT发生时，忽略该信号。</p>\n</li>\n</ul>\n<p>当程序刚开始执行时，根据不同的实现，每个信号的处理函数都会被初始化为SIG_DFL和SIG_IGN。</p>\n<p>如果signal调用失败（即无法对指定信号安装处理函数），就返回SIG_ERR（不是一个函数），并在errno中存入错误代码。</p>\n<p>C语言要求，除了SIGILL以外，当一个信号的处理函数被调用时，该信号的处理函数要被重置为SIG_DFL，或者以其他方式加以封锁。</p>\n<h3 id=\"raise函数\"><a href=\"#raise函数\" class=\"headerlink\" title=\"raise函数\"></a>raise函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">raise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> sig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>通常信号都是自然产生的，但也可以通过raise函数触发。</p>\n<p>raise函数的返回值可以用来测试调用是否成功：0代表成功，非0代表失败。</p>\n<h2 id=\"setjmp-h-非局部跳转\"><a href=\"#setjmp-h-非局部跳转\" class=\"headerlink\" title=\"setjmp.h: 非局部跳转\"></a>setjmp.h: 非局部跳转</h2><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;setjmp.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">setjmp</span><span class=\"token punctuation\">(</span>jmp_buf env<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">longjmp</span><span class=\"token punctuation\">(</span>jmp_buf env<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>通常情况下，函数会返回到它被调用的位置。setjmp.h可以使一个函数直接跳转到另一个函数，而不需要返回。</p>\n<p>setjmp宏“标记”程序中的一个位置，随后可以用longjmp函数跳转到该位置。这一机制主要用于错误处理。</p>\n<p>setjmp宏会将当前“环境”保存到一个jmp_buf类型的变量中，然后返回0。如果要返回setjmp宏所标记的位置，可以使用longjmp函数，调用的参数是调用setjmp宏时使用的同一个jmp_buf类型的变量。longjmp函数首先会根据jmp_buf变量的内容恢复当前环境，然后从setjmp宏调用中返回。这次setjmp宏的返回值是val，即调用longjmp函数时的第二个参数（如果val是0，那么返回1）。</p>\n<p>如果longjmp的参数未被setjmp初始化，调用longjmp的结果是UB。# 第二十五章 国际化特性</p>\n<hr>\n<h2 id=\"locale-h-本地化\"><a href=\"#locale-h-本地化\" class=\"headerlink\" title=\"locale.h 本地化\"></a>locale.h 本地化</h2><p>locale.h提供的函数用于控制标准库中对于不同的地区会不一样的部分。</p>\n<p>地区通常指一个国家，或者一个国家的不同区域。</p>\n<p>在标准库中，依赖地区的部分包括：</p>\n<ul>\n<li><p>数值的格式。比如一些地区的小数点是用逗号表示</p>\n</li>\n<li><p>货币的格式。不同国家的货币符号不同。</p>\n</li>\n<li><p>字符集。字符集依赖于地区使用的语言。亚洲国家通常比西方国家需要更大的字符集。</p>\n</li>\n<li><p>日期和时间的表示格式。</p>\n</li>\n</ul>\n<h3 id=\"类别\"><a href=\"#类别\" class=\"headerlink\" title=\"类别\"></a>类别</h3><p>通过修改地区，程序可以改变它的行为来适应不同地区。</p>\n<p>可以使用一些宏来指定一个<strong>类型</strong>：</p>\n<ul>\n<li><p>LC_COLLATE。影响两个字符串比较函数的行为（strcoll和strxfm）。</p>\n</li>\n<li><p>LC_CTYPE。影响ctype.h中函数的行为，除了isdigit和isxdigit。同时还影响stdlib.h中的多字节函数。</p>\n</li>\n<li><p>LC_MONETRAY。影响由localeconv函数返回的货币格式信息。</p>\n</li>\n<li><p>LC_NUMERIC。影响格式化输入/输出函数使用的小数点字符以及stdlib.h中的字符串转换函数（atof和strtod），还会影响localeconv函数返回的非货币格式信息。</p>\n</li>\n<li><p>LC_TIME。影响strftime函数的行为，该函数将时间转换成字符串。</p>\n</li>\n</ul>\n<h3 id=\"setlocale函数\"><a href=\"#setlocale函数\" class=\"headerlink\" title=\"setlocale函数\"></a>setlocale函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">setlocale</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> category<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>locale<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>setlocale函数修改当前的地区。如果第一个参数是LC_ALL，就会影响所有的类型。C语言标准对第二个参数仅定义了两种可能值：”c”和””。其余的由实现定义，比如， gcc 对于简体中文的地区，可以是”zh_CN.UTF-8”</p>\n<p>程序执行开始时，都会隐含调用：<code>setlocale(LC_ALL, &quot;C&quot;);</code></p>\n<p>如果用””作为第二个参数，就切换到了本地模式（native locale），这种模式下程序会适应本地的环境。</p>\n<p>如果调用成功，返回一个关于地区名字的字符串指针。如果调用失败，返回空指针。</p>\n<p>setlocale函数也可以当作搜索函数使用，如果第二个参数是空指针，setlocale函数会返回一个指向字符串的指针，这个字符串与当前地区类型的设置相关联。</p>\n<h3 id=\"localeconv函数\"><a href=\"#localeconv函数\" class=\"headerlink\" title=\"localeconv函数\"></a>localeconv函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> lconv <span class=\"token operator\">*</span><span class=\"token function\">localeconv</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>函数返回的struct lconv结构包含了当前地区的详细信息，此结构具有静态存储期限。</p>\n<p>详细信息参考书本。</p>\n<h2 id=\"多字节字符和宽字符\"><a href=\"#多字节字符和宽字符\" class=\"headerlink\" title=\"多字节字符和宽字符\"></a>多字节字符和宽字符</h2><p>因为定义已经把char型值的大小限制为一个字节，所以通过改变char类型的含义来处理更大的字符集显然是不可能的。</p>\n<p>C语言提供了两种可扩展字符集的编码：<strong>多字节字符</strong>（multibyte character）和<strong>宽字符</strong>（wide character）。</p>\n<p>C标准要求0字节始终用来表示空字符。</p>\n<h3 id=\"多字节字符\"><a href=\"#多字节字符\" class=\"headerlink\" title=\"多字节字符\"></a>多字节字符</h3><p>在多字节字符编码中，一个或多个字节表示一个可扩展字符。C语言要求的基本字符是单字节的。</p>\n<p>一些多字节字符集依靠<strong>依赖状态编码</strong>（state-dependent encoding）。在这类编码中，每个多字节字符序列都以<strong>初始移位状态</strong>（initial shift state）开始。序列中稍后遇到的一些多字节字符会改变移位状态，并且影响后续字节的含义。</p>\n<p>MB_LEN_MAX和MB_CUR_MAX说明了多字节字符中字节的最大数量。MB_LEN_MAX定义在limits.h中，给出了任意支持地区的最大值。MB_CUR_MAX定义在stdlib.h中，给出了当前地区的最大值。</p>\n<h3 id=\"宽字符\"><a href=\"#宽字符\" class=\"headerlink\" title=\"宽字符\"></a>宽字符</h3><p>宽字符是一种其值表示字符的整数，所有宽字符要求相同的字节数。</p>\n<p>宽字符具有wchar_t类型。</p>\n<p>一个宽字符常量可以写成：<code>L&#39;a&#39;</code></p>\n<p>一个宽字符字符串可以写成：<code>L&quot;abc&quot;</code></p>\n<p>即在普通字符常量前用字母L作为前缀。</p>\n<p>!!!note “my note”<br>    注意，在使用宽字符前，需要设置好本地环境，比如，要使用简体中文的宽字符，那么要先执行 <code>setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;)</code> ，这样才能正确地解析宽字符。</p>\n<h3 id=\"多字节字符函数\"><a href=\"#多字节字符函数\" class=\"headerlink\" title=\"多字节字符函数\"></a>多字节字符函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">mblen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">mbtowc</span><span class=\"token punctuation\">(</span>wchar_t <span class=\"token operator\">*</span>pwc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">wctomb</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>s<span class=\"token punctuation\">,</span> wchar_t wc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"多字节字符串函数\"><a href=\"#多字节字符串函数\" class=\"headerlink\" title=\"多字节字符串函数\"></a>多字节字符串函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdlib.h></span></span>\nsize_t <span class=\"token function\">mbstowcs</span><span class=\"token punctuation\">(</span>wchar_t <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsize_t <span class=\"token function\">wcstombs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>dest<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> wchar_t <span class=\"token operator\">*</span>src<span class=\"token punctuation\">,</span> size_t n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"三字符序列\"><a href=\"#三字符序列\" class=\"headerlink\" title=\"三字符序列\"></a>三字符序列</h2><p>见书本简要介绍。</p>\n<p>!!!note<br>    这就是一种字符替换方式，由于某些国家不支持C语言的标准的字符书写方式。# 其他库函数</p>\n<hr>\n<h2 id=\"stdarg-h-可变长度实参\"><a href=\"#stdarg-h-可变长度实参\" class=\"headerlink\" title=\"stdarg.h 可变长度实参\"></a>stdarg.h 可变长度实参</h2><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">va_start</span><span class=\"token punctuation\">(</span>va_list ap<span class=\"token punctuation\">,</span> last<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ntype <span class=\"token function\">va_arg</span><span class=\"token punctuation\">(</span>va_list ap<span class=\"token punctuation\">,</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">va_end</span><span class=\"token punctuation\">(</span>va_list ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>stdarg.h提供了一种工具可以让我们自行编写的函数具有可变长的参数列表（varying number of arguments of varying types）。stdarg.h定义了一种va_list类型和三种宏，名为va_start, va_arg, va_end, 可以把这些宏看成是带有上述原型的函数。</p>\n<p>书中使用了此例进行讲解：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">max_int</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>    <span class=\"token comment\" spellcheck=\"true\">// n must be at least 1</span>\n<span class=\"token punctuation\">{</span>\n    va_list ap<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> current<span class=\"token punctuation\">,</span> largest<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">va_start</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    largest <span class=\"token operator\">=</span> <span class=\"token function\">va_arg</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        current <span class=\"token operator\">=</span> <span class=\"token function\">va_arg</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">></span> largest<span class=\"token punctuation\">)</span>\n            largest <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">va_end</span><span class=\"token punctuation\">(</span>ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> largest<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>函数的第一个实参n说明了跟随其后的其他参数的数量。</p>\n<p>形参列表中的…符号表示可变数量的参数。带有可变参数的函数必须至少有一个“正常的”形参，在最后一个正常的参数后边始终会有省略号出现在参数列表的末尾。</p>\n<p><code>va_list ap</code>声明了一个变量，使得函数可以访问到可变参数。</p>\n<p><code>va_start(ap, n)</code>指出了实参列表中可变长度开始的位置。</p>\n<p><code>va_arg(ap, int)</code>把获取当前的可变参数，然后自动前进到下一个可变参数处。int说明希望此参数是int类型的。</p>\n<p>函数返回前，使用语句<code>va_end(ap)</code>进行清扫。</p>\n<h3 id=\"调用带有可变实参列表的函数\"><a href=\"#调用带有可变实参列表的函数\" class=\"headerlink\" title=\"调用带有可变实参列表的函数\"></a>调用带有可变实参列表的函数</h3><p>调用带有可变实参列表的函数是一个固有的风险提议。</p>\n<p>这里主要的难点就是带有可变实参列表的函数很难确定传递过来的参数的数量或类型。所以必须把这个信息传递给函数，并且函数假设知道了这个信息。上述max_int函数依靠第一个实参来指明跟随其后的其他参数的数量，并且它还设定参数是int类型的。</p>\n<p>另一个问题就是不得不处理NULL作为参数的情况，具体见书本。</p>\n<h3 id=\"v…printf类函数\"><a href=\"#v…printf类函数\" class=\"headerlink\" title=\"v…printf类函数\"></a>v…printf类函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">vprintf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> va_list ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">vfprintf</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> va_list ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">vsprintf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>str<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> va_list ap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>不同于printf等函数，v…printf类函数具有固定数量的实参，每个v…printf类函数的最后一个实参都是一个va_list型值。这个类型的值意味着此函数可以由带有可变实参列表的函数调用。</p>\n<p>实际上，v…printf类函数主要用于编写“包装”函数。包装函数接收可变数量的实参，并稍后把这些参数传递给v…printf类函数（通过va_list）。</p>\n<p>这种包装函数的核心内容是：</p>\n<ul>\n<li><p>va_start(ap, arg)</p>\n</li>\n<li><p>把ap传递给v…printf</p>\n</li>\n<li><p>va_end(ap)</p>\n</li>\n</ul>\n<h2 id=\"stdlib-h-通用的实用工具\"><a href=\"#stdlib-h-通用的实用工具\" class=\"headerlink\" title=\"stdlib.h 通用的实用工具\"></a>stdlib.h 通用的实用工具</h2><h3 id=\"字符串转换函数\"><a href=\"#字符串转换函数\" class=\"headerlink\" title=\"字符串转换函数\"></a>字符串转换函数</h3><pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">atoi</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token function\">atoll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">long</span> <span class=\"token keyword\">int</span> <span class=\"token function\">strtol</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>endptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token keyword\">int</span> <span class=\"token function\">strtoll</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>nptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>endptr<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"伪随机生成函数\"><a href=\"#伪随机生成函数\" class=\"headerlink\" title=\"伪随机生成函数\"></a>伪随机生成函数</h3><p>伪随机数的生成方法是：</p>\n<ul>\n<li><p>先设置一个随机种子（srand）</p>\n</li>\n<li><p>调用rand函数根据随机种子生成一个伪随机数</p>\n</li>\n</ul>\n<p>如果每次程序运行的随机种子都一样，那么rand出来的数就会一样。因此通常采用当前时间戳作为随机种子（但如果两次启动间隔不足一秒，时间戳也是一样滴）。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">srand</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> seed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">rand</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"与环境的通信\"><a href=\"#与环境的通信\" class=\"headerlink\" title=\"与环境的通信\"></a>与环境的通信</h3><p>与外部通信的标准库函数可以：</p>\n<ul>\n<li><p>为操作系统返回一个程序结束的状态码</p>\n</li>\n<li><p>获取环境变量</p>\n</li>\n<li><p>执行操作系统的命令</p>\n</li>\n</ul>\n<p><strong>返回状态码</strong></p>\n<p>在main中执行return语句，即返回了一个状态码给操作系统；或者在程序的任意处执行exit函数，也可以终止程序并返回一个状态码给操作系统。</p>\n<p>exit是正常性质的结束程序，可以清理程序打开的资源。</p>\n<p>atexit函数还可以注册一个函数，在程序正常结束前，执行这个注册函数。可以注册多个atexit函数，调用顺序和注册顺序一致。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">exit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">atexit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>function<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>获取环境变量</strong></p>\n<p>环境变量是一组存放到静态存储区的字符串，描述了操作系统的环境，比如PATH。使用getenv就可以获取它的值。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">getenv</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>执行命令</strong></p>\n<p>主要是通过system函数执行一个外部的命令。system函数返回该命令的终止状态码。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">system</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"搜索和排序工具\"><a href=\"#搜索和排序工具\" class=\"headerlink\" title=\"搜索和排序工具\"></a>搜索和排序工具</h3><p>用于搜索的工具是：bsearch（实现为二分查找），用于排序的工具是：qsort（实现为快速排序）。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">qsort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>base<span class=\"token punctuation\">,</span> size_t nmemb<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">,</span>\n                  <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>compar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">bsearch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>base<span class=\"token punctuation\">,</span>\n                     size_t nmemb<span class=\"token punctuation\">,</span> size_t size<span class=\"token punctuation\">,</span>\n                     <span class=\"token keyword\">int</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>compar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"整数算术运算函数\"><a href=\"#整数算术运算函数\" class=\"headerlink\" title=\"整数算术运算函数\"></a>整数算术运算函数</h3><p><strong>abs求绝对值</strong></p>\n<p>函数原型：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">abs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>div求除法运算结果</strong></p>\n<p>函数原型：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">div_t <span class=\"token function\">div</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> numerator<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> denominator<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>结果是第一个实参除以第二个实参。结果是一个div_t类型，它包含了商和余数，定义如下：</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> quot<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">/* Quotient.  */</span>\n    <span class=\"token keyword\">int</span> rem<span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">/* Remainder. */</span>\n<span class=\"token punctuation\">}</span> div_t<span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>但第二个实参一定不能为0，不然就会出现段错误。因此判断除数是否合法的责任就交给了程序员。</p>\n<h2 id=\"time-h-日期和时间\"><a href=\"#time-h-日期和时间\" class=\"headerlink\" title=\"time.h 日期和时间\"></a>time.h 日期和时间</h2><p>标准库提供了三种表示时间的类型：</p>\n<ol start=\"0\">\n<li><p>clock_t：按照“时钟滴答”进行测量的时间值</p>\n</li>\n<li><p>time_t：日历时间（时间戳），由于这个类型在不同平台下定义不同（unsigned int or long），因此输出的时候应当做一个强制转换。</p>\n</li>\n<li><p>struct tm：分解时间，一种适合人类理解的时间格式</p>\n</li>\n</ol>\n<p>clock_t和time_t是支持算术运算的，但是它们具体是整型还是浮点型并没有被C标准说明。但struct tm的类型定义很清楚：</p>\n<table>\n<thead>\n<tr>\n<th>成员</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tm_sec</td>\n<td>分后的秒，[0, 61]，允许两个额外的闰秒</td>\n</tr>\n<tr>\n<td>tm_min</td>\n<td>时后面的分，[0, 59]</td>\n</tr>\n<tr>\n<td>tm_hour</td>\n<td>午夜后的时，0到23</td>\n</tr>\n<tr>\n<td>tm_mday</td>\n<td>月份中的第几天，[1,31]</td>\n</tr>\n<tr>\n<td>tm_mon</td>\n<td>一月份以后的月，[0,11]</td>\n</tr>\n<tr>\n<td>tm_year</td>\n<td>从1900年开始的年</td>\n</tr>\n<tr>\n<td>tm_wday</td>\n<td>星期日以后的天，[0,6]</td>\n</tr>\n<tr>\n<td>tm_yday</td>\n<td>一月一日后的天，[0,365]</td>\n</tr>\n<tr>\n<td>tm_isdst</td>\n<td>夏令时标记，夏令时有效为正数，否则为0，如果未知，可为-1</td>\n</tr>\n</tbody></table>\n<p><strong>时钟滴答</strong></p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">clock_t <span class=\"token function\">clock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>clock函数返回处理器的时间（时钟滴答），即程序开始运行到执行到此的消耗的时间。但它的单位不是秒，为了将它转换成秒，可以给它除以宏CLOCK_PER_SEC。</p>\n<p>clock_t不能表示日期，只是善于表示时间区间（两个clock_t相减获得比较精准的时间差）。</p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\"><span class=\"token punctuation\">(</span><span class=\"token function\">clock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start_clock<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span>CLOCK_PER_SEC<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>加double强制转换的理由是，标准C没有指明宏CLOCK_PER_SEC的类型，也没有说明clock_t的类型，所以必须用强制转换明确一下类型。</p>\n<p><strong>日历时间</strong></p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">time_t <span class=\"token function\">time</span><span class=\"token punctuation\">(</span>time_t <span class=\"token operator\">*</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">double</span> <span class=\"token function\">difftime</span><span class=\"token punctuation\">(</span>time_t time1<span class=\"token punctuation\">,</span> time_t time0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>time用来获取时间戳（UNIX从1970年为纪元），difftime获取两个时间戳的间隔，但这种计算间隔的方式没有用clock_t计算精准。</p>\n<p><strong>分解时间</strong></p>\n<pre class=\"line-numbers language-c\"><code class=\"language-c\">time_t <span class=\"token function\">mktime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> tm <span class=\"token operator\">*</span>tm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">struct</span> tm <span class=\"token operator\">*</span><span class=\"token function\">localtime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> time_t <span class=\"token operator\">*</span>timep<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token function\">asctime</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> tm <span class=\"token operator\">*</span>tm<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li><p>mktime将分解时间转换成日历时间（时间戳）。但它有一个很好得到地方，除了转换成日历时间，它还会先修正分解时间，如果分解时间中的某些值不正确的话。修正的规则就是“进位”，把溢出的时间补给高位的时间。比如tm_mday超过了31，那么tm_mon就会增加至少1。可以利用这一个修正的规则来计算未来的日期。见代码案例。</p>\n</li>\n<li><p>localtime根据日历时间，获得本地的分解时间</p>\n</li>\n<li><p>asctime获取分解时间的字符串格式，末尾还会有一个换行符</p>\n</li>\n</ul>\n<p><strong>时间转换函数</strong></p>\n<p>有 ctime strftime 等。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"第一章-C语言概述\"><a href=\"#第一章-C语言概述\" class=\"headerlink\" title=\"第一章 C语言概述\"></a>第一章 C语言概述</h1><p>C语言是20世纪70年代初期，在贝尔实验室开发出来的一种用途广泛的编程语言。</p>\n<hr>\n<h2 id=\"C语言的历史\"><a href=\"#C语言的历史\" class=\"headerlink\" title=\"C语言的历史\"></a>C语言的历史</h2><p>C语言是Unix系统开发过程中的一个副产品。它被用来重写Unix系统。</p>\n<p>到20世纪80年代，许多计算机开始使用C语言开发程序，为了保证其程序的可移植性，建立标准成为了共识。</p>\n<p>1989年，通过C89标准。</p>\n<p>1999年，通过C99标准，但这个标准还没有被普遍使用。</p>\n<h3 id=\"C-语言\"><a href=\"#C-语言\" class=\"headerlink\" title=\"C++ 语言\"></a>C++ 语言</h3><p>虽然采纳了 ANSI/ISO 标准以后C语言自身不再发生变化。但是，从某种意义上说，随着基于C语言的新式语言的产生，C语言的演变还在继续。新式语言包括C++。它在许多方面对C语言进行了扩展，尤其是增加了面向对象编程的特性。</p>\n<p>随着C++语言的迅速普及，在不久的将来你很可能会用C++语言编写程序。果真如此，为何还要费心学习C语言呢？首先，C++语言比C语言更加难学，因此在掌握C++语言前，最好先精通C语言；其次，我们身边存在着大量的C语言代码，需要去维护和阅读；最后，不是每个人都喜欢改用C++编程，例如对于编写小规模的程序，使用C++反而不会获得多少好处。</p>\n<h2 id=\"C语言的优缺点\"><a href=\"#C语言的优缺点\" class=\"headerlink\" title=\"C语言的优缺点\"></a>C语言的优缺点</h2><p>C语言的优缺点都源于它最初的用途，以及其基础理论体系。</p>\n<ul>\n<li><p>C语言是一种底层语言。它提供了对内存访问的功能。C程序的许多服务都依赖于操作系统提供的接口。</p>\n</li>\n<li><p>C语言是一种小型语言。C语言的特性不多，应用程序的绝大部分功能依赖于标准库。</p>\n</li>\n<li><p>C语言是一种包容性语言。C语言假设用户知道自己在做什么，因此有编写自由度。C语言不强制进行错误检查。</p>\n</li>\n</ul>\n<h3 id=\"C语言的优点\"><a href=\"#C语言的优点\" class=\"headerlink\" title=\"C语言的优点\"></a>C语言的优点</h3><ol>\n<li><p>高效。发明C语言的目的是为了替代汇编语言。</p>\n</li>\n<li><p>可移植。有标准库的存在。</p>\n</li>\n<li><p>功能强大、灵活。C语言的数据类型和运算符集合有足够强大的表达能力。</p>\n</li>\n<li><p>与Unix集成。</p>\n</li>\n</ol>\n<h3 id=\"C语言的缺点\"><a href=\"#C语言的缺点\" class=\"headerlink\" title=\"C语言的缺点\"></a>C语言的缺点</h3><ol>\n<li><p>C程序更容易隐藏错误。由于其灵活性，导致编写的代码令编译器很难检查错误。</p>\n</li>\n<li><p>C程序可能会难以理解。</p>\n</li>\n<li><p>C程序可能会难以修改。因为它设计时没考虑到维护的问题。C语言没有提供类，包等模块化概念。</p>\n</li>\n</ol>\n<h3 id=\"高效地使用C语言\"><a href=\"#高效地使用C语言\" class=\"headerlink\" title=\"高效地使用C语言\"></a>高效地使用C语言</h3><ol>\n<li>学习规避C语言的缺陷。比如越界问题。</li>\n<li>使用软件工具。</li>\n<li>利用现有的代码库。</li>\n<li>采用切合实际的编码规范。</li>\n<li>避免“投机取巧”和极度复杂的代码。</li>\n<li>使用标准C，少用经典C。标准C即是 ANSI C ，本书采用的是标准C。</li>\n<li>避免不可以移植性。# 第二章 C语言基本概念</li>\n</ol>\n<hr>\n<h2 id=\"编写一个简单的C程序\"><a href=\"#编写一个简单的C程序\" class=\"headerlink\" title=\"编写一个简单的C程序\"></a>编写一个简单的C程序</h2><h3 id=\"程序：显示双关语\"><a href=\"#程序：显示双关语\" class=\"headerlink\" title=\"程序：显示双关语\"></a>程序：显示双关语</h3><p>这是经典C的一个示例：</p>\n<pre><code class=\"c\">// pun.c\n#include &lt;stdio.h&gt;\n\nmain()\n{\n    printf(&quot;To C, or not to C: that is the question.\\n&quot;);\n}</code></pre>\n<h3 id=\"编译和链接\"><a href=\"#编译和链接\" class=\"headerlink\" title=\"编译和链接\"></a>编译和链接</h3><p>首先，需要一个.c文件保存程序代码，接下来需要把程序转换为机器可以执行的形式。通常包含下列三个步骤：</p>\n<ul>\n<li><p>预处理。首先会把程序送交给预处理器（ preprocessor ）。预处理器执行以#开头的命令。</p>\n</li>\n<li><p>编译。修改后的程序现在可以进入编译器（ compiler ）了。编译器会把程序翻译成机器指令（即目标代码， object code ）。</p>\n</li>\n<li><p>链接。链接器（ linker ）把由编译器产生的目标代码和任何其他附加代码整合在一起，产生完全可执行的程序。</p>\n</li>\n</ul>\n<p>这个过程可以一步完成，即：</p>\n<pre><code class=\"bash\">cc pun.c</code></pre>\n<p>在编译和链接好程序后，编译器 cc 会把可执行程序放到默认名为 a.out 的文件中。编译器 cc 有许多选项，其中 -o 允许给可执行程序选择一个名字：</p>\n<pre><code class=\"bash\">cc -o pun pun.c</code></pre>\n<p>如果使用 gcc 进行编译，那么建议在编译时采用 -Wall 选项：</p>\n<pre><code class=\"bash\">gcc -Wall -o pun pun.c</code></pre>\n<p>也可以手动分布完成：</p>\n<pre><code class=\"bash\">cc -o main.i -E main.c # 预编译\ncc -o main.o -c main.i # 编译\ncc -o main main.o      # 链接</code></pre>\n<h2 id=\"简单程序的一般形式\"><a href=\"#简单程序的一般形式\" class=\"headerlink\" title=\"简单程序的一般形式\"></a>简单程序的一般形式</h2><p>形式如：</p>\n<pre><code class=\"c\">指令\n\nint main()\n{\n    语句\n}</code></pre>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>在编译C程序之前，预处理器会首先对C程序进行编辑。我们把预处理器执行的命令称为指令。这里只关注 #include 指令。</p>\n<pre><code class=\"c\">#include &lt;stdio.h&gt;</code></pre>\n<p>这条指令说明，在编译前把 stdio.h 中的信息“包含”到程序中。这段程序中包含 stdio,h 的原因是：C语言没有内置的“读”和“写”命令。因此，进行输入/输出操作就需要用标准库中的函数来实现。</p>\n<p>这里是指预所有指令都是以#开头。一条指令必须占据一行，且不留分号结尾。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>函数是用来构建程序的一个构建块。C程序就是函数的集合。函数分为两大类：一类是程序员编写的函数，另一类则是由C语言的实现所提供的函数。后者可以称为库函数（ library function ）。</p>\n<p>在C语言中，函数仅仅是一系列组合在一起并且赋予了名字的语句。某些函数计算一个值，而某些函数不是。计算出一个值的函数可以用 return 语句来指定所“返回”的值。</p>\n<p>每个程序必须有一个 main 函数。 main 函数是非常特殊的：在执行程序时系统会自动调用 main 函数。</p>\n<p>main 函数在程序终止时向操作系统返回一个状态码。 pun 程序始终让 main 函数返回0，0表明程序正常终止。</p>\n<p>建议加入 return 语句，如果不这样做，某些编译器可能会产生一条警告信息：</p>\n<pre><code class=\"c\">// pun.c\n#include &lt;stdio.h&gt;\n\nmain()\n{\n    printf(&quot;To C, or not to C: that is the question.\\n&quot;);\n    return 0;\n}</code></pre>\n<h3 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h3><p>语句是程序运行时执行的命令。每条语句都要以分号结尾。</p>\n<p>一条语句可以占据多行。</p>\n<p>程序 pun.c 只用到了两种语句。一种是返回语句，一种则是函数调用（ function call ）语句。为了在屏幕上显示一条字符串就调用了 printf 函数。</p>\n<h3 id=\"显示字符串\"><a href=\"#显示字符串\" class=\"headerlink\" title=\"显示字符串\"></a>显示字符串</h3><p>我们用 printf 函数显示了一条字符串字面量（ string literal ）。字符串字面量是用一对双引号包围的一系列字符。</p>\n<p>当打印结束时， printf 函数不会自动跳转到下一输出行。为了让 printf 跳转到下一行，必须要在打印的字符串中包含一个 \\n （换行符）。写换行符就意味着终止当前行，然后把后续的输出转到下一行进行。</p>\n<p>换行符可以在一个字符串字面量中出现多次。比如：</p>\n<pre><code class=\"c\">printf(&quot;Brevity is the soul of wit.\\n -- Shakespeare\\n&quot;);</code></pre>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>注释就是代码的说明。在预编译后，注释会移除出代码。</p>\n<p>例如：</p>\n<pre><code class=\"c\">/* This is a comment */</code></pre>\n<p>为 pun.c 增加注释：</p>\n<pre><code class=\"c\">/*    Name: pun.c\n    Purpose: Prints a bad pun.\n    Author: K.N.King\n    Data written: 5/21/95\n*/</code></pre>\n<h2 id=\"变量和赋值\"><a href=\"#变量和赋值\" class=\"headerlink\" title=\"变量和赋值\"></a>变量和赋值</h2><p>变量（ variable ）就是用来存储数据的存储单元。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>一个变量必须有一个类型。类型决定了存储单元的大小和对变量的操作方式。</p>\n<p>int 型变量可以存储整数，例如0、1、392或者-2553，但是，整数的取值范围是受限制的。某些计算机上，int型数值的最大取值仅仅是32767。</p>\n<p>float 型变量可以存储更大的数值，而且，float型变量可以存储带小数位的数据，例如379.125。但是，float 型变量有一些缺陷，即这类变量需要的存储空间要大于 int 型变量。而且，进行算术运算时 float 型变量通常比 int 型变量慢。另外， float 型变量所存储的数值往往只是实际数值的一个近似值。</p>\n<h3 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h3><p>在使用变量前，必须对其进行声明，这也是为了便于编译器工作。例如，声明变量 height 的方式如：</p>\n<pre><code class=\"c\">int height;</code></pre>\n<p>如果几个变量具有相同的类型，就可以把它们的声明合并：</p>\n<pre><code class=\"c\">int height, length, width;</code></pre>\n<p>当 main 函数包含声明时，必须把声明放置在语句之前：</p>\n<pre><code class=\"c\">main()\n{\n    声明\n    语句\n}</code></pre>\n<h3 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h3><p>变量可以通过赋值（ assignment ）的方式获得一个值。例如：</p>\n<pre><code class=\"c\">height = 8;\nvolume = height * length * width;</code></pre>\n<p>赋值运算符的右侧可以是一个含有常量、变量和运算符的公式（表达式， expression ）。</p>\n<h3 id=\"显示变量的值\"><a href=\"#显示变量的值\" class=\"headerlink\" title=\"显示变量的值\"></a>显示变量的值</h3><p>用 printf 可以显示当前变量的值。</p>\n<pre><code class=\"c\">printf(&quot;Height: %d\\n&quot;, height);</code></pre>\n<p>占位符 %d 用来指明在打印过程中变量 height 的值的显示位置。 %d 仅用于 int 型变量，如果要打印 float 型变量，需要用 %f 来代替。默认情况下， %f 会显示小数点后6位数字，若需要显示小数点后n位数字，则可以把 .n 放置在%和f之间。</p>\n<pre><code class=\"c\">printf(&quot;Profit: $%.2f\\n&quot;, profit);</code></pre>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>当程序开始执行时，某些变量会被自动设置为0，而大多数变量则不会。没有默认值并且尚未在程序中被赋值的变量是未初始化的（ uninitialized ）。</p>\n<p>使用初始化式对其变量进行初始化，如：</p>\n<pre><code class=\"c\">int a = 0;</code></pre>\n<h2 id=\"读入输入\"><a href=\"#读入输入\" class=\"headerlink\" title=\"读入输入\"></a>读入输入</h2><p>为了获取输入，就要用到 scanf 函数。 scanf 中的字母f和 printf 中的f含义相同，都是表示“格式化”的意思。 scanf 和 printf 函数都需要使用格式串（ format string ）来说明输入或输出的样式。</p>\n<p>为了读取一个 int 型数值，可以使用如下的 scanf 函数调用。</p>\n<pre><code class=\"c\">scanf(&quot;%d&quot;, &amp;i);</code></pre>\n<p>字符串“%d”说明 scanf 读入的是一个整数，i是一个 int 型变量，用来存储读入的输入。</p>\n<p>读入一个 float 型数值时，需要这样的 scanf 调用：</p>\n<pre><code class=\"c\">scanf(&quot;%f&quot;, &amp;x);</code></pre>\n<p>%f只适用于 float 型变量。</p>\n<h2 id=\"定义常量\"><a href=\"#定义常量\" class=\"headerlink\" title=\"定义常量\"></a>定义常量</h2><p>常量（ constant ）是在程序执行过程中固定不变的量。当程序含有常量时，建议给这些常量命名。方式是使用宏定义（ macro defination ）。</p>\n<pre><code class=\"c\">#define N 4</code></pre>\n<p>这里的 #define 是预处理指令。当程序进行编译时，预处理器会把每一个宏用其表示的值替换回来。</p>\n<p>此外，还可以利用宏来定义表达式：</p>\n<pre><code class=\"c\">#define SCALE_FACTOR (5.0 / 9.0)</code></pre>\n<p>当宏包含运算时，必须用括号把表达式括起来。</p>\n<p>宏的名字一般用大写字母，这是大多数程序员遵守的规范。</p>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p>标识符就是函数、变量、宏等实体的名字。</p>\n<p>标识符由字母、数字和下划线组成，且区分大小写。必须以字母或下划线开头。</p>\n<p>为了使名字清晰，可以使用两种命名风格：</p>\n<pre><code class=\"c\">symbol_table\nSymbolTable</code></pre>\n<p><strong>关键字</strong></p>\n<p>关键字（ keyword ）对编译器而言都有特殊的含义，因此标识符不能和关键字一样。</p>\n<p>所有的关键字见书本p19</p>\n<h2 id=\"C语言程序的布局\"><a href=\"#C语言程序的布局\" class=\"headerlink\" title=\"C语言程序的布局\"></a>C语言程序的布局</h2><p>C程序可以被看成一连串的<strong>记号（ token ）</strong>。记号就是无法分割的字符组。</p>\n<p>标识符、关键字、运算符、字符串等都是记号。</p>\n<p>记号之间可以有空格，换行等字符。</p>\n<p>有记号的概念后，C程序就可以这样书写：</p>\n<ul>\n<li><p>语句可以放到多行内。对于很长的语句这样很合适。</p>\n</li>\n<li><p>记号间的空格可以更容易区分记号。比如运算符两边加空格方便阅读。</p>\n</li>\n<li><p>缩进有助于识别程序嵌套。</p>\n</li>\n<li><p>空行可以把程序划分为逻辑单元。# 第三章 格式化输入输出</p>\n</li>\n</ul>\n<p>scanf 函数和 printf 函数是C语言使用最频繁的两个函数，它们用来支持格式化的读和写。</p>\n<hr>\n<h2 id=\"printf-函数\"><a href=\"#printf-函数\" class=\"headerlink\" title=\"printf 函数\"></a>printf 函数</h2><p>printf 函数被设计用来显示格式串（ format string ）的内容，并且在字符串指定位置插入可能的值。</p>\n<pre><code class=\"c\">printf(格式串, 表达式1, 表达式2, ...);</code></pre>\n<p>格式串包含普通字符和转换说明（ conversion specification ），其中转换说明以字符%开头。</p>\n<p>!!!warning<br>    C语言编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配。</p>\n<h3 id=\"转换说明\"><a href=\"#转换说明\" class=\"headerlink\" title=\"转换说明\"></a>转换说明</h3><p>在通用的情况下，转换说明可以有%m.pX格式或%-m.pX格式，这里的m和p都是整型常量，X是字母。m和p都是可选项。</p>\n<p>在转换说明%10.2f中，m是10，p是2，X是f。</p>\n<p><strong>最小字段宽度（ minimum field width ）</strong> m指定了要显示的最小字符数量。如果要打印的数值比m个字符少，那么值在字段内是右对齐的。如果要多，那么字段宽度会自动扩展为需要的尺寸。</p>\n<p><strong>精度（ precision ）</strong> p的含义依赖于<strong>转换说明符X（ conversion specifier ）</strong>的选择。对数来说，最常用的转换说明符有：</p>\n<ul>\n<li><p>d，表示十进制形式的整数。p说明可以显示的数字的最少个数（如果需要，就在数前加上额外的零）；如果忽略掉p，默认它的值为1。</p>\n</li>\n<li><p>e，表示指数形式的浮点数。p说明小数点后应该出现的数字的个数（默认为6）。如果p为0，则不显示小数点。</p>\n</li>\n<li><p>f，表示“定点十进制”形式的浮点数，没有指数。p的含义与在说明符e中的一员。</p>\n</li>\n<li><p>g，表示指数形式或者定点十进制形式的浮点数，形式的选择根据数的大小决定。p可以说明显示的有效数字的最大数量。与转换说明符f不同，g的转换将不显示尾随零。</p>\n</li>\n</ul>\n<h3 id=\"转义序列\"><a href=\"#转义序列\" class=\"headerlink\" title=\"转义序列\"></a>转义序列</h3><p>我们经常把在格式串中用的代码<code>\\n</code>称为转义序列（ escape sequence ）。转义序列使字符串包含一些特殊字符而又不会使编译器引发问题。</p>\n<p>详细的说明：<a href=\"https://zh.cppreference.com/w/cpp/language/escape\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/escape</a></p>\n<h2 id=\"scanf-函数\"><a href=\"#scanf-函数\" class=\"headerlink\" title=\"scanf 函数\"></a>scanf 函数</h2><p>scanf 函数也根据特定的格式读取输入， scanf 函数转换说明符的用法和 printf 函数转换说明符的用法本质上是一样的。</p>\n<p>scanf 函数有一些不易察觉的陷阱。使用 scanf 时，程序员必须检查转换说明的数量是否与输入变量的数量相匹配，并且检查每个转换是否适合相对应的变量。另一个陷阱涉及符号&amp;，通常把符号&amp;放在 scanf 函数调用的每个变量的前面。</p>\n<p>调用 scanf 函数是读取数据的一种有效但不理想的方法。许多专业C程序员避免用 scanf 函数，而是采用字符格式读取所有数据，然后再把它们转换成数值形式。</p>\n<h3 id=\"scanf-函数的工作方法\"><a href=\"#scanf-函数的工作方法\" class=\"headerlink\" title=\"scanf 函数的工作方法\"></a>scanf 函数的工作方法</h3><p>scanf 函数本质上是一种“模式匹配”函数，也就是试图把输入的字符组与转换说明匹配成组。</p>\n<p>scanf 调用时，从左边开始处理字符串中的信息。对于格式串中的每一个转换说明， scanf 函数努力从输入的数据中定位适当类型的项，并且跳过必要的空格。然后， scanf 函数读入数据项，并且在遇到不可能属于此项的字符时停止。</p>\n<p>在寻找数的起始位置时， scanf 函数会忽略空白（ white-space ）字符（空格符、横向和纵向制表符、换页符、换行符）。</p>\n<h3 id=\"格式串中的普通字符\"><a href=\"#格式串中的普通字符\" class=\"headerlink\" title=\"格式串中的普通字符\"></a>格式串中的普通字符</h3><p>处理格式串中普通字符时， scanf 函数采取的动作依赖于这个字符是否为空白字符。</p>\n<ul>\n<li><p>空白字符。当在格式串中遇到一个或多个连续的空白字符时， scanf 函数从输入中重复读空白字符直到遇到一个非空白字符（把该字符“放回原处”）为止。</p>\n</li>\n<li><p>其他字符。当在格式串中遇到一个非空白字符时， scanf 函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么 scanf 函数会放弃输入字符而继续处理格式串。如果两个字符不匹配，那么 scanf 函数会把不匹配的字符放回输入中，然后异常退出。# 第四章 表达式</p>\n</li>\n</ul>\n<p>表达式是显示如何计算值的公式。最简单的表达式是变量和常量。变量表示程序运行时计算出的值；常量表示不变的值。</p>\n<p>运算符是构建表达式的基本工具。C语言提供了基本的运算符：</p>\n<ul>\n<li>算术运算符。</li>\n<li>关系运算符。</li>\n<li>逻辑运算符。</li>\n</ul>\n<hr>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><p>算术运算符有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">一元运算符</th>\n<th align=\"center\">二元运算符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">+ -</td>\n<td align=\"center\">+ - * / %</td>\n</tr>\n</tbody></table>\n<p>二元运算符要求有两个操作数，而一元运算符只要有一个操作数。</p>\n<p>一元运算符+无任何操作，它主要是为了强调某数值常量是正的。</p>\n<p>%被称之为 mod （求模）或 rem （取余）。 i % j 的数值是i除以j后的余数。</p>\n<p>除了%，二元运算符既允许操作数是整数也允许操作数是浮点数，或者允许两者的混合。当把 int 型操作数和 float 型操作数混合在一起时，运算结果是 float 型的。</p>\n<p>运算符/和%需要特别注意：</p>\n<ul>\n<li>/可能产生意外的结果。当两个操作数都是整数时，运算符/通过丢掉分数部分的方法截取结果，因此1/2的结果是0。</li>\n<li>%要求整数操作数；如果两个操作数中有一个不是整数，那么程序将无法通过编译。</li>\n<li>当/和%用于负数时，其结果与具体实现有关。如果操作数中有一个为负数，那么除法的结果既可以向上取整也可以向下取整。</li>\n</ul>\n<p>!!!note “由实现定义”<br>    术语由实现定义（ implementation-defined ）出现频率很高，意思是指软件在特定的平台上编译、链接和执行。根据实现的不同，程序的行为可能会稍有差异。<br>    C语言的目的之一是达到高效率，这经常意味着要与硬件行为相匹配。当-9除以7时，一些机器可能产生的结果是-1，而另一些机器的结果为-2，C标准简单地反映了这一现实。<br>    最好避免编写与实现定义的行为相关的程序。</p>\n<h3 id=\"运算符的优先级和结合性\"><a href=\"#运算符的优先级和结合性\" class=\"headerlink\" title=\"运算符的优先级和结合性\"></a>运算符的优先级和结合性</h3><p>C语言允许在所有表达式中用圆括号进行分组。但如果不使用圆括号，就采用运算符优先级（ operator precedence ）的规则来解决问题。算术运算符有下列相对优先级：</p>\n<ul>\n<li>最高优先级：+ -（一元运算符）</li>\n<li>中级优先级：* / %</li>\n<li>最低优先级：+ -（二元运算符）</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"c\">i + j * k;    // 等价于 i + (j * k)</code></pre>\n<p>当一个表达式包含两个以上相同优先级的运算符时，单独的运算符优先级的规则是不够的。这种情况下，运算符的结合性（ associativity ）开始发挥作用。如果运算符是从左向右结合的，那么称这种运算符是左结合的（ left associative ）。二元算术运算符都是左结合的，所以：</p>\n<pre><code class=\"c\">i - j - k;    // 等价于 (i - j) - k</code></pre>\n<p>如果运算符是从右向左结合的，那么称为右结合的（ right associative ）。一元运算符都是右结合的。</p>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>一旦计算出表达式的值就常常需要把这个值存储在变量中，以便后面使用。C语言的=运算符（assignment）可以用于此目的。</p>\n<h3 id=\"简单赋值\"><a href=\"#简单赋值\" class=\"headerlink\" title=\"简单赋值\"></a>简单赋值</h3><p>表达式v = e的赋值效果是求出表达式e的值，并把此值复制给v。e可以是常量、变量或较为复杂的表达式：</p>\n<pre><code class=\"c\">i = 5;\nj = i;\nk = 10 * i + j;</code></pre>\n<p>如果v和e的类型不同，那么赋值运算发生时会把e的值转化为v的类型：</p>\n<pre><code class=\"c\">int i;\ni = 72.99; /* i is now 72 */</code></pre>\n<p>赋值操作产生结果，赋值表达式v=e的值就是赋值运算后v的值。因此，表达式i = 72.99的值是72。</p>\n<p>!!!note “副作用”<br>    大多数C语言运算符不会改变操作数的值，但是也有一些会改变。由于这类运算符所做的不再仅仅是计算出值，所以称它们有副作用（ side effect ）。简单的赋值运算符就是一个有副作用的运算符，它改变了运算符左边的操作数。表达式i=0产生的结果为0，作为副作用，把0赋值给i。</p>\n<p>运算符=是右结合的。所以：</p>\n<pre><code class=\"c\">i = j = k = 0;\ni = (j = (k = 0)); // 等价</code></pre>\n<h3 id=\"左值\"><a href=\"#左值\" class=\"headerlink\" title=\"左值\"></a>左值</h3><p>大多数C语言运算符允许它们的操作数是变量、常量或者包含其他运算符的表达式。然而，赋值运算符要求它左边的操作数必须是左值（ lvalue ）。左值表示存储在计算机内存中的对象，而不是常量或计算结果。变量是左值，而诸如10或2*i这样的表达式则不是左值。</p>\n<h3 id=\"复合赋值\"><a href=\"#复合赋值\" class=\"headerlink\" title=\"复合赋值\"></a>复合赋值</h3><p>利用变量原有值计算出新值并重新赋值给这个变量在C语言程序中是非常普遍的。例如：</p>\n<pre><code class=\"c\">i = i + 2;</code></pre>\n<p>C语言的复合赋值运算符（ compound assignment operator ）允许缩短这种语句和其他类似的语句。</p>\n<pre><code class=\"c\">i += 2;</code></pre>\n<p>+=运算符把右侧操作数的值加上左侧的变量，并把结果赋值给左侧的变量。还有另外的9种复合赋值运算符，包括：</p>\n<p>-= *= /= %=</p>\n<h2 id=\"自增运算符和自减运算符\"><a href=\"#自增运算符和自减运算符\" class=\"headerlink\" title=\"自增运算符和自减运算符\"></a>自增运算符和自减运算符</h2><p>++表示操作数加1，–表示操作数减1。++和–既可以作为前缀（ prefix ）运算符，也可以作为后缀（ postfix ）运算符使用。</p>\n<p>++和–也有副作用，它们会改变操作数的值。计算表达式++i的结果是i+1，副作用是自增i。计算表达式i++的结果是i，副作用是自增i。</p>\n<p>这个自增操作一定会在下一条语句执行前完成。</p>\n<h2 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h2><p>上述总结的运算符在下表列出了其优先级、结合性。更多讨论见书本p39。</p>\n<table>\n<thead>\n<tr>\n<th>优先级</th>\n<th>类型名称</th>\n<th>符号</th>\n<th>结合性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>后缀自增、自减</td>\n<td>++ –</td>\n<td>左结合</td>\n</tr>\n<tr>\n<td>2</td>\n<td>前缀自增、自减，一元正负</td>\n<td>++ – + -</td>\n<td>右结合</td>\n</tr>\n<tr>\n<td>3</td>\n<td>乘法类</td>\n<td>* / %</td>\n<td>左结合</td>\n</tr>\n<tr>\n<td>4</td>\n<td>加法类</td>\n<td>+ -</td>\n<td>左结合</td>\n</tr>\n<tr>\n<td>5</td>\n<td>赋值</td>\n<td>= *= /= %= += -=</td>\n<td>右结合</td>\n</tr>\n</tbody></table>\n<p><strong>子表达式的求值顺序</strong></p>\n<p>C语言没有定义子表达式的求值顺序（除了含有逻辑与运算符及逻辑或运算符、条件运算符以及逗号运算符的子表达式）。# 第五章 选择语句</p>\n<p>根据语句执行过程中顺序所产生的影响方式，C语言的其他语句大多属于以下三类：</p>\n<ul>\n<li><p>选择语句（ selection statement ）。 if 语句和 switch 语句允许程序在一组可选项中选择一条特定的执行路径。</p>\n</li>\n<li><p>循环语句（ iteration statement ）。 while 语句、 do 语句和 for 语句支持重复操作。</p>\n</li>\n<li><p>跳转语句（ jump statement ）。 break 语句、 continue 语句和 goto 语句引起无条件地跳转到程序中的某个位置。（ return 语句也属于此类）</p>\n</li>\n</ul>\n<p>C语言还有其他两类语句，一类是由几条语句组合成一条语句的复合语句，一类是不执行任何操作的空语句。</p>\n<hr>\n<h2 id=\"逻辑表达式\"><a href=\"#逻辑表达式\" class=\"headerlink\" title=\"逻辑表达式\"></a>逻辑表达式</h2><p>包括 if 语句在内的某些C语句都必须测试表达式的值是“真”还是“假”。诸如<code>i&lt;j</code>这样的比较运算会产生整数：0（假）或1（真）。</p>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>C语言的关系运算符（ relational operator ）用在C语言中时产生的结果是0（假）或1（真）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&lt;</td>\n<td align=\"center\">小于</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;</td>\n<td align=\"center\">大于</td>\n</tr>\n<tr>\n<td align=\"center\">&lt;=</td>\n<td align=\"center\">小于或等于</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;=</td>\n<td align=\"center\">大于或等于</td>\n</tr>\n</tbody></table>\n<p>关系运算符的优先级低于算术运算符，关系运算符都是左结合的。表达式<code>i+j&lt;k-1</code>意味着<code>(i+j)&lt;(k-1)</code>。</p>\n<h3 id=\"判等运算符\"><a href=\"#判等运算符\" class=\"headerlink\" title=\"判等运算符\"></a>判等运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">==</td>\n<td align=\"center\">等于</td>\n</tr>\n<tr>\n<td align=\"center\">!=</td>\n<td align=\"center\">不等于</td>\n</tr>\n</tbody></table>\n<p>判定运算符是左结合的，也是产生0或1作为结果。然而，判等运算符的优先级低于关系运算符。例如表达式<code>i&lt;j == j&lt;k</code>等价于表达式<code>(i&lt;j) == (j&lt;k)</code>。</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">!</td>\n<td align=\"center\">逻辑非</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;&amp;</td>\n<td align=\"center\">逻辑与</td>\n</tr>\n<tr>\n<td align=\"center\">||</td>\n<td align=\"center\">逻辑或</td>\n</tr>\n</tbody></table>\n<p>逻辑运算符所产生的结果是0或1。逻辑运算符将任何非零值操作数作为真值来处理，同时将任何零值操作作为假值来处理。</p>\n<p>运算符&amp;&amp;和||都对操作数进行“短路”计算。</p>\n<p>运算符!的优先级和一元正号、负号的优先级相同。运算符&amp;&amp;和||的优先级低于关系运算符和判等运算符。运算符!是右结合的，而运算符&amp;&amp;和||是左结合的。</p>\n<h2 id=\"if-语句\"><a href=\"#if-语句\" class=\"headerlink\" title=\"if 语句\"></a>if 语句</h2><p>if 语句允许程序通过测试表达式的值从两种选项中选择一种。 if 语句的最简单的格式如下：</p>\n<p>if (表达式) 语句</p>\n<p>执行 if 语句时，先计算圆括号内的表达式的值。如果表达式的值非零，那么接着执行括号后面的语句，C语言把非零值解释为真值。</p>\n<h3 id=\"复合语句\"><a href=\"#复合语句\" class=\"headerlink\" title=\"复合语句\"></a>复合语句</h3><p>如果想用 if 语句处理两条或更多语句，该怎么办呢？可以引入复合语句（ compound statement ）。复合语句有如下格式：</p>\n<p>{ 多条语句 }</p>\n<h3 id=\"else-子句\"><a href=\"#else-子句\" class=\"headerlink\" title=\"else 子句\"></a>else 子句</h3><p>if 语句可以有 else 子句：</p>\n<p>if (表达式) 语句 else 语句</p>\n<p>如果在圆括号内的表达式的值为0，那么就执行 else 后边的语句。</p>\n<h3 id=\"条件表达式\"><a href=\"#条件表达式\" class=\"headerlink\" title=\"条件表达式\"></a>条件表达式</h3><p>C语言提供了一种特殊的运算符，这种运算符允许表达式依据条件的值产生两个值中的一个。</p>\n<p>条件运算符（ conditional operator ）由符号?和符号:组成，两个符号必须按如下格式一起使用：</p>\n<p>表达式1 ? 表达式2 : 表达式3</p>\n<p>条件运算符是C运算符中唯一一个要求3个操作数的运算符。因此，经常把它称为三元运算符。</p>\n<p>条件表达式的求值步骤是：首先计算出表达式1的值，如果此值不为零，那么计算表达式2的值，并且计算出来的值就是整个条件表达式的值；如果表达式1的值为零，那么计算表达式3的值，并且此值就是整个条件表达式的值。</p>\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>因为许多程序需要变量能存储假值和真值，所以C语言缺少适当的布尔类型可能会很麻烦。可以使用 int 型变量来模拟布尔类型：</p>\n<pre><code class=\"c\">int flag;\nflag = 0;\nflag = 1;</code></pre>\n<p>为了使程序更加便于理解，一个好的方法是用类似 TRUE 和 FALSE 这样的名字定义宏：</p>\n<pre><code class=\"c\">#define TRUE 1\n#define FALSE 0\n\nflag = FALSE;\nflag = TRUE;</code></pre>\n<p>为了更进一步实现这个想法，甚至可以定义用作类型的宏：</p>\n<pre><code class=\"c\">#define BOOL int\n\nBOOL flag;</code></pre>\n<h2 id=\"switch-语句\"><a href=\"#switch-语句\" class=\"headerlink\" title=\"switch 语句\"></a>switch 语句</h2><p>C语言提供了 switch 语句作为级联式 if 语句的替换：</p>\n<pre><code class=\"c\">switch (grade) {\n    case 4: printf(&quot;Excellent&quot;); break;\n\n    case 3: printf(&quot;Good&quot;); break;\n\n    case 2: printf(&quot;Average&quot;); break;\n\n    case 1: printf(&quot;Poor&quot;); break;\n\n    case 0: printf(&quot;Failing&quot;); break;\n\n    default: printf(&quot;Illegal grade&quot;); break;\n}</code></pre>\n<p>switch 语句的最常用的格式如下：</p>\n<pre><code class=\"c\">switch (表达式) {\n    case 常量表达式: 多条语句\n    ...\n    case 常量表达式: 多条语句\n\n    default: 多条语句\n}</code></pre>\n<p>switch 语句的组成部分：</p>\n<ul>\n<li><p>控制表达式。 switch 后面必须跟着右圆括号括起来的整型表达式。C语言把字符当成整数来处理，因此可以在 switch 语句中对字符进行判定。但是，不能用浮点数和字符串。</p>\n</li>\n<li><p>情况标号。常量表达式（ constant expression ）更像是普通的表达式，5是常量表达式，5 + 10也是，而n + 10不是（除非n是表示常量的宏）。</p>\n</li>\n<li><p>语句。每个情况标号的后边可以跟任意数量的语句，不需要用大括号括起来。每组语句的最后通常是 break 语句。# 第六章 循环</p>\n</li>\n</ul>\n<p>循环（ loop ）是重复执行某些语句（循环体）的一种语句。在C语言中，每个循环都有一个控制表达式（ controlling expression ）。每次执行循环体时都要对控制表达式进行计算。如果表达式为真，也就是值不为零，那么继续执行循环。</p>\n<p>C语言提供了3种循环语句： while 语句、 do 语句和 for 语句。</p>\n<hr>\n<h2 id=\"while-语句\"><a href=\"#while-语句\" class=\"headerlink\" title=\"while 语句\"></a>while 语句</h2><p>while 语句的格式如下所示：</p>\n<p>while (表达式) 语句</p>\n<p>执行 while 语句时，首先计算控制表达式的值。如果值不为零（即真值），那么执行循环体，接着再次判定表达式。</p>\n<h2 id=\"do-语句\"><a href=\"#do-语句\" class=\"headerlink\" title=\"do 语句\"></a>do 语句</h2><p>do 语句的格式如下所示：</p>\n<p>do 语句 while (表达式);</p>\n<p>和处理 while 语句一样， do 语句的循环体也必须是一条语句（当然可以用复合语句）。</p>\n<p>执行 do 语句时，先执行循环体，再计算控制表达式的值。如果表达式的值是非零的，那么再次执行循环体。</p>\n<h2 id=\"for-语句\"><a href=\"#for-语句\" class=\"headerlink\" title=\"for 语句\"></a>for 语句</h2><p>for 语句的格式如下所示：</p>\n<p>for (表达式1; 表达式2; 表达式3) 语句</p>\n<p>循环开始执行前，表达式1是初始化步骤，并且只执行一次，表达式2用来控制循环的终止（只要表达式2不为零，那么将继续执行循环），而表达式3是在每次循环的最后被执行的一个操作。</p>\n<h3 id=\"逗号运算符\"><a href=\"#逗号运算符\" class=\"headerlink\" title=\"逗号运算符\"></a>逗号运算符</h3><p>有些时候，我们可能喜欢编写有两个（或更多个）初始表达式的 for 语句，或者希望在每次循环时一次对几个变量进行自增操作。使用逗号表达式（ comma expression ）作为 for 语句中的第一个或第三个表达式可以实现这些想法。</p>\n<p>逗号表达式的格式如下所示：</p>\n<p>表达式1, 表达式2</p>\n<p>逗号表达式的计算要通过两步来实现：第一步，计算表达式1并且扔掉计算出的值。第二步，计算表达式2，把这个值作为整个表达式的值。计算表达式1始终会有副作用；如果没有，那么表达式1就没有了存在的意义。</p>\n<p>逗号运算符的优先级低于所有其他运算符。</p>\n<h2 id=\"退出循环\"><a href=\"#退出循环\" class=\"headerlink\" title=\"退出循环\"></a>退出循环</h2><h3 id=\"break-语句\"><a href=\"#break-语句\" class=\"headerlink\" title=\"break 语句\"></a>break 语句</h3><p>break 语句还可以用于跳出 while、 do 或 for 循环。</p>\n<h3 id=\"continue-语句\"><a href=\"#continue-语句\" class=\"headerlink\" title=\"continue 语句\"></a>continue 语句</h3><p>continue 语句无法跳出循环，它把程序控制正好转移到循环体结束之前的一点。 break 语句可以用于 switch 语句，而 continue 语句只能用于循环。</p>\n<h3 id=\"goto-语句\"><a href=\"#goto-语句\" class=\"headerlink\" title=\"goto 语句\"></a>goto 语句</h3><p>goto 语句可以跳转到函数中任何有标号的语句处。</p>\n<p>标号只是放置在语句开始处的标识符：</p>\n<p>标识符: 语句</p>\n<p>goto 语句自身的格式如下：</p>\n<p>goto 标识符;</p>\n<p>执行 goto 语句可以把控制转移到标号后的语句上，而且这些语句必须和 goto 语句本身在同一个函数中。</p>\n<h2 id=\"空语句\"><a href=\"#空语句\" class=\"headerlink\" title=\"空语句\"></a>空语句</h2><p>语句可以为空，也就是除了末尾处的分号以外什么符号也没有。# 第七章 基本类型</p>\n<hr>\n<h2 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h2><p>C语言支持两种根本不同的数值类型：整型和浮点型。整型的值都是数，而浮点型可能还有小数部分。整型还分为有符号的和无符号的。</p>\n<p>!!!note “有符号整数和无符号整数”<br>    在有符号数中，如果数为正数或零，那么最左边的位（符号位）为0，如果是负数，符号位则为1。默认情况下，C语言中的整型变量都是有符号的。</p>\n<p>C语言提供了不同尺寸的整型， int 是正常的尺寸。可以指明变量是 long 型或 short 型， signed 型或 unsigned 型。可以有这些类型组合：</p>\n<p>short int, unsigned short int, int, unsigned int, long int, unsigned long int</p>\n<p>可以把 int 省略掉，即 short int 可以写成 short 。</p>\n<p>不同类型的整型表示的取值范围根据机器的不同而不同。</p>\n<h3 id=\"整型常量\"><a href=\"#整型常量\" class=\"headerlink\" title=\"整型常量\"></a>整型常量</h3><p>这里说的常量表示在程序中以文本形式显示的数。C语言允许用十进制、八进制和十六进制形式书写整型常量。</p>\n<p>十进制常量包含数字<code>0~9</code>，但是一定不能以零开头：15 255 32767</p>\n<p>八进制常量只包含数字<code>0~7</code>，但是必须以零开头：017 0377 07777</p>\n<p>十六进制常量包含数字0<del>9和字母a</del>f，而且总是以0x开头：0xf 0xff 0xffff</p>\n<p>当程序中出现整型常量时，如果它属于 int 类型的取值范围，那么编译器会把此常量作为普通整数来处理，否则作为长整型处理。为了迫使编译器把常量作为长整型来处理，只需在后边加上一个字母L：15L</p>\n<p>为了指明是无符号常量，可以在常量后边加上字母U：15U</p>\n<p>还可以把UL写在一起：0xffffUL</p>\n<h3 id=\"读写整数\"><a href=\"#读写整数\" class=\"headerlink\" title=\"读写整数\"></a>读写整数</h3><p>读写无符号、短的或长的整数需要一些新的转换说明符。</p>\n<ul>\n<li>读写无符号整数时，使用字母u、o或x代替转换说明符d。u代表十进制、o八进制、x十六进制。</li>\n<li>读写短整数时，在d、o、u或x前面加字母h。</li>\n<li>读写长整型时，在d、o、u或x前面加字母l。</li>\n</ul>\n<h2 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h2><p>有时候需要变量存储带有小数的数，或者能存储极大数或极小数。这类数可以用浮点格式进行存储（因小数点是浮动的而得名）。C语言提供3种浮点型，它们对应不同的浮点格式：</p>\n<ul>\n<li>float ：单精度浮点数</li>\n<li>double ：双精度浮点数</li>\n<li>long double ：扩展双精度浮点数</li>\n</ul>\n<h3 id=\"浮点常量\"><a href=\"#浮点常量\" class=\"headerlink\" title=\"浮点常量\"></a>浮点常量</h3><p>浮点常量有许多书写方式：57.0 57. 57E0 5.7E1</p>\n<p>用指数表示的是10的幂。</p>\n<p>默认情况下，浮点常量都以 double 的形式存储。为了表明只需要单精度，可以在常量的末尾处加上字母f，如 57.0f 。</p>\n<h3 id=\"读写浮点数\"><a href=\"#读写浮点数\" class=\"headerlink\" title=\"读写浮点数\"></a>读写浮点数</h3><p>转换说明符 %e %f 和 %g 用于读写单精度浮点数，当读取 double 时，需要用 %lf ，而写 double 时，不需要加l。</p>\n<h2 id=\"字符型\"><a href=\"#字符型\" class=\"headerlink\" title=\"字符型\"></a>字符型</h2><p>给 char 类型的变量赋值：</p>\n<pre><code class=\"c\">char ch;\nch = &#39;a&#39;;</code></pre>\n<p>C语言会按小整数的方式处理字符。</p>\n<h3 id=\"转义序列-1\"><a href=\"#转义序列-1\" class=\"headerlink\" title=\"转义序列\"></a>转义序列</h3><p>一些特殊的符号无法书写，比如换行符，这时候需要用C语言提供的特殊符号转义序列（ escape sequence ）。</p>\n<p>转义序列分成两种：字符转义序列和数字转义序列。</p>\n<h3 id=\"字符处理函数\"><a href=\"#字符处理函数\" class=\"headerlink\" title=\"字符处理函数\"></a>字符处理函数</h3><p>可以使用 toupper 库函数把小写字母转成大写字母：</p>\n<pre><code class=\"c\">ch = toupper(ch);</code></pre>\n<p>被调用时，函数检查参数是否是小写字母，如果是，那么将它转换成大写字母，否则，函数返回参数的值。</p>\n<h3 id=\"读写字符\"><a href=\"#读写字符\" class=\"headerlink\" title=\"读写字符\"></a>读写字符</h3><p>转换说明符 %c 允许 scanf 函数和 printf 函数对单独一个字符进行读写操作。</p>\n<pre><code class=\"c\">char c;\nscanf(&quot;%c&quot;, &amp;c);\nprintf(&quot;%c&quot;, c);</code></pre>\n<p>在读入字符前， scanf 不会跳过空白字符。为了强制 scanf 函数在读入字符前跳过空白字符，需要在格式串转换说明符 %c 前面加上一个空格。</p>\n<pre><code class=\"c\">char c;\nscanf(&quot; %c&quot;, &amp;c);</code></pre>\n<p>C语言还提供了读写单独字符的其他方法。可以使用 getchar 和 putchar 函数来替代调用 scanf 函数和 printf 函数。每次调用 getchar 函数时，它会读入一个字符，并返回这个字符。</p>\n<pre><code class=\"c\">ch = getchar();</code></pre>\n<p>putchar 函数用来写单独一个字符：</p>\n<pre><code class=\"c\">putchar(ch);</code></pre>\n<p>getchar 和 putchar 会比较快，原因是它们的实现比较简单，并且通常用宏来实现。</p>\n<h2 id=\"sizeof-运算符\"><a href=\"#sizeof-运算符\" class=\"headerlink\" title=\"sizeof 运算符\"></a>sizeof 运算符</h2><p>运算符 sizeof 允许程序确定用来存储指定类型值所需的空间的大小。</p>\n<p>sizeof(类型名)</p>\n<p>上述表达式的值是无符号整数，这个整数表示用来存储属于类型名的值所需的字节数。</p>\n<p>表达式 sizeof(char) 的值始终为1。</p>\n<p>通常情况下， sizeof 运算符也可以应用于常量、变量和表达式。</p>\n<p>既然 sizeof 返回的是无符号的整型，所以最安全的做法是把 sizeof 表达式转换成 unsigned long 型。然后用转换说明符 %lu 进行。</p>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。</p>\n<p>C语言允许表达式中混合使用基本数据类型，这种情况下编译器可能需要生成一些指令将某些操作数转换成不同类型，使得硬件可以对表达式进行计算。这类转换是隐式转换（ implicit conversion ）。C语言还允许程序员通过强制运算符执行显式转换（ explicit conversion ）。</p>\n<p>当发生下列情况时会进行隐式转换：</p>\n<ul>\n<li>当算术表达式或逻辑表达式中操作数类型不同时。</li>\n<li>当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。</li>\n<li>当函数调用中使用的参数类型与其对应的参数类型不匹配时。</li>\n<li>当 return 语句中表达式的类型和函数返回值的类型不匹配时。</li>\n</ul>\n<h3 id=\"常用的算术转换\"><a href=\"#常用的算术转换\" class=\"headerlink\" title=\"常用的算术转换\"></a>常用的算术转换</h3><p>常用的算术转换包括算术运算符、关系运算符和判等运算符。</p>\n<p>为了统一操作数的类型，通常把相对较狭小的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的是整型提升（integral promotion），它把字符或短整数转换成 int 。</p>\n<p>两种转换规则：</p>\n<ul>\n<li>任意操作数是浮点型的情况： float -&gt; double -&gt; long double</li>\n<li>两个操作数都不是浮点类型： int -&gt; unsigned int -&gt; long int -&gt; unsigned long int</li>\n</ul>\n<h3 id=\"赋值中的转换\"><a href=\"#赋值中的转换\" class=\"headerlink\" title=\"赋值中的转换\"></a>赋值中的转换</h3><p>C语言遵循一个简单的规则：把赋值运算符右侧的表达式转换成左边变量的类型。把浮点数赋值给整型变量会丢掉小数点后的部分。如果取值在变量的类型范围之外，那么把值赋值给一个较小的类型变量将会得到无意义的结果（甚至更糟）。# 第八章 数组</p>\n<p>数组是一种聚合（aggregate）变量，可以存储数值的集合。C语言中一共有两种聚合类型：数组和结构。</p>\n<hr>\n<h2 id=\"一维数组\"><a href=\"#一维数组\" class=\"headerlink\" title=\"一维数组\"></a>一维数组</h2><p>数组是含有多个数据值的数据结构，并且每个数据值具有相同的数据类型。这些数据值被称为元素。</p>\n<p>一维数组中的元素一个接一个地编排在单独一行。</p>\n<p>声明一个一维数组：</p>\n<pre><code class=\"c\">#define N 10\nint a[N];</code></pre>\n<h3 id=\"数组下标\"><a href=\"#数组下标\" class=\"headerlink\" title=\"数组下标\"></a>数组下标</h3><p>长度为n的数组元素的索引范围是0到n-1。</p>\n<p>使用数组元素：</p>\n<pre><code class=\"c\">a[0] = 1;</code></pre>\n<p>!!!warning<br>    C语言不要求检查下标的范围，当下标超出范围时，程序可能执行不可预知的行为。</p>\n<h3 id=\"数组初始化\"><a href=\"#数组初始化\" class=\"headerlink\" title=\"数组初始化\"></a>数组初始化</h3><p>数组可以在声明时获得一个初始值。</p>\n<p>数组初始化式（ array initializer ）：</p>\n<pre><code class=\"c\">int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n/* initial value of a is {1, 2, 3, 4, 5, 6, 0, 0, 0, 0} */\nint a[10] = {1, 2, 3, 4, 5, 6};\n\n/* initial value of a is {0, 0, 0, 0, 0, 0, 0, 0, 0, 0} */\nint a[10] = {0};\n\n/* 可以忽略数组长度，编译器自行确认 */\nint a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</code></pre>\n<h3 id=\"对数组使用-sizeof-运算符\"><a href=\"#对数组使用-sizeof-运算符\" class=\"headerlink\" title=\"对数组使用 sizeof 运算符\"></a>对数组使用 sizeof 运算符</h3><p>运算符 sizeof 可以确定数组的大小（字节数）。</p>\n<p>利用 sizeof 来计算数组元素的大小：</p>\n<pre><code class=\"c\">#define SIZE sizeof(a) / sizeof(a[0])</code></pre>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><p>数组可以有任意维数。</p>\n<p>声明一个二维数组（或称为矩阵）：</p>\n<pre><code class=\"c\">int m[5][9];</code></pre>\n<p>数组m有5行9列。</p>\n<p>为了在i行j列中存取数组m的元素，需要写成<code>m[i][j]</code>的形式。</p>\n<p>C语言按照行主序存储数组，也就是从第0行开始，接着第1行，如此下去。</p>\n<p><img src=\"%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8.jpg\" alt></p>\n<h3 id=\"多维数组初始化\"><a href=\"#多维数组初始化\" class=\"headerlink\" title=\"多维数组初始化\"></a>多维数组初始化</h3><p>通过嵌套一维数组的方法可以产生二维数组的初始化式：</p>\n<pre><code>int a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};</code></pre><h2 id=\"常量数组\"><a href=\"#常量数组\" class=\"headerlink\" title=\"常量数组\"></a>常量数组</h2><p>在数组定义前加const使得数组变成一个常量数组，表示不能修改数组里面的元素的值。但这样的数组必须在程序运行前就定义好数组内容，一般用于字符串数组。</p>\n<pre><code class=\"c\">const int months[] = \n{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n```# 第九章 函数\n\n函数是C语言中的构建块，本质上就是一个由语句组成的小程序。有了函数，程序就可以被划分成许多小块。\n\n---\n\n## 函数的定义和调用\n\n由一个案例说明函数中的一些基本概念：\n</code></pre>\n<p>double average(double a, double b)<br>{<br>    return (a + b) / 2;<br>}</p>\n<pre><code>\n**返回类型**：即函数开始处放置的double，表示每次调用该函数返回的类型。\n\n**形式参数（parameter）**：标识符a和b\n\n**函数体**：花括号里的内容。\n\n**实际参数（argument）**：调用函数时，传递给形式参数的表达式。\n\n### 函数定义\n\n函数定义的一般格式：\n</code></pre><p>返回类型 函数名(形式参数)<br>{<br>    声明<br>    语句<br>}</p>\n<pre><code>\n如果返回类型很长，可以把它单独放到一行。\n\nC89标准中，声明必须放在语句之前。\n\n### 函数调用\n\n这样调用函数：\n</code></pre><p>average(x, y);</p>\n<pre><code>\n注意，圆括号不能省略，否则无法正确调用。\n\n返回类型若非void，则会返回一个临时值，这个值可以保存到变量里，也可以丢弃。\n\n## 实际参数\n\n形式参数（parameter）出现在函数的定义中，表示函数调用时要提供的值。\n\n实际参数（argument）是出现在函数调用中的表达式。\n\n实际参数是通过**值传递**的。形参是实参的副本。\n\n### 实际参数的转换\n\n形参和实参的类型不一致时，会发生转换。应该先声明函数原型，然后再执行调用。\n\n这种转换属于隐式转换。实际参数将会转换成形式参数的类型。\n\n### 数组型实际参数\n\n数组名可以作为函数的参数，但是函数无法得知数组的长度，只能传递第二个参数以表明长度。\n\n通过此数组名就可以访问数组元素了。\n\n如果形式参数是多维数组，那么必须指明列的长度：\n</code></pre><p>void sum(arr[][LEN], int n);</p>\n<pre><code>\n但这种用法比较少见。\n\n## return语句\n\n非void的函数必须用return语句来指定要返回的值：\n</code></pre><p>return 表达式;</p>\n<pre><code>\n如果表达式的值得类型与返回值的类型不一致，那么会把表达式的值转换成返回值的类型。\n\n## 程序终止\n\n在main函数中执行return可以终止程序。\n\nmain函数的返回值是状态码，用于提供给操作系统，以表明程序的执行结果。正常结束返回0，异常结束返回非0值。\n\n**exit函数**\n\n另一种终止程序的办法是使用exit函数。此函数属于`&lt;stdlib.h&gt;`头。\n\n传递给exit的参数就是程序结束的状态码：\n</code></pre><p>exit(0); // 正常终止<br>exit(EXIT_SUCCESS); // 正常终止，此值为0<br>exit(EXIT_FAILURE); // 异常终止，此值为1</p>\n<pre><code>\n## 递归\n\n如果函数调用它自己，那么此函数就是递归的（recursive）。\n\n为了防止无限递归，一定要有一个终止递归的条件。# 第十章 程序结构\n\n---\n\n## 局部变量\n\n在函数体内或程序块内声明的变量叫局部变量。\n\n局部变量有如下性质：\n\n- 自动存储期限。局部变量的存储单元在函数被调用时分配的，在函数返回时收回。\n\n- 块作用域。作用域是可以引用该变量的代码文本部分。局部变量的作用域在程序块中，外部不可访问。\n\n### 静态局部变量\n\n使用static声明局部变量使其成为静态局部变量，它具有静态存储期限，而不再是自动存储期限。\n\n静态变量拥有永久的存储单元，在整个程序的执行期间都会保留。\n\n静态局部变量的作用域仍是块作用域。\n\n### 形式参数\n\n形式参数拥有和局部变量一样的性质，即自动存储期限和块作用域。\n\n其区别在于它是被实参赋值的。\n\n## 外部变量\n\n参数是给函数传递信息的一种方法。另一种方法就是使用外部变量（external variable）。\n\n外部变量声明于函数体外，也叫全局变量。它有如下性质：\n\n- 静态存储期限。如同在函数体内声明的static局部变量，静态存储期限的变量都会永久保留。\n\n- 文件作用域。外部变量的作用域为其声明处到文件末尾。\n\n### 外部变量的利弊\n\n使用外部变量容易引发的问题：\n\n- 在维护期间，如果改变了外部变量，那么就要检查引用了该外部变量的所有函数，以确认此变化对这些函数的影响\n\n- 如果外部变量的值错误，那么比较难定位是哪个函数赋予它错误的值\n\n- 使用了外部变量的函数难以复用，因为此函数不再独立，而是依赖于此外部变量\n\n要给外部变量起一个健全的名字，这样才不容易和其他变量混淆。\n\n## 程序块\n\n程序块就是这样的代码结构：\n</code></pre><p>{ 多条声明 多条语句 }</p>\n<pre><code>\n在程序块中声明的变量具有自动存储期限，出块时收回存储单元，其作用域在块内。\n\n函数体就是一个程序块。\n\n## 作用域\n\n当程序块内的声明命名了一个标识符时，如果此标识符已经可见（被其它地方声明并且可引用），那么新的声明就会”隐藏“旧的声明。\n\n## 构建C程序\n\n一个可能的编排程序的顺序：\n\n- \\#include指令\n\n- \\#define指令\n\n- 类型定义\n\n- 外部变量的声明\n\n- 除main函数之外的函数的原型\n\n- main函数的定义\n\n- 其它函数的定义# 第十一章 指针\n\n---\n\n## 指针变量\n\n现代计算机把**内存分隔为字节（byte）**。每个字节都有唯一的地址（address）。\n\n变量占有一个或多个字节的内存，把第一个字节的地址称为变量的地址。\n\n地址是一个整数，用指针类型（pointer）的变量来存储。\n\n**指针变量的声明**\n\n在变量名前加星号，来声明一个指针变量。如：\n</code></pre><p>int *p;</p>\n<pre><code>\n此声明说明p是指向int类型的对象。\n\n## 取地址运算符和间接寻址运算符\n\n### 取地址运算符\n\n得到一个变量的地址在它前面加&#39;&amp;&#39;（取地址）。如：\n</code></pre><p>int i;<br>int *p = &i;</p>\n<pre><code>\n### 间接寻址运算符\n\n获取指针变量指向的存储空间首地址在它前面加`*`（间接寻址）。如：\n</code></pre><p>*p = 10;</p>\n<pre><code>\n这个操作（\\*p）得到的就是变量的**别名**。该操作会修改变量的值。\n\n## 指针赋值\n\n只要是相同类型的指针，就可以相互赋值。这样它们就指向了相同的对象。\n\n## 指针作为参数\n\n指针可以做为函数的参数或返回值。\n\n这些情况，可能会用到指针类型的形参：\n\n0. 需要得到多个结果，故而用指针传出去\n\n0. 传入的对象太大，没有必要执行拷贝操作\n\n一般只有这些情况，返回一个指针类型才是安全的：\n\n0. 返回的是指针类型的参数\n\n0. 返回的是一个全局变量地址\n\n0. 返回的是一个static变量的地址# 第十二章 指针和数组\n\n---\n\n## 指针和数组\n\n当指针指向数组元素时，它可以操作数组元素。此时，可以对指针进行算术运算（加、减、比较）。\n\n数组名即是指向数组中第一个元素的指针。\n\n## 指针的算术运算\n\n指针指向了数组元素，之后对这个指针做算术运算就是合法的操作。但不要越界。\n\n- 指针加、减整数，代表移动元素指向\n\n- 指针相减，代表指针指向元素之间的距离\n\n- 指针比较，比较的是指针指向元素谁前谁后\n\n!!!warning\n    不能相加两个指针。\n\n## 指针用于数组处理\n\n指针可以操作数组中的元素，比如遍历数组：\n\n```c\nint *p = 0;\nfor (p = &amp;a[0]; p &lt; &amp;a[N]; ++p)\n{\n    // ...\n}</code></pre><p>这里N是数组a的长度，虽然<code>a[N]</code>不存在，但对它取地址是合法且安全的操作。</p>\n<p><strong>使用*和++组合</strong></p>\n<p>如，<code>*p++</code></p>\n<p>++操作的优先级高于*，所以这样的组合操作，会先操作指针p，然后获取其指向的内容。</p>\n<p>后置++会先返回p，然后对p递增，可以用这个操作遍历数组：</p>\n<pre><code class=\"c\">int *p = &amp;a[0];\nwhile (p &lt; &amp;a[LEN])\n{\n    int n = *p++;\n    // ...\n}</code></pre>\n<h2 id=\"用数组名作为指针\"><a href=\"#用数组名作为指针\" class=\"headerlink\" title=\"用数组名作为指针\"></a>用数组名作为指针</h2><p>数组名即第一个元素的地址。即a与&amp;a[0]等价。</p>\n<p>数组名是一个指针常量，不能改变其值，应该把它赋值给一个指针变量。</p>\n<p>因此可以这样遍历数组：</p>\n<pre><code class=\"c\">int *p = 0;\nfor (p = a; p &lt; a + LEN; ++p)\n{\n    // ...\n}</code></pre>\n<h2 id=\"指针和多维数组\"><a href=\"#指针和多维数组\" class=\"headerlink\" title=\"指针和多维数组\"></a>指针和多维数组</h2><p>二维数组在内存中实际上是一维的连续存储的。其首元素如果这样写：</p>\n<ul>\n<li><p><code>&amp;a[0]</code>，代表第一行的首地址</p>\n</li>\n<li><p><code>&amp;a[0][0]</code>，代表第一个元素的首地址</p>\n</li>\n</ul>\n<p>这俩地址的值是一样的，但意义不同，因为其指向元素的类型不一样。前者是<code>int*</code>，后者是<code>int</code>。</p>\n<h3 id=\"多维数组名作为指针\"><a href=\"#多维数组名作为指针\" class=\"headerlink\" title=\"多维数组名作为指针\"></a>多维数组名作为指针</h3><p><code>int a[n][m]</code>这样的二维数组，其数组名a代表的是<code>a[0]</code>的地址，<code>a[i]</code>得到的是第i行的地址。</p>\n<p>这样的指针类型是：</p>\n<pre><code class=\"c\">int (*p)[m] = a;</code></pre>\n<p>或</p>\n<pre><code class=\"c\">typedef int (*Line)[m];\nLine p = a;</code></pre>\n<p>这里定义了一个指向数组的指针，这个数组的元素有m个。# 第十三章 字符串</p>\n<hr>\n<h2 id=\"字符串字面量\"><a href=\"#字符串字面量\" class=\"headerlink\" title=\"字符串字面量\"></a>字符串字面量</h2><p>字符串字面量（ string literal ）是用一对双括号括起来的字符序列：</p>\n<pre><code class=\"c\">&quot;Hello World&quot;</code></pre>\n<h3 id=\"字符串字面量中的转义序列\"><a href=\"#字符串字面量中的转义序列\" class=\"headerlink\" title=\"字符串字面量中的转义序列\"></a>字符串字面量中的转义序列</h3><p>字符串字面量可以包含转义序列：</p>\n<pre><code class=\"c\">&quot;Hello\\tWorld\\n&quot;</code></pre>\n<h3 id=\"延续字符串字面量\"><a href=\"#延续字符串字面量\" class=\"headerlink\" title=\"延续字符串字面量\"></a>延续字符串字面量</h3><p>字符串字面量可能太长，以至于无法放置在单独一行内可以把第一行用字符\\结尾，那么C语言就允许在下一行延续字符串字面量：</p>\n<pre><code class=\"c\">printf(&quot;put a disk in drive A, then \\\npress any key to continue&quot;);</code></pre>\n<p>不只是字符串，字符\\可以用来分割任何长的符号。</p>\n<p>但\\有一个缺陷：字符串字面量必须从下一行的起始位置继续，从而破坏了程序的缩进结构。</p>\n<p>一个更好的办法是通过C语言的标准解决这个问题，也就是当两个或更多字符串字面量相连时（仅用空白字符分割），编译器必须把它们合并成单独一条字符串：</p>\n<pre><code class=\"c\">printf(&quot;put a disk in drive A, then&quot;\n       &quot;press any key to continue\\n&quot;);</code></pre>\n<h3 id=\"如何存储字符串字面量\"><a href=\"#如何存储字符串字面量\" class=\"headerlink\" title=\"如何存储字符串字面量\"></a>如何存储字符串字面量</h3><p>从本质上而言，C语言把字符串字面量作为字符数组来处理。当C语言编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。+1存储的是额外的空字符，它用来标志字符串的末尾，用转义序列\\0来表示，其数值为0。</p>\n<p>例如，字符串字面量”abc”是一个有4个字符的字符数组：</p>\n<p><img src=\"%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8.jpg\" alt=\"字符串存储\"></p>\n<p>字符串字面量可以为空。字符串””表示一个空串，仅有一个空字符。</p>\n<p>既然字符串字面量是作为数组来存储的，那么编译器会把它看作是char*类型的指针。</p>\n<h3 id=\"字符串字面量的操作\"><a href=\"#字符串字面量的操作\" class=\"headerlink\" title=\"字符串字面量的操作\"></a>字符串字面量的操作</h3><p>通常情况下可以在任何C语言允许使用char*指针的地方使用字符串字面量。例如：</p>\n<pre><code class=\"c\">char *p;\np = &quot;abc&quot;; /* 并非复制abc中的字符，而仅仅是使p指向字符串的第一个字符 */\n\nchar ch;\nch = &quot;abc&quot;[1]; /* C语言允许对指针添加下标，因此可以给字符串字面量添加下标 */</code></pre>\n<p>!!!warning<br>    对于一些编译器而言，改变字符串字面量的内容可能会导致运行异常。因此不推荐这么做。</p>\n<h3 id=\"字符串字面量与字符常量\"><a href=\"#字符串字面量与字符常量\" class=\"headerlink\" title=\"字符串字面量与字符常量\"></a>字符串字面量与字符常量</h3><p>只包含一个字符的字符串串字面量不同于字符串常量。字符串字面量”a”是指针，指向存放字符a以及后续空字符的内存单元。字符常量’a’是一个整数。</p>\n<h2 id=\"字符串变量\"><a href=\"#字符串变量\" class=\"headerlink\" title=\"字符串变量\"></a>字符串变量</h2><p>C语言只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。</p>\n<p>定义字符串变量的惯用法：</p>\n<pre><code class=\"c\">#define STR_LEN 80\nchar str[STR_LEN + 1]; /* 强调的事实是 str 可以存储最多80个字符 */</code></pre>\n<h3 id=\"初始化字符串变量\"><a href=\"#初始化字符串变量\" class=\"headerlink\" title=\"初始化字符串变量\"></a>初始化字符串变量</h3><p>字符串变量可以在声明时进行初始化：</p>\n<pre><code class=\"c\">char date1[8] = &quot;June 14&quot;;\n\nchar date2[8] = {&#39;J&#39;, &#39;u&#39;, &#39;n&#39;, &#39;e&#39;, &#39;1&#39;, &#39;4&#39;, &#39;\\0&#39;};\n\nchar date3[] = &quot;June 14&quot;; /* 编译器自动计算长度 */</code></pre>\n<h3 id=\"字符数组与字符指针\"><a href=\"#字符数组与字符指针\" class=\"headerlink\" title=\"字符数组与字符指针\"></a>字符数组与字符指针</h3><p>比如：</p>\n<pre><code class=\"c\">char date1[] = &quot;June 14&quot;; /* 字符数组 */\nchar *date2 = &quot;June 14&quot;; /* 字符串字面量的指针 */</code></pre>\n<p>任何期望传递字符数组或字符指针的函数都将接受这两种声明的 date 作为参数。</p>\n<p>然而，需要注意，不能错误地认为上面两种 date 可以互换。两者之间有显著的差异：</p>\n<ul>\n<li><p>在声明为数组时，就像任意数组元素一样，可以修改存储在 date 中的字符。但不可以修改字符串字面量。</p>\n</li>\n<li><p>在声明为数组时， date 是数组名。在声明为指针时， date 是变量，它可以指向其他字符串。</p>\n</li>\n</ul>\n<h2 id=\"字符串的读-写\"><a href=\"#字符串的读-写\" class=\"headerlink\" title=\"字符串的读/写\"></a>字符串的读/写</h2><p>使用 printf 和 puts 函数来读写字符串。</p>\n<p>使用 scanf 和 gets 函数来读字符串。但 gets 函数不安全。</p>\n<h2 id=\"使用C语言的字符串库\"><a href=\"#使用C语言的字符串库\" class=\"headerlink\" title=\"使用C语言的字符串库\"></a>使用C语言的字符串库</h2><p>C语言的运算符无法操作字符串，C语言的库函数为字符串的操作提供了丰富的函数集。这些函数的原型驻留在 string.h 头文件中。</p>\n<p>strcpy 函数可以拷贝字符串。</p>\n<p>strcat 函数可以追加字符串。</p>\n<p>strcmp 函数可以比较字符串。</p>\n<p>strlen 函数可以取得字符串的长度。</p>\n<h2 id=\"字符串数组\"><a href=\"#字符串数组\" class=\"headerlink\" title=\"字符串数组\"></a>字符串数组</h2><p>比如：</p>\n<pre><code class=\"c\">char *planets[] = {\n    &quot;Mercury&quot;,\n    &quot;Venus&quot;,\n    &quot;Earth&quot;,\n    &quot;Mars&quot;,\n    &quot;Jupiter&quot;,\n    &quot;Saturn&quot;,\n    &quot;Uranus&quot;,\n    &quot;Neptune&quot;,\n    &quot;Pluto&quot;,\n};</code></pre>\n<p>planets 数组的每一个元素是一个字符串的指针。</p>\n<h3 id=\"命令参数\"><a href=\"#命令参数\" class=\"headerlink\" title=\"命令参数\"></a>命令参数</h3><p>运行程序时，经常需要提供一些信息给程序，这是命令行参数（ command-line argument ）。必须把 main 函数定义为含有两个参数的函数：</p>\n<pre><code class=\"c\">int main(int argc, char* argv[])\n{\n\n}</code></pre>\n<p>argc （参数计数）是命令行参数的数量（包括程序名本身，最少为1）。 argv (“参数向量”)是指命令行参数的指针数组。 argv[0] 指向程序名， argv[n] 表示第n个参数。</p>\n<p>argv[argc] 始终是一个空指针。</p>\n<p>如果用户输入了下面的命令：</p>\n<pre><code class=\"shell\">ls -l remind.c</code></pre>\n<p>那么 argc 和 argv 是：</p>\n<ul>\n<li><p>argc: 3</p>\n</li>\n<li><p>argv: {“ls”, “-l”, “remind.c”, NULL}# 第十四章 预处理器</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"预处理器的工作方式\"><a href=\"#预处理器的工作方式\" class=\"headerlink\" title=\"预处理器的工作方式\"></a>预处理器的工作方式</h2><p>预处理器的行为是由指令控制的。这些指令是由#字符开头的一些命令。比如 #define 和 #include 。</p>\n<p><code>#define</code>定义了一个宏——用来代表其他东西的一个名字。当宏在后面的程序中用到时，预处理器扩展它，将宏替换为它所定义的值。</p>\n<p><code>#include</code>指令告诉预处理器打开一个特定的文件，将它的内容作为正在编译的文件的一部分。</p>\n<p>!!!note “my note”<br>    可以使用<code>gcc -E src.c</code>指令来查看预编译结果。</p>\n<h2 id=\"预处理指令\"><a href=\"#预处理指令\" class=\"headerlink\" title=\"预处理指令\"></a>预处理指令</h2><p>常见预处理指令包括：</p>\n<ul>\n<li><p>宏定义。<code>#define</code>定义一个宏，<code>#undef</code>删除一个宏。</p>\n</li>\n<li><p>文件包含。即<code>#include</code></p>\n</li>\n<li><p>条件编译。<code>#if #ifdef #ifndef #elif #else #endif</code></p>\n</li>\n</ul>\n<p>指令的通用规则有：</p>\n<ul>\n<li><p>都以#开始。</p>\n</li>\n<li><p>在指令的符号之间可以插入任意数量的空格或横向制表符。</p>\n</li>\n<li><p>指令总是在第一个换行符处结束，除非明确地指明要继续，用\\字符换行。</p>\n</li>\n<li><p>指令可以出现在程序的任何地方。</p>\n</li>\n<li><p>注释可以与指令放在同一行。</p>\n</li>\n</ul>\n<p><a href=\"../../codes/CProgramming/lab/test_precompiled_command.c\">测试代码</a></p>\n<h2 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h2><p>宏定义的作用范围从定义处开始到本文件末尾。</p>\n<h3 id=\"简单宏定义\"><a href=\"#简单宏定义\" class=\"headerlink\" title=\"简单宏定义\"></a>简单宏定义</h3><p>简单宏定义的格式如：</p>\n<pre><code class=\"c\">#define &lt;宏名&gt; [替换列表]</code></pre>\n<p>替换列表中可以有空格。甚至可以没有替换列表，此时宏替换后，就等于删除了这个宏一样。</p>\n<p>简单的宏定义一般用于：</p>\n<ul>\n<li>给字面量取一个别名</li>\n<li>辅助条件编译</li>\n</ul>\n<h3 id=\"带参数的宏定义\"><a href=\"#带参数的宏定义\" class=\"headerlink\" title=\"带参数的宏定义\"></a>带参数的宏定义</h3><p>格式如：</p>\n<pre><code class=\"c\">#define &lt;宏名&gt;(x1, x2, ..., xn) [替换列表]</code></pre>\n<p>注意点：</p>\n<ul>\n<li><p>宏名和参数列表的括号之间不能有空格，不然就是一个简单宏了</p>\n</li>\n<li><p>参数列表可以为空，这样的宏使用起来就像一个函数</p>\n</li>\n<li><p>参数只会替换记号，字符串内的同名单词并不会被替换</p>\n</li>\n</ul>\n<p>带参数的宏一般用于：</p>\n<ul>\n<li>替代一些小的函数，这样程序的执行效率会高一些，并且函数可能更加通用，因为宏不必检查参数类型</li>\n</ul>\n<h3 id=\"号和-号\"><a href=\"#号和-号\" class=\"headerlink\" title=\"#号和##号\"></a>#号和##号</h3><p>宏替换列表中有两个特殊符号：#和##，它们有如下的意义：</p>\n<ul>\n<li>#号代表参数会被替换成一个字符串字面量，例如 :</li>\n</ul>\n<pre><code class=\"c\">#define PRINT_INT(n) printf(#n &quot; = %d\\n&quot;, n)</code></pre>\n<p>#n会被替换成”n”，相邻的字符串字面量可以连起来形成一个字符串字面量，所以PRINT_INT(a)的宏替换结果是：</p>\n<pre><code class=\"c\">printf(&quot;a = %d\\n&quot;, a);</code></pre>\n<ul>\n<li>##代表将两边的记号连接在一起，成为一个记号，一个典型的例子：</li>\n</ul>\n<pre><code class=\"c\">#define GENERIC_MAX(type)               \\\ntype type##_max(type x, type y)         \\\n{                                       \\\n        return x &gt; y ? x : y;           \\\n};</code></pre>\n<p>这个宏定义定义了一个取最大值的函数，可以方便的为这个函数指定比较类型。</p>\n<p>值得注意的是，<strong>#和##都在简单的宏替换后起作用</strong>。</p>\n<h3 id=\"宏定义中的圆括号\"><a href=\"#宏定义中的圆括号\" class=\"headerlink\" title=\"宏定义中的圆括号\"></a>宏定义中的圆括号</h3><p>如果宏定义的替换列表是一个表达式，那么为其增加圆括号是必不可少的工作。</p>\n<p>这是因为如果不加圆括号，在宏替换后，新的表达式可能会破坏替换列表表达式的运算优先级。</p>\n<p><strong>在替换列表表达式中使用圆括号有两条规则：</strong></p>\n<ol start=\"0\">\n<li>用圆括号将替换列表括起来</li>\n<li>用圆括号把每个宏参数括起来</li>\n</ol>\n<p>一个安全的宏的例子：</p>\n<pre><code class=\"c\">#define SUM(x, y) ((x) + (y))</code></pre>\n<h3 id=\"创建较长的宏\"><a href=\"#创建较长的宏\" class=\"headerlink\" title=\"创建较长的宏\"></a>创建较长的宏</h3><p>一些废话：</p>\n<p>宏函数展开后，实际上只有一行。而编写的时候为了好看，可以用<code>\\</code>作为换行连接符号。</p>\n<p>另外，宏函数使用时看上去应该像普通函数一样：后面也要加分号。所以宏函数的替换列表的末尾应该没有分号。</p>\n<p><strong>直接上书上所给的解决方案：</strong></p>\n<pre><code class=\"cpp\">#define ECHO(str)    \\\ndo                   \\\n{                    \\\n    gets(str);       \\\n    puts(str);       \\\n} while(0)\n\n// use\nECHO(str);</code></pre>\n<h3 id=\"预定义宏\"><a href=\"#预定义宏\" class=\"headerlink\" title=\"预定义宏\"></a>预定义宏</h3><p>常用预定义宏：</p>\n<table>\n<thead>\n<tr>\n<th>宏</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__LINE__</code></td>\n<td>行号，十进制常数</td>\n</tr>\n<tr>\n<td><code>__FILE__</code></td>\n<td>文件名</td>\n</tr>\n<tr>\n<td><code>__DATE__</code></td>\n<td>文件编译时的日期</td>\n</tr>\n<tr>\n<td><code>__TIME__</code></td>\n<td>文件编译时的时间</td>\n</tr>\n</tbody></table>\n<p>文件名，日期，时间的预定义宏展开后都是一个字符串变量。行号是一个整型变量。</p>\n<p>另外，不同的系统会定义不同的预定义宏，来标识其编译平台。如：</p>\n<ul>\n<li><p>Linux下，<code>__unix</code></p>\n</li>\n<li><p>Windows下，<code>_WIN32</code></p>\n</li>\n</ul>\n<p>这种预定义宏配合条件编译就可以做到跨平台编译代码。</p>\n<p><a href=\"../../codes/CProgramming/lab/test_precompiled_macros.c\">测试代码</a></p>\n<p><strong>特殊的预定义宏<code>__VA_ARGS__</code></strong></p>\n<p>C99标准中，有一个特殊的预定义宏，它的作用是替换可变参数列表（…），但它要和##符号配合使用，此时##的意义不再是连接，而是：当可变参数列表为空的时候，去除<code>__VA_ARGS__</code>前面的逗号，从而避免编译错误。</p>\n<p>一个典型的例子：</p>\n<pre><code class=\"c\">#define CONSOLE_DEBUG(fmt, ...)\\\n    printf(&quot;FILE: &quot;__FILE__&quot;, LINE: %05d &quot;fmt&quot;\\n&quot;, __LINE__, ##__VA_ARGS__);</code></pre>\n<p><code>__FUNCTION__</code></p>\n<p>这个宏代表了当前执行函数的函数名字符串。</p>\n<h2 id=\"条件编译\"><a href=\"#条件编译\" class=\"headerlink\" title=\"条件编译\"></a>条件编译</h2><p>条件编译指令排除了不应该出现的文本。只有通过了条件编译的文本块才会被交给编译器编译。</p>\n<p>条件一般是一个普通的宏。</p>\n<p>书写格式如：</p>\n<pre><code class=\"c\">#if MACRO\ncode\n#elif MACRO\ncode\n#else\ncode\n#endif</code></pre>\n<h3 id=\"defined-运算符\"><a href=\"#defined-运算符\" class=\"headerlink\" title=\"defined 运算符\"></a>defined 运算符</h3><p>defined 运算符仅用于预处理器。</p>\n<pre><code class=\"c\">#if defined(DEBUG)\n...\n#endif</code></pre>\n<p>如果标识符 DEBUG 是一个定义过的宏，则返回1，否则返回0。 defined 返回1意味着通过条件。</p>\n<p>指令说明：</p>\n<ul>\n<li><p>#if, #elif可以判断这个宏的值，如果是0就不会通过条件编译</p>\n</li>\n<li><p>#ifdef, #ifndef可以判断这个宏是否被定义</p>\n</li>\n</ul>\n<p>条件编译的作用一般是：</p>\n<ul>\n<li><p>为了支持跨平台编译</p>\n</li>\n<li><p>排除一些调试代码</p>\n</li>\n</ul>\n<h2 id=\"其他指令\"><a href=\"#其他指令\" class=\"headerlink\" title=\"其他指令\"></a>其他指令</h2><p><strong>#error 指令</strong></p>\n<p>如果预处理器遇到一个<code>#error</code>指令，它会显示一个出错消息，大多数编译器会立即终止编译。</p>\n<pre><code class=\"c\">#error You can not include this file</code></pre>\n<p><strong>#pragma指令</strong></p>\n<p><code>#pragma</code>指令为要求编译器执行某些特殊操作提供了一种方法。</p>\n<p>使用#pragma pack预处理指令来设置字节对齐。具体用法如：</p>\n<pre><code class=\"c\">#pragma pack(push)    // 保存现在的字节对齐状态\n#pragma pack(4)       // 设置4字节对齐\n// 这里定义的结构体最好以4字节对齐\n#pragma pack(pop)     // 恢复字节对齐状态</code></pre>\n<p>这里字节对齐的意思是，将结构体中最大内置类型的成员的长度与默认字节对齐数（比如是4）对比，如果谁小，那么就按谁来对齐。# 第十五章 编写大规模程序</p>\n<p>源文件包含函数的定义和外部变量，而头文件包含可以在源文件之间共享的信息。</p>\n<hr>\n<h2 id=\"源文件\"><a href=\"#源文件\" class=\"headerlink\" title=\"源文件\"></a>源文件</h2><p>可以把程序分割成一定数量的源文件，源文件的扩展名为<code>.c</code>。源文件主要包含函数的定义和变量。其中一个源文件必须包含名为 main 的函数，作为程序的起始点。</p>\n<p>把程序分成多个源文件有许多显著的优点：</p>\n<ul>\n<li><p>把相关的函数和变量集合在单独一个文件中可以帮助明了程序的结构。</p>\n</li>\n<li><p>可以单独对每一个源文件进行编译。如果程序规模很大而且需要频繁改变的话，这种方法可以极大地节约时间。</p>\n</li>\n<li><p>利于复用。</p>\n</li>\n</ul>\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><p>当把程序分割成几个源文件时，问题也随之产生：某文件的函数如何能调用定义在其他文件中的函数？函数如何能访问其他文件中的外部变量？两个文件如何能共享同一个宏定义或类型定义？答案取决于<code>#include</code>指令。</p>\n<p><code>#include</code>指令告诉预处理器打开指定的文件，并且把此文件的内容插入到当前文件中。这种打开的文件称为头文件，其扩展名为<code>.h</code>。</p>\n<h3 id=\"include-指令\"><a href=\"#include-指令\" class=\"headerlink\" title=\"include 指令\"></a>include 指令</h3><p><code>#include</code>指令有两种书写格式：</p>\n<ul>\n<li><p><code>#include &lt;文件名&gt;</code> 搜索系统头文件所在目录，比如在 UNIX 系统中，通常是在 /usr/include</p>\n</li>\n<li><p><code>#include &quot;文件名&quot;</code> 搜索当前目录，然后搜索系统目录</p>\n</li>\n</ul>\n<p>利用加上诸如-I这样的命令行选项可以添加搜索头文件的位置。</p>\n<h3 id=\"共享宏定义和类型定义\"><a href=\"#共享宏定义和类型定义\" class=\"headerlink\" title=\"共享宏定义和类型定义\"></a>共享宏定义和类型定义</h3><p>大规模的程序包含用于几个源文件共享的宏定义和类型定义，这些定义应该放在头文件中。</p>\n<p>比如下图的例子：</p>\n<p><img src=\"%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89.png\" alt=\"宏定义和类型定义\"></p>\n<p>有两个源文件包含了 boolean.h</p>\n<p>把宏定义和类型定义放到头文件中有如下的好处：</p>\n<ol>\n<li><p>不必把定义复制到需要的源文件，节约时间。</p>\n</li>\n<li><p>程序变得更加容易修改，改变定义只需要改变头文件。</p>\n</li>\n<li><p>不用担心源文件包含了相同的宏或类型而其定义不同。</p>\n</li>\n</ol>\n<h3 id=\"共享函数原型\"><a href=\"#共享函数原型\" class=\"headerlink\" title=\"共享函数原型\"></a>共享函数原型</h3><p>没有原型依赖的函数调用是很危险的，编译器的假设可能是错误的。当调用定义在其他文件中的函数时，要始终确保编译器在调用之前看到函数f的原型。</p>\n<p>解决办法就是把函数的原型放进头文件中，然后在所有调用函数f的地方包含头文件。</p>\n<p>其包含的方式可能如图所示：</p>\n<p><img src=\"%E5%85%B1%E4%BA%AB%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B.png\" alt=\"共享函数原型\"></p>\n<h3 id=\"共享变量的声明\"><a href=\"#共享变量的声明\" class=\"headerlink\" title=\"共享变量的声明\"></a>共享变量的声明</h3><p>变量可以在文件中共享。</p>\n<p>为了声明变量而不定义，需要在变量声明的开始处放置关键字 extern :</p>\n<pre><code class=\"c\">/* in heaeder file */\nextern int i;</code></pre>\n<p>为了共享i，需要在一个源文件中定义i:</p>\n<pre><code class=\"c\">/* in source file */\nint i;</code></pre>\n<h3 id=\"保护头文件\"><a href=\"#保护头文件\" class=\"headerlink\" title=\"保护头文件\"></a>保护头文件</h3><p>如果一个源文件同时包含一个头文件两次，那么可能产生编译错误（比如包含了两次相同的类型定义）。</p>\n<p>因此要用到一种保护头文件的方法：</p>\n<pre><code class=\"c\">#ifndef BOOLEAN_H\n#define BOOLEAN_H\n\n/*\n real content\n*/\n\n#endif</code></pre>\n<p>如果再次包含此头文件，预处理器就不会再扩展真实的内容。</p>\n<h3 id=\"头文件中的-error指令\"><a href=\"#头文件中的-error指令\" class=\"headerlink\" title=\"头文件中的#error指令\"></a>头文件中的#error指令</h3><p>经常把#error指令放置在头文件中是用来检查不应该包含头文件的条件。例如：</p>\n<pre><code class=\"c\">#ifndef DOS\n#error Graphics supported only under DOS\n#endif</code></pre>\n<p>如果非DOS的程序试图包含此头文件，那么编译将在#error指令处终止。</p>\n<h2 id=\"构建多文件程序\"><a href=\"#构建多文件程序\" class=\"headerlink\" title=\"构建多文件程序\"></a>构建多文件程序</h2><p>构建大程序的基本步骤：</p>\n<ul>\n<li><p>编译，必须对每一个源文件进行编译。不需要编译头文件。编译器产生一个文件，此文件包含来自源文件的目标代码，称为目标文件（object file）。</p>\n</li>\n<li><p>链接，链接器把目标文件和库文件结合在一起生成一个可执行程序。</p>\n</li>\n</ul>\n<p>大多数编译器允许用单独一步来构建程序：</p>\n<pre><code class=\"c\">cc -m fmt fmt.c line.c word.c</code></pre>\n<h3 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h3><p>使用 makefile 更易于构建大型程序。 makefile 列出了作为程序的部分文件，并描述了它们之间的依赖性。</p>\n<p>更多讨论见书本。</p>\n<p>!!!note “my note”<br>    一种自动生成依赖性的说明的方法是键入命令：<code>gcc -MM *.c</code></p>\n<h3 id=\"在程序外定义宏\"><a href=\"#在程序外定义宏\" class=\"headerlink\" title=\"在程序外定义宏\"></a>在程序外定义宏</h3><p>大多数 UNIX 编译器支持-D选项，允许在命令行指定一个宏定义：</p>\n<pre><code class=\"c\">cc -DDEBUG=1 foo.c</code></pre>\n<p>定义了宏 Debug ，在 foo.c 程序中，且值为1。如同在 foo.c 中的开始出现：</p>\n<pre><code class=\"c\">#define DEBUG 1\n```# 第十六章 结构、联合和枚举\n\n---\n\n## 结构变量\n\n结构的元素可能具有不同的类型，而且，每个成员都有名字。\n\n### 结构变量的声明\n\n一个声明结构变量的例子：\n\n```c\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1, part2;</code></pre>\n<p>每个结构变量都有三个成员：number, name, on_hand 。</p>\n<p><code>struct {...}</code>指明了类型，而 part1 和 part2 则是具有这种类型的变量。</p>\n<p>结构的成员在内存中是按照声明的顺序存储的。第一个声明的变量放在存储位置的最前面。</p>\n<p>每个结构表示一种新的名字空间（ name space ）。 part1 的 number 和 part2 的 number 不会有冲突。</p>\n<h3 id=\"结构变量的初始化\"><a href=\"#结构变量的初始化\" class=\"headerlink\" title=\"结构变量的初始化\"></a>结构变量的初始化</h3><p>结构变量可以在声明的同时进行初始化：</p>\n<pre><code class=\"c\">struct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1 = { 528, &quot;Disk drive&quot;, 10 },\n  part2 = { 914, &quot;Printer cable&quot;, 5 };</code></pre>\n<p>结构初始化式的表达式必须是常量。初始化式可以短于它所初始化的结构，这样任何“剩余”成员都用0作为它的初始值。</p>\n<h3 id=\"对结构的操作\"><a href=\"#对结构的操作\" class=\"headerlink\" title=\"对结构的操作\"></a>对结构的操作</h3><p>为了访问结构内的成员，首先写出结构的名字，然后写出成员的名字：</p>\n<pre><code class=\"c\">printf(&quot;Part number: %d\\n&quot;, part1.number);</code></pre>\n<p>结构成员的值是左值：</p>\n<pre><code class=\"c\">part1.number = 258;</code></pre>\n<p>用于访问结构成员的句点是一个运算符，其优先级比较高：</p>\n<pre><code class=\"c\">/* &amp;计算的是 part1.on_hand 的地址 */\nscanf(&quot;%d&quot;, &amp;part1.on_hand);</code></pre>\n<p>另一种主要的结构操作是赋值运算：</p>\n<pre><code class=\"c\">part2 = part1;\n/* 现在 par1 和 part2 每个成员的值都一样 */</code></pre>\n<p>可以用结构来复制数组：</p>\n<pre><code class=\"c\">struct { int a[10]; } a1, a2;\na1 = a2;</code></pre>\n<p>运算符=仅仅用于类型一致的结构。</p>\n<h2 id=\"结构类型\"><a href=\"#结构类型\" class=\"headerlink\" title=\"结构类型\"></a>结构类型</h2><p>如果在两个地方编写了：</p>\n<pre><code class=\"c\">struct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part1;\n\nstruct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} part2;</code></pre>\n<p>那么 part1 和 part2 就不是同一个类型，这样就不能执行赋值操作。为了解决这个问题，需要为表示结构的类型定义名字。方法有两种：</p>\n<ul>\n<li><p>使用结构标记</p>\n</li>\n<li><p>使用 typedef 定义类型名</p>\n</li>\n</ul>\n<h3 id=\"结构标记的声明\"><a href=\"#结构标记的声明\" class=\"headerlink\" title=\"结构标记的声明\"></a>结构标记的声明</h3><p>结构标记（ structure tag ）即：</p>\n<pre><code class=\"c\">struct part {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n};\n\n/* 用标记 part 声明变量 */\nstruct part part1, part2;</code></pre>\n<h3 id=\"结构类型的定义\"><a href=\"#结构类型的定义\" class=\"headerlink\" title=\"结构类型的定义\"></a>结构类型的定义</h3><p>即：</p>\n<pre><code class=\"c\">typedef struct {\n    int number;\n    char name[NAME_LEN + 1];\n    int on_hand;\n} Part;\n\n/* 声明变量 */\nPart part1, part2;</code></pre>\n<h2 id=\"联合\"><a href=\"#联合\" class=\"headerlink\" title=\"联合\"></a>联合</h2><p>联合（ union ）也是由一个或多个成员构成的，而且这些成员可能具有不同的数据类型。但是，编译器只为联合中最大的成员分配足够的内存空间，联合的成员在这个空间内彼此覆盖。</p>\n<p>对于：</p>\n<pre><code class=\"c\">union {\n    int i;\n    float f;\n} u;\n\nstruct {\n    int i;\n    float f;\n} s;</code></pre>\n<p>他们的存储如：</p>\n<p><img src=\"%E8%81%94%E5%90%88%E5%92%8C%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%98%E5%82%A8.jpg\" alt=\"联合和结构的存储\"></p>\n<p>其中 u.i 和 u.f 具有相同的地址。</p>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>枚举（ enumeration ）是一种由程序员列出的值，而且程序员必须为每种值命名（枚举常量）：</p>\n<pre><code class=\"c\">enum { CLUBS, DIAMONDS, HEARTS, SPADES } s1, s2;</code></pre>\n<p>虽然枚举和结构没什么共同的地方，但是它们的声明方式很类似。</p>\n<p>枚举常量的名字必须不同于闭合作用域内声明的其他标识符。</p>\n<h3 id=\"枚举标记和枚举类型\"><a href=\"#枚举标记和枚举类型\" class=\"headerlink\" title=\"枚举标记和枚举类型\"></a>枚举标记和枚举类型</h3><p>为了定义枚举标记，可以写成：</p>\n<pre><code class=\"c\">enum suit { CLUBS, DIAMONDS, HEARTS, SPADES };\n\n/* 声明枚举变量 */\nenum suit s1, s2;</code></pre>\n<p>用 typedef 给枚举命名：</p>\n<pre><code class=\"c\">typedef enum { CLUBS, DIAMONDS, HEARTS, SPADES } Suit;\n\n/* 声明枚举变量 */\nSuit s1, s2;</code></pre>\n<h3 id=\"枚举作为整数\"><a href=\"#枚举作为整数\" class=\"headerlink\" title=\"枚举作为整数\"></a>枚举作为整数</h3><p>在系统内部，C语言会把枚举变量和常量作为整数来处理。枚举常量的值可以是任意整数：</p>\n<pre><code class=\"c\">enum suit { CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4 };</code></pre>\n<p>两个或多个枚举常量具有相同的值甚至也是合法的。</p>\n<p>当没有为枚举常量指定值时，它的值是一个大于前一个常量的值的值（大1）。默认第一个枚举常量的值为0。# 第十七章 指针的高级应用</p>\n<hr>\n<h2 id=\"动态存储分配\"><a href=\"#动态存储分配\" class=\"headerlink\" title=\"动态存储分配\"></a>动态存储分配</h2><p>任何单纯的数据结构（各种内置类型，数组，结构体），其大小在程序开始时已经确定了，且不能改变。而一些数据结构可能需要动态的改变其数据长度，比如链表。这就要用到<strong>动态存储分配</strong>（dynamic storage allocation）。</p>\n<p>使用动态存储分配的数据块存放在“堆”上，和其它存储区域不同的是，“堆”里的数据应该让程序员来控制释放（free）时机。</p>\n<p>为了动态地分配存储空间，将需要调用3种内存分配函数中的一种，这些函数都是声明在stdlib.h中的：</p>\n<ol start=\"0\">\n<li><p>malloc，分配内存块，但是不初始化它</p>\n</li>\n<li><p>calloc，分配内存块，并对其清零</p>\n</li>\n<li><p>realloc，调整先前分配的内存块</p>\n</li>\n</ol>\n<p>由于malloc函数不需要对分配的内存块进行清除，所以它比calloc函数更高效。</p>\n<h3 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h3><p>当调用内存分配函数时，无法定位满足我们需要的足够大的内存块，这种问题始终可能出现。如果真的发生了这类问题，函数会返回空指针。</p>\n<p><strong>空指针</strong>（null pointer）是指一个区别于所有有效指针的特殊值。</p>\n<p>!!!warning<br>    程序员的责任是测试任意内存分配函数的返回值，并且在返回空指针时采取适当的操作。通过空指针试图访问内存的效果是未定义的，程序可能会崩溃或者出现不可预测的行为。</p>\n<p>用名为NULL的宏来表示空指针，可用下列方式测试malloc函数的返回值：</p>\n<pre><code class=\"c\">p = malloc(10000);\nif (p == NULL) {\n    /* allocation failed; take appropriate action */\n}</code></pre>\n<h2 id=\"动态分配字符串\"><a href=\"#动态分配字符串\" class=\"headerlink\" title=\"动态分配字符串\"></a>动态分配字符串</h2><p>动态内存分配经常用于字符串操作。字符串始终存储在固定长度的数组中，而且可能很难预测这些数组需要的长度。通过动态地分配字符串，可以推迟到程序运行时才作决定。</p>\n<h3 id=\"使用malloc函数为字符串分配内存\"><a href=\"#使用malloc函数为字符串分配内存\" class=\"headerlink\" title=\"使用malloc函数为字符串分配内存\"></a>使用malloc函数为字符串分配内存</h3><p>函数原型：</p>\n<pre><code class=\"c\">void *malloc(size_t size);</code></pre>\n<p>size_t是无符号整型，malloc分配了一段size个字节的连续空间，并返回该空间首地址。如果分配失败就返回NULL。</p>\n<p>因为C语言保证char型值确切需要一个字节的内存，为了给n个字符的字符串分配内存空间，可以写成：</p>\n<pre><code class=\"c\">p = malloc(n + 1);</code></pre>\n<p>通常情况下，可以把void*型值赋给任何指针类型的变量。然而，一些程序员喜欢强制转换malloc函数的返回值：</p>\n<pre><code class=\"c\">char *p = (char*)malloc(n + 1);</code></pre>\n<p>由于使用malloc函数分配内存不需要清除或者以任何方式初始化，所以p指向带有n+1个字符的未初始化的数组。</p>\n<p>可以调用strcpy函数对上述数组进行初始化：</p>\n<pre><code class=\"c\">strcpy(p, &quot;abc&quot;);</code></pre>\n<p>数组中前4个字符分别为a, b, c和空字符。</p>\n<h2 id=\"动态分配数组\"><a href=\"#动态分配数组\" class=\"headerlink\" title=\"动态分配数组\"></a>动态分配数组</h2><p>编写程序时，常常为难数组估计合适的大小。较方便的做法是等到程序运行时再来确定数组的实际大小。</p>\n<p>虽然malloc函数可以为数组分配内存空间，但calloc函数确实是最常用的一种选择。因为calloc函数对分配的内存进行初始化。realloc函数允许根据需要对数组进行“扩展”或“缩减”。</p>\n<h3 id=\"使用malloc函数为数组分配存储空间\"><a href=\"#使用malloc函数为数组分配存储空间\" class=\"headerlink\" title=\"使用malloc函数为数组分配存储空间\"></a>使用malloc函数为数组分配存储空间</h3><p>当使用malloc函数为数组分配存储空间时，需要使用sizeof运算符来计算出每个元素所需要的空间数量。</p>\n<p>使用sizeof计算是必须的，因为这样计算的结果在不同平台下都是正确的。</p>\n<pre><code class=\"c\">int *a = malloc(n * sizeof(int));</code></pre>\n<p>这里的n可以在程序执行期间计算出来。</p>\n<p>一旦a指向了动态分配的内存块，就可以把它用作数组的名字。这都要感谢C语言中数组和指针的紧密关系。可以使用下列循环对此数组进行初始化：</p>\n<pre><code class=\"c\">for (i = 0; i &lt; n; ++i)\n    a[i] = 0;</code></pre>\n<h3 id=\"calloc函数\"><a href=\"#calloc函数\" class=\"headerlink\" title=\"calloc函数\"></a>calloc函数</h3><p>函数原型：</p>\n<pre><code class=\"c\">void *calloc(size_t nmemb, size_t size);</code></pre>\n<p>nmemb是数据单元的个数， size是一个数据单元的大小。返回成功申请的数据块首地址，失败返回NULL。</p>\n<p>calloc不仅会从“堆”申请存储区域，还会把这段区域清零。也因此其执行效率没有malloc高。</p>\n<p>下列calloc函数的调用为n个整数的数组分配存储空间，并且保证全部初始为0：</p>\n<pre><code class=\"c\">a = calloc(n, sizeof(int));</code></pre>\n<p>通过调用以1作为第一个实际参数的calloc函数，可以为任何类型的数据项分配空间：</p>\n<pre><code class=\"c\">struct point { int x, y; } *p;\np = calloc(1, sizeof(struct point));</code></pre>\n<p>此语句执行后，p指向结构，且此结构的成员x和y都会被设置为0。</p>\n<h3 id=\"realloc函数\"><a href=\"#realloc函数\" class=\"headerlink\" title=\"realloc函数\"></a>realloc函数</h3><p>一旦为数组分配完内存，稍后可能会发现数组过大或过小。realloc函数可以调整数组的大小使它更适合需要。</p>\n<p>函数原型：</p>\n<pre><code class=\"c\">void *realloc(void *ptr, size_t size);</code></pre>\n<p>ptr必须指向内存块，且此内存块一定是先通过malloc函数、calloc函数或realloc函数的调用获得的。size表示内存块的新尺寸，新尺寸可能会大于或小于原有尺寸。</p>\n<p>C标准列出几条关于realloc函数的规则：</p>\n<ul>\n<li><p>当扩展内存块时，realloc函数不会对添加进内存块的字节进行初始化。</p>\n</li>\n<li><p>如果realloc函数不能按要求扩大内存块，那么它会返回空指针，并且在原有内存块中的数据不会发生改变。</p>\n</li>\n<li><p>如果realloc函数调用时以空指针作为第一个实际参数，那么它的行为就像malloc函数一样。</p>\n</li>\n<li><p>如果realloc函数调用时以0作为第二个实际参数，那么它会释放掉内存块。</p>\n</li>\n</ul>\n<p>!!!warning<br>    一旦realloc函数返回，请一定要对指向内存块的所有指针进行更新，因为可能realloc函数移动了其他地方的内存块。</p>\n<p>实际使用时，realloc应该始终对ptr指向的存储区域进行扩展。</p>\n<p>realloc不是一个好用的函数，要很小心才行。这是因为原来的存储区域会被释放掉（虽然新的存储区域会可能和原来的重叠），其指针很可能都变的无效。</p>\n<h2 id=\"释放存储\"><a href=\"#释放存储\" class=\"headerlink\" title=\"释放存储\"></a>释放存储</h2><p>malloc函数和其他内存分配函数所获得的内存块都来自一个称为<strong>堆</strong>（heap）的存储池。调用这些函数经常会耗尽堆，或者要求大的内存块也可能耗尽堆，这会导致函数返回空指针。</p>\n<p>更糟的是，程序可能分配了内存块，然后又丢失了这些块的追踪路径，因而浪费了空间。如下例子：</p>\n<pre><code>p = malloc(...);\nq = malloc(...);\np = q;</code></pre><p>由于没有指针指向第一个内存块，所以再也不能使用此内存块了。</p>\n<p>对于程序而言，不再访问到的内存块被称为是<strong>垃圾</strong>（garbage）。在后边留有垃圾的程序有<strong>内存泄漏</strong>（memory leak）。一些语言提供了<strong>垃圾收集器</strong>（garbage collector），但C语言不提供。每个C程序负责回收各自的垃圾，方法是调用free函数来释放不需要的内存。</p>\n<p>如上例子，就是一个内存泄漏。第一块内存再也访问不到了，这应该就是上文所说的留有垃圾。</p>\n<p><strong>free</strong></p>\n<p>只有一个方法释放由动态存储分配函数分配的内存空间。就是使用free函数，如果不释放，那么这块资源就一直放在“堆”里，直到程序退出。</p>\n<p>函数原型：</p>\n<pre><code class=\"c\">void free(void *ptr);</code></pre>\n<p>使用free函数很容易，只是简单地把指向不再需要的内存块的指针传递给free函数就可以了：</p>\n<pre><code class=\"c\">p = malloc(...);\nfree(p);</code></pre>\n<p>调用free函数来释放p所指向的内存块。然后会把这个释放的内存返回给堆，使此内存块可以被复用。</p>\n<h3 id=\"“悬空指针”问题\"><a href=\"#“悬空指针”问题\" class=\"headerlink\" title=\"“悬空指针”问题\"></a>“悬空指针”问题</h3><p>free操作会生成<strong>悬空指针</strong>（dangling pointer）。即调用free(p)函数会释放p指向的内存块，但是不会改变p本身。如果忘记了p不再指向有效内存块（而使用它），后果很严重。</p>\n<p>悬空指针是很难发现的，因为几个指针可能指向相同的内存块。在释放内存块时，全部的指针都会留有悬空。</p>\n<h2 id=\"指向函数的指针\"><a href=\"#指向函数的指针\" class=\"headerlink\" title=\"指向函数的指针\"></a>指向函数的指针</h2><p>函数也有地址，所以就可以有指针指向。一些功能强大的函数（像模板一样）都是通过函数指针和<code>void*</code>实现的。</p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><p>函数指针主要被存放在：</p>\n<ul>\n<li>数组里，方便日后调用</li>\n<li>形参，成为模板函数的实现，比如qsort</li>\n</ul>\n<p>定义一个函数指针类型的例子：</p>\n<pre><code class=\"c\">typedef void (*Func)();</code></pre>\n<h3 id=\"函数入口地址\"><a href=\"#函数入口地址\" class=\"headerlink\" title=\"函数入口地址\"></a>函数入口地址</h3><p>函数名就是函数地址，但通常会对函数名做&amp;运算，其实得到的结果是一样的。同样对函数指针做<code>*</code>运算（解引用）和直接拿函数指针用也是一样的，都是代表了函数的入口地址。</p>\n<p>一般会对函数名做&amp;操作，对函数指针做<code>*</code>操作，让它们看上去比较像指针的使用。# 第十八章 声明</p>\n<hr>\n<h2 id=\"什么是声明\"><a href=\"#什么是声明\" class=\"headerlink\" title=\"什么是声明\"></a>什么是声明</h2><p>一个变量或者函数应该首先被声明，才会被使用。因为声明会告诉编译器这个变量或者函数的信息，然后编译器就可以检查其存储空间和作用域，以及使用时的语法是否正确。</p>\n<h2 id=\"声明的语法\"><a href=\"#声明的语法\" class=\"headerlink\" title=\"声明的语法\"></a>声明的语法</h2><p>声明的格式（声明式）是：</p>\n<p><strong>声明说明符 声明符</strong></p>\n<p>声明说明符描述了变量或者函数的性质，声明符代表变量名或者函数名，并且可以指明它的额外信息（如是一个数组or指针or函数）。</p>\n<p>声明说明符分为以下3类：</p>\n<ol start=\"0\">\n<li><p>存储类型。四种：auto（块内默认存储类型，无需显示声明），static，extern和register（已经被现代编译器优化，一般不需要声明）</p>\n</li>\n<li><p>类型限定符，有const和volatile</p>\n</li>\n<li><p>类型说明符，诸如int，long，unsighed，或者自定义数据类型等，对于函数，类型说明符就是返回类型。</p>\n</li>\n</ol>\n<p>声明符就是一个标识符，然后可以用星号（代表指针），方括号（代表数组），圆括号（代表函数）修饰。</p>\n<p>可以看到，声明没有赋值的内容。</p>\n<h2 id=\"存储类型\"><a href=\"#存储类型\" class=\"headerlink\" title=\"存储类型\"></a>存储类型</h2><h3 id=\"变量的性质\"><a href=\"#变量的性质\" class=\"headerlink\" title=\"变量的性质\"></a>变量的性质</h3><p>C程序中，变量都有三种性质：</p>\n<ol start=\"0\">\n<li><p>存储期限，决定了变量的生存周期。具有自动存储期限的变量在第一次执行时获得内存单元，出块时释放内存单元；具有静态存储期限的变量在程序的生命周期内都拥有内存单元。</p>\n</li>\n<li><p>作用域，拥有块作用域的变量只能在块内被使用；拥有文件作用域的变量从声明变量开始到文件结束的范围都可以使用。</p>\n</li>\n<li><p>链接，拥有外部链接的变量（内存单元）可以被程序的其它文件访问；拥有内部链接的变量只可以在文件内访问；无链接的变量只能在一个函数内访问。</p>\n</li>\n</ol>\n<p>上述三种性质取决于变量的声明位置以及变量的存储类型，比如不指明存储类型的话：</p>\n<ul>\n<li><p>在块内声明的变量，具有自动存储期限，块作用域，无链接</p>\n</li>\n<li><p>在程序的最外层声明的变量，具有静态存储期限，文件作用域，外部链接。</p>\n</li>\n</ul>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><p>决定一个变量的作用域的，仅在于它的声明位置：</p>\n<ol>\n<li><p>在块内声明的，具有块作用域</p>\n</li>\n<li><p>在文件最外层声明的，具有文件作用域</p>\n</li>\n</ol>\n<p>作用域是编译级别的（非链接）语法，编译器根据变量的作用域检查其使用的位置是否正确。</p>\n<h3 id=\"static存储类型\"><a href=\"#static存储类型\" class=\"headerlink\" title=\"static存储类型\"></a>static存储类型</h3><p>当static作用于一个块内声明的变量时，将改变它的存储期限为静态存储期限</p>\n<p>当static作用于一个最外层声明的变量时，将改变它的链接为内部链接，使这个变量的内存单元不能被其它文件所访问</p>\n<h3 id=\"extern存储类型\"><a href=\"#extern存储类型\" class=\"headerlink\" title=\"extern存储类型\"></a>extern存储类型</h3><p>用extern来声明一个变量，不会让编译器为它分配内存单元，它只是告诉编译器，这个变量是在别的地方定义的。因此：当extern作用于一个变量时，这个变量必须拥有静态存储期限且一般有外部链接。一般这个变量都是一个在最外层定义的变量。</p>\n<h3 id=\"函数存储类型\"><a href=\"#函数存储类型\" class=\"headerlink\" title=\"函数存储类型\"></a>函数存储类型</h3><p>默认情况下，函数存储类型都是extern的，代表此函数的链接是外部链接，可以被其它文件访问。</p>\n<p>如果给函数加上static声明，那么这个函数的链接就会被修改成内部链接，只能在文件内访问。如果一个函数不需要被多个模块共享，那么就应该声明成static的。</p>\n<h2 id=\"const限定符\"><a href=\"#const限定符\" class=\"headerlink\" title=\"const限定符\"></a>const限定符</h2><p>声明一个编译器维度上的常量，但却不能看做一个常量表达式，从而不能定义一个数组的边界（应该用#define）。</p>\n<p>const主要用于保护一个指针指向的对象不被修改，也就是定义一个常量指针，使其指向的空间不允许被修改。</p>\n<h2 id=\"声明符\"><a href=\"#声明符\" class=\"headerlink\" title=\"声明符\"></a>声明符</h2><p>声明符是由标识符和三个特殊符号组成的，这三个特殊符号是：</p>\n<ul>\n<li><p>放在标识符前面的<code>*</code>号</p>\n</li>\n<li><p>放在标示符后面的<code>()</code>或者<code>[]</code></p>\n</li>\n</ul>\n<h3 id=\"解释复杂声明\"><a href=\"#解释复杂声明\" class=\"headerlink\" title=\"解释复杂声明\"></a>解释复杂声明</h3><p>有时候声明符包含了多个特殊符号，这就要通过两条规则进行解释才能理解。它们是：</p>\n<ul>\n<li><p>始终从内向外读声明符，也就是先定位标识符，然后往外读</p>\n</li>\n<li><p><code>[]</code>和<code>()</code>始终优先于<code>*</code>，但<code>()</code>可以强制修改优先级</p>\n</li>\n</ul>\n<h2 id=\"初始化式\"><a href=\"#初始化式\" class=\"headerlink\" title=\"初始化式\"></a>初始化式</h2><p>在声明一个变量时，可以给它<code>=</code>一个初始值，这叫初始化式，而不是赋值。</p>\n<p>需要注意的几点：</p>\n<ul>\n<li><p>静态变量只能用常量表达式初始化，如果没有初始化，那么就是0</p>\n</li>\n<li><p>拥有自动存储期限的变量如果没有初始化，其值就是未定义的（包括数组）</p>\n</li>\n<li><p>数组的初始化（大括号闭合）必须用常量表达式初始化每一个元素# 第十九章 程序设计</p>\n</li>\n</ul>\n<p>虽然C语言不是专门用来编写大规模程序的，但许多大规模程序的确是用C语言编写的。相对于小型程序，编写一个大规模的程序需要更仔细的设计和更详细的计划。</p>\n<hr>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>当设计一个C程序（或其他任何语言的程序）时，最好将它看作是一些独立的模块。模块是一组功能（服务）的集合，其中一些功能可以被程序的其他部分（称为客户）使用。每个模块都有一个接口来描述所提供的功能。模块的细节，包括这些功能自身的源代码，都包含在模块的实现中。</p>\n<p>在C语言环境下，这些“功能”就是函数，模块的接口就是头文件，头文件中包含那些可以被其他文件调用的函数的原型。模块的实现就是包含该模块中函数的定义的源文件。</p>\n<p>将程序分割成模块有一系列好处：</p>\n<ul>\n<li><p>抽象。我们知道模块会做什么，但不需要知道这些功能是如何被实现的。因为抽象的存在，使我们不必为了修改部分程序而了解整个程序是如何工作的。</p>\n</li>\n<li><p>可复用性。每一个提供一定功能的模块，都有可能在另一个程序中复用。</p>\n</li>\n<li><p>可维护性。将程序模块化后，程序中的错误通常只会影响一个模块，因为更容易找到并解决错误。在解决了错误后，重新编译程序只需要将该模块的实现进行编译即可。</p>\n</li>\n</ul>\n<p>一旦我们已经认同了模块化程序设计是正确的方向，接下来的问题就是设计程序的过程中究竟应该定义哪些模块。</p>\n<h3 id=\"内聚性与耦合性\"><a href=\"#内聚性与耦合性\" class=\"headerlink\" title=\"内聚性与耦合性\"></a>内聚性与耦合性</h3><p>一个好的模块并不是随意的一组声明。好的模块应该具有下面两个性质：</p>\n<ul>\n<li><p>高内聚性。模块中的元素应该相互紧密相关。</p>\n</li>\n<li><p>低耦合性。模块之间应该尽可能相互独立。低耦合性可以使程序更便于修改，并方便以后复用模块。</p>\n</li>\n</ul>\n<h3 id=\"模块的类型\"><a href=\"#模块的类型\" class=\"headerlink\" title=\"模块的类型\"></a>模块的类型</h3><p>由于需要高内聚性、低耦合性，模块通常会属于下面几类：</p>\n<ul>\n<li><p>数据池。表示一些相关变量或常量的集合。通常这类模块是一些头文件。</p>\n</li>\n<li><p>库。库是一组相关函数的集合。</p>\n</li>\n<li><p>抽象对象。一个抽象对象是指对于隐藏的数据结构进行操作的一组函数的集合。</p>\n</li>\n<li><p>抽象数据类型。将具体数据的实现方式隐藏起来的数据类型称为抽象数据类型。作为客户的模块可以使用该类型来声明变量，但不会知道这些变量的具体数据结构。如果客户模块需要对变量进行操作，则必须调用抽象数据类型所提供的函数。</p>\n</li>\n</ul>\n<h2 id=\"信息隐藏\"><a href=\"#信息隐藏\" class=\"headerlink\" title=\"信息隐藏\"></a>信息隐藏</h2><p>一个设计良好的模块经常对它的客户隐藏一些信息。例如我们的栈模块的使用者就不需要知道究竟栈是用数组实现的还是用链表。信息隐藏有两大优点：</p>\n<ul>\n<li><p>安全性。数据必须通过模块自身提供的函数来操作，而这些函数都是经过测试的。</p>\n</li>\n<li><p>灵活性。无论对模块的内部机制进行多大的改动，都不会很复杂。不需要改变模块的接口。</p>\n</li>\n</ul>\n<p>在C语言中，可以用于强行信息隐藏的工具是 static 存储类型。将一个函数声明成 static 类型可以使函数内部链接，从而阻止其他文件（包括模块的客户）调用这个函数。将一个带文件作用域的变量声明成 static 类型可以达到类似的效果，使该变量只能被同一个文件中的其他函数访问。</p>\n<h2 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h2><p>对于作为抽象对象的模块，有一个缺点：不可能对同一个对象有多个实例。为了达到这个目的，需要进一步创建一个新的类型。这就是抽象数据类型。然后模块的接口函数需要传入这个类型对象的指针对其进行操作。</p>\n<p>但C语言不提供封装的功能，客户可以访问抽象数据类型的成员。确实有技巧可以达到类似的目的，但使用起来笨拙。</p>\n<p>实现封装的最佳方法是使用C++语言。实际上，C++语言产生的原因之一就是因为C语言不能很好的支持抽象数据类型。</p>\n<h2 id=\"C-语言-1\"><a href=\"#C-语言-1\" class=\"headerlink\" title=\"C++语言\"></a>C++语言</h2><p>略。# 第二十章 低级程序设计</p>\n<p>前面几章中讨论的是C语言中高级的、与机器无关的特性。有一些程序需要进行位级别的操作。位操作和其他一些低级运算在编写系统程序、加密程序、图形程序以及一些需要高执行速度或高效地使用空间的程序时非常有用。</p>\n<p>本章描述的一些技术需要用到数据在内存中如何存储的知识，这对不同机器和编译器可能会不同。依赖于这些技术很可能会使程序丧失可移植性。</p>\n<hr>\n<h2 id=\"按位运算符\"><a href=\"#按位运算符\" class=\"headerlink\" title=\"按位运算符\"></a>按位运算符</h2><h3 id=\"移位运算符\"><a href=\"#移位运算符\" class=\"headerlink\" title=\"移位运算符\"></a>移位运算符</h3><p>移位运算符可以改变数的二进制形式，将它的位向左或者向右移动。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&lt;&lt;</td>\n<td align=\"center\">左移位</td>\n</tr>\n<tr>\n<td align=\"center\">&gt;&gt;</td>\n<td align=\"center\">右移位</td>\n</tr>\n</tbody></table>\n<p>运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>的操作数可以是任意整数型或字符型的。对两个操作数都会进行整数提升，返回值的类型是左边操作数提升后的类型。</p>\n<p><code>i&lt;&lt;j</code>的值是将i中的位左移j位后的结果。每次从i的最左端溢出一位，在i的最右端补一个0位。<code>i&gt;&gt;j</code>的值是将i中的位右移j位后的结果。如果i是无符号数或非负数，则需要在i的最左端补0。如果i是负值，其结果是由实现定义的。一些补0，一些补1。</p>\n<p>!!!note<br>    可移植性技巧：最好仅对无符号数进行移位运算。</p>\n<h3 id=\"按位求反、按位与运算符、按位异或运算符和按位或运算符\"><a href=\"#按位求反、按位与运算符、按位异或运算符和按位或运算符\" class=\"headerlink\" title=\"按位求反、按位与运算符、按位异或运算符和按位或运算符\"></a>按位求反、按位与运算符、按位异或运算符和按位或运算符</h3><table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">~</td>\n<td align=\"center\">按位求反</td>\n</tr>\n<tr>\n<td align=\"center\">&amp;</td>\n<td align=\"center\">按位与</td>\n</tr>\n<tr>\n<td align=\"center\">^</td>\n<td align=\"center\">按位异或</td>\n</tr>\n<tr>\n<td align=\"center\">|</td>\n<td align=\"center\">按位或</td>\n</tr>\n</tbody></table>\n<p>上面的顺序也是运算符优先级的顺序。</p>\n<h2 id=\"结构中的位域\"><a href=\"#结构中的位域\" class=\"headerlink\" title=\"结构中的位域\"></a>结构中的位域</h2><p>C语言提供了声明成员为位域的结构。</p>\n<p>比如：</p>\n<pre><code class=\"c\">struct file_date {\n    unsigned int day:5;\n    unsigned int month:4;\n    unsigned int year:7;\n};\n\nstruct file_data fd;\nfd.day = 28;\nfd.month = 12;\nfd.year = 8; /* represents 1988 */</code></pre>\n<p>这个结构占据32个比特，每个成员后面的数字指定了它所占用位的长度。</p>\n<p>位域有一个限制，C语言不允许将&amp;运算符作用于位域。</p>\n<p>位域之间没有间隙，直到剩下的空间不够用来放下一个位域了，这时，一些编译器会跳到下一个存储单元继续存放位域，而另一些则会将位域拆开跨存储单元存放。位域的存放的顺序也是由实现定义的。# 第二十一章 标准库</p>\n<hr>\n<h2 id=\"标准库的使用\"><a href=\"#标准库的使用\" class=\"headerlink\" title=\"标准库的使用\"></a>标准库的使用</h2><p>C89标准库有15个部分，即15个头文件。</p>\n<p>标准头主要由函数原型、类型定义和宏定义组成。</p>\n<p><strong><code>&lt;assert.h&gt;</code> 诊断</strong></p>\n<p>允许程序插入自我检查，一旦检查失败，程序就被终止。</p>\n<p><strong><code>&lt;ctype.h&gt;</code> 字符处理</strong></p>\n<p>提供用于字符分类及大小写转换的函数。</p>\n<p><strong><code>&lt;errno.h&gt;</code> 错误</strong></p>\n<p>提供了error number，它是一个左值，可以在调用特定库函数后进行检测，来判断调用过程中是否有错误发生。</p>\n<p><strong><code>&lt;float.h&gt;</code> 浮点类型的特性</strong></p>\n<p>提供了用于描述浮点类型特定的宏，包括值得范围及精度。</p>\n<p><strong><code>&lt;limits.h&gt;</code> 整数类型的大小</strong></p>\n<p>提供了用于描述整数类型特性的宏，包括他们的最大值和最小值。</p>\n<p><strong><code>&lt;locale.h&gt;</code> 本地化</strong></p>\n<p>提供一些函数来帮助程序适应针对某个国家或地区的特定行为方式。包括显示数的方式、货币的格式、字符集以及日期和时间的表示形式。</p>\n<p><strong><code>&lt;math.h&gt;</code> 数学计算</strong></p>\n<p>提供常见的数学函数。</p>\n<p><strong><code>&lt;setjmp.h&gt;</code> 非本地跳转</strong></p>\n<p>提供了setjmp和longjmp函数，setjmp会标记程序中的一个位置，随后可以用longjmp返回标记的位置。可以实现从一个函数跳转到另一个函数中，绕过正常的函数返回机制。主要用来处理程序中的严重问题。</p>\n<p><strong><code>&lt;signal.h&gt;</code> 信号处理</strong></p>\n<p>提供了用于处理异常的函数，包括中断和运行时错误。signal可以设置一个函数，使系统信号到达时自动调用该函数；raise函数用来产生信号。</p>\n<p><strong><code>&lt;stdarg.h&gt;</code> 可变参数</strong></p>\n<p>提供一些工具用于编写参数个数可变的函数。</p>\n<p><strong><code>&lt;stddef.h&gt;</code> 常用定义</strong></p>\n<p>提供经验使用的类型和宏定义。</p>\n<p><strong><code>&lt;stdio.h&gt;</code> 输入与输出</strong></p>\n<p>提供大量的输入和输出函数，包括对文件的顺序访问和随机访问操作。</p>\n<p><strong><code>&lt;stdlib.h&gt;</code> 常用实用程序</strong></p>\n<p>包含大量无法划归其它头的函数。包含函数：将字符串转换成数，产生伪随机数，执行内存管理任务，与操作系统通信，执行搜索与排序等。</p>\n<p><strong><code>&lt;string.h&gt;</code> 字符串处理</strong></p>\n<p>包含操作字符串的函数。</p>\n<p><strong><code>&lt;time.h&gt;</code> 日期和时间</strong></p>\n<p>提供相应的函数来获取时间，操纵时间，以及格式化时间。</p>\n<h3 id=\"对标准库中所用名字的限制\"><a href=\"#对标准库中所用名字的限制\" class=\"headerlink\" title=\"对标准库中所用名字的限制\"></a>对标准库中所用名字的限制</h3><p>只要包含了标准头（没有不包含的情况吧？），必须遵循两条规则：</p>\n<ol>\n<li><p>不用自己定义标准头已定义过的宏</p>\n</li>\n<li><p>具有文件作用域的库名也不可以在文件层次重定义</p>\n</li>\n</ol>\n<p>还有一些命名规则，不要与标准库有冲突：</p>\n<ul>\n<li><p>由一个下划线和一个大写字母开头，或由两个下划线开头的标识符，是标准库保留的标识符</p>\n</li>\n<li><p>由一个下划线开头的标识符，被保留用作具有文件作用域的标识符和标记，只可用于函数内部声明</p>\n</li>\n<li><p>在标准库中所有具有外部链接的标识符被保留用作具有外部链接的标识符，比如printf</p>\n</li>\n</ul>\n<h3 id=\"使用宏隐藏的函数\"><a href=\"#使用宏隐藏的函数\" class=\"headerlink\" title=\"使用宏隐藏的函数\"></a>使用宏隐藏的函数</h3><p>C语言允许在头中定义与库函数同名的宏。从而使得宏隐藏掉函数。</p>\n<p>使用宏可能会提高程序的运行速度。如果有不想使用宏的情况，可能是因为想缩小可执行代码的大小。</p>\n<p>若要删掉宏，可用如下方法：</p>\n<pre><code>#include &lt;stdio.h&gt;\n#undef getchar</code></pre><p>还可以禁用宏：</p>\n<pre><code>(getchar)()</code></pre><h2 id=\"stddef-h-常用定义\"><a href=\"#stddef-h-常用定义\" class=\"headerlink\" title=\"stddef.h 常用定义\"></a>stddef.h 常用定义</h2><p>此头提供了常用的类型和宏的定义。定义的类型包括以下几个：</p>\n<ul>\n<li><p>ptrdiff_t，指针相减的结果类型，是有符号整数</p>\n</li>\n<li><p>size_t，sizeof运算符返回的类型，是无符号整数</p>\n</li>\n<li><p>wchar_t，一种足够大的，可以用来表示所有支持的地区的所有字符的类型</p>\n</li>\n</ul>\n<p>其中一个宏是：offsetof，其意思是求得结构体的起点到指定成员间的字节数。</p>\n<p>比如，有下面的结构体：</p>\n<pre><code class=\"c\">struct s {\n    char c;\n    int b[2];\n    float c;\n};</code></pre>\n<p>offsetof(struct s, a)的值一定是0，因为结构体的首元素的地址一定是结构体的地址；</p>\n<p>offsetof(struct s, b)的值可能是1，但也可能是4（考虑到字节对齐）。# 第二十二章 输入 输出</p>\n<hr>\n<h2 id=\"流\"><a href=\"#流\" class=\"headerlink\" title=\"流\"></a>流</h2><p>流意味着任意输入的源或任意输出的目的地。输入流通常和键盘相关，输出流通常和屏幕相关。</p>\n<p>流还可以表示为磁盘上的文件，以及其他设备。</p>\n<h3 id=\"文件指针\"><a href=\"#文件指针\" class=\"headerlink\" title=\"文件指针\"></a>文件指针</h3><p>流的访问是通过 <strong>文件指针（file pointer）</strong> 实现的。此指针的类型为<code>FILE*</code>。</p>\n<p>stdio.h提供了3种标准流，这三个标准流是备用的，不能声明、打开、关闭它们。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">文件指针</th>\n<th align=\"center\">流</th>\n<th align=\"center\">默认的含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">stdin</td>\n<td align=\"center\">标准输入</td>\n<td align=\"center\">键盘</td>\n</tr>\n<tr>\n<td align=\"center\">stdout</td>\n<td align=\"center\">标准输出</td>\n<td align=\"center\">屏幕</td>\n</tr>\n<tr>\n<td align=\"center\">stderr</td>\n<td align=\"center\">标准错误</td>\n<td align=\"center\">屏幕</td>\n</tr>\n</tbody></table>\n<p><strong>重定向（redirection）</strong></p>\n<p>操作系统允许通过重定向机制来改变标准流默认的含义。</p>\n<p>例如：</p>\n<pre><code>demo &lt; in.data</code></pre><p>称为<strong>输入重定向（input redirection）</strong>，即把stdin流表示为文件in.dat，而非键盘。对于程序demo而言，它并不知道输入流是来自键盘还是文件。</p>\n<p>这样子是<strong>输出重定向（output redirection）</strong>：</p>\n<pre><code>demo &gt; out.dat</code></pre><p>如此一来，写入stdout的内容将不再输出到屏幕，而是文件out.dat。</p>\n<h3 id=\"文本文件与二进制文件\"><a href=\"#文本文件与二进制文件\" class=\"headerlink\" title=\"文本文件与二进制文件\"></a>文本文件与二进制文件</h3><p>文件就是字节的序列。</p>\n<p>文本文件中，字节表示字符。</p>\n<p>二进制文件中，字节就是字节，可以用于表示任意类型的数据。</p>\n<p>DOS系统中，这两种文件之间有如下差异：</p>\n<ul>\n<li><p>行的结尾。文本文件写入换行符时，换行符扩展成一对字符，即回行符和跟随的回车符。如果把换行符写入二进制文件时，它就是一个单独的字符（换行符）。</p>\n</li>\n<li><p>文件末尾。文本文件中，文件的结束标记是CTRL+Z字符（\\x1a）。二进制文件中，此字符没有特别的含义，跟其它任何字符一样。</p>\n</li>\n</ul>\n<p>在Unix操作系统中，二进制文件和文本文件不进行区分，其存储方式一样。</p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p><strong>打开文件</strong></p>\n<p>使用 fopen 函数。</p>\n<p><strong>关闭文件</strong></p>\n<p>使用 fclose 函数。</p>\n<p><strong>从命令行获取文件名</strong></p>\n<p>当程序需要打开一个文件时，通常通过命令行参数把文件名传给程序，这样更具灵活性。</p>\n<p>主函数：</p>\n<pre><code class=\"c\">int main(int argc, char *argv[]);</code></pre>\n<p>argc是命令行实际参数的数量（非数组长度），argv是参数字符串数组。</p>\n<p>argv[0]是程序名，argv[1] ~ argv[argc-1]是剩余参数。</p>\n<p>argv[argc]是空指针。</p>\n<p><strong>临时文件</strong></p>\n<p>tmpfile 函数生成临时文件。</p>\n<p>tmpnam 函数生成一个临时的文件名。</p>\n<p><strong>文件缓冲</strong></p>\n<p>向磁盘直接读写数据相对比内存读写慢。使用缓冲区（buffer）来解决这个问题。写入流的数据首先放到缓冲区里面，当缓冲区满了（或关闭流）时，刷新缓冲区，把数据写入文件。</p>\n<p>输入流可以使用类似的方法进行缓冲：缓冲区包含来自输入设备的数据。</p>\n<p>使用 fflush 函数刷新缓冲区。</p>\n<p><strong>其它文件操作</strong></p>\n<p>remove 函数删除文件，rename 函数重命名文件。如果是用 fopen 和 tmpnam 产生的临时文件，可以使用 remove 把它删除，或者用 rename 使其成为永久文件。</p>\n<h2 id=\"格式化的输入与输出\"><a href=\"#格式化的输入与输出\" class=\"headerlink\" title=\"格式化的输入与输出\"></a>格式化的输入与输出</h2><p>即 …printf 类函数 和 …scanf 类函数的使用。</p>\n<h3 id=\"检测文件末尾和错误条件\"><a href=\"#检测文件末尾和错误条件\" class=\"headerlink\" title=\"检测文件末尾和错误条件\"></a>检测文件末尾和错误条件</h3><p>每个流都有与之相关的两个指示器：<strong>错误指示器</strong>（error indicator），<strong>文件末尾指示器</strong>（end-of-file indicator）。</p>\n<p>打开流时，会清除这些指示器；流上的操作失败时会设置某个指示器。</p>\n<p>遇到文件末尾就设置文件末尾指示器，遇到错误就设置错误指示器。</p>\n<p>一旦设置了指示器，它就会保持这种状态，直到可能由 clearerr 调用而引发的明确清除操作为止。 clearerr 可以清除文件末尾指示器和错误指示器。</p>\n<p>如果设置了文件末尾指示器， feof 返回非零值。</p>\n<p>如果设置了错误指示器， ferror 返回非零值。</p>\n<h2 id=\"字符的输入-输出\"><a href=\"#字符的输入-输出\" class=\"headerlink\" title=\"字符的输入/输出\"></a>字符的输入/输出</h2><p>输入输出的字符类型应使用int，原因之一是由于函数通过返回EOF说明文件末尾or错误情况，EOF是一个负的整型常量。</p>\n<h3 id=\"输出函数\"><a href=\"#输出函数\" class=\"headerlink\" title=\"输出函数\"></a>输出函数</h3><pre><code class=\"c\">int fputc(int c, FILE *stream);\nint putc(int c, FILE *stream);\nint putchar(int c);</code></pre>\n<h3 id=\"输入函数\"><a href=\"#输入函数\" class=\"headerlink\" title=\"输入函数\"></a>输入函数</h3><pre><code class=\"c\">int fgetc(FILE *stream);\nint getc(FILE *stream);\nint getchar(void);</code></pre>\n<h2 id=\"行的输入-输出\"><a href=\"#行的输入-输出\" class=\"headerlink\" title=\"行的输入/输出\"></a>行的输入/输出</h2><h3 id=\"输出函数-1\"><a href=\"#输出函数-1\" class=\"headerlink\" title=\"输出函数\"></a>输出函数</h3><pre><code class=\"c\">int fputs(const char *s, FILE *stream);\nint puts(const char *s);</code></pre>\n<p>puts函数向标准输出输出一行字符串，会自动添加一个换行符。</p>\n<p>fputs不会自动添加换行符。</p>\n<h3 id=\"输入函数-1\"><a href=\"#输入函数-1\" class=\"headerlink\" title=\"输入函数\"></a>输入函数</h3><pre><code class=\"c\">char *fgets(char *s, int size, FILE *stream);\nchar *gets(char *s);</code></pre>\n<p>gets函数逐个读取字符，存储到s中，直到读到换行符时停止，并把换行符丢弃。</p>\n<p>fgets当读入了size-1个字符时或读到换行符时停止，且会存储换行符。</p>\n<p>如果出现错误，或者在存储任何字符之前达到了输入流的末尾，函数返回空指针。否则返回第一个实参。</p>\n<p>函数会在字符串的末尾存储空字符。</p>\n<h2 id=\"块的输入输出\"><a href=\"#块的输入输出\" class=\"headerlink\" title=\"块的输入输出\"></a>块的输入输出</h2><pre><code class=\"c\">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\n\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code></pre>\n<p>fread函数和fwrite函数允许程序在单步中读写大的数据块。</p>\n<p>fwrite函数被设计用来把数组复制给流。第一个参数是数组首元素的地址，第二个参数是每个数组元素的大小（以字节为单位），第三个参数是要写的元素的数量，第四个参数是文件指针，说明了要写的数据位置。</p>\n<p>fwrite返回实际写入的元素数量，如果写入错误，此数就会小于第三个参数。</p>\n<p>fread函数从流读入数组的元素。其参数类似fwrite。</p>\n<p>fread返回实际读入的元素数量，此数应该等于第三个参数。否则可能达到了文件末尾或者出现了错误。使用feof和ferror确定出问题的原因。</p>\n<p>检查fread的返回值是非常重要的。</p>\n<h2 id=\"文件的定位\"><a href=\"#文件的定位\" class=\"headerlink\" title=\"文件的定位\"></a>文件的定位</h2><p>每个流都有相关联的<strong>文件位置（file position）</strong>。打开文件时，根据模式可以在文件的起始处或者末尾处设置文件位置。</p>\n<p>在执行读或写操作时，文件位置会自动推进。</p>\n<p>stdio.h提供了一些函数，用于确定当前的文件位置或者改变文件位置：</p>\n<pre><code class=\"c\">int fseek(FILE *stream, long offset, int whence);\n\nlong ftell(FILE *stream);\n\nvoid rewind(FILE *stream);\n\nint fgetpos(FILE *stream, fpos_t *pos);\nint fsetpos(FILE *stream, fpos_t *pos);</code></pre>\n<p><strong>fseek</strong>函数改变第一个参数相关的文件的位置。第二个参数说明新位置是根据文件的起始处、当前位置还是文件末尾来计算，也就是第三个参数来计算。</p>\n<p>第三个参数可取值为：</p>\n<ul>\n<li><p>SEEK_SET，文件的起始处。</p>\n</li>\n<li><p>SEEK_CUR，文件的当前位置。</p>\n</li>\n<li><p>SEEK_END，文件的末尾处。</p>\n</li>\n</ul>\n<p><strong>ftell</strong>函数返回当前文件位置。如果发生错误，ftell返回-1L，并且把错误码存储到errno。</p>\n<p><strong>rewind</strong>函数会把文件位置设置到起始处。rewind还会为fp清除错误指示器。</p>\n<p><strong>fgetpos</strong>和<strong>fsetpos</strong>用于处理大的文件，使用fpos_t表示文件位置，它可能是一个结构。函数成功返回0，失败返回非0值并把错误码存放到errno中。</p>\n<h2 id=\"字符串的输入-输出\"><a href=\"#字符串的输入-输出\" class=\"headerlink\" title=\"字符串的输入/输出\"></a>字符串的输入/输出</h2><p>sprintf和snprintf函数将按写到数据流一样的方式写字符到字符串。</p>\n<p>sscanf函数从字符串中读出数据就像从数据流中读数据一样。</p>\n<h3 id=\"输出函数-2\"><a href=\"#输出函数-2\" class=\"headerlink\" title=\"输出函数\"></a>输出函数</h3><pre><code class=\"c\">int sprintf(char *str, const char *format, ...);\nint snprintf(char *str, size_t size, const char *format, ...);</code></pre>\n<p>类似于printf函数，唯一不同是sprintf函数把输出写入字符数组而不是流。当完成向字符串写入的时候，sprintf函数会添加一个空字符，并返回所存储的字符数量（不计空字符）。如果遇到错误，返回负值。</p>\n<p>snprintf写入的字符数量不会超过size-1，结尾空字符不计。只要size不是0，都会有空字符。</p>\n<h3 id=\"输入函数-2\"><a href=\"#输入函数-2\" class=\"headerlink\" title=\"输入函数\"></a>输入函数</h3><pre><code class=\"c\">int sscanf(const char *str, const char *format, ...);</code></pre>\n<p>sscanf与scanf类似，唯一的不同就是sscanf从字符数组中读取数据而不是流。</p>\n<p>sscanf函数返回成功读入并存储的数据项的数量，如果在找到第一个数据项之前到达了字符串的末尾，那么sscan函数返回EOF。# 第二十三章 库对数值和字符数据的支持</p>\n<hr>\n<h2 id=\"float-h：浮点型的特性\"><a href=\"#float-h：浮点型的特性\" class=\"headerlink\" title=\"float.h：浮点型的特性\"></a>float.h：浮点型的特性</h2><p>提供了用来定义浮点型的范围及精度的宏。</p>\n<h2 id=\"limits-h：整型取值范围\"><a href=\"#limits-h：整型取值范围\" class=\"headerlink\" title=\"limits.h：整型取值范围\"></a>limits.h：整型取值范围</h2><p>仅定义了每种整数类型的取值范围的宏。</p>\n<h2 id=\"math-h：数学计算\"><a href=\"#math-h：数学计算\" class=\"headerlink\" title=\"math.h：数学计算\"></a>math.h：数学计算</h2><p>math.h里的函数处理的都是浮点类型的数值。</p>\n<p>在 UNIX/Linux 下编译，需要指明连接 math 库：-lm</p>\n<p>math.h中定义的函数包含下面5种类型：</p>\n<ul>\n<li><p>三角函数 sin cos tan acos asin atan atan2</p>\n</li>\n<li><p>双曲函数 cosh sinh tanh</p>\n</li>\n<li><p>指数和对数函数 exp log …</p>\n</li>\n<li><p>幂函数 pow sqrt</p>\n</li>\n<li><p>就近去整函数，绝对值函数和取余函数 ceil fabs floor fmod</p>\n</li>\n</ul>\n<h3 id=\"错误\"><a href=\"#错误\" class=\"headerlink\" title=\"错误\"></a>错误</h3><p>在math.h里声明的函数，如果出现错误（可能是参数不对），会把错误码存到errno。且若函数返回值大于double的最大值，那么函数会返回一个特殊值HUGE_VAL（double类型表示无穷大，Linux下输出成inf）。</p>\n<p>errno有两种可能值：</p>\n<ol>\n<li>EDOM：代表定义域错误（Linux下值为33），即参数取值不对，比如给sqrt传一个负数。</li>\n<li>ERANGE：代表取值范围错误（返回值）（Linux下值为34），无法用double来表示了。比如exp(1000)。（PS：不是所有的数学函数出现返回值为无穷大时都会置errno为ERANGE）</li>\n</ol>\n<h2 id=\"ctype-h：字符处理\"><a href=\"#ctype-h：字符处理\" class=\"headerlink\" title=\"ctype.h：字符处理\"></a>ctype.h：字符处理</h2><p>ctype.h提供了两类对字符进行处理的：</p>\n<ol>\n<li>测试字符性质</li>\n<li>对字符进行大小写转换</li>\n</ol>\n<h2 id=\"string-h：字符串处理\"><a href=\"#string-h：字符串处理\" class=\"headerlink\" title=\"string.h：字符串处理\"></a>string.h：字符串处理</h2><p>这些函数的参数的合法性需要程序员来保证。</p>\n<h3 id=\"复制函数\"><a href=\"#复制函数\" class=\"headerlink\" title=\"复制函数\"></a>复制函数</h3><pre><code class=\"c\">void *memcpy(void *dest, const void *src, size_t n);\nchar *strcpy(char *dest, const char *src);\nchar *strncpy(char *dest, const char *src, size_t n);</code></pre>\n<h3 id=\"拼接函数\"><a href=\"#拼接函数\" class=\"headerlink\" title=\"拼接函数\"></a>拼接函数</h3><pre><code class=\"c\">char *strcat(char *dest, const char *src);\nchar *strncat(char *dest, const char *src, size_t n);</code></pre>\n<h3 id=\"比较函数\"><a href=\"#比较函数\" class=\"headerlink\" title=\"比较函数\"></a>比较函数</h3><pre><code class=\"c\">int strcmp(const char *s1, const char *s2);\nint strncmp(const char *s1, const char *s2, size_t n);</code></pre>\n<h3 id=\"搜索函数\"><a href=\"#搜索函数\" class=\"headerlink\" title=\"搜索函数\"></a>搜索函数</h3><pre><code class=\"c\">char *strchr(const char *s, int c);\nvoid *memchr(const void *s, int c, size_t n);\nchar *strrchr(const char *s, int c);\nchar *strtok(char *str, const char *delim);</code></pre>\n<h3 id=\"其它函数\"><a href=\"#其它函数\" class=\"headerlink\" title=\"其它函数\"></a>其它函数</h3><pre><code class=\"c\">void *memset(void *s, int c, size_t n);\nsize_t strlen(const char *s);\n```# 第二十四章 错误处理\n\n---\n\n## assert.h: 诊断\n\n```c\nvoid assert(int expression);</code></pre>\n<p>assert声明在assert.h中，实际上是一个宏。其参数必须是一种“断言”，即被认为正常情况下一定为真的表达式。</p>\n<p>每次执行assert时，判断此断言，若为假（0），则显示一条错误信息，并调用abort函数终止程序执行。</p>\n<p>这条错误信息包含了：断言（以文本格式）、包含assert调用的文件名、assert调用所在的行号。</p>\n<p><strong>禁止assert调用</strong></p>\n<p>方法是：在包含assert.h之前，定义宏NDEBUG。如：</p>\n<pre><code class=\"c\">#define NDEBUG\n#include &lt;assert.h&gt;</code></pre>\n<h2 id=\"errno-h-错误\"><a href=\"#errno-h-错误\" class=\"headerlink\" title=\"errno.h: 错误\"></a>errno.h: 错误</h2><p>标准库中的一些函数通过向errno.h中声明的errno变量存储一个错误代码来表示有错误发生。</p>\n<p>大部分使用errno变量的函数集中在math.h，但也有一些在标准库的其他部分。</p>\n<p>如果errno不为0，则说明函数调用过程中有错误发生。</p>\n<p>errno在程序开始的时候值为0，通常在调用函数前把errno置为0，库函数不会将errno清零，这是程序员的责任。</p>\n<p>用法如：</p>\n<pre><code class=\"c\">y = sqrt(x); // x为负数则出错\nif (errno != 0) {\n    fprintf(stderr, &quot;sqrt error, terminated. \\n&quot;);\n    exit(EXIT_FAILURE);\n}</code></pre>\n<p><strong>perror函数和strerror函数</strong></p>\n<pre><code class=\"c\">void perror(const char *s);\nchar *strerror(int errnum);</code></pre>\n<p>当库函数向errno存储了一个非零值时，通过perror函数和strerror函数可以得到描述这种错误的信息。</p>\n<p>perror函数声明在stdio.h中，它会按照如下顺序把错误信息输出到stderr：</p>\n<pre><code>调用perror的参数: 出错消息（内容根据errno的值决定）</code></pre><p>strerror函数声明在string.h中，它传入errno，返回一个指针，指向描述出错消息的字符串。</p>\n<h2 id=\"signal-h-信号处理\"><a href=\"#signal-h-信号处理\" class=\"headerlink\" title=\"signal.h: 信号处理\"></a>signal.h: 信号处理</h2><p>signal.h提供了处理异常的工具，即信号（signal）。信号有两种类型：运行时错误（例如除以0），程序以外导致的事件（例如用户输入了ctrl+c）。</p>\n<p>当有错误或外部事件发生时，我们称产生了一个信号。大多数信号是<strong>异步的</strong>：它们可以在程序执行过程中的任意时刻发生。</p>\n<h3 id=\"信号宏\"><a href=\"#信号宏\" class=\"headerlink\" title=\"信号宏\"></a>信号宏</h3><p>signal.h定义了一系列宏，用于表示不同的信号。参见书本。</p>\n<h3 id=\"signal函数\"><a href=\"#signal函数\" class=\"headerlink\" title=\"signal函数\"></a>signal函数</h3><pre><code>typedef void (*sighandler_t)(int);\nsighandler_t signal(int signum, sighandler_t handler);</code></pre><p>signal函数安装一个信号处理函数。第一个参数是信号的代码，第二个参数是一个指向信号处理函数的指针。</p>\n<p>一旦随后在程序执行过程中出现了对应的信号，信号处理函数就会被自动调用，信号的代码作为参数传递给信号处理函数。</p>\n<p>除非信号是由调用abort函数或raise函数引发的，否则信号处理函数不应该调用任何库函数，或者试图使用一个静态存储期限的变量。</p>\n<p>一旦信号处理函数返回，程序会从信号发生点恢复并继续执行。但是，如果信号是SIGABRT，当处理函数返回时程序会异常终止。如果信号是SIGFPE，那么处理函数返回的结果是UB（即不要使用它）。</p>\n<p>signal函数的返回值是指定信号的前一个处理函数的指针。</p>\n<h3 id=\"预定义的信号处理函数\"><a href=\"#预定义的信号处理函数\" class=\"headerlink\" title=\"预定义的信号处理函数\"></a>预定义的信号处理函数</h3><p>signal.h提供了两个预定义的信号处理函数（都用宏表示）：</p>\n<ul>\n<li><p>SIG_DFL。表示按默认方式处理信号，大多数情况下会导致程序终止。</p>\n</li>\n<li><p>SIG_IGN，指明随后当信号SIGINT发生时，忽略该信号。</p>\n</li>\n</ul>\n<p>当程序刚开始执行时，根据不同的实现，每个信号的处理函数都会被初始化为SIG_DFL和SIG_IGN。</p>\n<p>如果signal调用失败（即无法对指定信号安装处理函数），就返回SIG_ERR（不是一个函数），并在errno中存入错误代码。</p>\n<p>C语言要求，除了SIGILL以外，当一个信号的处理函数被调用时，该信号的处理函数要被重置为SIG_DFL，或者以其他方式加以封锁。</p>\n<h3 id=\"raise函数\"><a href=\"#raise函数\" class=\"headerlink\" title=\"raise函数\"></a>raise函数</h3><pre><code class=\"c\">int raise(int sig);</code></pre>\n<p>通常信号都是自然产生的，但也可以通过raise函数触发。</p>\n<p>raise函数的返回值可以用来测试调用是否成功：0代表成功，非0代表失败。</p>\n<h2 id=\"setjmp-h-非局部跳转\"><a href=\"#setjmp-h-非局部跳转\" class=\"headerlink\" title=\"setjmp.h: 非局部跳转\"></a>setjmp.h: 非局部跳转</h2><pre><code class=\"c\">#include &lt;setjmp.h&gt;\nint setjmp(jmp_buf env);\nvoid longjmp(jmp_buf env, int val);</code></pre>\n<p>通常情况下，函数会返回到它被调用的位置。setjmp.h可以使一个函数直接跳转到另一个函数，而不需要返回。</p>\n<p>setjmp宏“标记”程序中的一个位置，随后可以用longjmp函数跳转到该位置。这一机制主要用于错误处理。</p>\n<p>setjmp宏会将当前“环境”保存到一个jmp_buf类型的变量中，然后返回0。如果要返回setjmp宏所标记的位置，可以使用longjmp函数，调用的参数是调用setjmp宏时使用的同一个jmp_buf类型的变量。longjmp函数首先会根据jmp_buf变量的内容恢复当前环境，然后从setjmp宏调用中返回。这次setjmp宏的返回值是val，即调用longjmp函数时的第二个参数（如果val是0，那么返回1）。</p>\n<p>如果longjmp的参数未被setjmp初始化，调用longjmp的结果是UB。# 第二十五章 国际化特性</p>\n<hr>\n<h2 id=\"locale-h-本地化\"><a href=\"#locale-h-本地化\" class=\"headerlink\" title=\"locale.h 本地化\"></a>locale.h 本地化</h2><p>locale.h提供的函数用于控制标准库中对于不同的地区会不一样的部分。</p>\n<p>地区通常指一个国家，或者一个国家的不同区域。</p>\n<p>在标准库中，依赖地区的部分包括：</p>\n<ul>\n<li><p>数值的格式。比如一些地区的小数点是用逗号表示</p>\n</li>\n<li><p>货币的格式。不同国家的货币符号不同。</p>\n</li>\n<li><p>字符集。字符集依赖于地区使用的语言。亚洲国家通常比西方国家需要更大的字符集。</p>\n</li>\n<li><p>日期和时间的表示格式。</p>\n</li>\n</ul>\n<h3 id=\"类别\"><a href=\"#类别\" class=\"headerlink\" title=\"类别\"></a>类别</h3><p>通过修改地区，程序可以改变它的行为来适应不同地区。</p>\n<p>可以使用一些宏来指定一个<strong>类型</strong>：</p>\n<ul>\n<li><p>LC_COLLATE。影响两个字符串比较函数的行为（strcoll和strxfm）。</p>\n</li>\n<li><p>LC_CTYPE。影响ctype.h中函数的行为，除了isdigit和isxdigit。同时还影响stdlib.h中的多字节函数。</p>\n</li>\n<li><p>LC_MONETRAY。影响由localeconv函数返回的货币格式信息。</p>\n</li>\n<li><p>LC_NUMERIC。影响格式化输入/输出函数使用的小数点字符以及stdlib.h中的字符串转换函数（atof和strtod），还会影响localeconv函数返回的非货币格式信息。</p>\n</li>\n<li><p>LC_TIME。影响strftime函数的行为，该函数将时间转换成字符串。</p>\n</li>\n</ul>\n<h3 id=\"setlocale函数\"><a href=\"#setlocale函数\" class=\"headerlink\" title=\"setlocale函数\"></a>setlocale函数</h3><pre><code class=\"c\">char *setlocale(int category, const char *locale);</code></pre>\n<p>setlocale函数修改当前的地区。如果第一个参数是LC_ALL，就会影响所有的类型。C语言标准对第二个参数仅定义了两种可能值：”c”和””。其余的由实现定义，比如， gcc 对于简体中文的地区，可以是”zh_CN.UTF-8”</p>\n<p>程序执行开始时，都会隐含调用：<code>setlocale(LC_ALL, &quot;C&quot;);</code></p>\n<p>如果用””作为第二个参数，就切换到了本地模式（native locale），这种模式下程序会适应本地的环境。</p>\n<p>如果调用成功，返回一个关于地区名字的字符串指针。如果调用失败，返回空指针。</p>\n<p>setlocale函数也可以当作搜索函数使用，如果第二个参数是空指针，setlocale函数会返回一个指向字符串的指针，这个字符串与当前地区类型的设置相关联。</p>\n<h3 id=\"localeconv函数\"><a href=\"#localeconv函数\" class=\"headerlink\" title=\"localeconv函数\"></a>localeconv函数</h3><pre><code class=\"c\">struct lconv *localeconv(void);</code></pre>\n<p>函数返回的struct lconv结构包含了当前地区的详细信息，此结构具有静态存储期限。</p>\n<p>详细信息参考书本。</p>\n<h2 id=\"多字节字符和宽字符\"><a href=\"#多字节字符和宽字符\" class=\"headerlink\" title=\"多字节字符和宽字符\"></a>多字节字符和宽字符</h2><p>因为定义已经把char型值的大小限制为一个字节，所以通过改变char类型的含义来处理更大的字符集显然是不可能的。</p>\n<p>C语言提供了两种可扩展字符集的编码：<strong>多字节字符</strong>（multibyte character）和<strong>宽字符</strong>（wide character）。</p>\n<p>C标准要求0字节始终用来表示空字符。</p>\n<h3 id=\"多字节字符\"><a href=\"#多字节字符\" class=\"headerlink\" title=\"多字节字符\"></a>多字节字符</h3><p>在多字节字符编码中，一个或多个字节表示一个可扩展字符。C语言要求的基本字符是单字节的。</p>\n<p>一些多字节字符集依靠<strong>依赖状态编码</strong>（state-dependent encoding）。在这类编码中，每个多字节字符序列都以<strong>初始移位状态</strong>（initial shift state）开始。序列中稍后遇到的一些多字节字符会改变移位状态，并且影响后续字节的含义。</p>\n<p>MB_LEN_MAX和MB_CUR_MAX说明了多字节字符中字节的最大数量。MB_LEN_MAX定义在limits.h中，给出了任意支持地区的最大值。MB_CUR_MAX定义在stdlib.h中，给出了当前地区的最大值。</p>\n<h3 id=\"宽字符\"><a href=\"#宽字符\" class=\"headerlink\" title=\"宽字符\"></a>宽字符</h3><p>宽字符是一种其值表示字符的整数，所有宽字符要求相同的字节数。</p>\n<p>宽字符具有wchar_t类型。</p>\n<p>一个宽字符常量可以写成：<code>L&#39;a&#39;</code></p>\n<p>一个宽字符字符串可以写成：<code>L&quot;abc&quot;</code></p>\n<p>即在普通字符常量前用字母L作为前缀。</p>\n<p>!!!note “my note”<br>    注意，在使用宽字符前，需要设置好本地环境，比如，要使用简体中文的宽字符，那么要先执行 <code>setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;)</code> ，这样才能正确地解析宽字符。</p>\n<h3 id=\"多字节字符函数\"><a href=\"#多字节字符函数\" class=\"headerlink\" title=\"多字节字符函数\"></a>多字节字符函数</h3><pre><code class=\"c\">#include &lt;stdlib.h&gt;\nint mblen(const char *s, size_t n);\nint mbtowc(wchar_t *pwc, const char *s, size_t n);\nint wctomb(char *s, wchar_t wc);</code></pre>\n<h3 id=\"多字节字符串函数\"><a href=\"#多字节字符串函数\" class=\"headerlink\" title=\"多字节字符串函数\"></a>多字节字符串函数</h3><pre><code class=\"c\">#include &lt;stdlib.h&gt;\nsize_t mbstowcs(wchar_t *dest, const char *src, size_t n);\nsize_t wcstombs(char *dest, const wchar_t *src, size_t n);</code></pre>\n<h2 id=\"三字符序列\"><a href=\"#三字符序列\" class=\"headerlink\" title=\"三字符序列\"></a>三字符序列</h2><p>见书本简要介绍。</p>\n<p>!!!note<br>    这就是一种字符替换方式，由于某些国家不支持C语言的标准的字符书写方式。# 其他库函数</p>\n<hr>\n<h2 id=\"stdarg-h-可变长度实参\"><a href=\"#stdarg-h-可变长度实参\" class=\"headerlink\" title=\"stdarg.h 可变长度实参\"></a>stdarg.h 可变长度实参</h2><pre><code class=\"c\">void va_start(va_list ap, last);\ntype va_arg(va_list ap, type);\nvoid va_end(va_list ap);</code></pre>\n<p>stdarg.h提供了一种工具可以让我们自行编写的函数具有可变长的参数列表（varying number of arguments of varying types）。stdarg.h定义了一种va_list类型和三种宏，名为va_start, va_arg, va_end, 可以把这些宏看成是带有上述原型的函数。</p>\n<p>书中使用了此例进行讲解：</p>\n<pre><code class=\"c\">int max_int(int n, ...)    // n must be at least 1\n{\n    va_list ap;\n    int i, current, largest;\n\n    va_start(ap, n);\n    largest = va_arg(ap, int);\n\n    for (i = 1; i &lt; n; ++i) {\n        current = va_arg(ap, int);\n        if (current &gt; largest)\n            largest = current;\n    }\n\n    va_end(ap);\n    return largest;\n}</code></pre>\n<p>函数的第一个实参n说明了跟随其后的其他参数的数量。</p>\n<p>形参列表中的…符号表示可变数量的参数。带有可变参数的函数必须至少有一个“正常的”形参，在最后一个正常的参数后边始终会有省略号出现在参数列表的末尾。</p>\n<p><code>va_list ap</code>声明了一个变量，使得函数可以访问到可变参数。</p>\n<p><code>va_start(ap, n)</code>指出了实参列表中可变长度开始的位置。</p>\n<p><code>va_arg(ap, int)</code>把获取当前的可变参数，然后自动前进到下一个可变参数处。int说明希望此参数是int类型的。</p>\n<p>函数返回前，使用语句<code>va_end(ap)</code>进行清扫。</p>\n<h3 id=\"调用带有可变实参列表的函数\"><a href=\"#调用带有可变实参列表的函数\" class=\"headerlink\" title=\"调用带有可变实参列表的函数\"></a>调用带有可变实参列表的函数</h3><p>调用带有可变实参列表的函数是一个固有的风险提议。</p>\n<p>这里主要的难点就是带有可变实参列表的函数很难确定传递过来的参数的数量或类型。所以必须把这个信息传递给函数，并且函数假设知道了这个信息。上述max_int函数依靠第一个实参来指明跟随其后的其他参数的数量，并且它还设定参数是int类型的。</p>\n<p>另一个问题就是不得不处理NULL作为参数的情况，具体见书本。</p>\n<h3 id=\"v…printf类函数\"><a href=\"#v…printf类函数\" class=\"headerlink\" title=\"v…printf类函数\"></a>v…printf类函数</h3><pre><code class=\"c\">int vprintf(const char *format, va_list ap);\nint vfprintf(FILE *stream, const char *format, va_list ap);\nint vsprintf(char *str, const char *format, va_list ap);</code></pre>\n<p>不同于printf等函数，v…printf类函数具有固定数量的实参，每个v…printf类函数的最后一个实参都是一个va_list型值。这个类型的值意味着此函数可以由带有可变实参列表的函数调用。</p>\n<p>实际上，v…printf类函数主要用于编写“包装”函数。包装函数接收可变数量的实参，并稍后把这些参数传递给v…printf类函数（通过va_list）。</p>\n<p>这种包装函数的核心内容是：</p>\n<ul>\n<li><p>va_start(ap, arg)</p>\n</li>\n<li><p>把ap传递给v…printf</p>\n</li>\n<li><p>va_end(ap)</p>\n</li>\n</ul>\n<h2 id=\"stdlib-h-通用的实用工具\"><a href=\"#stdlib-h-通用的实用工具\" class=\"headerlink\" title=\"stdlib.h 通用的实用工具\"></a>stdlib.h 通用的实用工具</h2><h3 id=\"字符串转换函数\"><a href=\"#字符串转换函数\" class=\"headerlink\" title=\"字符串转换函数\"></a>字符串转换函数</h3><pre><code class=\"c\">int atoi(const char *nptr);\nlong long atoll(const char *nptr);\n\nlong int strtol(const char *nptr, char **endptr, int base);\nlong long int strtoll(const char *nptr, char **endptr, int base);</code></pre>\n<h3 id=\"伪随机生成函数\"><a href=\"#伪随机生成函数\" class=\"headerlink\" title=\"伪随机生成函数\"></a>伪随机生成函数</h3><p>伪随机数的生成方法是：</p>\n<ul>\n<li><p>先设置一个随机种子（srand）</p>\n</li>\n<li><p>调用rand函数根据随机种子生成一个伪随机数</p>\n</li>\n</ul>\n<p>如果每次程序运行的随机种子都一样，那么rand出来的数就会一样。因此通常采用当前时间戳作为随机种子（但如果两次启动间隔不足一秒，时间戳也是一样滴）。</p>\n<pre><code class=\"c\">void srand(unsigned int seed);\nint rand(void);</code></pre>\n<h3 id=\"与环境的通信\"><a href=\"#与环境的通信\" class=\"headerlink\" title=\"与环境的通信\"></a>与环境的通信</h3><p>与外部通信的标准库函数可以：</p>\n<ul>\n<li><p>为操作系统返回一个程序结束的状态码</p>\n</li>\n<li><p>获取环境变量</p>\n</li>\n<li><p>执行操作系统的命令</p>\n</li>\n</ul>\n<p><strong>返回状态码</strong></p>\n<p>在main中执行return语句，即返回了一个状态码给操作系统；或者在程序的任意处执行exit函数，也可以终止程序并返回一个状态码给操作系统。</p>\n<p>exit是正常性质的结束程序，可以清理程序打开的资源。</p>\n<p>atexit函数还可以注册一个函数，在程序正常结束前，执行这个注册函数。可以注册多个atexit函数，调用顺序和注册顺序一致。</p>\n<pre><code class=\"c\">void exit(int status);\nint atexit(void (*function)(void));</code></pre>\n<p><strong>获取环境变量</strong></p>\n<p>环境变量是一组存放到静态存储区的字符串，描述了操作系统的环境，比如PATH。使用getenv就可以获取它的值。</p>\n<pre><code class=\"c\">char *getenv(const char *name);</code></pre>\n<p><strong>执行命令</strong></p>\n<p>主要是通过system函数执行一个外部的命令。system函数返回该命令的终止状态码。</p>\n<pre><code class=\"c\">int system(const char *command);</code></pre>\n<h3 id=\"搜索和排序工具\"><a href=\"#搜索和排序工具\" class=\"headerlink\" title=\"搜索和排序工具\"></a>搜索和排序工具</h3><p>用于搜索的工具是：bsearch（实现为二分查找），用于排序的工具是：qsort（实现为快速排序）。</p>\n<pre><code class=\"c\">void qsort(void *base, size_t nmemb, size_t size,\n                  int(*compar)(const void *, const void *));\n\nvoid *bsearch(const void *key, const void *base,\n                     size_t nmemb, size_t size,\n                     int (*compar)(const void *, const void *));</code></pre>\n<h3 id=\"整数算术运算函数\"><a href=\"#整数算术运算函数\" class=\"headerlink\" title=\"整数算术运算函数\"></a>整数算术运算函数</h3><p><strong>abs求绝对值</strong></p>\n<p>函数原型：</p>\n<pre><code class=\"c\">int abs(int j);</code></pre>\n<p><strong>div求除法运算结果</strong></p>\n<p>函数原型：</p>\n<pre><code class=\"c\">div_t div(int numerator, int denominator);</code></pre>\n<p>结果是第一个实参除以第二个实参。结果是一个div_t类型，它包含了商和余数，定义如下：</p>\n<pre><code class=\"c\">typedef struct\n{\n    int quot;    /* Quotient.  */\n    int rem;     /* Remainder. */\n} div_t;</code></pre>\n<p>但第二个实参一定不能为0，不然就会出现段错误。因此判断除数是否合法的责任就交给了程序员。</p>\n<h2 id=\"time-h-日期和时间\"><a href=\"#time-h-日期和时间\" class=\"headerlink\" title=\"time.h 日期和时间\"></a>time.h 日期和时间</h2><p>标准库提供了三种表示时间的类型：</p>\n<ol start=\"0\">\n<li><p>clock_t：按照“时钟滴答”进行测量的时间值</p>\n</li>\n<li><p>time_t：日历时间（时间戳），由于这个类型在不同平台下定义不同（unsigned int or long），因此输出的时候应当做一个强制转换。</p>\n</li>\n<li><p>struct tm：分解时间，一种适合人类理解的时间格式</p>\n</li>\n</ol>\n<p>clock_t和time_t是支持算术运算的，但是它们具体是整型还是浮点型并没有被C标准说明。但struct tm的类型定义很清楚：</p>\n<table>\n<thead>\n<tr>\n<th>成员</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tm_sec</td>\n<td>分后的秒，[0, 61]，允许两个额外的闰秒</td>\n</tr>\n<tr>\n<td>tm_min</td>\n<td>时后面的分，[0, 59]</td>\n</tr>\n<tr>\n<td>tm_hour</td>\n<td>午夜后的时，0到23</td>\n</tr>\n<tr>\n<td>tm_mday</td>\n<td>月份中的第几天，[1,31]</td>\n</tr>\n<tr>\n<td>tm_mon</td>\n<td>一月份以后的月，[0,11]</td>\n</tr>\n<tr>\n<td>tm_year</td>\n<td>从1900年开始的年</td>\n</tr>\n<tr>\n<td>tm_wday</td>\n<td>星期日以后的天，[0,6]</td>\n</tr>\n<tr>\n<td>tm_yday</td>\n<td>一月一日后的天，[0,365]</td>\n</tr>\n<tr>\n<td>tm_isdst</td>\n<td>夏令时标记，夏令时有效为正数，否则为0，如果未知，可为-1</td>\n</tr>\n</tbody></table>\n<p><strong>时钟滴答</strong></p>\n<pre><code class=\"c\">clock_t clock(void);</code></pre>\n<p>clock函数返回处理器的时间（时钟滴答），即程序开始运行到执行到此的消耗的时间。但它的单位不是秒，为了将它转换成秒，可以给它除以宏CLOCK_PER_SEC。</p>\n<p>clock_t不能表示日期，只是善于表示时间区间（两个clock_t相减获得比较精准的时间差）。</p>\n<pre><code class=\"c\">(clock() - start_clock) / (double)CLOCK_PER_SEC</code></pre>\n<p>加double强制转换的理由是，标准C没有指明宏CLOCK_PER_SEC的类型，也没有说明clock_t的类型，所以必须用强制转换明确一下类型。</p>\n<p><strong>日历时间</strong></p>\n<pre><code class=\"c\">time_t time(time_t *t);\ndouble difftime(time_t time1, time_t time0);</code></pre>\n<p>time用来获取时间戳（UNIX从1970年为纪元），difftime获取两个时间戳的间隔，但这种计算间隔的方式没有用clock_t计算精准。</p>\n<p><strong>分解时间</strong></p>\n<pre><code class=\"c\">time_t mktime(struct tm *tm);\nstruct tm *localtime(const time_t *timep);\nchar *asctime(const struct tm *tm);</code></pre>\n<ul>\n<li><p>mktime将分解时间转换成日历时间（时间戳）。但它有一个很好得到地方，除了转换成日历时间，它还会先修正分解时间，如果分解时间中的某些值不正确的话。修正的规则就是“进位”，把溢出的时间补给高位的时间。比如tm_mday超过了31，那么tm_mon就会增加至少1。可以利用这一个修正的规则来计算未来的日期。见代码案例。</p>\n</li>\n<li><p>localtime根据日历时间，获得本地的分解时间</p>\n</li>\n<li><p>asctime获取分解时间的字符串格式，末尾还会有一个换行符</p>\n</li>\n</ul>\n<p><strong>时间转换函数</strong></p>\n<p>有 ctime strftime 等。</p>\n"},{"title":"C++学习笔记","top":"ture","cover":false,"toc":true,"mathjax":true,"date":"2019-09-30T07:15:26.000Z","password":null,"summary":"学习一门新的程序设计语言的最好方法就是练习编写程序。","_content":"\n\n# 开始\n\n学习一门新的程序设计语言的最好方法就是练习编写程序。更多的内容可以查看我的github主页[C++课后习题集](https://github.com/HaoxinGuo/CPlusPlusPrimerProblemset)\n\n<img src=\"readme.jpg\" width=\"50%\" height=\"50%\" alt=\"习题集目录\">\n\n---\n\n## 编写一个简单的C++程序\n\n每个C++程序都包含一个或多个函数（function），其中一个必须命名为**main**。操作系统通过调用main来运行C++程序。\n\n下面是一个简单的main函数，它什么都不做，只是返回给操作系统一个值：\n\n```c++\nint main()\n{\n    return 0;\n}\n```\n\nmain函数的返回类型必须为int。int类型是一种**内置类型**（built-in type），即语言自身定义的类型。\n\n函数体是一个以左**花括号**（curly brace）开始，以右花括号结束的语句块（block of statements）。\n\nreturn语句结束函数的执行。main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。\n\n**重要概念：类型**\n\n一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。程序所处理的数据都保存在变量中，而每个变量都拥有自己的类型。\n\n### 编译、运行程序\n\n编写好程序后，我们就需要编译它，这依赖于操作系统和编译器。\n\n**程序源文件命名约定**\n\n程序文件通常被称为源文件（source file）。它以一个后缀为结尾，告诉系统这个文件是一个C++程序，比如.cpp。\n\n## 初识输入输出\n\nC++包含了一个全面的**标准库**（standard library）来提供IO机制（以及很多其他设施）。\n\n**iostream**库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。\n\n**标准输入输出对象**\n\n标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为**标准输入**（standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为**标准输出**（standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为**标准错误**（standard error）。clog用来输出程序运行时的一般性消息。\n\n系统通常将程序所运行的窗口与这些对象关联起来。因此，当读取cin，数据将从程序正在运行的窗口读入，当向cout写入数据时，将会写到同一个窗口。\n\n!!!note\n\tclog关联到标准错误，默认情况下，写到clog的数据是被缓冲的。写到cerr的数据是不缓冲的。\n\n**一个使用IO库的程序**\n\n```c++\n#include <iostream>\nint main()\n{\n        std::cout << \"Enter two numbers:\" << std::endl;\n        int v1 = 0, v2 = 0;\n        std::cin >> v1 >> v2;\n        std::cout << \"The sum of \" << v1 << \" and \" << v2 << \" is \"\n                  << v1 + v2 << std::endl;\n        return 0;\n}\n```\n\n`#include <iostream>`告诉编译器我们想要使用iostream库。尖括号中的名字指出了一个**头文件**（header）。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。#include指令一般出现在所有函数之外，源文件的开始位置。\n\n**向流写入数据**\n\n```c++\nstd::cout << \"Enter two numbers\" << std::endl;\n```\n\n这条语句执行了一个**表达式**（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了**输出运算符**（<<）。\n\n`<<`运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。\n\n\"Enter two numbers\"是一个**字符串字面值常量**（string literal），它是用一对双引号包围的字符序列。\n\nendl是一个被称为**操纵符**（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。\n\n!!!note\n\t一个表达式接一个分号就是一条语句。\n\n**使用标准库中的名字**\n\n前缀std::指出名字cout和endl是定义在名为**std**的**命名空间**（namespace）中的。\n\n命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。\n\n**从流读取数据**\n\n首先定义两个名为v1和v2的**变量**（variable）来保存输入：\n\n```c++\nint v1 = 0, v2 = 0;\n```\n\n这两个变量被定义为int类型，并**初始化**（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。\n\n```c++\nstd::cin >> v1 >> v2;\n```\n\n这条语句读入输入数据。**输入运算符**（>>）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。\n\n## 注释简介\n\n注释（comments）通常用于概述算法，确定变量的用途，或者解释晦涩难懂的代码段。编译器会忽略掉注释，因此注释对程序的行为和性能不会有任何影响。\n\n**C++中注释的种类**\n\nC++中有两种注释：单行注释和界定符注释。\n\n**注释界定符不能嵌套**\n\n界定符对形式的注释是以`/*`开始，以`*/`结束的。因此，一个注释不能嵌套在另一个注释之内。\n\n如果在调试期间要注释掉包含界定符对形式注释的代码，最好的方式是用单行注释方式注释掉代码段的每一行。\n\n```c++\n// /*\n//  * comments\n//  */\n```\n\n## 控制流\n\n语句一般是顺序执行的，语句块的第一条语句首先执行，然后是第二条，以此类推。但程序设计语言提供了多种不同的控制语句，允许我们写出更为复杂的执行路径。\n\n### while语句\n\nwhile语句反复执行一段代码，直到给定条件为假为止。\n\nwhile语句的形式为：\n\n```c++\nwhile (condition)\n    statement\n```\n\nwhile语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假时停止。所谓**条件**就是一个产生真或假的结果的表达式。\n\nstatement可以是语句块，也叫循环体。所谓语句块（block），就是用花括号包围的语句序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。\n\n### for语句\n\n每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。\n\n比如：\n\n```c++\nfor (int val = 1; val <= 10; ++val)\n    sum += val;\n```\n\nfor循环的总体执行流程：\n\n0. 创建变量val，将其初始化为1，它仅在循环内部存在。\n\n0. 检测val是否小于等于10。如果检测成功，执行循环体。若失败，退出循环。\n\n0. 将val的值增加1。\n\n0. 重复第二个步骤。\n\n### 读取数量不定的输入数据\n\n使用这样的方法连续读入数据，直到遇到文件尾（Linux下，输入CTRL+D）：\n\n```c++\nwhile (std::cin >> value)\n    statement\n```\n\n输入运算符返回其左侧对象，因此，此循环条件检测的是std::cin。\n\n当使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象的状态会变为无效。\n\n### if语句\n\nif也对一个条件求值，书本里有一个完整的例子。\n\n语法大致如此：\n\n```c++\nif (condition) {\n    statements\n} else {\n    statements\n}\n```\n\n## 类简介\n\n在C++中，通过定义一个**类**（class）来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。\n\n类似使用标准库设施，我们也需要使用头文件来自己的类。习惯上，头文件根据类名来命名，使用.h作为头文件的后缀。标准库的头文件通常不带后缀。\n\n### 初识成员函数\n\n**什么是成员函数？**\n\n有这样的检测条件：\n\n```c++\nitem1.isbn() == item2.isbn()\n```\n\n调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数。\n\n使用**点运算符（.）**来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。\n\n我们使用**调用运算符（()）**来调用一个函数，它是一对圆括号，里面放实参列表（可能为空）。# 第二章\n1. 'void*'\n是一种特殊的指针类，可以存放任意对象的地址。  \n2. const 对象必须初始化。 const int buf =10  \n3. const 指针，其值不能被改变，所有必须初始化。\n4. 顶层const和底层const，顶层const表示指针本身是一个常量，底层const表示指针所指对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。\n\n```\nint i = 0;\nint *const p1 = &i;    // 不能改变p1的值，p1是一个顶层const\nconst int ci = 42；    // 不能改变ci的值，ci是一个顶层const\nconst int *p2 = &ci;   // 允许改变p2的值，p2是一个底层const\nconst int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const\nconst int &r = ci;     // 用于声明引用的const都是底层const\n```\n\nC++新标准引入了第二种类型说明符**decltype**，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n\n```\ndecltype(f()) sum = x; // sum的类型就是函数f的返回类型\n```\n\n编译器并不实际调用f，而是使用当调用发生时f的返回值的类型作为sum的类型。\n\n如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n\n```\nconst int ci = 0, &cj = ci;\ndecltype(ci) x = 0; // x的类型是const int\ndecltype(cj) y = x; // y的类型是const int&, y绑定到x\n```\n\n**decltype和引用**\n\n如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式向decltype返回一个引用类型，一般来说，意味着该表达式的结果对象能作为一条赋值语句的左值：\n\n```\n// decltype的结果可以是引用类型\nint i = 42, *p = &i, &r = i;\ndecltype(r + 0) b; // 正确，加法的结果是int，因此b是一个int\ndecltype(*p) c; // 错误，c是int&，必须初始化\n```\n\n如果表达式的内容是解引用操作，则decltype将得到引用类型。\n\n有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：\n\n```\n// decltype的表达式如果是加上了括号的变量，结果是引用\ndecltype((i)) d; // 错误，d是int&，必须初始化\ndecltype(i) e; // 正确，e是一个int。\n```\n\n\n**auto 和decltype的区别主要有三个方面**：\n第一，auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。\n第二，编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。\n第三，与auto不同，decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。\n\n\n# 字符串、向量和数组\n\n## String\n1. **头文件不应包含using声明**  \n2. **初始化string对象的方式：**  \n```c++\nstring s1;           // 默认初始化，s1是一个空串\nstring s2(s1);       // s2是s1的副本\nstring s2 = s1;      // 等价于s2(s1)\nstring s3(\"value\");  // s3是字面值\"value\"的副本，不包括最后的空字符\nstring s3 = \"value\"; // 等价于s3(\"value\")\nstring s4(n, 'c');   // 初始化为由n个字符c组成的串\n```  \n3. **直接初始化和拷贝初始化**  \n\n如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化（copy initialization）**，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是**直接初始化**（direct initialization）。  \n```c++\nstring s5 = \"hiya\";  // 拷贝初始化\nstring s6(\"hiya\");   // 直接初始化\nstring s7(10, 'c');  // 直接初始化\n```  \n4. getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。  \n\n**string::size_type类型**  \n\nsize函数返回的是一个string::size_type类型的值。这是一个无符号的整数。  \n5. **处理每个字符？使用基于范围的for语句**  \n\n如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：**范围for**（range for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：  \n\n```c++\nfor (declaration : expression)\n    statement\n```  \n如：  \n```c++\nfor (auto c : str)\n    // do something\n```  \n**使用下标运算符**\n\n`[ ]`符号叫做下标运算符，范围是`[0, s.size())`，越界的结果是UB（undefined behavior，未定义行为）。  \n\n## Vector\n1. vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。  \n2. vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。  \n3. vector是模板而非类型，由vector生成的类型必须包含元素的类型，如：  \n```c++\nvector<int> v;\n```  \n4. **vector中存放的是对象，而引用不是对象，故不能存储引用。**  \n### 定义和初始化vector对象  \nvector模板控制着初始化向量的方法。定义vector对象的方法有：  \n- `vector<T> v1`，默认初始化，v1是一个空的vector  \n- `vector<T> v2(v1)`，v2中包含v1所有元素的副本  \n- `vector<T> v2 = v1`，等价于v2(v1)  \n- `vector<T> v3(n, val)`，v3包含了n个重复的元素，每个元素的值都是val  \n- `vector<T> v4(n)`，v4包含了n个执行了值初始化的对象  \n- `vector<T> v5{a,b,c...}`，v5里包含了用a,b,c...初始化的元素  \n- `vector<T> v5 = {a,b,c...}`，等价于`vector<T> v5{a,b,c...}`  \n**值初始化**  \n值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。\n`vector<T>(n)`中，所有元素将执行值初始化。\n### 向vector中添加元素\npush_back函数把一个元素压入vector对象的尾端。  \nvector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。  \n**一定不能在遍历vector的时候改变vector对象的大小。**  \nC++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。  \n### 其它vector操作\n如（很多和string类似）：\n- `v.empty()`，如果v不含有任何元素，返回true  \n- `v.size()`，返回v中的元素个数  \n- `v[n]`，返回v中第n个位置上元素的引用  \n- `v1 = v2`，v2中的元素将拷贝替换v1的  \n- `v1 = {a,b,c...}`，列表中的元素将拷贝替换v1中的  \n- `v1 == v2`, `v1 != v2`，元素数量相同，对应位置的元素也相等，则相等  \n- <,<=,>,>=，比首个相异元素的大小，如都一样，比长度，即字典顺序  \nsize返回的类型由vector定义的size_type类型。\n```c++\nvector<int>::size_type    // 正确\nvector::size_type         // 错误\n```  \n**只有当元素的值可比较时，vector对象才能被比较。只能对确已存在的元素执行下标操作。**  \n## 迭代器介绍\n使用迭代器（iterator）是一种通用的访问容器中元素的方法。\n迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。\n### 使用迭代器\n有迭代器的类型同时拥有返回迭代器的成员。  \n标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。  \nend成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫**尾后迭代器（off-the-end iterator）**。  \n如果容器为空，begin和end都返回尾后迭代器。即：`v.begin() == v.end()`  \n如：  \n```c++\nauto b = v.begin();\nauto e = v.end();\n```  \n**迭代器运算符**  \n标准容器迭代器的运算符：  \n- `*iter`，返回迭代器所指对象的引用（解引用）  \n- `iter->mem`，解引用iter，并获取其成员mem，等价于`(*iter).mem`  \n- `++iter`，令iter指示容器中的下一个元素  \n- `--iter`，令iter指示容器中的上一个元素  \n- `iter1 == iter2`，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等  \n迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。  \n**迭代器类型**  \n标准库类型使用iterator和const_iterator来表示迭代器类型。  \n如：\n```c++\nvector<int>::iterator it1;\nvector<int>::const_iterator it2;\n```  \nit1能读写元素，而it2只能读。  \n认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。  \n**begin和end运算符**begin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。  \n为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：  \n```c++\nauto it = v.cbegin();\n```  \n**箭头运算符**即`->`，它把解引用和成员访问两个操作结合在一起。即：`(*iter).mem`等价于`iter->mem`。  \n**某些对vector对象的操作会使迭代器失效**任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。\n### 迭代器运算  \n递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。  \nstring和vector的迭代器提供了额外的运算符，有：  \n- `iter + n`，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器  \n- `iter - n`，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器  \n- `iter1 - iter2`，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  \n- `>,>=,<,<=`，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置    \n**迭代器的算数运算**  \n迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。  \ndifference_type是一个带符号的整数，string和vector都定义了这个类型。  \n**迭代器相加没有意义**\n```c++\nauto mid = (beg) +(end-beg)/2;//正确\nauto mid =(beg+end)/2;//错误 迭代器加法不存在\n```  \nstring类本身接受无参数的初始化方式，无论数组定义在函数体内部还是外部都被默认初始化为空串，对于内置类型int，数组定义在函数体外部时默认初始化为0，在main函数内部时，将不被初始化。\n\n## 数组\n1. 数组是存放相同类型的对象的容器，这些对象是匿名的。  \n2. 数组的大小确定不变。  \n3. 数组是一种内置类型。  \n### 定义和初始化内置数组\n数组是一种复合类型，其声明形如`a[N]`  。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个**常量表达式**，即其值在编译期间已知。  \n默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。  \n定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。  \n**显式初始化数组元素**\n即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。如：  \n```c++\nint a1[10] = {0}; // 剩下的元素执行值初始化，即为0\nint a2[] = {1, 2, 3};\n```\n**字符数组的特殊性**可以用字符串字面值对此类数组进行初始化。如：  \n```c++\nchar s[] = \"hello\";\n```\n这样初始化的数组包含结尾的空字符。  \n**不允许拷贝和赋值**\n这样的操作是非法的：  \n```c++\nint a1[] = {1, 2, 3};\nint a2[] = a1; // 非法\n```\n**理解复杂的数组声明**  \n1. 定义一个指针数组\n```c++\nint* a[10] = {};\n```  \n2. 定义一个指向数组的指针：  \n```c++\nint (*ptr)[10] = &a;\n```  \n3. 定义一个绑定到数组的引用：  \n```c++\nint (&a_ref)[10] = a;\n```  \n默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。  \n### 访问数组元素  \n使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。可以使用范围for语句来遍历数组。  \n```c++\nfor (auto i : arr)\n    cout << i << \" \";\ncout << endl;\n```  \n**得到数组的大小**\n```\nsizeof(array/sizeof(array[0];\n```\n**检查下标的值**  \n与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。  \n### 指针和数组\n在很多用到数组名字的地方，编译器都会自动地将其替换为一个**指向数组首元素的指针**。  \n**decltype**\n下面得到一个数组类型：   \n```c++\nint a1[10] = {};\ndecltype(a1) a2;\n```  \n**auto**\n下面得到一个整型指针：\n```c++\nint a1[10] = {};\nauto a2(a1);\n```  \n**指针也是迭代器**  \nstring和vector的迭代器支持的运算，指针都支持。使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。这样可以获取数组尾元素的下一个位置的指针：\n```c++\nint *end = &a[N];\n```  \n不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：\n```c++\nint a[10] = {};\nint *beg_p = begin(a);\nint *end_p = end(a);\n```  \n这俩函数定义在头文件iterator.h中。尾后指针不能解引用和递增操作。和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。  \n**下标和指针**  \n对数组执行下标运算其实是对指向数组元素的指针执行下标运算：  \n```c++\nint i = ia[2];    // ia转换成指向数组首元素的指针\n                  // ia[2]得到(ia + 2)所指的元素\nint *p = ia;      // p指向ia的首元素\ni = *(p + 2);     // 等价于i = ia[2]\n```  \n只要指针指向的是数组中的元素，都可以执行下标运算。  \n内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。  \n### C风格字符串  \nC风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null terminated）。\np109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。  \n**c_str函数**\nstring可使用c_str函数返回其C风格的字符串，如：  \n```c++\nstring s(\"hello\");\nconst char *c_s = s.c_str();\n```\n无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方\n**使用数组初始化vector对象**如：  \n```c++\nint a[] = {1, 2, 3};\nvector<int> vec(begin(a), end(a));\n```  \n## 多维数组\n多维数组，实际上是数组的数组。\n如：`int a[3][4]`，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。\n对于二维数组，常把第一个维度看作行，第二个维度看作列。  \n**多维数组的初始化**如：  \n```c++\nint a[3][4] = {\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9, 10, 11}\n};\n```  \n列表初始化中未列出的元素执行值初始化。  \n**多维数组的下标引用**  \n如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组\n```c++\nint a[3][4] = {};\nint (&row)[4] = a[2]; // row绑定到a的第二个数组上\n```  \n**使用范围for语句处理多维数组**  \n如果是外层循环，控制变量将得到数组类型。\n除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。  \n**指针和多维数组**\n当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。  \n多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。  \n即：\n```c++\nint a[2][3] = {};\nint (*p)[3] = a;\n```  \n还可以使用auto或者begin来得到指向内层数组的指针。  \n**类型别名简化多维数组的指针**  \n可以这样定义一个数组类型：\n```c++\nusing int_arr = int[4]; // C++11\ntypedef int int_arr[4];\n```  \n**指针**  \n1. 指针本身的值（value）；\n2. 指针所指的对象（content）；\n3. 指针本身在内存中的储存位置（address）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 表达式\n1. `*iter.empty()`和`(*iter).empty()`和`iter->empty()`的区别  \n2. `somevalue ? ++x,++y:--x,--y;`等价于`(somevalue ? ++x,++y:--x),--y;`\n# 位运算符\n\n位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。\n|运算符|功能|用法|\n|-|-|-|\n|~|位求反|~expr|\n|<<|左移|expr1 << expr2|\n|>>|右移|expr1 >> expr2|\n|&|位与|expr1 & expr2|\n|^|位异或|expr1 ^ expr2|\n|\\||位或|expr1 \\| expr2|\n  \n一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。  \n强烈建议将位运算符用于处理无符号类型。  \n一个提升例子就是，如果对char做位运算，它会先被提升为int。  \n**移位运算符**\n<<和>>  \n运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。  \n左移运算符<<在右侧插入值为0的二进制位。右移运算符>>的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。  \n# sizeof运算符  \nsizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：  \n- sizeof(type)\n- sizeof?expr\n常量表达式意味着在编译期间就能得到计算。  \n第二种形式中，sizeof返回的是表达式结果类型的大小。  \nsizeof运算符的结果部分地依赖于其作用的类型：  \n- 对char或者类型为char的表达式执行sizeof运算，结果得1。\n- 对引用类型执行sizeof运算得到被引用对象所占空间大小。\n- 对指针执行sizeof运算得到指针本身所占空间的大小。\n- 对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。\n- 对数组执行sizeof运算得到整个数组所占空间大小。\n- 对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。\n# ?显式转换\n**命名的强制类型转换**  \n一个命名的强制类型转换有如下形式：  \ncast-name<type>(expression);  \n其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast,?dynamic_cast,?const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。  \n**static_cast**  \n任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。\n```\n//?进行强制类型转换以便执行浮点数除法\ndouble?slope?=?static_cast<double>(j)?/?i;\n```  \n当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。  \nstatic_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void\\*的指针中的值：  \n```\nvoid?*p?=?&d;????//?正确，任何非常量对象的地址都能存入void*\n\n//?正确，将void*转换回初始的指针类型\ndouble?*dp?=?static_cast<double*>(p);\n```  \n必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。  \n**const_cast**  \nconst_cast只能改变运算对象的底层const：  \n```\nconst?char?*pc;\nchar?*p?=?const_cast<char*>(pc);????//?正确，但是通过p写值是未定义的行为\n```  \n如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。  \nconst_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。  \n**reinterpret_cast**  \nreinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：  \n```\nint?*ip;\nchar?*pc?=?reinterpret_cast<char*>(ip);\n```  \n我们必须牢记pc所指的真实对象是一个int而非字符。  \n\treinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。  \n**旧式的强制类型转换**  \n在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：  \n```\ntype(expr);???//?函数形式的强制类型转换\n(type)expr;???//?C语言风格的强制类型转换\n```  \n根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast,?static_cast或reinterpret_cast相似的行为。  \n\t与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。# try语句块\ntry语句块的通用语法形式是：  \n```c++\ntry {\n    program-statements\n} catch (exception-declaration) {\n    handler-statements\n} // ...\n```  \n当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。  \ntry语句块内声明的变量在catch子句内无法访问。  \n一个简要的例子：  \n```c++\nwhile (cin >> item1 >> item2) {\n    try {\n        // ... 可能抛出一个异常的代码\n    } catch (runtime_error err) {\n        cout << err.what() << \"\\nTry Again? Enter y or n\" << endl;\n        char c;\n        cin >> c;\n        if (!cin || c == 'n')\n            break; // 跳出while循环\n    }\n}\n```  \n# throw表达式\n抛出异常的一个例子是：  \n```c++\nthrow runtime_error(\"Data must refer to same ISBN\");\n```  \n该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。  \n- **throw 表达式（throw expression）**，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw**引发（raise）**了异常。  \n- **try语句块（try block）**，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个**catch子句（catch clause）**结束。try语句块中代码抛出的异常通常会被某个catch子句处理。  \n- 一套**异常类（exception class）**，用于在throw表达式和相关的catch子句之间传递异常的具体信息。  \n# 简单语句\nC++语言中的大多数语句都以分号结束，一个表达式，比如ival+5，末尾加上分号就变成了**表达式语句**(expression statement)，表达式语句的作用是执行表达式并丢弃掉求值结果：\n```c++\nival + 5;    // 无意义的表达式语句\ncout << ival;// 有意义的表达式语句\n```  \n**空语句**  \n最简单的语句是**空语句**（null statement），它只有一个分号： \n```c++\n; // 空语句\n```  \n如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。  \n**复合语句（块）**  \n复合语句（compound statement）是指用花括号括起来的语句和声明的序列，复合语句也被称作**块**（block）。一个块就是一个作用域。  \n如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。  \n所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：  \n```c++\nwhile (cin >> s && s != sought)\n{}  // 空块\n```  \n# 语句作用域\n可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：  \n```c++\nwhile (int i = get_num()) // 每次迭代时创建并初始化\n    cout << i << endl;\ni = 0;    // 错误，在循环外部无法访问\n```  \n# 条件语句\nC++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流；另一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。  \n## if语句\nif语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。  \n## switch语句\nswitch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。  \n# 迭代语句\n迭代语句通常称之为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。  \n## while语句\n语法格式是：  \n```c++\nwhile (condition)\n    statement\n```  \n只要condition的求值结果为真就一直执行statement。如果condition第一次求值就是false，statement一次都不执行。  \nwhile的条件部分可以是一个表达式或者是一个带初始化的变量声明。  \n**使用while循环**  \n当不确定到底要迭代多少次时，使用while循环比较合适。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。  \n## 传统的for语句  \nfor语句的语法形式是  \n```c++\nfor (init-statement: condition; expression)\n    statement\n```\n## 范围for语句\nC++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。**范围for语句**（range for statement）的语法形式是：\n```c++\nfor (declaration : expression)\n    statement\n```\nexpression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。  \ndeclaration定义一个变量，序列中的每个元素都能转换成该变量的类型。  \n每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。  \n在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。因此不能通过范围for语句增加vector对象的元素。  \n## do while语句\ndo while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少会执行一次循环。do while语句的语法形式如下：  \n```c++\ndo\n    statement\nwhile (condition);\n```\n## 跳转语句  \n跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break, continue, goto和return。本章介绍前三种，return在第六章介绍（p199页）。  \n## break语句\nbreak语句负责终止离它最近的while, do while, for或switch语句，并从这些语句之后的第一条语句开始执行。\n## continue语句\ncontinue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for, while和do while循环的内部。  \n## goto语句  \ngoto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 函数 \n函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。  \n---\n## 函数基础  \n一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。  \n我们通过**调用运算符（call operator）**来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。  \n函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，**主调函数**（calling function）的执行暂时被中断，**被调函数**（called function）开始执行。  \n当遇到一条return语句时函数结束执行过程。函数的返回值用于初始化调用表达式的结果。  \n**函数返回类型**\n大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何类型。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。  \n### 局部对象\n在C++语言中，名字有作用域，对象有**生命周期（lifetime）**，理解这两个概念非常重要：  \n- 名字的作用域是程序文本的一部分，名字在其中可见。  \n- 对象的生命周期是程序执行过程中该对象存在的一段时间。  \n形参和函数体内部定义的变量统称为**局部变量（local variable）**。它们仅在函数的作用域内可见。  \n在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。  \n**自动对象**  \n对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为**自动对象（automatic object）**。  \n形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。  \n对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化（内置类型产生未定义的值）。  \n**局部静态对象（local static object）**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。例：  \n```c++\n// 统计函数被调用了多少次\nsize_t count_calls()\n{\n    static size_t ctr = 0; // 调用结束后，这个值仍然有效\n    return ++ctr;\n}\n```  \n### 函数声明\n函数的名字必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。  \n函数的声明和定义唯一的区别是**声明无须函数体**，用一个分号替代即可。  \n函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作**函数原型（function prototype）**。  \n**在头文件中进行函数声明**\n我们建议函数在头文件中声明，在源文件中定义。\n这是因为如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。\n定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。  \n### 分离式编译\nC++语言支持所谓的**分离式编译（separate compilation）**。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。  \n\n\n## 参数传递\n如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。  \n当形参是引用类型时，我们说它对应的实参被**引用传递**（passed by reference）或者函数被**传引用调用**（called by reference）。  \n当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被**值传递**（passed by value）或函数被**传值调用**（called by value）。  \n### 传值参数\n当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。  \n**指针形参**  \n当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。  \n\t熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。\n\n### 传引用参数\n对于引用的操作实际上是作用于引用所引的对象上，引用形参也是如此。通过使用引用形参，允许函数改变一个或多个实参的值。  \n**使用引用避免拷贝**  \n拷贝大的类类型对象或者容器对象比较低效。甚至有的类型根本就不支持拷贝操作。此时应该使用引用形参访问该类型的对象。  \n如果函数无须改变引用形参的值，最好将其声明为常量引用。  \n**使用引用形参返回额外信息**  \n一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。那就是通过引用形参并修改它（也就是修改了其引用的对象），从而作为结果传出。  \n### const形参和实参\n当形参是const时，必须注意关于顶层const的讨论（p57）。  \n当用实参初始化形参时会忽略形参的顶层const。即当形参有顶层const时，传递给它常量对象或者非常量对象都是可以的。  \n忽略形参的顶层const可能产生意想不到的结果：  \n```c++\nvoid fcn(const int i) {}\nvoid fcn(int i) {}    // 错误：重复定义\n```  \n在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表有明显的区别。因为顶层const被忽略了，所以在上面的代码中传入两个fcn函数的参数可以完全一样（从而编译器不知道该调用哪一个）。  \n**指针或引用形参与const**  \n我们可以使用非常量初始化一个底层const，但是反过来不行（不能用一个常量初始化一个非底层const）；同时一个普通的引用必须用同类型的对象初始化。  \n**尽量使用常量引用**  \n把函数不会改变的形参定义成（普通的）引用是一种常见错误，这么做给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型（比如无法传入一个常量对象了）。  \n比如下面这个例子将导致编译错误（p192）：\n```c++\n// 不良设计，第一个形参的类型应该是const string&\nstring::size_type find_char(string &s, char c, string::size_type &occurs);\n//...\nfind_char(\"Hello World\", 'o', ctr); // 无法编译通过\n```\n### 数组形参\n当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。  \n尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：  \n```c++\n// 每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);    // 可以看出来，函数的意图是作用于一个数组\nvoid print(const int[10]);  // 这里的维度表示我们期望数组含有多少元素，实际不一定\n```  \n\t和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。  \n因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技术。  \n1. 使用标记指定数组长度，如C风格字符串。  \n2. 使用标准库规范，如传递首元素和尾后元素的指针，来表示一个范围。  \n3. 显示传递一个表示数组大小的形参。  \n**数组形参和const**  \n当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。  \n**数组引用形参**  \nC++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。  \n```c++\n// 正确，形参是数组的引用，维度是类型的一部分\nvoid print(int (&arr)[10])\n{\n    for (auto elem : arr)\n        cout << elem << endl;\n}\n```  \n但这一用法也限制了print函数的可用性，我们只能将函数作用于大小为10的数组。  \n**传递多维数组**  \n和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，也就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：  \n```c++\n// matrix指向数组的首元素，该数组的元素是由10个整数构成的数组\nvoid print(int (*matrix)[10], int rowSize) { /* ... */ }\n```  \n\t`*matrix`两端的括号必不可少：`int *matrix[10]//10个指针构成的数组`；`int (*matrix)[10]//指向含有10个整数的数组的指针`。\n也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：  \n```c++\n// 等价定义\nvoid print(int matrix[][10], int rowSize) { /* ... */ }\n```  \nmatrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。  \n### main: 处理命令行选项\n有时候我们需要给main函数传递实参。一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如：  \n```c++\nprog -d -o ofile data0\n```\n这些命令行选项通过两个（可选的）形参传递给main函数。  \n```c++\nint main(int argc, char *argv[]) { ... }\n```  \n第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量；argc至少为1。  \n当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。  \n以上面的为例，argc应该等于5，argv应该包含如下的C风格字符串：  \n```c++\nargv[0] = \"prog\";    // 或者argv[0]也可以指向一个空字符串\nargv[1] = \"-d\";\nargv[2] = \"-o\";\nargv[3] = \"ofile\";\nargv[4] = \"data0\";\nargv[5] = 0;\n```  \n\t当使用argv中的实参时，一定要记得可选的实参从`argv[1]`开始；`argv[0]`保存程序的名字，而非用户的输入。\n### 含有可变形参的函数\n为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：\n1. 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；  \n2. 如果实参的类型不同，我们可以编写一种可变参数模板，其细节将在16.4节介绍（p618）。  \nC++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序。  \n**initializer_list形参**  \ninitializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。  \n与vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。  \n**省略符形参**  \n省略符形参是为了便于C++程序访问某些特殊的C代码而设置的。  \n\t省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。  \n省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：  \n```c++\nvoid foo(param_list, ...);\nvoid foo(...);\n```  \n## 返回类型和return语句\nreturn语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。  \nreturn语句有两种形式：  \n```c++\nreturn;\nreturn expression;\n```  \n### 无返回值函数\n没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。  \n### 有返回值函数  \n只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。  \n**值是如何被返回的**  \n返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。  \n如果函数返回引用，则该引用仅是它所引对象的一个别名。  \n**不要返回局部对象的引用或指针**  \n函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。  \n**返回类类型的函数和调用运算符**  \n调用运算符的优先级和点运算符、箭头运算符相同，并且符合左结合律。\n```c++\n//调用string对象的size成员，该string对象有shorterstring函数返回\nauto sz = shorterstring(s1,s2).size();\n```\n**引用返回左值**  \n函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。  \n```c++\nchar &get_val(string &str,string::size_type ix){\n\treturn str[ix];\n}\nint main(){\n\tstring s(\"a value\");\n\tcout<<s<<endl;\n\tget_val(s,0)='A';\n\tcout<<s<<endl;\n\treturn 0;\t\n}\n```\n**列表初始化返回值**  \nC++11新标准规定，函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。  \n**主函数main的返回值**  \n我们允许main函数没有return语句直接结束，这样编译器将隐式地插入一条返回0的return语句，表示执行成功。  \n为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，可以用来表示成功与失败：  \n```c++\nint main()\n{\n    if (some_failure)\n        return EXIT_FAILURE;\n    else\n        return EXIT_SUCCESS;\n}\n```  \n**递归**\n如果函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为**递归函数**（recursive function）。  \n在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。  \n\tmain函数不能调用它自己。  \n### 返回数组指针\n因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。使用**类型别名**（p60）可以简化这种返回类型：  \n```c++\ntypedef int arrT[10];    // arrT是一个类型别名，表示含有10个整数的数组\nusing arrT = int[10];    // arrT的等价声明\narrT* func(int i);       // func返回一个指向含有10个整数的数组的指针\n```  \n**声明一个返回数组指针的函数**  \n返回数组指针的函数形式如下：  \n```c++\nType (*function(param_list))[dimension]\n```\n类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（\\*表示返回的是一个指针。）例：  \n```c++\nint (*func(int i))[10];\n```  \n可以按照以下的顺序来逐层理解该声明的含义：  \n- `func(int i)`表示调用func函数时需要一个int类型的实参。  \n- `(*func(int i))`意味着我们可以对函数的调用结果执行解引用操作。  \n- `(*func(int i))[10]`表示解引用func的调用将得到一个大小是10的数组。  \n- `int (*func(int i))[10]`表示数组中的元素是int类型。  \n**使用尾置返回类型**  \nC++新标准提供了另一种简化上述func声明的方法，就是使用**尾置返回类型（trailing return type）**。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。  \n尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个`auto`：  \n```c++\n// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -> int(*)[10];\n```  \n**使用decltype**  \n如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型（即获得一个数组类型）。例：  \n```c++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *arrPtr(int i)\n{\n    return (i % 2) ? &odd : &even;\n}\n```  \n\t decltype并不负责把数组类型转换成对应的指针，所以decltype的结果只是一个数组，要想表示arrptr返回指针还必须在函数声明时加一个`*`的符号。\n## 函数重载\n如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载（overload）函数**。比如：  \n```c++\nvoid print(const char *cp);\nvoid print(const int *beg, const int *end);\nvoid print(const int ia[], size_t size);\n```  \n这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。  \n函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。  \nmain函数不能重载。  \n不允许两个函数除了返回类型以外其他所有的要素都相同。比如：  \n```c++\nRecord lookup(const Account&);\nbool lookup(const Account&);    // 错误，与上一个函数相比只有返回类型不同\n```  \n\t my note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。  \n**重载和const形参**  \n顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：  \n```c++\nRecord lookup(Phone);\nRecord lookup(const Phone);    // 重复声明\n```  \n如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：  \n```c++\nRecord lookup(Account&);       // 此函数作用于Account的引用\nRecord lookup(const Account&); // 新函数，作用于常量引用\n```  \n这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。  \n**const_cast和重载**  \nconst_cast在重载函数的情境中最有用。比如这两个重载函数：  \n```c++\n// 比较两个string对象的长度，返回较短的那个引用\nconst string &shorterString(const string &s1, const string &s2)\n{\n    return s1.size() <= s2.size() ? s1 : s2; \n}\n\n// 重载\nstring &shorterString(string &s1, string &s2)\n{\n    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));\n    return const_cast<string&>(r);\n}\n```\n下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const&，这显然是安全的。  \n\t传入非常量的实参将调用非常量的版本。  \n**调用重载的函数**  \n定义了一组重载函数后，我们需要以合理的实参调用它们。**函数匹配（function matching）**是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。  \n当调用重载函数时有三种可能的结果：  \n- 编译器找到一个与实参**最佳匹配（best match）**的函数，并生成调用该函数的代码。\n- 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配（no match）**的错误信息。\n- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用（ambiguous call）**。\n### 重载与作用域  \n一般来说，将函数声明置于局部作用域内不是一个明智的选择。  \n如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。  \n## 特殊用途语言特性\n### 默认实参\n这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的**默认实参**（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：  \n```c++\ntypedef string::size_type sz;\nstring screen(sz ht = 24, sz wid = 80, char backrnd = ' ');\n```\n一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。  \n**使用默认实参调用函数**  \n如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：  \n```c++\nstring window;\nwindow = screen();    // 等价于screen(24, 80, ' ');\nwindow = stcreen(66); // 等价于screen(66, 80, ' ');\n```  \n函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。  \n当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。  \n**默认实参初始值**  \n局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。  \n如：\n```c++\nint g_a = 0;\nvoid f(int a = g_a);\n```  \n### 内联函数和constexpr函数\n调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。  \n**内联函数可以避免函数调用的开销**  \n将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。  \n内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。  \n内联机制用于优化规模小，流程直接，频繁调用的函数。  \n**constexpr函数**  \n是指能用于**常量表达式**的函数。  \n函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。如：  \n```c++\nconstexpr int new_sz() { return 8; }\nconstexpr int foo = new_sz();\n```\nconstexpr函数被隐式地指定为内联函数。  \n**把内联函数和constexpr函数放在头文件内**  \n这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。  \n### 调试帮助\n程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。  \n**assert预处理宏**  \nassert是一种**预处理宏（preprocessor macro）**。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：  \n```c++\nassert(expr);\n```\n首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。  \nassert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无需提供using声明。  \nassert宏常用于检查“不能发生”的条件。\n**NDEBUG预处理变量**  \nassert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。  \n我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：  \n```c++\n$ CC -D NDEBUG main.c\n```  \n这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。  \n我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。  \n除了用于assert，也可以使用NDEBUG编写自己的调试代码。  \n比如：  \n```c++\nvoid print(const int ia[], size_t size)\n{\n#ifndef NDEBUG\n    // __func__是编译器定义的一个局部静态变量，用于存放函数的名字\n    cerr << __func__ << \"\": array size is: \" << size << endl;\n#endif\n\n// ...\n}\n```  \n编译器为每个函数都定义了`__func__`，除此之外，预处理器还定义了4个对于调试程序很有用的名字：  \n- `__FILE__`, 存放文件名的字符串字面值。  \n- `__LINE__`, 存放当前行号的整型字面值。  \n- `__TIME__`, 存放文件编译时间的字符串字面值。  \n- `__DATA__`, 存放文件编译日期的字符串字面值。  \n## 函数匹配\n以下述这组函数及其调用为例,讲述编译器如何确定调用哪个重载函数:  \n```c++\nvoid f();\nvoid f(int);\nvoid f(int, int);\nvoid f(double, double = 3.14);\nf(5.6);    // 调用void f(double, double);\n```  \n**确定候选函数和可行函数**  \n函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为**候选函数（candidate function）**。候选函数具备两个特征：  \n1. 与被调用函数同名。  \n2. 其声明在调用点可见。  \n第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数（viable function）**。可行函数也有两个特征：  \n1. 其形参数量与本次调用提供的实参数量相等。  \n2. 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。\n\t如果没有找到可行函数，编译器将报告无匹配函数的错误。\n**寻找最佳匹配（如果有的话）**  \n第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。  \n如果有且只有一个函数满足下列条件，则匹配成功：  \n- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。  \n- 至少有一个实参的匹配优于其他可行函数提供的匹配。  \n\t如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。  \n### 实参类型转换\n为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：  \n1. 精确匹配，包括以下情况：  \n- 实参类型和形参类型相同。  \n- 实参从数组类型或函数类型转换成对应的指针类型。  \n- 向实参添加顶层const或者从实参中删除顶层const。  \n2. 通过const转换实现的匹配（p143）。  \n3. 通过类型提升实现的匹配（p142）。  \n4. 通过算数类型转换或指针转换实现的匹配（p142）。  \n5. 通过类类型转换实现的匹配（参见14.9节，p514）。\n**需要类型提升和算术类型转换的匹配**  \n**函数匹配和const实参**  \n```c++\nint calc(char*,char*)\nint calc(const char*,const char*)\n//区别是他们的指针类型的形参是否指向了常量，属于底层const，合法定义\n```\n```c++\nint calc(char*,char*)\nint calc(char* const,char* const)\n//区别是他们的指针类型的形参是否是常量，属于顶层const,非法定义\n```\n## 函数指针\n函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：   \n```c++\nbool lengthCompare(const string&, const string&);\n```  \n该函数的类型是：`bool (const string&, const string&);`  \n要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：  \n```c++\nbool (*pf)(const string&, const string&);\n```  \n**使用函数指针**  \n当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。  \n例如，可以这样给把函数地址赋值给指针：  \n```c++\npf = lengthCompare; // pf指向名为lengthCompare的函数\npf = &lengthCompare; // 等价的赋值语句，取地址符是可选的\n```  \n可以直接对指向函数的指针调用该函数，无须解引用指针：  \n```\nbool b1 = pf(\"Hello\", \"Hi\");\nbool b2 = (*pf)(\"Hello\", \"Hi\"); // 等价调用\nbool b3 = lengthCompare(\"Hello\", \"Hi\"); // 等价调用\n```  \n可以给函数指针赋一个nullptr或0，表示没有指向任何函数。  \n**重载函数的指针**  \n当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。  \n**函数指针形参**  \n不能定义函数类型的形参，但是形参可以是指向函数的指针。  \n当把函数名作为实参使用，它会自动转换成指针。  \n定义一个函数（以及指针）类型的方法有：  \n- typedef  \n```c++\ntypedef bool Func(int); // Func是函数类型\ntypedef bool (*FuncP)(int); // FuncP是函数指针类型\n```  \n- decltype  \n假如已经有了一个函数：`bool Foo(int);`  \n```c++\ndecltype(Foo) Func;\ndecltype(Foo) *FuncP;\n```\n- using  \n```c++\nusing Func = bool(int);\nusing FuncP = bool(*)(int);\n```  \n**返回指针函数的指针**\n和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名：  \n```c++\nusing F=int(int*，int)；//F是函数类型，不是指针\nusing PF=int(*)(int*，int)；//PF是指针类型\n```\n其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针：  \n```\nPF f1(int);//正确：PF是指向函数的指针，f1返回指向函数的指针\nF f1(int);//错误：F是函数类型，f1不能返回一个函数\nF *f1(int);//正确：显式地指定返回类型是指向函数的指针\n```\n\t出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式(参见6.3.3节，第206页)声明一个返回函数指针的函数：\n```c++\nauto fl(int)->int(*)(int*，int);\n```\n**将auto和decltype用于函数指针类型**  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 类\n\n类的基本思想是**数据抽象**(data abstraction)和**封装**(encapsulation)。\n\n数据抽象就是**接口(interface)与实现(implementation)分离**的技术。\n\n接口就是暴露给用户的操作，比如公有的成员函数。\n\n实现就是数据成员、接口的实现、私有的成员函数。\n\n通过**抽象数据类型(abstract data type)**，来实现数据抽象和封装。\n\n## 定义抽象数据类型\n\n封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。\n\n**定义成员函数**\n\n类内的所有成员必须声明在类的内部。\n\n类的成员函数可以定义在类的内部，也可以定义在类的外部。\n\n\t定义在类内部的函数是隐式的inline函数。\n\n**引入this**\n\n当调用一个成员函数时，实际上是替某个对象调用它。\n\n成员函数通过名为**this**的隐式参数来访问此对象。this指向了此对象的地址。\n\n在成员函数内部，可以省略this来访问成员。\n\nthis是一个常量指针，不能够修改其值。\n\n当成员函数中调用另一个成员函数时，将隐式传递this指针。\n\n```\nstd::string isbn() const {return this->bookNo;}\n```\n\n**引入const成员函数**\n\n参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。\n\nconst对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。\n\nC++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。\n\n\t常量对象，以及常量对象的引用或指针都只能调用常量成员函数。\n\n**类作用域和成员函数**\n\n类本身就是一个作用域。\n\n成员函数的定义必须包含其所属的类名（使用作用域运算符）。\n\n如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。\n\n成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。\n\n**定义一个返回this对象的函数**\n\n可以使用如下语句返回this对象：\n\n```c++\nreturn *this;\n```\n\n返回类型使用引用类型，表明返回的就是this所指的对象。\n\n一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。\n\n### 定义类相关的非成员函数\n\n有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。\n\n可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。\n\n有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。\n\n### 构造函数\n\n类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫**构造函数（constructor）**。\n\n每当类对象被创建，构造函数就会被执行。\n\n构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。\n\n对于const对象，构造函数执行完毕后，它才获得const属性。\n\n**合成的默认构造函数**\n\n如果对象没有初始值，它将执行默认初始化。\n\n类通过**默认构造函数(default constructor)**来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。\n\n合成的默认构造函数根据如下规则初始化类成员：\n\n- 如果存在类内初始值，使用它来初始化成员\n\n- 否则，对成员执行默认初始化\n\n**某些类不能依赖合成的默认构造函数**\n\n所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：\n\n- 如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。\n\n- 默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。\n\n- 有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。\n\n**=default的含义**\n\nC++11中，使用这种语句来让编译器生成一个默认构造函数：\n\n```c++\nSalesData() = default;\n```\n\n\t这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。\n\n**构造函数初始值列表**\n\n```c++\nSales_data(const std::string &s):\n\t\t\t\t\t\tbookNo(s){}\nSales_data(const std::string &s,unsigned n,double p):\n\t\t\t\t\t\tbookNo(s),units_sold(n),revenue(p*n){}\n```\n参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。\n\n它负责为对象的成员变量赋初值。\n\n如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。\n\n\t构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。\n**在类的外部定义构造函数**\n```c++\nSales data:：Sales data（std:：istream&is）\n{\nread（is，*this）；//read函数的作用是从is中读取一条交易信息然后\n\t\t//存入this对象中\n}\n```\n为了更好地理解调用函数 read的意义，要特别注意read的第二个参数是一个Sales data对象的引用。在7.1.2节（第232页）中曾经提到过，使用this来把对象当成一个整体访问，而非直接访问对象的某个成员。因此在此例中，我们使用*this将\n“this”对象作为实参传递给read函数。\n\n### 拷贝、赋值和析构\n\n拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。\n\n赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。\n\n析构函数，当一个变量不在存在时，会执行析构。\n\n这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。\n\n**某些类不能依赖合成的版本**\n\n如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。\n\n可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。\n\n## 访问控制与封装\n\n使用**访问说明符（access specifiers）**加强类的封装性。\n\n- public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。\n\n- private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。\n\n**class和struct**\n\n其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。\n\n\t作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。\n\n### 友元\n\n类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。即在函数或类前面加friend关键字。\n\n友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。\n\n一般来说，最好在类定义的开始或结束前的位置集中声明友元。\n\n\"封装的益处\"\n\t封装有两个重要的优点：\n\n\t- 确保用户代码不会无意间破坏封装对象的状态。\n\n\t- 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。\n\n## 类的其它特性\n\n### 类成员再探\n\n**定义一个类型成员**\n\n可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。\n\n通常放在类的开头位置。\n\n**令成员作为内联函数**\n\n规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。\n\n如果定义在类内的函数，默认就是inline的。\n\ninline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。\n\n**重载成员函数**\n\n和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。\n\n如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。\n\n**类数据成员的初始值**\n\n可以给类数据成员一个类内初始值。使用等号或者花括号。\n\n### 返回\\*this的成员函数\n\n返回引用的函数是左值的，意味着这些函数（返回\\*this）返回的是对象本身而非对象的副本。\n\n\t一个const成员函数如果以引用的形式返回\\*this，那么它的返回类型将是常量引用。\n\n但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是**重载一个非常量版本的接口**，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。\n\n建议：对于公共代码使用私有功能函数。\n\n### 类类型\n\n每个类是一个唯一的类型，即使其内容完全一样。\n\n**类的声明**\n\n可以暂时声明类而不定义它，这叫前置声明（forward declaration）。\n\n这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：\n\n- 定义指向这种类型的指针or引用\n\n- 声明以不完全类型为参数or返回值的函数\n\n要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。\n\n只有被定义，才能访问其成员。\n\n声明一个前置类型的方法：\n\n```c++\nclass A;\nstruct B;\nnamespace game\n{\n    class C;    // 前置声明一个在命名空间中的类\n}\n```\n\n### 友元再探\n\n类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。\n\n友元类有权访问本类的非公有成员。\n\n\n## 类的作用域\n\n一个类就是一个作用域。\n\n类的作用域之外，普通的成员只能通过对象、引用or指针访问。对于类型成员的访问，需要使用域运算符`::`来访问。\n\n### 名字查找与类的作用域\n\n编译器处理完类的全部声明后，才会处理成员函数的定义。因此成员函数体中可以使用类中定义的任何位置的名字。\n\n**成员函数中的名字查找**\n\n按如下方式解析：\n\n- 在块内查找声明\n\n- 在类内查找，所有成员都可以被考虑\n\n- 在类的外围作用域中查找\n\n## 构造函数再探\n\n### 构造函数初始值列表\n\n如果没有在构造函数的初始值列表中显示初始化成员，那么该成员将执行默认初始化。\n\n\t如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。\n```c++\nclass ConstRef{\npublic:\n\tConstRef(int ii);\nprivate:\n\tint i;\n\tconst int ci;\n\tint &i;\n};\nConstRef::ConstRef(int ii){\n\ti = ii;// 正确\n\tci = ii; //错误，不能给const赋值\n\tri = i; //错误：ri未被初始化\n}\n//正确形式\nConstRef::ConstRef(int ii)::i(ii),ci(ii),ri(i){}\n```\n\n**成员初始化的顺序**\n\n成员的初始化顺序和它们在类内的定义顺序一致。\n\n而非其在初始值列表中的顺序，初始值列表只是做了初始化的工作。所以要让初始值列表中的成员顺序与定义顺序一致。\n\n\t最好使构造函数初始值的顺序与成员声明的顺序一致，尽量避免用某些成员初始化其他成员。\n\t\n**有默认实参的构造函数**\n\n如果构造函数的所有实参都有默认实参，那么它实际上也同时定义了默认构造函数。\n\n### 委托构造函数\n\nC++11可以定义委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。\n\n当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。\n\n\t 即先执行受委托的构造函数内容，再执行自己的。\n\n### 默认构造函数的作用\n\n当对象被默认初始化或值初始化时，自动执行默认构造函数。\n\n默认构造函数在以下情况发生：\n\n- 不使用初始值定义一个非静态变量或者数组时\n\n- 当类含有类类型的成员且使用合成的默认构造函数时\n\n- 当类类型的成员没有在构造函数初始值列表中显式初始化时\n\n值初始化在以下情况下发生：\n\n- 数组初始化时，若提供的初始值少于数组大小时\n\n- 不使用初始值定义一个局部静态变量时\n\n- 书写形如T()的表达式显式请求值初始化时\n\n### 隐式的类类型转换\n\n如果构造函数只接受一个实参，则它实际上定义了**转换构造函数（converting constructor）**。\n\n即定义了一个隐式转换机制。如string的接受一个const char\\*版本的构造函数。\n\n使用explicit阻止这种隐式转换机制，explicit只能放到类内声明构造函数里。\n\n**只允许一步类类型转换**\n\n### 聚合类\n\n聚合类（aggregate class）使得用户可以直接访问其成员。当类满足如下条件时，是聚合的：\n\n- 所有成员都是public的\n\n- 没有定义任何构造函数\n\n- 没有类内初始值\n\n- 没有基类，没有virtual函数\n\n可以使用花括号括起来的成员初始值列表来初始化聚合类对象。\n\n### 字面值常量类（ Literal Classes）\n\n类也可以是字面值类型。\n\n这样的类可以含有constexpr函数成员，且符合constexpr函数的所有要求，且是隐式const的。\n\n数据成员都是字面值类型的聚合类是字面值常量类。\n\n如果不是聚合类，满足如下条件也是一个字面值常量类：\n\n- 数据成员都是字面值类型\n\n- 至少含有一个constexpr构造函数\n\n- 如果数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；类类型成员必须使用自己的constexpr构造函数\n\n- 类必须使用析构函数的默认定义\n\n**声明静态成员**\n\n在声明前加static关键字。\n\n静态成员可以是public或private。数据成员可以是常量，引用，指针，类类型等。\n\n对象不包含与静态数据成员有关的数据。\n\n静态函数不包含this指针。\n\n**使用类的静态成员**\n\n使用作用域运算符访问静态成员。\n\n类的对象、引用或指针可以访问静态成员。\n\n类的成员函数可以直接访问静态成员。\n\n**定义静态成员**\n\nstatic只能出现在类的内部，不能出现在外部。\n\n静态数据成员不属于类的对象，不是有构造函数初始化的。静态数据成员定义在函数体之外，一旦定义，就一直存在于程序的整个生命周期中。\n\n```c++\ndouble T::a = 1; // 定义并初始化一个静态成员\n```\n\n**静态成员的类内初始化**\n\n通常，不应该在类内初始化静态数据成员。\n\n不过，可以为静态成员提供const整数类型的类内初始值，且要求静态成员必须是字面值常量类型。\n\n\n# IO库\n\n## IO类\n为了支持不同种类的IO处理操作，标准库定义了这几种类型：\n\n- iostream 定义了用于读写流的基本类型\n\n- fstream 定义了读写命名文件的类型\n\n- sstream 定义了读写内存string对象的类型\n\n它们分别定义在同名的头文件中。\n\n**IO类型间的关系**\n\n类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。\n\n### IO对象无拷贝或赋值\n\n由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。\n\n读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。\n\n### 条件状态\nIO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。\n一个IO错误的例子：\n\n```c++\nint ival;\ncin >> ival;\n```\n\n如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。\n\n如果输入一个文件结束符标识，cin也会进入错误状态。\n\n一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：\n\n```c++\nwhile (cin >> word)\n    // ok\n```\n### 管理输出缓冲\n每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：\n\n```c++\nos << \"please enter a value: \";\n```\n\n文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。\n\n导致缓冲区刷新的原因有：\n\n- 程序正常结束\n\n- 缓冲区满时\n\n- 使用操纵符，如endl，来显式刷新缓冲区\n\n- 读cin或写cerr，都会导致cout的缓冲区被刷新\n\n**刷新输出缓冲区**\n\nIO库还提供了两个操纵符用于刷新缓冲区：\n\n- flush 刷新缓冲区，但不输出任何额外字符\n\n- ends 向缓冲区插入一个空字符，然后刷新缓冲区\n\n**unitbuf操纵符**\n\n如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。\n\n```c++\ncout << unitbuf;    // 所有输出操作后都会立即刷新缓冲区\ncout << nounitbuf;  // 回到正常的缓冲方式\n```\n\t如果程序崩溃，输出缓冲区不会刷新\n\n## 文件输入输出\n\n除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。\n\n### 使用文件流对象\n\n当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。\n\n每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。\n\n创建文件流对象时，如果提供了一个文件名，则open会被自动调用：\n\n```c++\nifstream in(file);    // 构造一个ifstream并打开给定的文件\nofstream out;         // 输出文件流未关联到任何文件\n```\n\t当一个fstream对象被销毁时，close会自动被调用。\n\n### 文件模式\n\n每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。\n\n每个文件流类型都定义了一个默认的文件模式，当未指定文件模式时，就使用此默认模式。\n\n- 与ifstream关联的文件默认以in模式打开；\n\n- 与ofstream关联的文件默认以out模式打开；\n\n- 与fstream关联的文件默认以in和out模式打开。\n\n**以out模式打开文件会丢失已有数据**\n\n默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。\n\n阻止丢弃的方法是同时指定app模式：\n\n```c++\nofstream out(\"file1\");    // 文件被截断\nofstream app(\"file2\", ofstream::app);    // 保留文件内容，写操作在文件末尾进行\n```\n\n## string流\n\nsstream头文件定义了三个类型来支持内存IO：\n\n- istringstream从string读取数据。\n\n- ostringstream向string写入数据。\n\n- stringstream既可以从string读数据，也可以向string写数据。\n\nsstream增加了一些成员来管理与流相关联的string。见p287。\n\n### 使用istringstream\n\n当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。\n\n### 使用ostringstream\n\n当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。\n# 顺序容器\n\n## 顺序容器概述\n\n所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：\n\n-. 向容器添加或从容器中删除元素的代价\n\n-. 非顺序访问容器中元素的代价\n\n顺序容器有：vector, deque, list, forward_list, array, string。\n\nstring和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在其中间添加或删除元素就会非常耗时，因为这需要移动插入或删除位置之后的所有元素。而且，添加元素可能导致分配额外的存储空间，这种情况下，每个元素都会移动到新的存储空间中。\n\nlist和forward_list两个容器添加和删除操作都很快速。作为代价，它们不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。与vector、deque和array相比，这两个容器的额外内存开销也很大。\n\ndeque支持快速随机访问，在deque的中间位置插入或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的。\n\nforward_1ist和array是新C++标准增加的类型。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list 没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size保证是一个快速的常量时间的操作。\n\n**确定使用哪种容器**\n\n\t通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。\n\n## 容器库概览\n\n**对容器可以保存的元素类型的限制**\n\n顺序容器几乎可以保存任意类型的元素。\n\n### 迭代器\n\n迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。比如解引用操作。\n\n表3.6（96页）列出了容器迭代器支持的所有操作。表3.7（99页）列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array。\n\n**迭代器范围**\n\n迭代器范围由一对迭代器表示，通常被称为begin和end，它们标记了容器中元素的一个范围。这个范围被称为左闭合区间：`[begin, end)`\n\n**使用左闭合区间蕴含的编程假定**\n\n假定begin和end构成一个合法的迭代器范围，则：\n\n- 如果begin与end相等，则范围为空\n\n- 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素\n\n- 我们可以对begin递增若干次，使得begin == end\n\n### 容器定义和初始化\n\n每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以指定容器大小和元素初始值的参数。\n\n**将一个容器初始化为另一个容器的拷贝**\n\n方法有两种：\n\n- 直接拷贝整个容器，两个容器的类型和元素的类型都必须匹配。\n\n- 拷贝一个迭代器范围，容器类型不一定匹配，且元素类型只要能够转换即可。\n\n```c++\n//每个容器有三个元素，用给定的初始化器进行初始化\nlist<string> authors={\"Milton\"，\"Shakespeare\"，\"Austen\"};\nvector<const char*> articles={\"a\"，\"an\"，\"the\"};\n1ist<string>1ist2(authors);//正确：类型匹配\ndeque<string>authList(authors);//错误：容器类型不匹配\nvector<string>words(articles);//错误：容器类型必须匹配\n//正确：可以将const char*元素转换为\nstring forward_list<string> words(articles.begin()，articles.end());\n```\n\n**列表初始化**\n\n```c++\nlist<const char *> articles = {\"a\",\"an\",\"the\"};\n```\n\n**标准库array具有固定大小**\n\n为了使用array类型，我们必须同时指定元素类型和大小，\n\n```c++\narray<int,10>::size_type i;//数组类型包括元素类型和大小；\n```\n\n### 赋值和swap\n\n赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝。\n\n```c++\nc1 = c2;\nca = {a,b,c};\n```\n与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型：\n\n```c++\narray<int，10>al={0，1，2，3，4，5，6，7，8，9};\narray<int，10>a2={0};//所有元素值均为0\nal=a2;//替换a1中的元素\na2={0};//错误：不能将一个花括号列表赋予数组\n```\n**由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持asign，也不允许用花括号包围的值列表进行赋值。**\n\n**使用assign(仅顺序容器)**\n\n\n赋值运算要求两边容器类型和元素类型相同。顺序容器（除了array）还定义了一个名为assign的成员，允许从一个相容的序列中赋值。\n\n**使用swap**\n\n调用swap操作后，两个容器中的元素将会交换。\n\n除了array，交换两个容器的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构。\n\n### 容器大小操作\n\n每个容器都支持这些大小相关的操作：\n\n- 成员函数size，返回容器中元素的数目，forward_list不支持；\n\n- empty，当size为0时返回true，否则返回false；\n\n- max_size，返回一个大于或等于该容器所能容纳的最大元素数的值，这是一个很大的值。\n\n### 关系运算符\n\n每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（>, >=, <, <=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。\n\n比较两个容器实际上是进行元素的逐对比较。\n\n\t只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符比较两个容器。\n\n## 顺序容器操作\n\n顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加及删除。\n\n### 向顺序容器添加元素\n\n标准库容器提供了灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。表9.5，p305。\n\n```c++\n这些操作会改变容器的大小；array不支持这些操作。\nforward_list有自己专有版本的insert和emplace；参见9.3.4节（第312页）。\nforward_1ist不支持 push_back和emplace_back。\nvector和string不支持push front和emplace front。\nc. push back(t);\nc. emplace back(args);\nc. push_front(t);\nc. emplace_front(args);\nc. insert(p,t);\nc. emplace(p, args);\nc. insert(p,n,t)c. insert(p,b,e);\nc. insert(p, il);\n```\n\n\t向一个deque、string或vector插入元素会使所有指向容器的迭代器、引用和指针失效。\n\n\t将元素插入到deque、string或vector中的任何位置都是合法的。然而，这样做可能很耗时。\n\n**关键概念：容器元素是拷贝**\n\n当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝。\n\n### 访问元素\n\n表9.6（p310）列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。\n\n**访问成员函数返回的是引用**\n\n在容器中访问元素的成员函数(即，front、back、下标和at)返回的都是引用。\n\n如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：\n\n```c++\nif(！c.empty()){\nC.front()=42;//将42赋予c中的第一个元素\nauto&v=c.back();//获得指向最后一个元素的引用\nv=1024;//改变c中的元素\nauto v2=c.back();//v2不是一个引用，它是c.back()的一个拷贝\nv2=0;//未改变c中的元素\n```\n\n**下标操作和安全的随机访问**\n\n提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。保证下标合法是程序员的责任，编译器不检查越界错误。\n\n如果想确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，如果下标越界，at会抛出一个out_of_range异常。\n\n### 删除元素\n\n\t删除deque中除首尾之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。\n\n\t删除元素之前，程序员必须确保它们是存在的。\n\n```c++\n这些操作会改变容器的大小，所以不适用于array。\nforward list 有特殊版本的erase，参见9.3.4节（第312页）。\nforward_list 不支持 popback；vector和string不支持pop_front。\nc.pop_back()\nc.pop_front()\nc.erase(p)\nc.erase(b,e)\nc.clear()\n```\n\n### 改变容器大小\n可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。\n\nresize接受一个可选的元素指参数，用来初始化新添加的元素。如果未提供，新元素进行值初始化。\n\n```c++\nc.resize(n);\nc.resize(n,t);\n```\n### 容器操作可能使迭代器失效\n\n使用失效的迭代器、引用、或指针是一种严重的错误。\n\n向容器添加元素后：\n\n- 如果容器是vector或string，且存储空间被重新分配，那么所有的迭代器都会失效。如果空间未重新分配，指向插入位置之前的元素的迭代器仍有效，但之后的迭代器会失效。\n\n- 对于list和forward_list，指向容器的迭代器仍有效。\n\n当从容器中删除元素后：\n\n- 对于list和forward_list，指向容器其他位置的迭代器仍有效。\n\n- 对于string和vector，被删除元素之前的元素的迭代器仍有效。\n\n## vector对象是如何增长的\n\n**管理容量的成员函数**\n\n```c++\n//shrink to_fit 只适用于vector、string 和deque。\n//capacity和 reserve 只适用于vector和string。\nc.shrink_to_fit();//请将 capacity()减少为与size()相同大小\nc.capacity();//不重新分配内存空间的话，c可以保存多少元素\nC.reserve(n);//分配至少能容纳n个元素的内存空间\n```\n\n## 额外的 string 操作\n\n除了顺序容器共同的操作之外， string 类型还提供了一些额外的操作。\n\n### 构造 string 的其他方法\n\n使用下面这些方法可以构造 string ：\n\n以下 n, len2, pos2 都是无符号值。\n\n|方法|说明|\n|-|-|\n|string s(cp, n)|s是cp指向的数组中前n个字符的拷贝|\n|string s(s2, pos2)|s是 string s2 从下标 pos2 开始的字符拷贝|\n|string s(s2, pos2, len2)|s是 string s2 从下标 pos2 开始 len2 个字符的拷贝，不管 len2 的值是多少，构造函数至多拷贝 s2.size() - pos2 个字符|\n**substr 操作**\n\nsubstr 返回一个 string ，它是原始 string 的一部分或全部的拷贝。\n\n`s.substr(pos, n)` 返回一个 string ，包含s中从pos开始的n个字符的拷贝。pos默认为0,n默认为 s.size() - pos ，即拷贝从 pos 开始的所有字符。\n\n### 改变 string 的其他方法\n\nstring 类型支持顺序容器的赋值运算符以及 assign, insert, erase 操作。除此之外，它还定义了额外的 insert 和 erase 版本。即使用下标的版本。\n\n```c++\ns.insert(s.size(),5,\"!\");//在s末尾插入五个！\n```\n\n这些函数都拥有许多重载的版本。\n\nassign 版本还接受C风格字符串：**需要以空格结尾**\n\nappend 和 replace 是额外的成员函数， append 在 string 末尾进行插入操作， replace 替换内容，它是调用 erase 和 insert 的一种简写形式：\n\n```c++\nstring s(\"C++ Primer 4th Ed.\");\n//从位置11开始，删除三个字符并插入Fifth;\ns.replace(11,3,\"Fifth)\n```\n\n### string 搜索操作\nstring 提供了6个搜索函数，它们都有4个重载版本。它们都返回一个 string::size_type 的值作为匹配位置（下标）。如果搜索失败，返回 string::npos ，其值为 -1 。\n\n可以给函数一个搜索的起始位置 pos ，它默认值是0：\n`auto pos = s.find_first_of(numbers, pos);`\n\n```c++\nstring name(\"guohaoxin01236578\");\nauto pos1 = name.find(\"guo\");//pos1==0返回字符串guo第一次出现的位置\nnumbers = \"0123456789\";\nauto pos2 = name.find_first_of(numbers);//寻找numbers字符串中任意字符出现的位置，find_first_not_of\n```\n\n**指定从哪里开始搜索**\n\n```c++\nstring size_type pos = 0;\nwhile((pos=name.find_first_of(numbers,pos))!=string::npos){\n\tcout<<\"found number at index:\"<<pos<<\" element is \"<<name[pos]<<endl;\n\t++pos;//移动到下一字符\n}\n```\n\n### compare 函数\n\n这是字符串比较函数，和C标准库的 strcmp 很相似。\n\n### 数值转换\n\n标准库提供了数值转换的函数。\n\n```c++\nto_string(val)\nstoi/l/ul/ll/ull/f/d/ld//转换成int、double、float\n```\n\n如果 string 不能转换成一个数值，那么会抛出一个 invalid_argument 的异常。如果转换得到的数值无法用任何类型来表示，则抛出一个 out_of_range 异常。\n\n## 容器适配器\n\n三个容器适配器：stack(栈适配器),queue,priority_queue(队列适配器)。\n\n**定义一个适配器**\n\nstack<int> stk;\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 泛型算法\n\n标准库并未给每个容器都定义成员函数来实现一些特殊的操作，如查找元素、替换或删除元素、重排元素等。而是定义了一组泛型算法。它们实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型，包括内置的数组类型。\n\n\n---\n## 概述\n\n大多数算法定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。\n\n\n通常，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。\n\n\n算法不依赖于容器，但依赖于元素类型的操作。比如，find用元素类型的==运算符完成序列中的元素与给定值的比较。大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符（即使用谓词）。\n\n**迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。**\n\n## 初识泛型算法\n\n附录A按照操作方式列出了所有的算法。\n\n除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。\n\n理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。\n\n### 只读算法\n\n一些算法只会读取其输入范围内的元素，而从不改变元素。比如find、accumulate。\n\n```c++\nint sum = accumulate(vec.cbegin(),vec.cend(),0);//求和，和的初值为0；\nstring sum =accumulate(v.cbegin(),v.cend(),string(\"\"));//string定义了字符串的“+”法，\n//错误，const char *上没有定义+运算符\nstring sum =accumulate(v.cbegin(),v.cend(),\"\");\n```\n**操作两个序列的算法**\n\n举一个列子：equal算法，它比较两个序列中的元素。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：\n\n```c++\n// roster2中的元素数目应该至少与roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());\n```\n这样的算法基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。\n\n### 写容器元素的算法\n\n一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入元素数目（note：如容器大小足够）。\n\n这样的算法比如fill。\n\n**介绍back_inserter**\n\n一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器**（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。\n\n**拷贝算法**\n\n拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。\n\n我们可以用copy实现内置数组的拷贝，如下面代码所示：\n\n```c++\nint al[]={0，1，2，3，4，5，6，7，8，9};\nint a2[sizeof(a1)/sizeof(*al)];//a2与al大小一样\n//ret指向拷贝到a2的尾元素之后的位置\nauto ret=copy(begin(a1)，end(al)，a2);//把a1的内容拷贝给a2\n```\ncopy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。\n\n### 重排元素的算法\n\n某些算法会重排容器中元素的顺序，比如sort，它利用元素类型的<运算符来实现排序。\n\n## 定义操作\n\n很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或==运算符完成比较。标准库为这些算法定义了额外的版本，允许我们提供自己定义的操作来替代默认运算符。\n\n### 向算法传递函数\n\nsort接受第三个参数，此参数是一个谓词（predicate）。\n\n**谓词**\n\n谓词是一个可调用的表达式，其调用结果是一个能用作条件的值。标准库算法使用的谓词分为两类：\n\n- 一元谓词，意味着它们只接受单一参数\n\n- 二元谓词，意味着它们有两个参数\n\n接受谓词的算法对输入序列中的元素调用谓词。\n\n### lambda表达式\n\n我们传递给算法的谓词必须严格接受一个或两个参数，但是有时我们希望进行的操作需要更多的参数，超出了算法对谓词的限制。\n\n**介绍lambda**\n\n我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。\n\n一个lambda表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。\n\n一个lambda表达式具有如下形式：\n\n```c++\n[capture list](parameter list) -> return type { function body }\n```\n\n其中，capture list是一个lambda所在函数中定义的局部变量的列表。\n\n可以忽略返回类型，这时会自动推断返回类型。\n\n```c++\nauto func = [](){ return 42; };\n```\n\n### lambda捕获和返回\n\n当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。类似地，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。\n\n默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。\n\n变量捕获的方式可以是值或引用。值捕获是变量的拷贝，引用捕获是变量的引用。\n\n\t当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。\n\n**建议：**\n\n尽量保持lambda的变量捕获简单化。如果可能的话，应该避免捕获指针或引用。见p351。\n\n**隐式捕获**\n\n可以让编译器根据lambda体中的代码来推断要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。\n\n如：\n\n```c++\n// sz为隐式捕获，值捕获方式\nwc = find_if(words.begin(), words.end(),\n             [=](const string &s) { return s.size() >= sz; } );\n```\n\n详见lambda捕获列表，p352。\n\n**可变lambda**\n\n默认情况下，对于一个值拷贝的变量，lambda不会改变其值。如果希望改变，必须在参数列表后加上关键字mutable。\n\n```c++\nvoid fcn3()\n{\n    size_t v1 = 42;\n    // f可以改变它捕获的变量的值\n    auto f = [v1]() mutable { return ++v1; };\n    v1 = 0;\n    auto j = f(); // j为43\n}\n```\n\n### 参数绑定\n\n对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。\n\n如果lambda的捕获列表为空，通常可以用函数来代替它。但如果捕获列表不为空就不能直接代替了。\n\n**标准库bind函数**\n\n为了解决这个问题，可以使用一个新的名为bind的标准库函数，它定义在头文件functional中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。\n\n```c++\nauto newCallable = bind(callable, arg_list);\n```\n\nnewCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。\n\narg_list中的参数可能包含形如`_n`的名字，这些参数是“占位符”，表示newCallable的参数。比如：`_1`为newCallable的第一个参数，`_2`为第二个参数。\n\n**使用placeholders名字**\n\n名字`_n`都定义在一个名为placeholders的命名空间中，这个命名空间本身定义在std命名空间中。\n\n一种简单的using语句是：\n\n```c++\nusing namespace namespace_name;\n```\n\n这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。如：\n\n```c++\nusing namespace std::placeholders;\n```\n\n这使得placeholders定义的所有名字都可用。\n\n## 再探迭代器\n\n除了每个容器的迭代器，标准库在头文件iterator中还定义了额外几种迭代器。\n\n- 插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。\n\n- 流迭代器：这些迭代器被绑定到输入或输出流上，可以来遍历所关联的IO流。\n\n- 反向迭代器：这些迭代器向后而不是向前移动。\n\n- 移动迭代器：不拷贝其中的元素，而是移动它们。将在13.6.2节（p480页）介绍。\n\n### 插入迭代器\n\n插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。\n\n```c++\nit = t; // 在it指定的当前位置插入值t。\n```\n\n插入迭代器有三种类型，差异在于元素插入的位置：\n\n- back_inserter，创建一个使用push_back的迭代器。\n\n- front_inserter，创建一个使用push_front的迭代器。\n\n- inserter，创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。\n\n```c++\nlist<int> lst = {1,2,3,4};\nliat<int>lst2,lst3;//空的list\n//copy 完成后lst2包含4 3 2 1\ncopy(lst.begin(),lst.end(),front_inserter(lst2));\n//opy 完成后lst3包含1 2 3 4\ncopy(lst.begin(),lst.end(),inserter(lst3,lst3.begin()));\n```\n### iostream迭代器\n\nistream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。\n\n通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。\n\n详细操作见p359。\n\n### 反向迭代器\n\n反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。\n\n可以通过rbegin, rend, crbegin, crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。\n\n## 泛型算法结构\n\n任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别。\n\n\n|迭代器|要求|\n|-|-|\n|输入迭代器|只读，不写；单遍扫描，只能递增|\n|输出迭代器|只写，不读；单遍扫描，只能递增|\n|前向迭代器|可读写；多遍扫描，只能递增|\n|双向迭代器|可读写；多遍扫描，可递增递减|\n|随机访问迭代器|可读写，多遍扫描，支持全部迭代器运算|\n\n### 5类迭代器\n\n类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。\n\n如ostream_iterator只支持递增、解引用和赋值。vector、string、deque的迭代器除了这些操作，还支持递减、关系和算术运算。\n\n除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。\n\n### 算法的形参模式\n大多数算法具有如下4种形式之一：\n\n```c++\nalg(beg, end, other args);\nalg(beg, end, dest, other args);\nalg(beg, end, beg2, other args);\nalg(beg, end, beg2, end2, other args);\n```\n\n其中，alg是算法名字，beg和end表述输入范围。几乎所有算法都有一个输入范围。\n\n**接受单个目标迭代器的算法**\n\ndest参数是一个表示算法可以写入目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。\n\n一般dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因为保证空间是足够的。\n\n**接受第二个输入序列的算法**\n\n接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围。\n\n接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。\n\n### 算法命名规范\n\n除了参数规范，算法还遵循一套命名和重载规范。\n\n**一些算法使用重载形式传递一个谓词**\n\n函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外的谓词参数，来代替<或==：\n\n```c++\nunique(beg, end);\nunique(beg, end, comp);\n```\n\n**\\_if版本的算法**\n\n接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的\\_if前缀：\n\n```c++\nfind(beg, end, val);\nfind_if(beg, end, pred);\n```\n**区分拷贝元素的版本和不拷贝的版本**\n\n默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。\n\n```\nreverse(beg, end);\nreverse_copy(beg, end, dest);\n```\n## 特定容器的算法\n\n链表类型list定义了几个成员函数形式的算法。通用版本的sort要求随机访问迭代器，因此不能用于list。\n\n链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。\n\n这些算法见p369。\n\n**链表特有的操作会改变容器**\n\n多数链表特有的算法与通用版本的很相似，但不完全相同，其中一个至关重要的区别是链表版本的会修改底层的容器。例如， remove 的链表版本会删除指定的元素， unique 的链表版本会删除第二个和后继的重复元素。\n\n\t对于通用版本的，如 std::remove ，不会删除容器的元素。它只会迁移元素。之后需要调用 erase 才能执行确切的删除动作。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 关联容器\n\n关联容器与顺序容器有着根本的不同：\n\n- 关联容器中的元素是按关键字来保存和访问的。\n\n- 顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。\n\n关联容器支持高效的关键字查找和访问，有两个主要的关联容器：\n\n- map，其元素是一些关键字-值对，关键字起到索引作用，值则表示与之相关的数据。\n\n- set，每个元素只包含一个关键字。\n\n标准库提供8个关联容器，如表11.1所示。这8个容器间的不同体现在三个维度上：每个容器  \n1. 或者是一个set，或者是一个map；\n2. 或者要求不重复的关键字，或者允许重复关键字；\n3. 按顺序保存元素，或无序保存。\n\n允许重复关键字的容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头。因此一个unordered multi set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。\n\n\n## 使用关联容器\n\nmap是关键字-值对的集合，通常被称为**关联数组**。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。与之相对，set就是关键字的简单集合。\n```\n//统计每个单词在输入中出现的次数\nmap<string,size_t) word_count;\nstring word;\nwhile(cin>>word)\n\t++word_count[word];\nfor(const auto &a:word_count)\n//打印结果\n\tcout<<a.first<<\"occurs\"<<w.second<<((w.second>1)?\"times\":\"time\"<<endl;\n```\n**使用set**  \n可以使用set忽略我们想要忽略的单词，例如：\n```c++\n\t// 统计每个单词在输入中出现的次数\n\tmap<string, size_t> word_count;\t// string到size_t的空map\n\tset<string> exclude = {\"The\", \"the\", \"And\", \"and\"};\n\n\tstring word;\n\twhile (cin >> word) {\n\t\t// 只统计不在exclude中的单词\n\t\tif (exclude.find(word) == exclude.end())\n\t\t\t++word_count[word];\t// 提取word的计数器并将其加1\n\t}\n\t\n\tfor (const auto &w : word_count) // 对map中的每个元素\n\t\t// 打印结果\n\t\tcout << w.first << \" occurs time: \" << w.second << endl;\n```\n\n## 关联容器概述\n\n关联容器（有序的和无序的）都支持9.2节（第294页）中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front。\n\n除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作（见p388）和类型别名（见p381）。\n\n关联容器的迭代器都是双向的。\n\n### 定义关联容器\n\n```c++\nmap<string, size_t> word_count; // 空容器\nset<string> exclude = {\"the\", \"but\", \"and\"}; // 列表初始化\n\n// 三个元素；authors将姓映射为名\nmap<string, string> authors = {\n    {\"Joyce\", \"James\"},\n    {\"Austen\", \"Jane\"},\n    {\"Dickens\", \"Charles\"}\n};\n```\n\n**初始化multimap或multiset**\n\n一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。\n\nmultimap和multiset没有此限制，它们都允许多个元素具有相同的关键字（这些元素会相邻存储）。\n\n### 关键字类型的要求\n\n对于有序容器，关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。\n\n**使用关键字类型的比较函数**\n\n用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型（比如一个函数指针类型）。\n\n```c++\nbool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)\n{\n    return lhs.isbn() < rhs.isbn();\n}\n\nmultiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);\n```\n\n### pair类型\n\npair类型定义在头文件utility中。\n\n一个pair保存两个数据成员，pair是一个用来生成特定类型的模板。\n\n```c++\npair<string, string> anon; // 保存两个string\npair<string, vector<int>> line; // 保存string和vector<int>\n```\n\npair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：\n\n```c++\npair<string, string> author{\"James\", \"Joyce\"};\n```\n\npair的数据成员是public的，两个成员分别是first，second。\n\n**创建pair对象的函数**\n\n```c++\npair<string, int>\nprocess(vector<string> &v)\n{\n    // 处理v\n    if (!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair<string, int>(); // 隐式构造返回值\n}\n```\n\n## 关联容器操作\n\n除了表9.2(第295页)中列出的类型，关联容器还定义了这些类型：\n\n- key_type, 此容器类型的关键字类型\n\n- mapped_type, 每个关键字关联的类型，只适用于map\n\n- value_type, 对于set，与key_type相同，对于map, 为`pair<const key_type, mapped_type>`\n\n### 关联容器迭代器\n\n当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型。\n\n\t必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。\n\n**set的迭代器是const的**\n\n与不能改名map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。\n\n**遍历关联容器**\n\nmap和set类型都支持begin和end操作，我们可以利用这些函数获取迭代器，然后用迭代器来遍历容器。\n\n```c++\nauto map_it = word_count.cbegin();\nwhile (map_it != word_count.cend()) {\n    // ...\n    ++map_it; // 递增迭代器，移动到下一个元素\n}\n```\n\n!!!note\n\t当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。\n\n**关联容器和算法**\n\n我们通常不对关联容器使用泛型算法。更多讨论见书本p383。\n\n### 添加元素\n\n关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。\n\n**向map添加元素**\n\n对一个map进行insert操作时，必须记住元素类型是pair。\n\n```c++\nword_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair<string, size_t>(word, 1));\nword_count.insert(map<string, size_t>::value_type(word, 1));\nword_count. insert(map<string, size_t>:: value_type(word,1));\n```\n\n**检测insert的返回值**\n\ninsert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。**pair的first成员是一个迭代器**，指向具有给定关键字的元素；second成员是一个boo1值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的boo1部分为false。如果关键字不存在，元素被插入容器中，且boo1值为true。\n\n**展开递增语句**\n\n```c++\n++ret.first->second;\n`++((ret.first)->second)`//等价的表达式\n```\n\n-. ret保存insert返回的值，是一个pair。\n-. ret.first是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素。\n-. ret.first->解引用此迭代器，提取map中的元素，元素也是一个pair。\n-. ret.first->second map中元素的值部分。\n-. ++ret.first->second 递增此值。\n\n\n**向multiset或multimap添加元素**\n\n由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：\n\n```c++\nmultimap<string, string> authors;\n// 插入第一个元素\nauthors.insert({\"Barth, John\", \"Sot-Weed Factor\"});\n// 正确，添加第二个元素\nauthors.insert({\"Barth, John\"}, \"Lost in the Funhouse\");\n```\n\n对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。\n\n### 删除元素\n\n关联容器定义了三个版本的erase：\n\n- 与顺序容器一样，传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围。\n\n- 接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。\n\n对于保存不重复关键字的容器，erase的返回值总是0或1。\n\n对允许重复关键词的容器，删除的元素的数量可能大于1。\n\n### map的下标操作\n\nmap和unordered_map容器提供了下标运算符和一个对应的at函数。\n\nset类型不支持下标操作，不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。\n\nmap下标运算符接受一个索引获取与此关键字相关联的值，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。\n\n**使用下标操作的返回值**\n\n当对一个map进行下标操作时，会获得一个mapped_type对象。\n\n当解引用一个map迭代器时，会得到一个value_type对象。\n\n!!!note\n\t与vector与string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。\n\n### 访问元素\n\n如果我们关心的只不过是一个特定元素是否已在容器中，使用find比较好。\n\n对于不允许重复关键字的容器，可能使用find还是count没什么区别。\n\n`c.find(k)`返回一个迭代器,`c.count(k)`返回关键词等于k的元素的数量。\n\n对于允许重复关键字的容器，count会统计有多少个元素有相同的关键字。\n```c++\nc.count(k);\nc.lower_bound(k);//返回一个迭代器，指向第一个关键词不小于k的元素\nc.upper_bound(k);//返回一个迭代器，指向第一个关键词大于k的元素\nc.equal_bound(k);//返回一个迭代器pair\n```\n\n## 无序容器\n\n无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。\n\n在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。\n# 动态内存\n\n\n我们的程序到目前为止只使用过静态内存或栈内存。\n\n- 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。\n\n- 栈内存用来保存定义在函数内的非static对象。\n\n分配在静态或栈内存中的对象由编译器自动创建和销毁。\n\n- 对于栈对象，仅在其定义的程序块运行时才存在。\n\n- static对象在使用之前分配，在程序结束时销毁。\n\n除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。\n\n动态对象的生存周期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。\n\n\n## 动态内存与智能指针\n\nC++中，动态内存的管理是通过一对运算符来完成的：\n\n- new，在动态内存中为对象分配空间并返回一个指向该对象的指针。\n\n- delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。\n\n为了更容易（同时也更安全）地使用动态内存，新的标准提供了两种智能指针（smart pointer）类型来管理动态对象。\n\n智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：\n\n- shared_ptr允许多个指针指向同一个对象；\n\n- unique_ptr则“独占”所指向的对象。\n\n- 标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。\n\n这些类型定义在memory头文件中。\n\n### shared_ptr类\n\n智能指针也是模板，当创建一个智能指针时，必须提供指向的类型：\n\n```c++\nshared_ptr<string> p1; // shared_ptr, 可以指向string\n```\n\n默认初始化的智能指针中保存着一个空指针。\n\n解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：\n\n```c++\nif (p1) *p1 = \"hi\";\n```\n\n\n**make_shared函数**\n\n最安全的分配和使用动态内存的方法是调用标准库函数make_shared。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。\n\n```c++\n// 指向一个值为42的int的shared_ptr\nshared_ptr<int> p3 = make_shared<int>(42);\n\n// p6指向一个动态分配的空vector<string>\nauto p6 = make_shared<vector<string>>();\n```\n\n类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。\n\n**shared_ptr的拷贝和赋值**\n\n每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：\n\n```c++\nauto p = make_shared<int>(42); // p指向的对象只有p一个引用者\nauto q(p); // p和q指向相同的对象，此对象有两个引用者\n```\n\n可以认为每个shared_ptr都有一个关联的计数器，通常称其为**引用计数**(reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。\n\n一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。\n\n!!!note\n\t到底是由一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。\n\n**使用了动态生存期的资源的类**\n\n程序使用动态内存出于以下三种原因之一：\n\n1. 程序不知道自己需要多少对象\n\n2. 程序不知道所需对象的准确类型\n\n3. 程序需要在多个对象间共享数据\n\n容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因的例子。本章介绍出于第三种原因的例子。\n\n### 直接管理内存\n\nC++提供了new运算符分配内存，delete运算符释放new分配的内存。\n\n相对于智能指针，使用这两个运算符管理内存非常容易出错。\n\n**使用new动态分配和初始化对象**\n\n在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：\n\n```c++\nint *pi = new int; // pi指向一个动态分配的、未初始化的无名对象\n```\n\n默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型将使用默认构造函数进行初始化。\n\n可以使用直接初始化方式来初始化一个动态分配的对象：\n\n```c++\nint *pi = new int(1024);\n\nvector<int> *pv = new vector<int>{1, 2, 3};\n```\n\n**动态分配的const对象**\n\n用new分配const对象是合法的：\n\n```c++\nconst int *pci = new const int(1024);\n```\n\n类似其他任何const对象，一个动态分配的const对象必须进行初始化。\n\n**内存耗尽**\n\n一旦一个程序用光了它所有可用的内存，new表达式就会失败（并返回一个空指针）。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。\n\n我们可以改变使用new的方式来阻止它抛出异常：\n\n```c++\n// 如果分配失败，new返回一个空指针\nint *p1 = new int; // 如果分配失败，new抛出std::bad_alloc\nint *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针\n```\n\n**释放动态内存**\n\n为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。\n\n```c++\ndelete p; // p必须指向一个动态分配的对象或是一个空指针\n```\n\n**指针值和delete**\n释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。\n\n\n```c++\nint i，*pil=&i，*pi2=nullptr;\ndouble*pd = new double(33)，*pd2=pd;\ndelete i；//错误：i不是一个指针\ndelete pi1；//未定义；pi1指向一个局部变量\ndelete pd；//正确\ndelete pd2；//未定义：pd2指向的内存已经被释放了\ndelete pi2；//正确：释放一个空指针总是没有错误的\n```\n\n**动态对象的生存期直到被释放时为止**\n\n如12.1.1节（第402页）所述，由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个由内置指针管理的动态对象，直到被显式释放之前它都是存在的。\n\n返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担—调用者必须记得释放内存：\n\n```c++\n//factory返回一个指针，指向一个动态分配的对象\nFoo* factory(T arg){\n\t//视情况处理arg\n\treturn new Foo(arg);//调用者负责释放此内存\n}\n\n```\n\n\n\t使用new和delete管理动态内存存在三个常见问题：\n\t1.忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。\n\t2.使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。\n\t3.同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。相对于查找和修正这些错误来说，制造出这些错误要简单得多。\n\n\n### shared_ptr和new结合使用\n\n如果不初始化一个智能指针，它就会被初始化为一个空指针。还可以用new返回的指针来初始化智能指针：\n\n```c++\nshared_ptr<int> p2(new int(42)); // p2指向一个值为42的int\n```\n\n接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针：\n\n```c++\nshared_ptr<int> p1 = new int(1024); // 错误：必须使用直接初始化形式\nshared_ptr<int> p2(new int(1024));  // 正确：使用了直接初始化形式\n```\n\np1的初始化隐式地要求编译器用一个new返回的int*来创建一个shared_ptr。由于我们不能进行内置指针到智能指针间的隐式转换，因此这条初始化语句是错误的。出于相同的原因，一个返回 shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：\n\n```c++\nshared ptr<int>clone(int p){\nreturn new int(p)；//错误：隐式转换为shared ptr<int>\n}\n```\n\n我们必须将shared_ptr显式绑定到一个想要返回的指针上：\n\n```c++\nshared ptr<int>clone(int p){\n//正确：显式地用int*创建 shared ptr<int>\nreturn shared_ptr<int>(new int(p))；\n}\n```\n\n默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象（可以提供自己的操作来替代delete）。\n\n更多关于智能指针使用的讨论见p412。\n\n### 智能指针和异常\n\n程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针：\n\n```c++\nvoid f()\n{\n    shared_ptr<int> sp(new int(42)); // 分配一个对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n} // 函数结束时shared_ptr自动释放内存\n```\n\n无论是否发生了异常，局部对象都会被销毁，sp是指向这块内存的唯一指针，因此内存会被释放掉。\n\n如果使用了内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：\n\n```c++\nvoid f()\n{\n    int *ip = new int(42); // 动态分配一个新对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n    delete ip; // 在退出以前释放内存\n}\n```\n\n如果在new和delete之间发生了异常，且异常未在f中被捕获，则内存就永远不会被释放了。\n\n**使用我们自己的释放操作**\n\n这里给一个简单的定义删除器的例子，而具体的讨论见书本p416。\n\n```c++\nauto deleter = [](int* p)\n{   \n\tstd::cout << \"delete data: \" << *p << std::endl;\n\tdelete p;\n};  \n\nstd::shared_ptr<int> p(new int(42), deleter);\n```\n\n智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：\n\n-. 不使用相同的内置指针值初始化（或reset）多个智能指针。\n-. 不delete get（）返回的指针。\n-. 不使用get（）初始化或reset另一个智能指针。\n-. 如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。\n-. 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（参见12.1.4节，第415页和12.1.5节，第419页）。\n\n\n### unique_ptr\n\n与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。\n\n与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。\n\n```c++\nunique_ptr<double> p1; // 可以指向一个double的unique_ptr\nunique_ptr<int> p2(new int(42)); // p2指向一个值为42的int\n```\n\n由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。\n\n更多有关unique_ptr操作的讨论见p418。\n\n### weak_ptr\n\nweak_ptr是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象还是会被释放。\n\n当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：\n\n```c++\nauto p = make_shared<int>(42);\nweak_ptr<int> wp(p); // wp若共享p；p的引用计数未改变\n```\n\n由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。如果存在，lock返回一个指向共享对象的shared_ptr。否则返回一个空shared_ptr。\n\n```c++\nif (shared_ptr<int> np = wp.lock()) { // 如果np不为空则条件成立\n    // 在if中，np与p共享对象\n}\n```\n\n## 动态数组\n\nC++语言和标准库提供了两种一次分配一个对象数组的方法：\n\n- 一种new表达式语法，可以分配并初始化一个对象数组。\n\n- 标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。\n\n!!!note\n\t大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。\n\n### new和数组\n\n为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目：\n\n```c++\n// 调用get_size确定分配多少个int\nint *pia = new int[get_size()]; // pia指向第一个int\n```\n\n方括号中的大小必须是整型，但不必是常量。\n\n**分配一个数组会得到一个元素类型的指针**\n\n当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。\n\n!!!note\n\t要记住我们所说的动态数组并不是数组类型，这是很重要的。\n\n**初始化动态分配对象的数组**\n\n默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：\n\n```c++\nint *pia = new int[10]; // 10个未初始化的int\nint *pia2 = new int[10](); // 10个值初始化为0的int\n```\n\n新标准中，我们还可以提供一个元素初始化器的花括号列表：\n\n```c++\n// 10个int分别用列表中对应的初始化器初始化\nint *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};\n```\n\n**释放动态数组**\n\n为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对：\n\n```c++\ndelete p; // p必须指向一个动态分配的对象或为空\ndelete [] pa; // pa必须指向一个动态分配的数组或为空\n```\n\n数组的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。\n\n**智能指针和动态数组**\n\n标准库提供了一个可以管理new分配的数组的unique_ptr版本：\n\n```c++\n// up指向一个包含10个未初始化int的数组\nunique_ptr<int[]> up(new int[10]);\nup.release(); // 自动用delete[]销毁其指针\n```\n\n> my note: 这里似乎有错误，release方法据p418介绍，是放弃对指针的控制权，返回指针。并不销毁原来指向的对象。另一个事例见：http://zh.cppreference.com/w/cpp/memory/unique_ptr/release\n\n当unique_ptr销毁时，会自动销毁其指向的对象。\n\n### allocator类\n\nnew和delete有一些灵活性上的局限：\n\n- new将内存分配和对象构造组合在了一起。\n\n- delete将对象析构和内存释放组合在了一起。\n\n当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。\n\n**allocator类**\n\n标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。\n\nallocator也是模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定对象类型来确定恰当的内存大小和对齐位置：\n\n```c++\nallocator<string> alloc; // 可以分配string的allocator对象\nauto const p = alloc.allocate(n); // 分配n个未初始化的string\n```\n\n**allocator分配未构造的内存**\n\nallocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。\n\n```c++\nauto q = p; // q指向最后构造元素之后的位置\nalloc.construct(q++); // *q为空字符串\nalloc.construct(q++, \"hi\"); // *q为hi!\n```\n\n还未构造对象的情况下就使用原始内存是错误的。\n\n当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。\n\n```c++\nwhile (q != p)\n    alloc.destroy(--q); // 释放我们真正构造的string\n```\n\n一旦元素被销毁后，就可以重新用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：\n\n```c++\nalloc.deallocate(p, n);\n```\n\n我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。\n\n**拷贝和填充未初始化内存的算法**\n\n标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。见p429。\n# 拷贝控制\n\n一个类通过定义五种特殊的成员函数来控制拷贝、移动、复制、销毁这些操作，包括：**拷贝构造函数、拷贝赋值函数、移动赋值函数、移动构造函数和析构函数。**\n\n## 拷贝、赋值、销毁\n\n### 拷贝构造函数\n\n拷贝构造函数的第一个参数是自身的应用，且额外参数都有默认值。\n\n`拷贝构造函数的第一个参数必须是一个引用类型。`\n\n```c++\nclass Foo{\npublic:\n\tFoo();//默认构造函数\n\tFoo(const Foo&);//拷贝构造函数\n};\n```\n\n**拷贝构造函数通常不应该是explicit的。**\n\n### 合成拷贝构造函数\n\n对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。\n\n```c++\nclass Sales_data{\npublic:\n\tSales_data(const Sales_data&)//合成拷贝构造函数\nprivate:\n\tstring BookNo;\n\tint units_sold = 0;\n\tdouble revenue = 0.0;\n};\n//与Sales_data的合成的拷贝构造函数等价\nSales_data::Sales_data(const Sales_data &orig):\n\t\t\t\t\t\t\t\t\t\t\t\tBookNo(orig.BookNo),\n\t\t\t\t\t\t\t\t\t\t\t\tunits_sold(orig.units_sold),\n\t\t\t\t\t\t\t\t\t\t\t\trevenue(orig.revenue)\n{}\n```\n\n**拷贝初始化**\n\n拷贝初始化通常使用拷贝构造函数完成（有时候为移动构造函数）。\n\n拷贝初始化不仅在我们用=定义变量时发生，在下列情况下也会发生：\n\n*. 将一个对象作为实参传递给一个非引用类型的形参\n\n*. 从一个返回类型为非引用类型的函数返回一个对象\n\n*. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员\n\n**参数和返回值**\n\n当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。\n\n**拷贝初始化的限制**\n\n```c++\nvector<int> v1(10)//正确：直接初始化\nvector<int> v2=10;//错误，接受大小参数的构造函数是显式的\nvoid f(vector<int>);//f的参数进行拷贝初始化\nf(10);//错误；不能用一个显式的构造函数拷贝一个实参\nf(vector<int>(10));//正确，从一个int直接构造一个临时的vector\n```\n\n**编译器可以绕过构造函数**\n\n在拷贝初始化的过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。例如：\n\n```c++\nstring null_book=\"9-999-999999-9\";//拷贝初始化\nstring null_book(\"9-999-999999-9\");//编译器绕过了拷贝构造函数\n```\n\n### 拷贝赋值运算符\n\n**重载赋值运算符**\n\n重载赋值运算符本质是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。\n\n```c++\nclass Foo{\npublic:\n\tFoo& operator=(const Foo&);//赋值运算符\n//...\n}\n```\n\n为了与内置运算符保持一致性，赋值运算符通常返回一个指向其左侧运算对象的引用。\n\n**合成拷贝赋值运算符**\n\n如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。\n\n```c++\nSales_data&\nSales_data::operator=(const Sales_data &rhs){\n\tBookNo = rhs.BookNo;\n\tunits_sold = rhs.units_sold;\n\trevenue = rhs.revenue;\n\treturn *this;\n}\n```\n\n### 析构函数\n\n析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他的工作，析构函数释放对象使用的资源，并销毁对象的非static数据成员。\n\n析构函数没有返回值，也不接受参数。\n\n**析构函数完成什么工作**\n\n在一个人构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序执行。\n\n通常，析构函数释放对象在生存期分配的所有资源。\n\n\t隐式销毁一个内置指针类型的成员不会delete它所指向的对象。\n\n**什么时候会调用析构函数**\n\n无论何时一个对象被销毁，就会自动调用其析构函数：\n\n1. 变量离开其作用域时被销毁\n\n2. 当一个对象被销毁时，其成员被销毁\n\n3. 容器被销毁时，其元素被销毁\n\n4. 对于动态分配的对象，当指向它的指针应用delete运算符时被销毁\n\n5. 对于临时对象，当创建它的完整表达式时被销毁\n\n\t当一个指向对象的引用或者指针离开作用域时，析构函数不会执行。\n\n**合成析构函数**\n\n当一个类未定义自己的析构函数时，编译器便会自动为它自动定义一个合成析构函数。\n\n### 三/五法则\n\n\t如果一个函数需要自定义析构函数，几乎可以肯定他也需要自定义拷贝赋值运算符合拷贝构造函数。\n\n**需要拷贝操作的类也需要赋值操作，反之亦然**\n\n### 使用default\n\n我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。\n\n### 阻止拷贝\n\n\t大多数类应该定义拷贝构造函数、构造函数和拷贝赋值运算符，无论是显式地还是隐式的。\n\n**定义删除的函数**\n\n我们可以通过将拷贝构造函数和拷贝赋值函数定义为删除的函数来阻止拷贝。删除的函数是这样的函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：\n\n```c++\nstruct NoCopy{\nNoCopy()=default;\nNoCopy(const NoCopy&)=delete;//阻止拷贝；\n}\n```\n\n还可以对任何函数指定=delete。\n\n**析构函数不能是删除的函数**\n\n如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。\n\n**合成的拷贝控制成员可能是删除的**\n\n对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。\n\n\n**private拷贝控制**\n\n在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。\n\n## 拷贝控制和资源管理\n\n通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。\n\n为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。\n\n类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。\n\n类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。\n\n### 行为像值的类\n\n对于类管理的资源，每个对象都应该拥有一份自己的拷贝。\n\n为了实现类值的行为，HasPtr需要：\n\n- 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针\n\n- 定义一个析构函数来释放string\n\n- 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string\n\n**类值拷贝赋值运算符**\n\n一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。\n\n这样就可以正确进行自赋值操作。\n\n### 定义行为像指针的类\n\n这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。\n\n令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。\n\n但是有时候我们希望直接管理资源，这种情况下，可以使用**引用计数（reference count）**。\n\n**引用计数**\n\n引用计数的工作方式如下：\n\n- 除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。\n\n- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。\n\n- 析构函数递减计数器，如果变为0，则析构函数释放状态。\n\n- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。\n\n引用计数应该保存在动态内存中，这样才能保证共享引用计数。\n\n## 交换操作\n\n管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。\n\n如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：\n\n```c++\nHasPtr temp = v1;\nv1 = v2;\nv2 = temp;\n```\n\n但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。\n\n```c++\nstring *temp = v1.ps;\nv1.ps = v2.ps;\nv2.ps = temp;\n```\n\nswap函数的存在是为了优化代码。详细定义方法见书本。\n\n**在赋值运算符中使用swap**\n\n定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为**拷贝并交换（copy and swap）**的技术。\n\n```c++\nHasPtr &HasPtr::operator=(HasPtr rhs)\n{\n    swap(*this, rhs);\n    return *this;\n}\n```\n\nrhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。\n\n这种技术自动处理了自赋值的情况且天然就是异常安全的。\n\n## 拷贝控制示例\n\n见习题练习13.33-13.38。\n\n## 动态内存管理类\n\n再看看！\n\n## 对象移动\n\n新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。\n\n使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。\n\n### 右值引用\n\n为了支持移动操作，新标准引入了一种新的类型——**右值引用（rvalue reference）**。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。\n\n```c++\nint i = 42;\nint &r = i;    // 正确：r引用i\nint &&rr = i;  // 错误：不能将一个右值引用绑定到一个左值上\nconst int &r3 = i*42;//正确：我们可以将一个const的引用绑定到一个右值上\nint &&r2 = i * 42; // 正确：将rr2绑定到乘法结果上\n```\n\n**左值持久，右值短暂**\n\n左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。\n\n由于右值引用只能绑定到临时对象，我们得知：\n\n*. 所引用的对象将要被销毁\n\n*. 该对象没有其他用户\n\n这两个特性意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。\n\n**变量是左值**\n\n变量可以看作只有一个运算对象而没有运算符的表达式。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。\n\n因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上：\n\n```c++\nint &&rr1 = 42;     // 正确：字面常量是右值\nint &&rr2 = rr1;    // 错误：表达式rr1是左值！\n```\n\n\t变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行，\n\n**标准库move函数**\n\n虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。\n\n```c++\nint &&rr3 = std::move(i); // OK\n```\n\nmove调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。\n\n\t我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。\n\t使用move的代码应该是std::move而不是move。\n\n### 移动构造函数和移动赋值运算符\n\n移动的版本从给定对象“窃取”资源而不是拷贝资源。\n\n移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。\n\n除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。\n\n```c++\nStrVec::StrVec(StrVec &&s) noexcpet // 移动构造函数不应抛出异常\n // 成员初始化器接管s中的资源\n : elements(s.elements), first_free(s.first_free), cap(s.cap)\n{\n    // 令s进入这样的状态——对其运行析构函数是安全的\n    s.elements = s.first_free = s.cap = nullptr;\n}\n```\n\n**移动操作、标准库容器和异常**\n\n移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。\n\n通知的方法是在构造函数中指明noexcept。\n\n```c++\nclass StrVec{\npublic:\n\tStrVec(StrVec&& ) noexcept;//移动构造函数 \n};\nStrVec::StrVec(StrVec &&s) noexcept:/*成员初始化器*/\n{/*构造函数体*/}\n```\n\n**移动赋值运算符**\n\n移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：\n\n```c++\nStrVec& StrVec::operator=(StrVec &&rhs) noexcept\n{\n    // 直接检测自赋值\n    if (this != &rhs) {\n        free();    // 释放已有资源\n        elements = rhs.elements; // 接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}\n```\n\n**移后源对象必须可析构**\n\n从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。\n\n除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。但是移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。\n\n\t在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。\n\n**合成的移动操作**\n\n如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。\n\n如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的拷贝版本会被定义为删除的。\n\n**移动右值，拷贝左值**\n\n如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。\n\n```c++\nStrVec v1, v2;\nv1 = v2;                    // v2是左值，使用拷贝赋值\nStrVec getVec(istream&);    // getVec返回一个右值\nv2 = getVec(cin);           // getVec(cin)是一个右值；使用移动赋值\n```\n\n**更新三/五法则**\n\n所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。\n\n### 右值引用和成员函数\n\n除了构造函数和赋值运算符之外，成员函数也可以提供拷贝和移动的版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。\n\n```c++\nvoid push_back(const X&);   // 拷贝：绑定到任意类型的X\nvoid push_back(X&&);        // 移动：只能绑定到类型X的可修改的右值\n```\n\n**右值和左值引用成员函数**\n\n我们可以强制左侧运算对象是一个左值。\n\n我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个**引用限定符（reference qualifier）**。\n\n```c++\nclass Foo {\npublic:\n    Foo &operator=(const Foo&) &;   // 只能向可修改的左值赋值\n};\n```\n\n引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。如果存在const限定符，引用限定符必须跟随在const限定符之后。\n\n**重载和引用函数**\n\n我们可以综合引用限定符和const来区分一个成员函数的重载版本。\n\n```c++\nclass Foo{\npublic:\n\tFoo sorted() &&;//可用于可改变的右值\n\tFoo sorted() const &;//可用于任何类型的Foo\nprivate:\n\tvector<int> data;\n};\n//本对象为右值，因此可以原址排序\nFoo Foo::sorted() &&\n{\n\tsort(data.begin(),data.end());\n\treturn *this;\n}\n//本对象是一个左值或者一个const，哪种情况我们都不能对其进行原址排序\nFoo Foo::sorted() const &{\n\tFoo ret(*this);\n\tsort(ret.data.begin(),ret.data.end());\n\treturn ret;\n}\n```\n\n\t如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 重载运算和类型转换\n\n## 基本概念\n\n重载运算符是具有特殊名字的函数：他们的名字由关键字operator和其后要定义的运算符号组成。重载运算符也包含返回类型，参数列表以及函数体。\n\n\t当一个运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。\n\n对于一个运算符函数来是哦，它或者是类的成员，或者至少含有一个类型的参数：\n\n```c++\n//错误，不能为int重定义内置的运算符\nint operator+(int,int);\n```\n\n不能被重载的运算符： .* :: . ? ：\n\n**直接调用一个重载的运算符函数**\n\n调用方法如下：\n\n```c++\n//一个非成员运算符的等价调用\ndata1+data2;//普通的表达式\noperator+(data1,data2);//等价的函数调用\ndata1 += data2;//基于调用的表达式\ndata1.operator+=(data2);//对成员运算符函数的等价调用\n```\n\n将this绑定到data1的位置，将data2作为实参传入函数。\n\n**某些运算符不应该被重载**\n\n\t通常情况下不应该重载逗号，取地址，逻辑与和逻辑或运算符。\n\n**使用与内置类型一致的含义**\n\n**选择作为成员或者非成员函数**\n\n有的运算符必须作为成员，另一些情况下，运算符作为非成员更好：\n\n1. 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）运算符必须作为成员；\n\n2. 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值略有不同；\n\n3. 递增、递减和解引用运算符，一般应该是成员；\n\n4. 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该时普通的非成员函数。\n\n```c++\nstring s = \"world\";\nstring t = s + \"!\";//正确，我们能把一个const char*加到一个string中等价于s.operator+(\"!\")\nstring u = \"Hi\" + s;//错误，等价于：\"Hi\".operator+(s),hi的类型是const char* ，这是一种内置类型，没有成员函数\n```\n\n## 输入和输出运算符\n\n### 重载输出运算符<<\n\n第一个形参通常是一个非常量的ostream对象的引用，之所以ostream是非常量是因为向流写入内容会改变其状态，而引用该形参是因为我们没法直接复制一个ostream对象。\n\n第二个形参通常是一个常量的引用，该常量是我们要输出的类类型。\n\n为了与其他输出运算符保持一致，operator<<通常返回它的ostream形参。例如：\n\n```c++\nclass Salas_data{\nfriend std::ostream& operator<<(ostream&, const Salas_data&);\nfriend std::ostream& operator>>(istream&, const Salas_data&);\n};\n```\n\n\t通常，输出运算符不应该打印换行符，主要负责输出打印的对象而非格式。\n\n**输出输出运算符必须是非成员函数**\n\n### 重载输入运算符>>\n\n通常情况下，输入运算符的第一个实参为将要读取的流的引用，第二个形参为将要读入到的（非常量）对象的引用。该运算符会返回某个流的引用。\n\n\t输入运算符必须处理输入失败的问题，而输出运算符不需要。\n\n## 算术和关系运算符\n\n通常我们把算术和关系运算符作为非成员函数以允许对左侧和右侧的运算对象进行转换。形参都是常量的引用。\n\n```c++\nSalas_data operator+(const Salas_data &lhs,const Salas_data &rhs){\n\tSalas_data sum = lhs;\n\tsum += rhs;\n\treturn sum;\n}\n```\n\n\t如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符来实现。\n\n### 相等运算符\n\n```c++\nbool operator==(const Sales_data &lhs, const Sales_data &rhs)\n{\n\treturn lhs.isbn() == rhs.isbn() &&\n\t       lhs.units_sold == rhs.units_sold &&\n\t       lhs.revenue == rhs.revenue;\n}\n\nbool operator!=(const Sales_data &lhs, const Sales_data &rhs)\n{\n\treturn !(lhs == rhs);\n}\n```\n\n### 关系运算符\n\n如果一个类不存在一种逻辑可靠的<定义，这个类不定义<运算符也许更好。\n\n### 赋值运算符\n\n之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。\n\n比如：\n\n```c++\nvector<string> v;\nv = {\"a\", \"b\", \"c\"};\n```\n\n```c++\nclass StrVec {\npublic:\n\tStrVec& operator=(std::initializer_list<std::string>)\n\t{\n\t\t// ...\n\t}\n};\n```\n\n\t赋值运算符必须为成员函数。\n\n### 复合赋值运算符 \n\n\t赋值运算符必须为成员函数，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。\n\n```c++\n// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针\nSales_data& Sales_data::operator+=(const Sales_data &rhs)\n{\n\tunits_sold += rhs.units_sold;\n\trevenue += rhs.revenue;\n\treturn *this;\n}\n```\n\n### 下标运算符\n\n表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。\n\n\t下标运算符必须是成员函数。\n\n为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。\n\n```c++\nclass StrVec {\npublic:\n\tstd::string& operator[](std::size_t n) { return elements[n]; }\n\n\tconst std::string& operator[](std::size_t n) const { return elements[n]; }\n\nprivate:\n\tstd::string *elements;\t// 指向数组首元素的指针\n};\n```\n\n## 递增递减运算符\n\n在迭代器类中通常会实现递增运算符++和递减运算符--，这两种运算符使得类可以在元素的序列中前后移动。\n\n对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。\n\n```c++\nclass StrBlobPtr {\npublic:\n\tStrBlobPtr& operator++();\t\t// 前置运算符\n\tStrBlobPtr& operator--();\n};\n```\n\n```c++\n//前置版本：返回递增递减对象的引用\nStrBlobPtr& StrBlobPtr::operator++(){\n//如果curr已经指向了容器的尾后位置，则无法递增它\n\tcheck(curr, \"increment past end of StrBlobPtr \")\n\t++curr;\t//将curr在当前状态下向前移动一个元素\n\treturn *this;\n}\n\nStrBlobPtr& StrBlobPtr::operator--(){\n\t//如果curr是0，则继续递减它将产生一个无效下标\n\t--curr;\t\t//将curr在当前状态下向后移动一个元素\n\tcheck(curr, \"decrement past begin of StrBlobPtr\");\n\treturn *this;\n}\n```\n\n**区分前置和后置运算符**\n\n后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。\n\n```c++\nclass StrBlobPtr {\npublic:\n\tStrBlobPtr operator++(int);\t\t// 后置运算符\n\tStrBlobPtr operator--(int);\n};\n```\n\n!!!note\n\t为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。\n\n```c++\n//后置版本：递增递减对象的值但是返回原值\nStrBlobPtr StrBlobPtr::operator++(int){\n\t//此处无须检查有效性，调用前置递增运算符时才需要检查\n\tStrBlobPtr ret = *this;//记录当前的值\n\t++*this;//向前移动一个元素，前置++需要检查递增的有效性\n\treturn ret;//返回之前记录的状态\n}\n\nStrBlobPtr StrBlobPtr::operator--(int){\n\t//此处无须检查有效性，调用前置递减运算符时才需要检查\n\tStrBlobPtr ret = *this\t//记录当前的值\n\t--*this //向后移动一个元素，前置--需要检查递减的有效性\n\treturn ret;\n}\n```\n\n**显式的调用后置运算符**\n\n```c++\nStrBlobPtr p(a1);//p指向a1中的vector\np.operator++(0);//调用后置版本的operator++\np.operator++();//调用前置版本的operator++\n```\n\n## 成员访问运算符\n\n在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。\n\n```c++\nclass StrBlobPtr {\npublic:\n\tstd::string& operator*() const;\n\t{\n\t\tauto p = check(curr,\"dereference past end\");\n\t\treturn (*p)[curr];\n\t}\n\tstd::string* operator->() const\n\t{\n\t\t// 将实际工作委托给解引用运算符\n\t\treturn & this->operator*();\n\t}\n};\n```\n\n**对箭头运算符返回值的限定**\n\n对于形如point->mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator->类的对象。根据point类型的不同，point->分别等价于：\n\n```c++\n(*point).mem;\t\t//point是一个内置的指针类型\npoint.operator()->mem;\t\t//point是一个类对象\n```\n\n除此之外，代码都将发生错误。\n\n## 函数调用运算符\n\n如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更灵活。\n\n```c++\nstruct absInt {\n\tint operator()(int val) const {\n\t\treturn val < 0 ? -val : val;\n\t}\n};\n```\n\n这个类只定义了一种操作：函数调用运算符，它负责接受一个int类型的实参，然后返回该实参的绝对值。\n\n使用调用运算符的方式是令一个absInt对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：\n\n```c++\nint i = -42;\nabsInt absObj;\nint ui = absObj(i);\t\t// 将i传递给absObj.operator()\n```\n\n函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。\n\n如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的行为像函数一样。\n\n\n\n\n### lambda是函数对象\n\n当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符，默认情况下，它是一个const成员函数。\n\n当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象确实存在。因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。\n\n通过值捕获的变量被拷贝到lambda中。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。\n\n### 标准库定义的函数对象\n\n标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作。\n\n这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，`plus<string>`令string的加法运算符作用于string对象。\n\n```c++\nplus<int> intAdd;\t\t\t// 可执行int加法的函数对象\nint sum = intAdd(10, 20);\t// 使用intAdd::operator(int, int)求10和20的和\n```\n\n**在算法中使用标准库函数对象**\n\n表示运算符的函数对象类常用来替换算法中的默认运算符。比如，默认情况下排序算法使用operator<将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个greater类型的对象。\n\n```c++\n// 传入一个临时的函数对象用于执行两个string对象的>比较运算\nsort(svec.begin(), svec.end(), greater<string>());\n```\n\n### 可调用对象与function\n\nC++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。\n\n和其他对象一样，可调用对象也有类型。lambda有它自己唯一的未命名的类类型；函数及函数指针的类型由其返回值和实参类型决定。\n\n然而，两个不同类型的可调用对象却可能共享同一种调用形式（call signature）。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：\n\n```c++\nint(int, int)\n```\n**标准库function函数**\n\nfunction是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，此额外信息是指该function类型能够表示的对象的调用形式：\n\n```c++\nfunction<int(int, int)>\n```\n\n这里声明的function类型，表示接受两个int、返回一个int的可调用对象：\n\n```c++\nfunction<int(int, int)> f1 = add;\t\t\t// 函数指针\nfunction<int(int, int)> f2 = divide();\t\t// 函数对象类的对象\nfunction<int(int, int)> f3 = [](int i, int j) { return i * j; };\t// lambda\n\ncout << f1(4, 2) << endl;\ncout << f2(4, 2) << endl;\ncout << f3(4, 2) << endl;\n```\n\n## 重载、类型转换与运算符\n\n在263页中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。\n\n转换构造函数和类型转换运算符共同定义了**类类型转换（class-type conversions）**。\n\n### 类型转换运算符\n\n**类型转换运算符（conversion  operator）**是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。其一般形式如下：\n\n```c++\noperator type() const;\n```\n\n其中type表示某种类型。类型转换运算符可以面向任意类型（除了void之外）进行定义，只要该类型能作为函数的返回类型，因此我们不允许转换成数组或者函数类型，但允许转换成指针或者引用类型。\n\n\t类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，一般被定义成const成员。\n\n**定义含有类型转换运算符的类**\n\n举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：\n\n```c++\nclass SmallInt {\npublic:\n\tSmallInt(int i = 0) : val(i)\n\t{\n\t\tif (i < 0 || i > 255)\n\t\t\tthrow std::out_of_range(\"Bad SmallInt value\");\n\t}\n\n\toperator int() const { return val; }\nprivate:\n\tstd::size_t val;\n};\n```\n\nSmallInt类的构造函数将算数类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int：\n\n```c++\nSmallInt si;\nsi = 4;\t\t\t// 4 -> SmallInt, 然后调用赋值运算符\nsi + 3;\t\t\t// si -> int，然后执行整数的加法\n```\n\n**类型转换运算符可能产生意外结果**\n\n在实践中，类很少提供类型转换运算符。但有一种例外：对于类来说，定义向bool的类型转换还是比较普遍的现象，但这会遇到一个问题：因为bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中（这不是期望的）。\n\n**显式的类型转换运算符**\n\n为了防止上述异常情况的发生，C++新标准引入了显式的类型转换运算符（explicit conversion operator）：\n\n```c++\nclass SmallInt {\npublic:\n\t// 编译器不会自动执行这一类型转换\n\texplicit operator int() const { return val; }\n};\n```\n\n编译器不会将一个显式的类型转换运算符用于隐式类型转换：\n\n```c++\nSmallInt si = 3;\t\t\t// 正确：SmallInt的构造函数不是显式的\nsi + 3;\t\t\t\t\t\t// 错误：此处需要隐式的类型转换，但类的运算符是显式的\nstatic_cast<int>(si) + 3;\t// 正确：显式地请求类型转换\n```\n\n但，如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它。\n\n\n\t向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的。\n\n### 避免有二义性的类型转换\n\n\t通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。\n\n**实参匹配和相同的类型转换**\n\n\n\n\t我们无法通过强制类型转换来解决二义性问题，因为强制类型转换也面临二义性问题。\n\n### 函数匹配和重载运算符\n\n\n\n\n\n\n\n\n\n\n# 面向对象程序设计\n\n面向对象程序设计基于三个基本概念：数据抽象、继承、动态绑定。\n\n---------\n\n## OOP概述\n\n**面向对象程序设计(object-oriented programming)**的核心思想时数据抽象，继承和动态绑定。通过数据抽象我们可以将类的接口和实现分开，使用继承，我们可以定义相似的类型并对其相似关系建模；使用动态绑定，我们可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。\n\n**继承**\n\n通过继承(inheritance)；联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类(base class)，其他类则间接或直接地从基类继承而来，这些继承而来的类称为派生类(derived class)。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。\n\n```c++\nclass Quote{\npublic:\n\tstd::string isbn() const;\n\tvirtual double net_price(std::size_t n) const;\n};\n\nclass Bulk_Quote:public Quote{\npublic:\n\tdouble net_price(std::size_t n) const override;\n};\n```\n\n**动态绑定**\n\n通过使用动态绑定(dynamic binding)，我们能用用一段代码分别处理Quote和Bulk_Quote的对象。\n\n```c++\n//计算并打印销售给定数量的某种书籍所得的费用\ndouble print_total(ostream &os,const Quote &item,size_t n){\n\t//根据传入item的形参的对象调用Quote::net_price()\n\t//或者Bulk_Quote::net_price\n\tdouble ret = item.net_price(n);\n\tos<<\"ISBN: \"<<item.isbn()<< \"# sold: \"<<n<< \"total due \"<<ret<<endl;\n\treturn ret;\n}\n\n//basic的类型时Quote,bulk的类型是Bulk_Quote\n\nprint_total(cout,basic,20);//调用Quote::net_price()\n\nprint_total(cout,bulk,20);//调用Bulk_Quote::net_price()\n```\n\n\t当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。\n\n## 定义基类和派生类\n\n### 定义基类\n\n```c++\nclass Quote{\npublic:\n\tQuote() = default;\n\tQuote(std::string &book,double sales_price):bookNo(book),price(sales_price){}\n\tstd::string isbn() const {return bookNo;};\n\tvirtual double net_price(size_t n) const {return n*price;}\n\tvirtual ~Quote()\nprivate:\n\tstd::string bookNo;\nprotected:\n\tdouble pricr = 0.0;\n};\n```\n\n\t通常，基类都应该定义一个虚析构函数，即使该函数在不执行任何实际操作也是如此。\n\n**成员函数和继承**\n\n成员函数如果没有被定义为虚函数，则其解析过程在发生编译时而不是运行时。\n\n基类通过在其成员函数的声明语句之前加上关键词virtual使得该函数执行动态绑定。\n\n**访问控制和继承**\n\n派生类可以继承定义在基类的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。派生类可以访问公有成员，而不能访问私有成员。不过，如果基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的(protected)访问运算符说明这样的成员。\n\n### 定义派生类\n\n派生类必须使用类派生列表(class derivation list)明确指出它是从哪个基类继承而来的。\n\n**派生类中的虚函数**\n\nC++新标准允许派生类显式的注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键词后面，或者在引用函数的引用限定符后面添加一个关键词override。\n\n**派生类对象及派生类向基类的类型转换**\n\n因为在派生类对象中含有基类对应的组成部分，所以我们能够把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上。\n\n```c++\nQuote item;\t\t//基类对象\nBulk_Quote bulk;\t\t//派生类对象\nQuote *p = &item;\t\t//p指向Quote对象\np = &bulk;\t\t//p指向bulk的Quote部分\nQuote &r = bulk;\t\tr绑定到bulk的Quote部分\n```\n\n**派生类构造函数**\n\n```c++\nBulk_Quote(const string &book,double p,size_t qty,double disc):\n\t\t\tQuote(book,p),min_qty(qty),discount(dis){}\n```\n\n\t首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。\n\n**派生类使用基类的成员**\n\n派生类可以使用基类的公有和保护成员。\n\n**继承与静态成员**\n\n静态成员遵循通用的访问规则。\n\n**被用作基类的类**\n\n如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明：\n\n```c++\nclass Quote;\t\t//声明但未定义；\n//错误：quote必须被定义\nclass Bulk_Quote:public Quote{...};\n```\n\n**防止继承的发生**\n\n在类名后加一个final可以防止继承的发生。\n\n```c++\nclass NoDerived final{};\n```\n\n### 类型转换与继承\n\n可以将基类的指针或者引用绑定到派生类的对象上有一层极为重要的含义：当使用基类的引用或指针时，实际上我们不知道该引用（指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。\n\n**动态类型与静态类型**\n\n我们必须把一个变量或者表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或者表达式生成的类型；动态类型则是变量或者表达式表示的内存中的对象的类型。动态类型直到运行时才可知。\n\n例如：当print_total调用net_price时`double ret = item.net_price(n);`\n\n我们知道item的静态类型是Quote&，它的动态类型则依赖于item绑定的实参，动态类型直到运行时才可知。\n\n**不存在从基类向派生类的隐式类型转换......**\n\n因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类到派生类的自动类型转换。\n\n```c++\nQuote base;\nBulk_Quote* bulkp = &base;\t\t//错误：不能将基类转换成派生类\nBulk_Quote& bulkref = base;\t\t//错误：不能将基类转换成派生类\nBulk_Quote bulk;\nQuote *itemp = &bulk;\t\t//正确：动态类型是Bulk_Quote\nBulk_Quote *bulkp = itemp;\t\t//错误：不能将基类转换成派生类\n```\n\n**......在对象之间不存在类型转换**\n\n\t当我们用一个派生类为一个基类对象赋值时，只有该派生类对象中的基类部分会被拷贝，移动和赋值，它的派生类部分会被忽略掉。\n\n\n## 虚函数\n\n我们必须为每个虚函数提供定义。\n\n**对虚函数的调用可能在运行时才被解析**\n\n动态绑定只有当我们通过指针或者引用调用虚函数时才会发生。\n\n**派生类中的虚函数**\n\n一旦某个函数被声明为虚函数，则在所有的派生类中它都是虚函数。\n\n\t基类中的虚函数在派生了中隐含地也是一个虚函数。\n\t当派生类覆盖某个虚函数时，该函数的形参必须与派生类的形参严格匹配。\n\t返回类型在返回的是类的指针或者引用时可不一样，但是要求从基类到派生类的类型转换是可访问的。\n\n**final和override说明符**\n\nfinal和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。\n\n**虚函数和默认实参**\n\n\t如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。\n\n**回避虚函数机制**\n\n在某些情况下，我们希望对虚函数的调用不要动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的：\n\n```c++\n//强行调用基类中定义的函数版本而不管baseP的动态类型如何\ndouble undiscount = baseP->Quote::net_price(42);\n```\n\n## 抽象基类\n\n**纯虚函数**\n\n纯虚函数无需定义、我们在函数体的位置书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。\n\n```c++\ndouble net_price(size_t) const =0;\n```\n\n**含有纯虚函数的类是抽象基类**\n\n抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能创建一个抽象基类的对象。因为Disc_quoto将net_price定义为纯虚函数，所以我们不能定义Disc_quote的对象。我们可以定义Disc_quote的派生类的对象。前提是这些类覆盖了net_price函数。\n\n\t我们不能创建抽象基类的对象。\n\n**派生类构造函数只初始化它的直接基类**\n\n## 访问控制与继承\n\n**受保护的成员**\n\nprotected说明符可以看做是public和private中和后的产物：\n\n1. 和私有成员类似，受保护的成员对于类的用户来说是不可访问的\n\n2. 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的\n\n3. **派生类的成员只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护的成员没有任何访问特权**\n\n```c++\nclass Base{\nprotected:\n\tint prot_mem;\n};\n\nclass Sneaky:public Base{\n\tfriend void clobber(Sneaky&);//能访问Sneaky::prot_mem\n\tfriend void clobber(Base&);//不能访问Base::prot_mem\n\tint j;\n};\n\n//正确，clobber能够访问Sneaky对象的private和protected成员\nvoid clobber(Snaaky &s){s.j=s.prot_mem=0;}\n//错误;clobber不能访问Base的protected成员\nvoid clobber(base &s){s.prot_mem=0;}\n```\n\n**公有，私有和受保护继承**\n\n某个类对其继承而来的成员的访问权限受到两个因素的影响：\n\n1. 在基类中该成员的访问说明符\n\n2. 在派生类的派生列表中的访问说明符\n\n派生类说明符的目的是控制派生类影虎对于基类成员的访问权限，还可以控制继承自派生类的新类的访问权限。\n\n**派生类向基类转换的可访问性**\n\n派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：\n\n- 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。\n\n- 不论以什么方式继承B，D的成员和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的。\n\n- 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。\n\n\t对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。\n\n**友元与继承**\n\n友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。\n\n**改变个别成员的可访问性**\n\n有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：\n\n```c++\nclass Base {\npublic:\n\tstd::size_t size() const { return n; }\nprotected:\n\tstd::size_t n;\n};\n\nclass Derived : private Base {\npublic:\n\t// 令size成员保持public访问级别\n\tusing Base::size;\nprotected:\n\tusing Base::n;\n};\n```\n\n因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。\n\n通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中任何可访问成员标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。\n\n\t派生类只能为那些它可以访问的名字提供using声明。\n\n**默认的继承保护级别**\n\n默认情况下，使用class关键词定义的派生类是私有继承，而使用struct关键字定义的派生类为公有继承。\n\n## 继承中的类作用域\n\n每个类定义自己的作用域，在这个作用域内我们定义类的成员。\n\n当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，所以派生类才能像使用自己的成员一样使用基类的成员。\n\n**在编译时进行名字查找**\n\n一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。\n\n**名字冲突和继承**\n\n和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。\n\n\t派生类将隐藏同名的基类成员。\n\n**通过作用域运算符来使用隐藏的成员**\n\n作用域运算符将覆盖掉原有的查找规则。\n\n\t除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。\n\n**名字查找先去类型检查**\n\n```c++\nstruct Base{\n\tBase():mem(0){};\n\tint memfcn();\nprotected:\n\tint mem;\n};\n\nstruct Derived:Base{\n\tDerived(int i):mem(i){};\n\tint memfcn(int);\n\tint get_mem(){return mem;};\nprotected:\n\tint mem;\n};\n\nDerived d;\nBase b;\nb.memfcn();\t\t//调用Base::memfcn\nd.memfcn(10);\t\t//调用Derived::memfcn\nd.memfcn();\t\t//错误：参数列表为空的memfcn被隐藏了\nd.Base::memfcn();\t\t//正确：调用Base::memfcn\n```\n\n**虚函数和作用域**\n\n加入基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数。\n\n**通过基类调用隐藏的虚函数**\n\n## 构造函数与拷贝控制\n\n和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。\n\n### 虚析构函数\n\n当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本。\n\n```c++\nclass Quote {\npublic:\n\t// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数\n\tvirtual ~Quote() = default;\t// 动态绑定析构函数\n};\n```\n\n\t如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。\n\n之前介绍的经验准则说，如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但这里基类的析构函数并不遵顼这个准则，它是一个重要的例外。\n\n虚析构函数还将阻止合成移动操作。\n\n### 合成拷贝控制与继承\n\n基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如：\n\n- 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。\n\n- Quote的默认构造函数将bookNo成员默认初始化为空子行串，同时便用类内例始值将price初始化为0。\n\n- Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化qty和discount。\n\n- Disc quote的构造函数完成后，继续执行Bu1k_quote的构造函数，但是它什么具体工作也不做。\n\n**对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。**\n\n**派生类中删除的拷贝控制与基类的关系**\n\n某些定义为基类的方式也可能导致有的派生类成员成为删除的函数：\n\n-. 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问（参见15.5节，第543页），则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。\n\n-. 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。\n\n-. 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=defau1t请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。\n\n例如：\n\n```c++\nclass B{\npublic:\n\tB();\n\tB(const B&)=delete;\n};\n\nclass D:public B{\n\t//没有声明任何构造函数\n};\n\nD d;\t\t//正确，D的合成默认构造函数使用B的默认构造函数\nD d2(d);\t\t//错误：D的合成拷贝构造函数是被删除的\nD d3(std::move(d));\t\t//错误：隐式的使用D的被删除的拷贝构造函数\n```\n\n**移动操作和继承**\n\n因为基类缺少移动操作会阻止派生类拥有自己的移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。\n\n```c++\nclass Quote{\npublic:\n\tQuote()=default;//对成员依次进行默认初始化\n\tQuote(const Quote&)=default;//对成员依次拷贝\n\tQuote(Quote&&)=default;//对成员依次拷贝\n\tQuote& operator=(const Quote&)=default;//拷贝赋值\n\tQuote& operator=(Quote&&)=default;//拷贝赋值\n\tvirtual ~Quote()=default;//析构函数\n}\n```\n\n### 派生类的拷贝控制成员\n\n派生类的构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要移动和拷贝基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。\n\n和构造函数及赋值运算符不同的是，析构函数只负责销毁自己分配的资源。\n\n\t当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。\n\n**定义派生类的拷贝和移动构造函数**\n\n当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分：\n\n```c++\nclass Base{/* */};\nclass D:public Base{\npublic:\n\t//默认情况下，基类的默认构造函数初始化对象的基类部分\n\t//要想使用拷贝或移动构造函数，我们必须在构造函数初始列表中\n\t//显式的调用该构造函数\n\tD(const D&):Base(d)\t\t//拷贝基类成员\n\t\t\t/*D的成员的初始值*/{ /* */}\n\tD(D&& d):Base(std::move(d))\t\t//移动基类成员\n\t\t\t/*D的成员的初始值*/{ /* */}\n};\n```\n\n\t在默认情况下，其基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝或者移动基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝构造函数。\n\n**派生类赋值运算符**\n\n派生类的赋值运算符也必须显式地为其基类部分赋值。\n\n```c++\n//Base::operator=(const Base&)不会被自动调用\nD &D::operator=(const D &rhs){\n\tBase::operator=(rhs);//为基类部分赋值\n\t//按照过去的方式为派生类的成员赋值\n\t//酌情处理自赋值及释放已有资源等情况\n\treturn *this;\n}\n```\n\n**派生类析构函数**\n\n派生类析构函数只负责销毁由派生类自己分配的资源。\n\n**在构造函数和析构函数中调用虚函数**\n\n### 继承的构造函数\n\n**类不能继承默认、拷贝、移动构造函数**，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。\n\n在C++11新标准中，派生类能够重用其直接基类定义的构造函数。\n\n一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。\n\n派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。\n\n```c++\nclass Bulk_quote : public Disc_quote {\npublic:\n\tusing Disc_quote::Disc_quote; // 继承Disc_quote的构造函数\n\tdouble net_price(std::size_t) const;\n};\n```\n\n通常情况下，using声明语句只是令某个名字在当前作用域内可见。当当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。\n\n在Bulk_quote类中，继承的构造函数等价于：\n\n```c++\nBulk_quote(const std::string &book, double price, std::size_t qty, double disc) :\n\tDisc_quote(book, price, qty, disc) {}\n```\n\n如果派生类含有自己的数据成员，则这些成员将被默认初始化。\n\n**继承的构造函数的特点**\n\n一个构造函数的using声明不会改变该构造函数的访问级别。不能指定explicit和constexpr。\n\n## 容器与继承\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 模板和泛型编程\n\n## 定义模板\n\n### 函数模板\n\n一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板函数可以像这样：\n\n```c++\ntemplate<typename T>\nint compare(const T &v1,const T &v2){\n\treturn  v1 > v2 ? 1 : -1;\n}\n```\n\n模板定义以一个关键词template开始，后跟一个模板参数列表，这是一个逗号分隔或多个模板参数的列表，用< 和 > 包围起来。\n\n\t在模板定义中，模板参数列表不能为空。\n\n**实例化参数模板**\n\n'''c++\ncout<<compare(1,0)<<endl;//T为int\n'''\n\n**模板类型参数**\n\n类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换。\n\n**非类型模板参数**\n\n一个非类型模板参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或者typename来指定非类型参数。\n\n\t非类型模板参数的模板实参必须是常亮表达式。\n\n**inline和constexpr的函数模板**\n\ninline或者constexpr说明符放在参数列表之后，返回类型之前：\n\n```c++\ntemplate<typename T>\ninline T min(const T &a,const T &b)\n```\n\n**编写类型无关的代码**\n\n编写泛型代码的两个重要的原则：\n\n1. 模板中的函数参数是const的引用；\n\n2. 函数体的条件判断仅使用<比较运算。\n\n**模板编译**\n\n## 类模板\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 标准库特殊设施\n\n## tuple类型\n\ntuple是类似pair的模板。每个pair的成员类型都不相同，但是每个pair都恰好有两个成员。不同tuple类型的成员类型也不相同，但是每个tuple可以有任意数量的成员。每个确定的tuple类型的成员数目是固定的，但一个tuple类型的成员数目可以与另一个tuple类型不同。\n\n```c++\ntuple支持的操作\ntuple<T1,T2,...,Tn> t;\ntuple<T1,T2,...,Tn> t(v1,v2,v3,v4,...,vn);\nmake_tuple(v1,v2,...,vn);\nt1==t2;\nt1 relop t2;\nget<i>(t);\n```\n\n### 定义和初始化tuple\n\n当我们定义一个tuple时，需要指出每个成员的类型：\n\n```c++\ntuple<size_t,size_t,size_t> threeD;//三个成员都设置为0\ntuple<string,vector<double>,int,list<int>) someVal(\"contents\",{3.14,2.718},42,{0,1,2,3,4,5})\n```\n\n**访问tuple的成员**\n\n要访问一个tuple的成员，就要使用一个名为get的标准函数模板。\n\n```c++\nauto book = get<0>(item);//返回item成员的第一个成员\nauto cnt = get<1>(item);//返回item成员的第二个成员\n```\n\n如果不知道一个tuple准确的类型细节信息，可以使用辅助类模板来查询tuple成员的类型和数量：\n\n```c++\ntypedef decltype(item) trans;//trans是item的类型\n//返回item类型对象中成员的数量\nsize_t sz = tuple_size<trans>::value;//返回3\n//cnt类型与item中第二个成员相同\ntuple_element<1,trans>::type cnt = get<1>(item);//cnt为int型\n```\n\n### 使用tuple返回多个值\n\n## bitset类型\n\n标准库定义了bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。\n\n### 定义和初始化bitset\n\nbitset类是一个类模板，它类似array类，具有固定的大小。当我们定义一个bitset时，需要声明它包含多少个二进制位。\n\n```c++\nbitset<32> bitvec(1U);\t// 32位；低位为1，其他位为0\n```\n\n二进制位的位置是从0开始编号的，因此，bitvec包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位（low-order），编号到31结束的二进制位被称为高位（high-order）。\n\n\n**使用unsigned值初始化bitset**\n\n当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当作位模式来处理。bitset中的二进制位将是此模式的一个副本。如果bitset的大小大于unsigned long long的位数，则剩余高位被置为0。如果小于，则只使用给定值中的低位，超出bitset大小的高位被丢弃。\n\n**从一个string初始化bitset**\n\n我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符都直接表示位模式。当我们使用字符串表示数时，字符串中下标最小的字符对应高位：\n\n```c++\nbitset<32> bitvec4(\"1100\");\t// 2、3两位为1，剩余两位为0\n```\n\n如果string包含的字符数比bitset少，则bitset的高位被置为0。\n\n\tstring的下标编号习惯于bitset恰好相反：string中下标最大的字符（最右）用来初始化bitset中的低位。\n\n### bitset操作\n\nbitset操作定义了多种检测或设置一个或多个二进制位的方法。\n\n```c++\nbitset<32> bitvec(1U);\nbool is_set = bitvec.any();\t\t\t// true，因为有1位置位\nbool is_not_set = bitvec.none();\t// false，因为有1位置位了\nbool all_set = bitvec.all();\t\t// false，因为只有1位置位了\nsize_t onBits = bitvec.count();\t\t// 返回1\nsize_t sz = bitvec.size();\t\t\t// 返回32\nbitvec.flip();\t\t\t\t\t\t// 翻转bitvec中的所有位\nbitvec.reset();\t\t\t\t\t\t// 将所有位复位\nbitvec.set();\t\t\t\t\t\t// 将所有位置位\n\nbitvec.flip(0);\t\t\t\t\t\t// 翻转第一位\nbitvec.set(0);\t\t\t\t\t\t// 置位第一位\nbitvec.reset(i);\t\t\t\t\t// 复位第i位\nbitvec.test(0);\t\t\t\t\t\t// 返回false，因为第一位已复位\n\nbitvec[0] = 0;\t\t\t\t\t\t// 将第一位复位\nbitvec[31] = bitvec[0];\t\t\t\t// 将最后一位设置为与第一位一样\n~bitvec[0];\t\t\t\t\t\t\t// 翻转第一位\n```\n\n**提取bitset的值**\n\nto_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式，只有当bitset的大小小于等于对应的大小时，我们才能使用这两个操作，否则将会抛出overflow_error异常。\n\n```c++\nunsigned long ulong = bitvec3.to_ulong();\ncout << \"ulong = \" << ulong << endl;\n```\n\n**bitset的IO运算符**\n\n输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的字符数达到对应bitset的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，读取过程才停止。随即用临时string对象来初始化bitset。如果读取的字符数小于bitset的大小，高位被置为0。\n\n```c++\nbitset<16> bits;\ncin >> bits;\t\t// 从cin读取最多16个0或1\ncout << \"bits: \" << bits << endl;\n```\n\n## 正则表达式\n\n正则表达式是一种描述字符序列的方法，是一种及其强大的计算工具。它定义在头文件regex中，它包含多个组件：\n\n|组件|说明|\n|-|-|\n|regex|表示有一个正则表达式的类|\n|regex_match|将一个字符序列与一个正则表达式匹配|\n|regex_search|寻找第一个与正则表达式匹配的子序列|\n|regex_replace|使用给定格式替换一个正则表达式|\n|sregex_iterator|迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串|\n|smatch|容器类，保存在string中搜索的结果|\n|ssub_match|string中匹配的子表达式的结果|\n\nregex类表示一个正则表达式。\n\n函数regex_match和regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个输入序列与表达式匹配，则regex_match返回true；如果输入一个序列中一个子串与表达式匹配，则regex_search返回true。\n\n## 随机数\n\n程序通常需要一个随机数源。在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。此函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。\n\nrand函数有一些问题：即使不是大多数，也有很多程序员需要不同范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。\n\n定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎（random-number engines）和随机数分布类（random-number distribution）。\n\n|组件|说明|\n|-|-|\n|引擎|类型，生成随机unsigned整数序列|\n|分布|类型，使用引擎返回服从特定概率分布的随机数|\n\n!!!note\n\tC++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。\n\n### 随机数引擎和分布\n\n随机数引擎是函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。\n\n```c++\ndefault_random_engine e;\ncout << e() << endl;\t\t// 生成一个随机无符号数\n```\n\n标准库定义了多个随机数引擎类，区别在于性能和随机质量不同。\n\n**分布类型和引擎**\n\n为了得到一个指定范围内的数，我们使用一个分布类型的对象：\n\n```c++\n// 生成0到9之间（包含）均匀分布的随机数\nuniform_int_distribution<unsigned> u(0, 9);\ndefault_random_engine e;\ncout << u(e) << endl;\n```\n\n分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。\n\n\t当我们说随机数发生器时，是指分布对象和引擎对象的组合。\n\n**引擎生成一个数值序列**\n\n随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序它都会返回相同的数值序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。\n\n\n\n**设置随机数发生器种子**\n\n我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子（seed）来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。\n\n```c++\ndefault_random_engine e1;\t\t// 使用默认种子\ne1.seed(42);\t\t\t\t\t// 调用seed设置一个种子值\ndefault_random_engine e2(42);\t// 使用给定的种子值\n```\n\n如果引擎种子相同，将生成相同的序列。\n\n选择一个好种子，是极其困难的，可能最常用的方法是调用系统函数time。它定义在头文件ctime中，它返回从一个特定时刻到当前经过了多少秒。\n\n```c++\ndefault_random_engine e(time(0));\t// 稍微随机些的种子\n```\n\n> my note: 使用random_device引擎为另一个引擎创建一个种子也是一种方法。\n\n后续内容讨论了其他随机数的分布，比如：生成随机实数、生成非均匀分布随机数等。\n\n## IO库再探\n\n### 格式化输入与输出\n\n除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽度等。\n\n标准库定义了一组操纵符来修改流的格式状态。一个操纵符是一个函数或是一个对象，会影响流的状态。\n\n!!!warning\n\t当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。\n\n**控制布尔值的格式**\n\n默认情况下，bool值打印为1或0，通过对流使用boolalpha操纵符来修改原有格式：\n\n```c++\ncout << boolalpha << true << \" \" << false << endl; // 输出：true false\n```\n\n一旦向cout“写入”了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印true或false，为了取消格式的改变，noboolalpha：\n\n```c++\ncout << noboolalpha;\n```\n\n**指定整型值的进制**\n\n默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct、dec将其改为十六进制、八进制或是改回十进制。\n\n```c++\ncout << \"default: \" << 20 << endl;\ncout << \"octal: \" << oct << 20 << endl;\ncout << \"hex: \" << hex << 20 << endl;\ncout << \"decimal: \" << dec << 20 << endl; \n```\n\n**在输出中指出进制**\n\n当对流应用showbase操纵符时，会在输出结果中显示进制：\n\n- 前导0x表示十六进制。\n\n- 前导0表示八进制。\n\n- 无前导字符串表示十进制。\n\n```c++\ncout << showbase;\t// 打印整型值时显示进制\ncout << \"default: \" << 20 << endl;\ncout << \"octal: \" << oct << 20 << endl;\ncout << \"hex: \" << hex << 20 << endl;\ncout << \"decimal: \" << dec << 20 << endl;\ncout << noshowbase; // 恢复流状态 \n```\n\n**指定打印精度**\n\nsetprecision操纵符接受一个参数，用来设置精度。它定义在头文件iomanip中。\n\n```c++\ncout << setprecision(3);\ncout << sqrt(2.0) << endl;\t// 输出：1.41\n```\n\n更多操纵符见p669。\n\n### 未格式化的输入/输出操作\n\n标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这组操作允许我们将一个流当作一个无解释的字节序列来处理。\n\n**单字节操作**\n\n有几个未格式化操作每次一个字节地处理流，它们会读取而不是忽略空白符。\n\n```c++\n// 读写一个字符\nchar ch;\nwhile (cin.get(ch))\n\tcout.put(ch);\n```\n\n|操作|说明|\n|-|-|\n|is.get(ch)|从istream is读取下一个字节存入字符ch中。返回is|\n|os.put(ch)|将字符ch输出到ostream os。返回os|\n|is.get()|将is的下一个字节作为int返回|\n|is.putback(ch)|将字符ch放回is。返回is|\n|is.unget()|将is向后移动一个字节。返回is|\n|is.peek()|将下一个字节作为int返回，但不从流中删除它|\n\n详细讨论见p673。\n\n**多字节操作**\n\n一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。\n\n书中未给出代码案例讲解，具体操作见p674。\n\n### 流随机访问\n\n标准库提供了一对函数，来定位（seek）到流中给定的位置，以及告诉（tell）我们当前的位置。\n\n在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问，因为这种操作对它们没有意义。对这些流调用seek和tell会导致运行时出错，将流置于一个无效状态。\n\n**seek和tell函数**\n\n为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。标准库实际上定义了两对seek和tell函数，差别在于名字的后缀是g还是p，g版本表示我们正在读取数据，而p版本表示我们正在写入数据。\n\n|操作|说明|\n|-|-|\n|tellg() tellp()|返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置|\n|seekg(pos) seekp(pos)|在一个输入流或输出流中奖标记重定位到给定的绝对地址。pos通常是前一个tell返回的值|\n|seekp(off, from) seekg(off, from)|在一个输入流或输出流中，奖标记定位到from之前或之后off个字符，from可以是：beg（流开始位置）, cur（流当前位置）, end（流结尾位置）|\n\n从逻辑上讲，我们只能对istream使用g版本，对ostream使用p版本。iostream则可以使用g版本又可以使用p版本。\n\n\n\n\n\n\n\n\n\n","source":"_posts/2019-cPlusPlusproblemset.md","raw":"---\ntitle: C++学习笔记\ntop: ture\ncover: false\ntoc: true\nmathjax: true\ndate: 2019-09-30 15:15:26\npassword:\nsummary: 学习一门新的程序设计语言的最好方法就是练习编写程序。\ntags:\n- C++ 读书笔记\ncategories:\n- C++\n---\n\n\n# 开始\n\n学习一门新的程序设计语言的最好方法就是练习编写程序。更多的内容可以查看我的github主页[C++课后习题集](https://github.com/HaoxinGuo/CPlusPlusPrimerProblemset)\n\n<img src=\"readme.jpg\" width=\"50%\" height=\"50%\" alt=\"习题集目录\">\n\n---\n\n## 编写一个简单的C++程序\n\n每个C++程序都包含一个或多个函数（function），其中一个必须命名为**main**。操作系统通过调用main来运行C++程序。\n\n下面是一个简单的main函数，它什么都不做，只是返回给操作系统一个值：\n\n```c++\nint main()\n{\n    return 0;\n}\n```\n\nmain函数的返回类型必须为int。int类型是一种**内置类型**（built-in type），即语言自身定义的类型。\n\n函数体是一个以左**花括号**（curly brace）开始，以右花括号结束的语句块（block of statements）。\n\nreturn语句结束函数的执行。main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。\n\n**重要概念：类型**\n\n一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。程序所处理的数据都保存在变量中，而每个变量都拥有自己的类型。\n\n### 编译、运行程序\n\n编写好程序后，我们就需要编译它，这依赖于操作系统和编译器。\n\n**程序源文件命名约定**\n\n程序文件通常被称为源文件（source file）。它以一个后缀为结尾，告诉系统这个文件是一个C++程序，比如.cpp。\n\n## 初识输入输出\n\nC++包含了一个全面的**标准库**（standard library）来提供IO机制（以及很多其他设施）。\n\n**iostream**库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。\n\n**标准输入输出对象**\n\n标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为**标准输入**（standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为**标准输出**（standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为**标准错误**（standard error）。clog用来输出程序运行时的一般性消息。\n\n系统通常将程序所运行的窗口与这些对象关联起来。因此，当读取cin，数据将从程序正在运行的窗口读入，当向cout写入数据时，将会写到同一个窗口。\n\n!!!note\n\tclog关联到标准错误，默认情况下，写到clog的数据是被缓冲的。写到cerr的数据是不缓冲的。\n\n**一个使用IO库的程序**\n\n```c++\n#include <iostream>\nint main()\n{\n        std::cout << \"Enter two numbers:\" << std::endl;\n        int v1 = 0, v2 = 0;\n        std::cin >> v1 >> v2;\n        std::cout << \"The sum of \" << v1 << \" and \" << v2 << \" is \"\n                  << v1 + v2 << std::endl;\n        return 0;\n}\n```\n\n`#include <iostream>`告诉编译器我们想要使用iostream库。尖括号中的名字指出了一个**头文件**（header）。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。#include指令一般出现在所有函数之外，源文件的开始位置。\n\n**向流写入数据**\n\n```c++\nstd::cout << \"Enter two numbers\" << std::endl;\n```\n\n这条语句执行了一个**表达式**（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了**输出运算符**（<<）。\n\n`<<`运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。\n\n\"Enter two numbers\"是一个**字符串字面值常量**（string literal），它是用一对双引号包围的字符序列。\n\nendl是一个被称为**操纵符**（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。\n\n!!!note\n\t一个表达式接一个分号就是一条语句。\n\n**使用标准库中的名字**\n\n前缀std::指出名字cout和endl是定义在名为**std**的**命名空间**（namespace）中的。\n\n命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。\n\n**从流读取数据**\n\n首先定义两个名为v1和v2的**变量**（variable）来保存输入：\n\n```c++\nint v1 = 0, v2 = 0;\n```\n\n这两个变量被定义为int类型，并**初始化**（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。\n\n```c++\nstd::cin >> v1 >> v2;\n```\n\n这条语句读入输入数据。**输入运算符**（>>）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。\n\n## 注释简介\n\n注释（comments）通常用于概述算法，确定变量的用途，或者解释晦涩难懂的代码段。编译器会忽略掉注释，因此注释对程序的行为和性能不会有任何影响。\n\n**C++中注释的种类**\n\nC++中有两种注释：单行注释和界定符注释。\n\n**注释界定符不能嵌套**\n\n界定符对形式的注释是以`/*`开始，以`*/`结束的。因此，一个注释不能嵌套在另一个注释之内。\n\n如果在调试期间要注释掉包含界定符对形式注释的代码，最好的方式是用单行注释方式注释掉代码段的每一行。\n\n```c++\n// /*\n//  * comments\n//  */\n```\n\n## 控制流\n\n语句一般是顺序执行的，语句块的第一条语句首先执行，然后是第二条，以此类推。但程序设计语言提供了多种不同的控制语句，允许我们写出更为复杂的执行路径。\n\n### while语句\n\nwhile语句反复执行一段代码，直到给定条件为假为止。\n\nwhile语句的形式为：\n\n```c++\nwhile (condition)\n    statement\n```\n\nwhile语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假时停止。所谓**条件**就是一个产生真或假的结果的表达式。\n\nstatement可以是语句块，也叫循环体。所谓语句块（block），就是用花括号包围的语句序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。\n\n### for语句\n\n每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。\n\n比如：\n\n```c++\nfor (int val = 1; val <= 10; ++val)\n    sum += val;\n```\n\nfor循环的总体执行流程：\n\n0. 创建变量val，将其初始化为1，它仅在循环内部存在。\n\n0. 检测val是否小于等于10。如果检测成功，执行循环体。若失败，退出循环。\n\n0. 将val的值增加1。\n\n0. 重复第二个步骤。\n\n### 读取数量不定的输入数据\n\n使用这样的方法连续读入数据，直到遇到文件尾（Linux下，输入CTRL+D）：\n\n```c++\nwhile (std::cin >> value)\n    statement\n```\n\n输入运算符返回其左侧对象，因此，此循环条件检测的是std::cin。\n\n当使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象的状态会变为无效。\n\n### if语句\n\nif也对一个条件求值，书本里有一个完整的例子。\n\n语法大致如此：\n\n```c++\nif (condition) {\n    statements\n} else {\n    statements\n}\n```\n\n## 类简介\n\n在C++中，通过定义一个**类**（class）来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。\n\n类似使用标准库设施，我们也需要使用头文件来自己的类。习惯上，头文件根据类名来命名，使用.h作为头文件的后缀。标准库的头文件通常不带后缀。\n\n### 初识成员函数\n\n**什么是成员函数？**\n\n有这样的检测条件：\n\n```c++\nitem1.isbn() == item2.isbn()\n```\n\n调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数。\n\n使用**点运算符（.）**来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。\n\n我们使用**调用运算符（()）**来调用一个函数，它是一对圆括号，里面放实参列表（可能为空）。# 第二章\n1. 'void*'\n是一种特殊的指针类，可以存放任意对象的地址。  \n2. const 对象必须初始化。 const int buf =10  \n3. const 指针，其值不能被改变，所有必须初始化。\n4. 顶层const和底层const，顶层const表示指针本身是一个常量，底层const表示指针所指对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。\n\n```\nint i = 0;\nint *const p1 = &i;    // 不能改变p1的值，p1是一个顶层const\nconst int ci = 42；    // 不能改变ci的值，ci是一个顶层const\nconst int *p2 = &ci;   // 允许改变p2的值，p2是一个底层const\nconst int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const\nconst int &r = ci;     // 用于声明引用的const都是底层const\n```\n\nC++新标准引入了第二种类型说明符**decltype**，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：\n\n```\ndecltype(f()) sum = x; // sum的类型就是函数f的返回类型\n```\n\n编译器并不实际调用f，而是使用当调用发生时f的返回值的类型作为sum的类型。\n\n如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n\n```\nconst int ci = 0, &cj = ci;\ndecltype(ci) x = 0; // x的类型是const int\ndecltype(cj) y = x; // y的类型是const int&, y绑定到x\n```\n\n**decltype和引用**\n\n如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式向decltype返回一个引用类型，一般来说，意味着该表达式的结果对象能作为一条赋值语句的左值：\n\n```\n// decltype的结果可以是引用类型\nint i = 42, *p = &i, &r = i;\ndecltype(r + 0) b; // 正确，加法的结果是int，因此b是一个int\ndecltype(*p) c; // 错误，c是int&，必须初始化\n```\n\n如果表达式的内容是解引用操作，则decltype将得到引用类型。\n\n有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：\n\n```\n// decltype的表达式如果是加上了括号的变量，结果是引用\ndecltype((i)) d; // 错误，d是int&，必须初始化\ndecltype(i) e; // 正确，e是一个int。\n```\n\n\n**auto 和decltype的区别主要有三个方面**：\n第一，auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。\n第二，编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。\n第三，与auto不同，decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。\n\n\n# 字符串、向量和数组\n\n## String\n1. **头文件不应包含using声明**  \n2. **初始化string对象的方式：**  \n```c++\nstring s1;           // 默认初始化，s1是一个空串\nstring s2(s1);       // s2是s1的副本\nstring s2 = s1;      // 等价于s2(s1)\nstring s3(\"value\");  // s3是字面值\"value\"的副本，不包括最后的空字符\nstring s3 = \"value\"; // 等价于s3(\"value\")\nstring s4(n, 'c');   // 初始化为由n个字符c组成的串\n```  \n3. **直接初始化和拷贝初始化**  \n\n如果使用等号（=）初始化一个变量，实际上执行的是**拷贝初始化（copy initialization）**，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是**直接初始化**（direct initialization）。  \n```c++\nstring s5 = \"hiya\";  // 拷贝初始化\nstring s6(\"hiya\");   // 直接初始化\nstring s7(10, 'c');  // 直接初始化\n```  \n4. getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。  \n\n**string::size_type类型**  \n\nsize函数返回的是一个string::size_type类型的值。这是一个无符号的整数。  \n5. **处理每个字符？使用基于范围的for语句**  \n\n如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：**范围for**（range for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：  \n\n```c++\nfor (declaration : expression)\n    statement\n```  \n如：  \n```c++\nfor (auto c : str)\n    // do something\n```  \n**使用下标运算符**\n\n`[ ]`符号叫做下标运算符，范围是`[0, s.size())`，越界的结果是UB（undefined behavior，未定义行为）。  \n\n## Vector\n1. vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。  \n2. vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。  \n3. vector是模板而非类型，由vector生成的类型必须包含元素的类型，如：  \n```c++\nvector<int> v;\n```  \n4. **vector中存放的是对象，而引用不是对象，故不能存储引用。**  \n### 定义和初始化vector对象  \nvector模板控制着初始化向量的方法。定义vector对象的方法有：  \n- `vector<T> v1`，默认初始化，v1是一个空的vector  \n- `vector<T> v2(v1)`，v2中包含v1所有元素的副本  \n- `vector<T> v2 = v1`，等价于v2(v1)  \n- `vector<T> v3(n, val)`，v3包含了n个重复的元素，每个元素的值都是val  \n- `vector<T> v4(n)`，v4包含了n个执行了值初始化的对象  \n- `vector<T> v5{a,b,c...}`，v5里包含了用a,b,c...初始化的元素  \n- `vector<T> v5 = {a,b,c...}`，等价于`vector<T> v5{a,b,c...}`  \n**值初始化**  \n值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。\n`vector<T>(n)`中，所有元素将执行值初始化。\n### 向vector中添加元素\npush_back函数把一个元素压入vector对象的尾端。  \nvector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。  \n**一定不能在遍历vector的时候改变vector对象的大小。**  \nC++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。  \n### 其它vector操作\n如（很多和string类似）：\n- `v.empty()`，如果v不含有任何元素，返回true  \n- `v.size()`，返回v中的元素个数  \n- `v[n]`，返回v中第n个位置上元素的引用  \n- `v1 = v2`，v2中的元素将拷贝替换v1的  \n- `v1 = {a,b,c...}`，列表中的元素将拷贝替换v1中的  \n- `v1 == v2`, `v1 != v2`，元素数量相同，对应位置的元素也相等，则相等  \n- <,<=,>,>=，比首个相异元素的大小，如都一样，比长度，即字典顺序  \nsize返回的类型由vector定义的size_type类型。\n```c++\nvector<int>::size_type    // 正确\nvector::size_type         // 错误\n```  \n**只有当元素的值可比较时，vector对象才能被比较。只能对确已存在的元素执行下标操作。**  \n## 迭代器介绍\n使用迭代器（iterator）是一种通用的访问容器中元素的方法。\n迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。\n### 使用迭代器\n有迭代器的类型同时拥有返回迭代器的成员。  \n标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。  \nend成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫**尾后迭代器（off-the-end iterator）**。  \n如果容器为空，begin和end都返回尾后迭代器。即：`v.begin() == v.end()`  \n如：  \n```c++\nauto b = v.begin();\nauto e = v.end();\n```  \n**迭代器运算符**  \n标准容器迭代器的运算符：  \n- `*iter`，返回迭代器所指对象的引用（解引用）  \n- `iter->mem`，解引用iter，并获取其成员mem，等价于`(*iter).mem`  \n- `++iter`，令iter指示容器中的下一个元素  \n- `--iter`，令iter指示容器中的上一个元素  \n- `iter1 == iter2`，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等  \n迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。  \n**迭代器类型**  \n标准库类型使用iterator和const_iterator来表示迭代器类型。  \n如：\n```c++\nvector<int>::iterator it1;\nvector<int>::const_iterator it2;\n```  \nit1能读写元素，而it2只能读。  \n认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。  \n**begin和end运算符**begin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。  \n为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：  \n```c++\nauto it = v.cbegin();\n```  \n**箭头运算符**即`->`，它把解引用和成员访问两个操作结合在一起。即：`(*iter).mem`等价于`iter->mem`。  \n**某些对vector对象的操作会使迭代器失效**任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。\n### 迭代器运算  \n递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。  \nstring和vector的迭代器提供了额外的运算符，有：  \n- `iter + n`，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器  \n- `iter - n`，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器  \n- `iter1 - iter2`，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  \n- `>,>=,<,<=`，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置    \n**迭代器的算数运算**  \n迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。  \ndifference_type是一个带符号的整数，string和vector都定义了这个类型。  \n**迭代器相加没有意义**\n```c++\nauto mid = (beg) +(end-beg)/2;//正确\nauto mid =(beg+end)/2;//错误 迭代器加法不存在\n```  \nstring类本身接受无参数的初始化方式，无论数组定义在函数体内部还是外部都被默认初始化为空串，对于内置类型int，数组定义在函数体外部时默认初始化为0，在main函数内部时，将不被初始化。\n\n## 数组\n1. 数组是存放相同类型的对象的容器，这些对象是匿名的。  \n2. 数组的大小确定不变。  \n3. 数组是一种内置类型。  \n### 定义和初始化内置数组\n数组是一种复合类型，其声明形如`a[N]`  。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个**常量表达式**，即其值在编译期间已知。  \n默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。  \n定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。  \n**显式初始化数组元素**\n即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。如：  \n```c++\nint a1[10] = {0}; // 剩下的元素执行值初始化，即为0\nint a2[] = {1, 2, 3};\n```\n**字符数组的特殊性**可以用字符串字面值对此类数组进行初始化。如：  \n```c++\nchar s[] = \"hello\";\n```\n这样初始化的数组包含结尾的空字符。  \n**不允许拷贝和赋值**\n这样的操作是非法的：  \n```c++\nint a1[] = {1, 2, 3};\nint a2[] = a1; // 非法\n```\n**理解复杂的数组声明**  \n1. 定义一个指针数组\n```c++\nint* a[10] = {};\n```  \n2. 定义一个指向数组的指针：  \n```c++\nint (*ptr)[10] = &a;\n```  \n3. 定义一个绑定到数组的引用：  \n```c++\nint (&a_ref)[10] = a;\n```  \n默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。  \n### 访问数组元素  \n使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。可以使用范围for语句来遍历数组。  \n```c++\nfor (auto i : arr)\n    cout << i << \" \";\ncout << endl;\n```  \n**得到数组的大小**\n```\nsizeof(array/sizeof(array[0];\n```\n**检查下标的值**  \n与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。  \n### 指针和数组\n在很多用到数组名字的地方，编译器都会自动地将其替换为一个**指向数组首元素的指针**。  \n**decltype**\n下面得到一个数组类型：   \n```c++\nint a1[10] = {};\ndecltype(a1) a2;\n```  \n**auto**\n下面得到一个整型指针：\n```c++\nint a1[10] = {};\nauto a2(a1);\n```  \n**指针也是迭代器**  \nstring和vector的迭代器支持的运算，指针都支持。使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。这样可以获取数组尾元素的下一个位置的指针：\n```c++\nint *end = &a[N];\n```  \n不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：\n```c++\nint a[10] = {};\nint *beg_p = begin(a);\nint *end_p = end(a);\n```  \n这俩函数定义在头文件iterator.h中。尾后指针不能解引用和递增操作。和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。  \n**下标和指针**  \n对数组执行下标运算其实是对指向数组元素的指针执行下标运算：  \n```c++\nint i = ia[2];    // ia转换成指向数组首元素的指针\n                  // ia[2]得到(ia + 2)所指的元素\nint *p = ia;      // p指向ia的首元素\ni = *(p + 2);     // 等价于i = ia[2]\n```  \n只要指针指向的是数组中的元素，都可以执行下标运算。  \n内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。  \n### C风格字符串  \nC风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null terminated）。\np109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。  \n**c_str函数**\nstring可使用c_str函数返回其C风格的字符串，如：  \n```c++\nstring s(\"hello\");\nconst char *c_s = s.c_str();\n```\n无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方\n**使用数组初始化vector对象**如：  \n```c++\nint a[] = {1, 2, 3};\nvector<int> vec(begin(a), end(a));\n```  \n## 多维数组\n多维数组，实际上是数组的数组。\n如：`int a[3][4]`，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。\n对于二维数组，常把第一个维度看作行，第二个维度看作列。  \n**多维数组的初始化**如：  \n```c++\nint a[3][4] = {\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9, 10, 11}\n};\n```  \n列表初始化中未列出的元素执行值初始化。  \n**多维数组的下标引用**  \n如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组\n```c++\nint a[3][4] = {};\nint (&row)[4] = a[2]; // row绑定到a的第二个数组上\n```  \n**使用范围for语句处理多维数组**  \n如果是外层循环，控制变量将得到数组类型。\n除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。  \n**指针和多维数组**\n当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。  \n多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。  \n即：\n```c++\nint a[2][3] = {};\nint (*p)[3] = a;\n```  \n还可以使用auto或者begin来得到指向内层数组的指针。  \n**类型别名简化多维数组的指针**  \n可以这样定义一个数组类型：\n```c++\nusing int_arr = int[4]; // C++11\ntypedef int int_arr[4];\n```  \n**指针**  \n1. 指针本身的值（value）；\n2. 指针所指的对象（content）；\n3. 指针本身在内存中的储存位置（address）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 表达式\n1. `*iter.empty()`和`(*iter).empty()`和`iter->empty()`的区别  \n2. `somevalue ? ++x,++y:--x,--y;`等价于`(somevalue ? ++x,++y:--x),--y;`\n# 位运算符\n\n位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。\n|运算符|功能|用法|\n|-|-|-|\n|~|位求反|~expr|\n|<<|左移|expr1 << expr2|\n|>>|右移|expr1 >> expr2|\n|&|位与|expr1 & expr2|\n|^|位异或|expr1 ^ expr2|\n|\\||位或|expr1 \\| expr2|\n  \n一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。  \n强烈建议将位运算符用于处理无符号类型。  \n一个提升例子就是，如果对char做位运算，它会先被提升为int。  \n**移位运算符**\n<<和>>  \n运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。  \n左移运算符<<在右侧插入值为0的二进制位。右移运算符>>的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。  \n# sizeof运算符  \nsizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：  \n- sizeof(type)\n- sizeof?expr\n常量表达式意味着在编译期间就能得到计算。  \n第二种形式中，sizeof返回的是表达式结果类型的大小。  \nsizeof运算符的结果部分地依赖于其作用的类型：  \n- 对char或者类型为char的表达式执行sizeof运算，结果得1。\n- 对引用类型执行sizeof运算得到被引用对象所占空间大小。\n- 对指针执行sizeof运算得到指针本身所占空间的大小。\n- 对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。\n- 对数组执行sizeof运算得到整个数组所占空间大小。\n- 对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。\n# ?显式转换\n**命名的强制类型转换**  \n一个命名的强制类型转换有如下形式：  \ncast-name<type>(expression);  \n其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast,?dynamic_cast,?const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。  \n**static_cast**  \n任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。\n```\n//?进行强制类型转换以便执行浮点数除法\ndouble?slope?=?static_cast<double>(j)?/?i;\n```  \n当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。  \nstatic_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void\\*的指针中的值：  \n```\nvoid?*p?=?&d;????//?正确，任何非常量对象的地址都能存入void*\n\n//?正确，将void*转换回初始的指针类型\ndouble?*dp?=?static_cast<double*>(p);\n```  \n必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。  \n**const_cast**  \nconst_cast只能改变运算对象的底层const：  \n```\nconst?char?*pc;\nchar?*p?=?const_cast<char*>(pc);????//?正确，但是通过p写值是未定义的行为\n```  \n如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。  \nconst_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。  \n**reinterpret_cast**  \nreinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：  \n```\nint?*ip;\nchar?*pc?=?reinterpret_cast<char*>(ip);\n```  \n我们必须牢记pc所指的真实对象是一个int而非字符。  \n\treinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。  \n**旧式的强制类型转换**  \n在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：  \n```\ntype(expr);???//?函数形式的强制类型转换\n(type)expr;???//?C语言风格的强制类型转换\n```  \n根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast,?static_cast或reinterpret_cast相似的行为。  \n\t与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。# try语句块\ntry语句块的通用语法形式是：  \n```c++\ntry {\n    program-statements\n} catch (exception-declaration) {\n    handler-statements\n} // ...\n```  \n当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。  \ntry语句块内声明的变量在catch子句内无法访问。  \n一个简要的例子：  \n```c++\nwhile (cin >> item1 >> item2) {\n    try {\n        // ... 可能抛出一个异常的代码\n    } catch (runtime_error err) {\n        cout << err.what() << \"\\nTry Again? Enter y or n\" << endl;\n        char c;\n        cin >> c;\n        if (!cin || c == 'n')\n            break; // 跳出while循环\n    }\n}\n```  \n# throw表达式\n抛出异常的一个例子是：  \n```c++\nthrow runtime_error(\"Data must refer to same ISBN\");\n```  \n该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。  \n- **throw 表达式（throw expression）**，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw**引发（raise）**了异常。  \n- **try语句块（try block）**，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个**catch子句（catch clause）**结束。try语句块中代码抛出的异常通常会被某个catch子句处理。  \n- 一套**异常类（exception class）**，用于在throw表达式和相关的catch子句之间传递异常的具体信息。  \n# 简单语句\nC++语言中的大多数语句都以分号结束，一个表达式，比如ival+5，末尾加上分号就变成了**表达式语句**(expression statement)，表达式语句的作用是执行表达式并丢弃掉求值结果：\n```c++\nival + 5;    // 无意义的表达式语句\ncout << ival;// 有意义的表达式语句\n```  \n**空语句**  \n最简单的语句是**空语句**（null statement），它只有一个分号： \n```c++\n; // 空语句\n```  \n如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。  \n**复合语句（块）**  \n复合语句（compound statement）是指用花括号括起来的语句和声明的序列，复合语句也被称作**块**（block）。一个块就是一个作用域。  \n如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。  \n所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：  \n```c++\nwhile (cin >> s && s != sought)\n{}  // 空块\n```  \n# 语句作用域\n可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：  \n```c++\nwhile (int i = get_num()) // 每次迭代时创建并初始化\n    cout << i << endl;\ni = 0;    // 错误，在循环外部无法访问\n```  \n# 条件语句\nC++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流；另一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。  \n## if语句\nif语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。  \n## switch语句\nswitch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。  \n# 迭代语句\n迭代语句通常称之为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。  \n## while语句\n语法格式是：  \n```c++\nwhile (condition)\n    statement\n```  \n只要condition的求值结果为真就一直执行statement。如果condition第一次求值就是false，statement一次都不执行。  \nwhile的条件部分可以是一个表达式或者是一个带初始化的变量声明。  \n**使用while循环**  \n当不确定到底要迭代多少次时，使用while循环比较合适。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。  \n## 传统的for语句  \nfor语句的语法形式是  \n```c++\nfor (init-statement: condition; expression)\n    statement\n```\n## 范围for语句\nC++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。**范围for语句**（range for statement）的语法形式是：\n```c++\nfor (declaration : expression)\n    statement\n```\nexpression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。  \ndeclaration定义一个变量，序列中的每个元素都能转换成该变量的类型。  \n每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。  \n在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。因此不能通过范围for语句增加vector对象的元素。  \n## do while语句\ndo while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少会执行一次循环。do while语句的语法形式如下：  \n```c++\ndo\n    statement\nwhile (condition);\n```\n## 跳转语句  \n跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break, continue, goto和return。本章介绍前三种，return在第六章介绍（p199页）。  \n## break语句\nbreak语句负责终止离它最近的while, do while, for或switch语句，并从这些语句之后的第一条语句开始执行。\n## continue语句\ncontinue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for, while和do while循环的内部。  \n## goto语句  \ngoto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 函数 \n函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。  \n---\n## 函数基础  \n一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。  \n我们通过**调用运算符（call operator）**来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。  \n函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，**主调函数**（calling function）的执行暂时被中断，**被调函数**（called function）开始执行。  \n当遇到一条return语句时函数结束执行过程。函数的返回值用于初始化调用表达式的结果。  \n**函数返回类型**\n大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何类型。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。  \n### 局部对象\n在C++语言中，名字有作用域，对象有**生命周期（lifetime）**，理解这两个概念非常重要：  \n- 名字的作用域是程序文本的一部分，名字在其中可见。  \n- 对象的生命周期是程序执行过程中该对象存在的一段时间。  \n形参和函数体内部定义的变量统称为**局部变量（local variable）**。它们仅在函数的作用域内可见。  \n在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。  \n**自动对象**  \n对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为**自动对象（automatic object）**。  \n形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。  \n对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化（内置类型产生未定义的值）。  \n**局部静态对象（local static object）**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。例：  \n```c++\n// 统计函数被调用了多少次\nsize_t count_calls()\n{\n    static size_t ctr = 0; // 调用结束后，这个值仍然有效\n    return ++ctr;\n}\n```  \n### 函数声明\n函数的名字必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。  \n函数的声明和定义唯一的区别是**声明无须函数体**，用一个分号替代即可。  \n函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作**函数原型（function prototype）**。  \n**在头文件中进行函数声明**\n我们建议函数在头文件中声明，在源文件中定义。\n这是因为如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。\n定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。  \n### 分离式编译\nC++语言支持所谓的**分离式编译（separate compilation）**。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。  \n\n\n## 参数传递\n如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。  \n当形参是引用类型时，我们说它对应的实参被**引用传递**（passed by reference）或者函数被**传引用调用**（called by reference）。  \n当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被**值传递**（passed by value）或函数被**传值调用**（called by value）。  \n### 传值参数\n当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。  \n**指针形参**  \n当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。  \n\t熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。\n\n### 传引用参数\n对于引用的操作实际上是作用于引用所引的对象上，引用形参也是如此。通过使用引用形参，允许函数改变一个或多个实参的值。  \n**使用引用避免拷贝**  \n拷贝大的类类型对象或者容器对象比较低效。甚至有的类型根本就不支持拷贝操作。此时应该使用引用形参访问该类型的对象。  \n如果函数无须改变引用形参的值，最好将其声明为常量引用。  \n**使用引用形参返回额外信息**  \n一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。那就是通过引用形参并修改它（也就是修改了其引用的对象），从而作为结果传出。  \n### const形参和实参\n当形参是const时，必须注意关于顶层const的讨论（p57）。  \n当用实参初始化形参时会忽略形参的顶层const。即当形参有顶层const时，传递给它常量对象或者非常量对象都是可以的。  \n忽略形参的顶层const可能产生意想不到的结果：  \n```c++\nvoid fcn(const int i) {}\nvoid fcn(int i) {}    // 错误：重复定义\n```  \n在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表有明显的区别。因为顶层const被忽略了，所以在上面的代码中传入两个fcn函数的参数可以完全一样（从而编译器不知道该调用哪一个）。  \n**指针或引用形参与const**  \n我们可以使用非常量初始化一个底层const，但是反过来不行（不能用一个常量初始化一个非底层const）；同时一个普通的引用必须用同类型的对象初始化。  \n**尽量使用常量引用**  \n把函数不会改变的形参定义成（普通的）引用是一种常见错误，这么做给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型（比如无法传入一个常量对象了）。  \n比如下面这个例子将导致编译错误（p192）：\n```c++\n// 不良设计，第一个形参的类型应该是const string&\nstring::size_type find_char(string &s, char c, string::size_type &occurs);\n//...\nfind_char(\"Hello World\", 'o', ctr); // 无法编译通过\n```\n### 数组形参\n当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。  \n尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：  \n```c++\n// 每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);    // 可以看出来，函数的意图是作用于一个数组\nvoid print(const int[10]);  // 这里的维度表示我们期望数组含有多少元素，实际不一定\n```  \n\t和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。  \n因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技术。  \n1. 使用标记指定数组长度，如C风格字符串。  \n2. 使用标准库规范，如传递首元素和尾后元素的指针，来表示一个范围。  \n3. 显示传递一个表示数组大小的形参。  \n**数组形参和const**  \n当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。  \n**数组引用形参**  \nC++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。  \n```c++\n// 正确，形参是数组的引用，维度是类型的一部分\nvoid print(int (&arr)[10])\n{\n    for (auto elem : arr)\n        cout << elem << endl;\n}\n```  \n但这一用法也限制了print函数的可用性，我们只能将函数作用于大小为10的数组。  \n**传递多维数组**  \n和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，也就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：  \n```c++\n// matrix指向数组的首元素，该数组的元素是由10个整数构成的数组\nvoid print(int (*matrix)[10], int rowSize) { /* ... */ }\n```  \n\t`*matrix`两端的括号必不可少：`int *matrix[10]//10个指针构成的数组`；`int (*matrix)[10]//指向含有10个整数的数组的指针`。\n也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：  \n```c++\n// 等价定义\nvoid print(int matrix[][10], int rowSize) { /* ... */ }\n```  \nmatrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。  \n### main: 处理命令行选项\n有时候我们需要给main函数传递实参。一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如：  \n```c++\nprog -d -o ofile data0\n```\n这些命令行选项通过两个（可选的）形参传递给main函数。  \n```c++\nint main(int argc, char *argv[]) { ... }\n```  \n第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量；argc至少为1。  \n当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。  \n以上面的为例，argc应该等于5，argv应该包含如下的C风格字符串：  \n```c++\nargv[0] = \"prog\";    // 或者argv[0]也可以指向一个空字符串\nargv[1] = \"-d\";\nargv[2] = \"-o\";\nargv[3] = \"ofile\";\nargv[4] = \"data0\";\nargv[5] = 0;\n```  \n\t当使用argv中的实参时，一定要记得可选的实参从`argv[1]`开始；`argv[0]`保存程序的名字，而非用户的输入。\n### 含有可变形参的函数\n为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：\n1. 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；  \n2. 如果实参的类型不同，我们可以编写一种可变参数模板，其细节将在16.4节介绍（p618）。  \nC++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序。  \n**initializer_list形参**  \ninitializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。  \n与vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。  \n**省略符形参**  \n省略符形参是为了便于C++程序访问某些特殊的C代码而设置的。  \n\t省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。  \n省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：  \n```c++\nvoid foo(param_list, ...);\nvoid foo(...);\n```  \n## 返回类型和return语句\nreturn语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。  \nreturn语句有两种形式：  \n```c++\nreturn;\nreturn expression;\n```  \n### 无返回值函数\n没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。  \n### 有返回值函数  \n只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。  \n**值是如何被返回的**  \n返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。  \n如果函数返回引用，则该引用仅是它所引对象的一个别名。  \n**不要返回局部对象的引用或指针**  \n函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。  \n**返回类类型的函数和调用运算符**  \n调用运算符的优先级和点运算符、箭头运算符相同，并且符合左结合律。\n```c++\n//调用string对象的size成员，该string对象有shorterstring函数返回\nauto sz = shorterstring(s1,s2).size();\n```\n**引用返回左值**  \n函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。  \n```c++\nchar &get_val(string &str,string::size_type ix){\n\treturn str[ix];\n}\nint main(){\n\tstring s(\"a value\");\n\tcout<<s<<endl;\n\tget_val(s,0)='A';\n\tcout<<s<<endl;\n\treturn 0;\t\n}\n```\n**列表初始化返回值**  \nC++11新标准规定，函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。  \n**主函数main的返回值**  \n我们允许main函数没有return语句直接结束，这样编译器将隐式地插入一条返回0的return语句，表示执行成功。  \n为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，可以用来表示成功与失败：  \n```c++\nint main()\n{\n    if (some_failure)\n        return EXIT_FAILURE;\n    else\n        return EXIT_SUCCESS;\n}\n```  \n**递归**\n如果函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为**递归函数**（recursive function）。  \n在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。  \n\tmain函数不能调用它自己。  \n### 返回数组指针\n因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。使用**类型别名**（p60）可以简化这种返回类型：  \n```c++\ntypedef int arrT[10];    // arrT是一个类型别名，表示含有10个整数的数组\nusing arrT = int[10];    // arrT的等价声明\narrT* func(int i);       // func返回一个指向含有10个整数的数组的指针\n```  \n**声明一个返回数组指针的函数**  \n返回数组指针的函数形式如下：  \n```c++\nType (*function(param_list))[dimension]\n```\n类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（\\*表示返回的是一个指针。）例：  \n```c++\nint (*func(int i))[10];\n```  \n可以按照以下的顺序来逐层理解该声明的含义：  \n- `func(int i)`表示调用func函数时需要一个int类型的实参。  \n- `(*func(int i))`意味着我们可以对函数的调用结果执行解引用操作。  \n- `(*func(int i))[10]`表示解引用func的调用将得到一个大小是10的数组。  \n- `int (*func(int i))[10]`表示数组中的元素是int类型。  \n**使用尾置返回类型**  \nC++新标准提供了另一种简化上述func声明的方法，就是使用**尾置返回类型（trailing return type）**。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。  \n尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个`auto`：  \n```c++\n// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -> int(*)[10];\n```  \n**使用decltype**  \n如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型（即获得一个数组类型）。例：  \n```c++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *arrPtr(int i)\n{\n    return (i % 2) ? &odd : &even;\n}\n```  \n\t decltype并不负责把数组类型转换成对应的指针，所以decltype的结果只是一个数组，要想表示arrptr返回指针还必须在函数声明时加一个`*`的符号。\n## 函数重载\n如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载（overload）函数**。比如：  \n```c++\nvoid print(const char *cp);\nvoid print(const int *beg, const int *end);\nvoid print(const int ia[], size_t size);\n```  \n这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。  \n函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。  \nmain函数不能重载。  \n不允许两个函数除了返回类型以外其他所有的要素都相同。比如：  \n```c++\nRecord lookup(const Account&);\nbool lookup(const Account&);    // 错误，与上一个函数相比只有返回类型不同\n```  \n\t my note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。  \n**重载和const形参**  \n顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：  \n```c++\nRecord lookup(Phone);\nRecord lookup(const Phone);    // 重复声明\n```  \n如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：  \n```c++\nRecord lookup(Account&);       // 此函数作用于Account的引用\nRecord lookup(const Account&); // 新函数，作用于常量引用\n```  \n这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。  \n**const_cast和重载**  \nconst_cast在重载函数的情境中最有用。比如这两个重载函数：  \n```c++\n// 比较两个string对象的长度，返回较短的那个引用\nconst string &shorterString(const string &s1, const string &s2)\n{\n    return s1.size() <= s2.size() ? s1 : s2; \n}\n\n// 重载\nstring &shorterString(string &s1, string &s2)\n{\n    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));\n    return const_cast<string&>(r);\n}\n```\n下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const&，这显然是安全的。  \n\t传入非常量的实参将调用非常量的版本。  \n**调用重载的函数**  \n定义了一组重载函数后，我们需要以合理的实参调用它们。**函数匹配（function matching）**是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。  \n当调用重载函数时有三种可能的结果：  \n- 编译器找到一个与实参**最佳匹配（best match）**的函数，并生成调用该函数的代码。\n- 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配（no match）**的错误信息。\n- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用（ambiguous call）**。\n### 重载与作用域  \n一般来说，将函数声明置于局部作用域内不是一个明智的选择。  \n如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。  \n## 特殊用途语言特性\n### 默认实参\n这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的**默认实参**（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：  \n```c++\ntypedef string::size_type sz;\nstring screen(sz ht = 24, sz wid = 80, char backrnd = ' ');\n```\n一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。  \n**使用默认实参调用函数**  \n如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：  \n```c++\nstring window;\nwindow = screen();    // 等价于screen(24, 80, ' ');\nwindow = stcreen(66); // 等价于screen(66, 80, ' ');\n```  \n函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。  \n当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。  \n**默认实参初始值**  \n局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。  \n如：\n```c++\nint g_a = 0;\nvoid f(int a = g_a);\n```  \n### 内联函数和constexpr函数\n调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。  \n**内联函数可以避免函数调用的开销**  \n将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。  \n内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。  \n内联机制用于优化规模小，流程直接，频繁调用的函数。  \n**constexpr函数**  \n是指能用于**常量表达式**的函数。  \n函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。如：  \n```c++\nconstexpr int new_sz() { return 8; }\nconstexpr int foo = new_sz();\n```\nconstexpr函数被隐式地指定为内联函数。  \n**把内联函数和constexpr函数放在头文件内**  \n这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。  \n### 调试帮助\n程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。  \n**assert预处理宏**  \nassert是一种**预处理宏（preprocessor macro）**。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：  \n```c++\nassert(expr);\n```\n首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。  \nassert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无需提供using声明。  \nassert宏常用于检查“不能发生”的条件。\n**NDEBUG预处理变量**  \nassert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。  \n我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：  \n```c++\n$ CC -D NDEBUG main.c\n```  \n这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。  \n我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。  \n除了用于assert，也可以使用NDEBUG编写自己的调试代码。  \n比如：  \n```c++\nvoid print(const int ia[], size_t size)\n{\n#ifndef NDEBUG\n    // __func__是编译器定义的一个局部静态变量，用于存放函数的名字\n    cerr << __func__ << \"\": array size is: \" << size << endl;\n#endif\n\n// ...\n}\n```  \n编译器为每个函数都定义了`__func__`，除此之外，预处理器还定义了4个对于调试程序很有用的名字：  \n- `__FILE__`, 存放文件名的字符串字面值。  \n- `__LINE__`, 存放当前行号的整型字面值。  \n- `__TIME__`, 存放文件编译时间的字符串字面值。  \n- `__DATA__`, 存放文件编译日期的字符串字面值。  \n## 函数匹配\n以下述这组函数及其调用为例,讲述编译器如何确定调用哪个重载函数:  \n```c++\nvoid f();\nvoid f(int);\nvoid f(int, int);\nvoid f(double, double = 3.14);\nf(5.6);    // 调用void f(double, double);\n```  \n**确定候选函数和可行函数**  \n函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为**候选函数（candidate function）**。候选函数具备两个特征：  \n1. 与被调用函数同名。  \n2. 其声明在调用点可见。  \n第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数（viable function）**。可行函数也有两个特征：  \n1. 其形参数量与本次调用提供的实参数量相等。  \n2. 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。\n\t如果没有找到可行函数，编译器将报告无匹配函数的错误。\n**寻找最佳匹配（如果有的话）**  \n第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。  \n如果有且只有一个函数满足下列条件，则匹配成功：  \n- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。  \n- 至少有一个实参的匹配优于其他可行函数提供的匹配。  \n\t如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。  \n### 实参类型转换\n为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：  \n1. 精确匹配，包括以下情况：  \n- 实参类型和形参类型相同。  \n- 实参从数组类型或函数类型转换成对应的指针类型。  \n- 向实参添加顶层const或者从实参中删除顶层const。  \n2. 通过const转换实现的匹配（p143）。  \n3. 通过类型提升实现的匹配（p142）。  \n4. 通过算数类型转换或指针转换实现的匹配（p142）。  \n5. 通过类类型转换实现的匹配（参见14.9节，p514）。\n**需要类型提升和算术类型转换的匹配**  \n**函数匹配和const实参**  \n```c++\nint calc(char*,char*)\nint calc(const char*,const char*)\n//区别是他们的指针类型的形参是否指向了常量，属于底层const，合法定义\n```\n```c++\nint calc(char*,char*)\nint calc(char* const,char* const)\n//区别是他们的指针类型的形参是否是常量，属于顶层const,非法定义\n```\n## 函数指针\n函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：   \n```c++\nbool lengthCompare(const string&, const string&);\n```  \n该函数的类型是：`bool (const string&, const string&);`  \n要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：  \n```c++\nbool (*pf)(const string&, const string&);\n```  \n**使用函数指针**  \n当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。  \n例如，可以这样给把函数地址赋值给指针：  \n```c++\npf = lengthCompare; // pf指向名为lengthCompare的函数\npf = &lengthCompare; // 等价的赋值语句，取地址符是可选的\n```  \n可以直接对指向函数的指针调用该函数，无须解引用指针：  \n```\nbool b1 = pf(\"Hello\", \"Hi\");\nbool b2 = (*pf)(\"Hello\", \"Hi\"); // 等价调用\nbool b3 = lengthCompare(\"Hello\", \"Hi\"); // 等价调用\n```  \n可以给函数指针赋一个nullptr或0，表示没有指向任何函数。  \n**重载函数的指针**  \n当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。  \n**函数指针形参**  \n不能定义函数类型的形参，但是形参可以是指向函数的指针。  \n当把函数名作为实参使用，它会自动转换成指针。  \n定义一个函数（以及指针）类型的方法有：  \n- typedef  \n```c++\ntypedef bool Func(int); // Func是函数类型\ntypedef bool (*FuncP)(int); // FuncP是函数指针类型\n```  \n- decltype  \n假如已经有了一个函数：`bool Foo(int);`  \n```c++\ndecltype(Foo) Func;\ndecltype(Foo) *FuncP;\n```\n- using  \n```c++\nusing Func = bool(int);\nusing FuncP = bool(*)(int);\n```  \n**返回指针函数的指针**\n和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名：  \n```c++\nusing F=int(int*，int)；//F是函数类型，不是指针\nusing PF=int(*)(int*，int)；//PF是指针类型\n```\n其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针：  \n```\nPF f1(int);//正确：PF是指向函数的指针，f1返回指向函数的指针\nF f1(int);//错误：F是函数类型，f1不能返回一个函数\nF *f1(int);//正确：显式地指定返回类型是指向函数的指针\n```\n\t出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式(参见6.3.3节，第206页)声明一个返回函数指针的函数：\n```c++\nauto fl(int)->int(*)(int*，int);\n```\n**将auto和decltype用于函数指针类型**  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 类\n\n类的基本思想是**数据抽象**(data abstraction)和**封装**(encapsulation)。\n\n数据抽象就是**接口(interface)与实现(implementation)分离**的技术。\n\n接口就是暴露给用户的操作，比如公有的成员函数。\n\n实现就是数据成员、接口的实现、私有的成员函数。\n\n通过**抽象数据类型(abstract data type)**，来实现数据抽象和封装。\n\n## 定义抽象数据类型\n\n封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。\n\n**定义成员函数**\n\n类内的所有成员必须声明在类的内部。\n\n类的成员函数可以定义在类的内部，也可以定义在类的外部。\n\n\t定义在类内部的函数是隐式的inline函数。\n\n**引入this**\n\n当调用一个成员函数时，实际上是替某个对象调用它。\n\n成员函数通过名为**this**的隐式参数来访问此对象。this指向了此对象的地址。\n\n在成员函数内部，可以省略this来访问成员。\n\nthis是一个常量指针，不能够修改其值。\n\n当成员函数中调用另一个成员函数时，将隐式传递this指针。\n\n```\nstd::string isbn() const {return this->bookNo;}\n```\n\n**引入const成员函数**\n\n参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。\n\nconst对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。\n\nC++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。\n\n\t常量对象，以及常量对象的引用或指针都只能调用常量成员函数。\n\n**类作用域和成员函数**\n\n类本身就是一个作用域。\n\n成员函数的定义必须包含其所属的类名（使用作用域运算符）。\n\n如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。\n\n成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。\n\n**定义一个返回this对象的函数**\n\n可以使用如下语句返回this对象：\n\n```c++\nreturn *this;\n```\n\n返回类型使用引用类型，表明返回的就是this所指的对象。\n\n一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。\n\n### 定义类相关的非成员函数\n\n有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。\n\n可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。\n\n有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。\n\n### 构造函数\n\n类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫**构造函数（constructor）**。\n\n每当类对象被创建，构造函数就会被执行。\n\n构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。\n\n对于const对象，构造函数执行完毕后，它才获得const属性。\n\n**合成的默认构造函数**\n\n如果对象没有初始值，它将执行默认初始化。\n\n类通过**默认构造函数(default constructor)**来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。\n\n合成的默认构造函数根据如下规则初始化类成员：\n\n- 如果存在类内初始值，使用它来初始化成员\n\n- 否则，对成员执行默认初始化\n\n**某些类不能依赖合成的默认构造函数**\n\n所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：\n\n- 如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。\n\n- 默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。\n\n- 有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。\n\n**=default的含义**\n\nC++11中，使用这种语句来让编译器生成一个默认构造函数：\n\n```c++\nSalesData() = default;\n```\n\n\t这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。\n\n**构造函数初始值列表**\n\n```c++\nSales_data(const std::string &s):\n\t\t\t\t\t\tbookNo(s){}\nSales_data(const std::string &s,unsigned n,double p):\n\t\t\t\t\t\tbookNo(s),units_sold(n),revenue(p*n){}\n```\n参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。\n\n它负责为对象的成员变量赋初值。\n\n如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。\n\n\t构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。\n**在类的外部定义构造函数**\n```c++\nSales data:：Sales data（std:：istream&is）\n{\nread（is，*this）；//read函数的作用是从is中读取一条交易信息然后\n\t\t//存入this对象中\n}\n```\n为了更好地理解调用函数 read的意义，要特别注意read的第二个参数是一个Sales data对象的引用。在7.1.2节（第232页）中曾经提到过，使用this来把对象当成一个整体访问，而非直接访问对象的某个成员。因此在此例中，我们使用*this将\n“this”对象作为实参传递给read函数。\n\n### 拷贝、赋值和析构\n\n拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。\n\n赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。\n\n析构函数，当一个变量不在存在时，会执行析构。\n\n这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。\n\n**某些类不能依赖合成的版本**\n\n如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。\n\n可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。\n\n## 访问控制与封装\n\n使用**访问说明符（access specifiers）**加强类的封装性。\n\n- public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。\n\n- private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。\n\n**class和struct**\n\n其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。\n\n\t作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。\n\n### 友元\n\n类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。即在函数或类前面加friend关键字。\n\n友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。\n\n一般来说，最好在类定义的开始或结束前的位置集中声明友元。\n\n\"封装的益处\"\n\t封装有两个重要的优点：\n\n\t- 确保用户代码不会无意间破坏封装对象的状态。\n\n\t- 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。\n\n## 类的其它特性\n\n### 类成员再探\n\n**定义一个类型成员**\n\n可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。\n\n通常放在类的开头位置。\n\n**令成员作为内联函数**\n\n规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。\n\n如果定义在类内的函数，默认就是inline的。\n\ninline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。\n\n**重载成员函数**\n\n和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。\n\n如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。\n\n**类数据成员的初始值**\n\n可以给类数据成员一个类内初始值。使用等号或者花括号。\n\n### 返回\\*this的成员函数\n\n返回引用的函数是左值的，意味着这些函数（返回\\*this）返回的是对象本身而非对象的副本。\n\n\t一个const成员函数如果以引用的形式返回\\*this，那么它的返回类型将是常量引用。\n\n但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是**重载一个非常量版本的接口**，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。\n\n建议：对于公共代码使用私有功能函数。\n\n### 类类型\n\n每个类是一个唯一的类型，即使其内容完全一样。\n\n**类的声明**\n\n可以暂时声明类而不定义它，这叫前置声明（forward declaration）。\n\n这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：\n\n- 定义指向这种类型的指针or引用\n\n- 声明以不完全类型为参数or返回值的函数\n\n要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。\n\n只有被定义，才能访问其成员。\n\n声明一个前置类型的方法：\n\n```c++\nclass A;\nstruct B;\nnamespace game\n{\n    class C;    // 前置声明一个在命名空间中的类\n}\n```\n\n### 友元再探\n\n类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。\n\n友元类有权访问本类的非公有成员。\n\n\n## 类的作用域\n\n一个类就是一个作用域。\n\n类的作用域之外，普通的成员只能通过对象、引用or指针访问。对于类型成员的访问，需要使用域运算符`::`来访问。\n\n### 名字查找与类的作用域\n\n编译器处理完类的全部声明后，才会处理成员函数的定义。因此成员函数体中可以使用类中定义的任何位置的名字。\n\n**成员函数中的名字查找**\n\n按如下方式解析：\n\n- 在块内查找声明\n\n- 在类内查找，所有成员都可以被考虑\n\n- 在类的外围作用域中查找\n\n## 构造函数再探\n\n### 构造函数初始值列表\n\n如果没有在构造函数的初始值列表中显示初始化成员，那么该成员将执行默认初始化。\n\n\t如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。\n```c++\nclass ConstRef{\npublic:\n\tConstRef(int ii);\nprivate:\n\tint i;\n\tconst int ci;\n\tint &i;\n};\nConstRef::ConstRef(int ii){\n\ti = ii;// 正确\n\tci = ii; //错误，不能给const赋值\n\tri = i; //错误：ri未被初始化\n}\n//正确形式\nConstRef::ConstRef(int ii)::i(ii),ci(ii),ri(i){}\n```\n\n**成员初始化的顺序**\n\n成员的初始化顺序和它们在类内的定义顺序一致。\n\n而非其在初始值列表中的顺序，初始值列表只是做了初始化的工作。所以要让初始值列表中的成员顺序与定义顺序一致。\n\n\t最好使构造函数初始值的顺序与成员声明的顺序一致，尽量避免用某些成员初始化其他成员。\n\t\n**有默认实参的构造函数**\n\n如果构造函数的所有实参都有默认实参，那么它实际上也同时定义了默认构造函数。\n\n### 委托构造函数\n\nC++11可以定义委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。\n\n当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。\n\n\t 即先执行受委托的构造函数内容，再执行自己的。\n\n### 默认构造函数的作用\n\n当对象被默认初始化或值初始化时，自动执行默认构造函数。\n\n默认构造函数在以下情况发生：\n\n- 不使用初始值定义一个非静态变量或者数组时\n\n- 当类含有类类型的成员且使用合成的默认构造函数时\n\n- 当类类型的成员没有在构造函数初始值列表中显式初始化时\n\n值初始化在以下情况下发生：\n\n- 数组初始化时，若提供的初始值少于数组大小时\n\n- 不使用初始值定义一个局部静态变量时\n\n- 书写形如T()的表达式显式请求值初始化时\n\n### 隐式的类类型转换\n\n如果构造函数只接受一个实参，则它实际上定义了**转换构造函数（converting constructor）**。\n\n即定义了一个隐式转换机制。如string的接受一个const char\\*版本的构造函数。\n\n使用explicit阻止这种隐式转换机制，explicit只能放到类内声明构造函数里。\n\n**只允许一步类类型转换**\n\n### 聚合类\n\n聚合类（aggregate class）使得用户可以直接访问其成员。当类满足如下条件时，是聚合的：\n\n- 所有成员都是public的\n\n- 没有定义任何构造函数\n\n- 没有类内初始值\n\n- 没有基类，没有virtual函数\n\n可以使用花括号括起来的成员初始值列表来初始化聚合类对象。\n\n### 字面值常量类（ Literal Classes）\n\n类也可以是字面值类型。\n\n这样的类可以含有constexpr函数成员，且符合constexpr函数的所有要求，且是隐式const的。\n\n数据成员都是字面值类型的聚合类是字面值常量类。\n\n如果不是聚合类，满足如下条件也是一个字面值常量类：\n\n- 数据成员都是字面值类型\n\n- 至少含有一个constexpr构造函数\n\n- 如果数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；类类型成员必须使用自己的constexpr构造函数\n\n- 类必须使用析构函数的默认定义\n\n**声明静态成员**\n\n在声明前加static关键字。\n\n静态成员可以是public或private。数据成员可以是常量，引用，指针，类类型等。\n\n对象不包含与静态数据成员有关的数据。\n\n静态函数不包含this指针。\n\n**使用类的静态成员**\n\n使用作用域运算符访问静态成员。\n\n类的对象、引用或指针可以访问静态成员。\n\n类的成员函数可以直接访问静态成员。\n\n**定义静态成员**\n\nstatic只能出现在类的内部，不能出现在外部。\n\n静态数据成员不属于类的对象，不是有构造函数初始化的。静态数据成员定义在函数体之外，一旦定义，就一直存在于程序的整个生命周期中。\n\n```c++\ndouble T::a = 1; // 定义并初始化一个静态成员\n```\n\n**静态成员的类内初始化**\n\n通常，不应该在类内初始化静态数据成员。\n\n不过，可以为静态成员提供const整数类型的类内初始值，且要求静态成员必须是字面值常量类型。\n\n\n# IO库\n\n## IO类\n为了支持不同种类的IO处理操作，标准库定义了这几种类型：\n\n- iostream 定义了用于读写流的基本类型\n\n- fstream 定义了读写命名文件的类型\n\n- sstream 定义了读写内存string对象的类型\n\n它们分别定义在同名的头文件中。\n\n**IO类型间的关系**\n\n类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。\n\n### IO对象无拷贝或赋值\n\n由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。\n\n读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。\n\n### 条件状态\nIO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。\n一个IO错误的例子：\n\n```c++\nint ival;\ncin >> ival;\n```\n\n如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。\n\n如果输入一个文件结束符标识，cin也会进入错误状态。\n\n一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：\n\n```c++\nwhile (cin >> word)\n    // ok\n```\n### 管理输出缓冲\n每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：\n\n```c++\nos << \"please enter a value: \";\n```\n\n文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。\n\n导致缓冲区刷新的原因有：\n\n- 程序正常结束\n\n- 缓冲区满时\n\n- 使用操纵符，如endl，来显式刷新缓冲区\n\n- 读cin或写cerr，都会导致cout的缓冲区被刷新\n\n**刷新输出缓冲区**\n\nIO库还提供了两个操纵符用于刷新缓冲区：\n\n- flush 刷新缓冲区，但不输出任何额外字符\n\n- ends 向缓冲区插入一个空字符，然后刷新缓冲区\n\n**unitbuf操纵符**\n\n如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。\n\n```c++\ncout << unitbuf;    // 所有输出操作后都会立即刷新缓冲区\ncout << nounitbuf;  // 回到正常的缓冲方式\n```\n\t如果程序崩溃，输出缓冲区不会刷新\n\n## 文件输入输出\n\n除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。\n\n### 使用文件流对象\n\n当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。\n\n每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。\n\n创建文件流对象时，如果提供了一个文件名，则open会被自动调用：\n\n```c++\nifstream in(file);    // 构造一个ifstream并打开给定的文件\nofstream out;         // 输出文件流未关联到任何文件\n```\n\t当一个fstream对象被销毁时，close会自动被调用。\n\n### 文件模式\n\n每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。\n\n每个文件流类型都定义了一个默认的文件模式，当未指定文件模式时，就使用此默认模式。\n\n- 与ifstream关联的文件默认以in模式打开；\n\n- 与ofstream关联的文件默认以out模式打开；\n\n- 与fstream关联的文件默认以in和out模式打开。\n\n**以out模式打开文件会丢失已有数据**\n\n默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。\n\n阻止丢弃的方法是同时指定app模式：\n\n```c++\nofstream out(\"file1\");    // 文件被截断\nofstream app(\"file2\", ofstream::app);    // 保留文件内容，写操作在文件末尾进行\n```\n\n## string流\n\nsstream头文件定义了三个类型来支持内存IO：\n\n- istringstream从string读取数据。\n\n- ostringstream向string写入数据。\n\n- stringstream既可以从string读数据，也可以向string写数据。\n\nsstream增加了一些成员来管理与流相关联的string。见p287。\n\n### 使用istringstream\n\n当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。\n\n### 使用ostringstream\n\n当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。\n# 顺序容器\n\n## 顺序容器概述\n\n所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：\n\n-. 向容器添加或从容器中删除元素的代价\n\n-. 非顺序访问容器中元素的代价\n\n顺序容器有：vector, deque, list, forward_list, array, string。\n\nstring和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在其中间添加或删除元素就会非常耗时，因为这需要移动插入或删除位置之后的所有元素。而且，添加元素可能导致分配额外的存储空间，这种情况下，每个元素都会移动到新的存储空间中。\n\nlist和forward_list两个容器添加和删除操作都很快速。作为代价，它们不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。与vector、deque和array相比，这两个容器的额外内存开销也很大。\n\ndeque支持快速随机访问，在deque的中间位置插入或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的。\n\nforward_1ist和array是新C++标准增加的类型。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list 没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size保证是一个快速的常量时间的操作。\n\n**确定使用哪种容器**\n\n\t通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。\n\n## 容器库概览\n\n**对容器可以保存的元素类型的限制**\n\n顺序容器几乎可以保存任意类型的元素。\n\n### 迭代器\n\n迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。比如解引用操作。\n\n表3.6（96页）列出了容器迭代器支持的所有操作。表3.7（99页）列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array。\n\n**迭代器范围**\n\n迭代器范围由一对迭代器表示，通常被称为begin和end，它们标记了容器中元素的一个范围。这个范围被称为左闭合区间：`[begin, end)`\n\n**使用左闭合区间蕴含的编程假定**\n\n假定begin和end构成一个合法的迭代器范围，则：\n\n- 如果begin与end相等，则范围为空\n\n- 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素\n\n- 我们可以对begin递增若干次，使得begin == end\n\n### 容器定义和初始化\n\n每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以指定容器大小和元素初始值的参数。\n\n**将一个容器初始化为另一个容器的拷贝**\n\n方法有两种：\n\n- 直接拷贝整个容器，两个容器的类型和元素的类型都必须匹配。\n\n- 拷贝一个迭代器范围，容器类型不一定匹配，且元素类型只要能够转换即可。\n\n```c++\n//每个容器有三个元素，用给定的初始化器进行初始化\nlist<string> authors={\"Milton\"，\"Shakespeare\"，\"Austen\"};\nvector<const char*> articles={\"a\"，\"an\"，\"the\"};\n1ist<string>1ist2(authors);//正确：类型匹配\ndeque<string>authList(authors);//错误：容器类型不匹配\nvector<string>words(articles);//错误：容器类型必须匹配\n//正确：可以将const char*元素转换为\nstring forward_list<string> words(articles.begin()，articles.end());\n```\n\n**列表初始化**\n\n```c++\nlist<const char *> articles = {\"a\",\"an\",\"the\"};\n```\n\n**标准库array具有固定大小**\n\n为了使用array类型，我们必须同时指定元素类型和大小，\n\n```c++\narray<int,10>::size_type i;//数组类型包括元素类型和大小；\n```\n\n### 赋值和swap\n\n赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝。\n\n```c++\nc1 = c2;\nca = {a,b,c};\n```\n与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型：\n\n```c++\narray<int，10>al={0，1，2，3，4，5，6，7，8，9};\narray<int，10>a2={0};//所有元素值均为0\nal=a2;//替换a1中的元素\na2={0};//错误：不能将一个花括号列表赋予数组\n```\n**由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持asign，也不允许用花括号包围的值列表进行赋值。**\n\n**使用assign(仅顺序容器)**\n\n\n赋值运算要求两边容器类型和元素类型相同。顺序容器（除了array）还定义了一个名为assign的成员，允许从一个相容的序列中赋值。\n\n**使用swap**\n\n调用swap操作后，两个容器中的元素将会交换。\n\n除了array，交换两个容器的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构。\n\n### 容器大小操作\n\n每个容器都支持这些大小相关的操作：\n\n- 成员函数size，返回容器中元素的数目，forward_list不支持；\n\n- empty，当size为0时返回true，否则返回false；\n\n- max_size，返回一个大于或等于该容器所能容纳的最大元素数的值，这是一个很大的值。\n\n### 关系运算符\n\n每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（>, >=, <, <=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。\n\n比较两个容器实际上是进行元素的逐对比较。\n\n\t只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符比较两个容器。\n\n## 顺序容器操作\n\n顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加及删除。\n\n### 向顺序容器添加元素\n\n标准库容器提供了灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。表9.5，p305。\n\n```c++\n这些操作会改变容器的大小；array不支持这些操作。\nforward_list有自己专有版本的insert和emplace；参见9.3.4节（第312页）。\nforward_1ist不支持 push_back和emplace_back。\nvector和string不支持push front和emplace front。\nc. push back(t);\nc. emplace back(args);\nc. push_front(t);\nc. emplace_front(args);\nc. insert(p,t);\nc. emplace(p, args);\nc. insert(p,n,t)c. insert(p,b,e);\nc. insert(p, il);\n```\n\n\t向一个deque、string或vector插入元素会使所有指向容器的迭代器、引用和指针失效。\n\n\t将元素插入到deque、string或vector中的任何位置都是合法的。然而，这样做可能很耗时。\n\n**关键概念：容器元素是拷贝**\n\n当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝。\n\n### 访问元素\n\n表9.6（p310）列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。\n\n**访问成员函数返回的是引用**\n\n在容器中访问元素的成员函数(即，front、back、下标和at)返回的都是引用。\n\n如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：\n\n```c++\nif(！c.empty()){\nC.front()=42;//将42赋予c中的第一个元素\nauto&v=c.back();//获得指向最后一个元素的引用\nv=1024;//改变c中的元素\nauto v2=c.back();//v2不是一个引用，它是c.back()的一个拷贝\nv2=0;//未改变c中的元素\n```\n\n**下标操作和安全的随机访问**\n\n提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。保证下标合法是程序员的责任，编译器不检查越界错误。\n\n如果想确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，如果下标越界，at会抛出一个out_of_range异常。\n\n### 删除元素\n\n\t删除deque中除首尾之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。\n\n\t删除元素之前，程序员必须确保它们是存在的。\n\n```c++\n这些操作会改变容器的大小，所以不适用于array。\nforward list 有特殊版本的erase，参见9.3.4节（第312页）。\nforward_list 不支持 popback；vector和string不支持pop_front。\nc.pop_back()\nc.pop_front()\nc.erase(p)\nc.erase(b,e)\nc.clear()\n```\n\n### 改变容器大小\n可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。\n\nresize接受一个可选的元素指参数，用来初始化新添加的元素。如果未提供，新元素进行值初始化。\n\n```c++\nc.resize(n);\nc.resize(n,t);\n```\n### 容器操作可能使迭代器失效\n\n使用失效的迭代器、引用、或指针是一种严重的错误。\n\n向容器添加元素后：\n\n- 如果容器是vector或string，且存储空间被重新分配，那么所有的迭代器都会失效。如果空间未重新分配，指向插入位置之前的元素的迭代器仍有效，但之后的迭代器会失效。\n\n- 对于list和forward_list，指向容器的迭代器仍有效。\n\n当从容器中删除元素后：\n\n- 对于list和forward_list，指向容器其他位置的迭代器仍有效。\n\n- 对于string和vector，被删除元素之前的元素的迭代器仍有效。\n\n## vector对象是如何增长的\n\n**管理容量的成员函数**\n\n```c++\n//shrink to_fit 只适用于vector、string 和deque。\n//capacity和 reserve 只适用于vector和string。\nc.shrink_to_fit();//请将 capacity()减少为与size()相同大小\nc.capacity();//不重新分配内存空间的话，c可以保存多少元素\nC.reserve(n);//分配至少能容纳n个元素的内存空间\n```\n\n## 额外的 string 操作\n\n除了顺序容器共同的操作之外， string 类型还提供了一些额外的操作。\n\n### 构造 string 的其他方法\n\n使用下面这些方法可以构造 string ：\n\n以下 n, len2, pos2 都是无符号值。\n\n|方法|说明|\n|-|-|\n|string s(cp, n)|s是cp指向的数组中前n个字符的拷贝|\n|string s(s2, pos2)|s是 string s2 从下标 pos2 开始的字符拷贝|\n|string s(s2, pos2, len2)|s是 string s2 从下标 pos2 开始 len2 个字符的拷贝，不管 len2 的值是多少，构造函数至多拷贝 s2.size() - pos2 个字符|\n**substr 操作**\n\nsubstr 返回一个 string ，它是原始 string 的一部分或全部的拷贝。\n\n`s.substr(pos, n)` 返回一个 string ，包含s中从pos开始的n个字符的拷贝。pos默认为0,n默认为 s.size() - pos ，即拷贝从 pos 开始的所有字符。\n\n### 改变 string 的其他方法\n\nstring 类型支持顺序容器的赋值运算符以及 assign, insert, erase 操作。除此之外，它还定义了额外的 insert 和 erase 版本。即使用下标的版本。\n\n```c++\ns.insert(s.size(),5,\"!\");//在s末尾插入五个！\n```\n\n这些函数都拥有许多重载的版本。\n\nassign 版本还接受C风格字符串：**需要以空格结尾**\n\nappend 和 replace 是额外的成员函数， append 在 string 末尾进行插入操作， replace 替换内容，它是调用 erase 和 insert 的一种简写形式：\n\n```c++\nstring s(\"C++ Primer 4th Ed.\");\n//从位置11开始，删除三个字符并插入Fifth;\ns.replace(11,3,\"Fifth)\n```\n\n### string 搜索操作\nstring 提供了6个搜索函数，它们都有4个重载版本。它们都返回一个 string::size_type 的值作为匹配位置（下标）。如果搜索失败，返回 string::npos ，其值为 -1 。\n\n可以给函数一个搜索的起始位置 pos ，它默认值是0：\n`auto pos = s.find_first_of(numbers, pos);`\n\n```c++\nstring name(\"guohaoxin01236578\");\nauto pos1 = name.find(\"guo\");//pos1==0返回字符串guo第一次出现的位置\nnumbers = \"0123456789\";\nauto pos2 = name.find_first_of(numbers);//寻找numbers字符串中任意字符出现的位置，find_first_not_of\n```\n\n**指定从哪里开始搜索**\n\n```c++\nstring size_type pos = 0;\nwhile((pos=name.find_first_of(numbers,pos))!=string::npos){\n\tcout<<\"found number at index:\"<<pos<<\" element is \"<<name[pos]<<endl;\n\t++pos;//移动到下一字符\n}\n```\n\n### compare 函数\n\n这是字符串比较函数，和C标准库的 strcmp 很相似。\n\n### 数值转换\n\n标准库提供了数值转换的函数。\n\n```c++\nto_string(val)\nstoi/l/ul/ll/ull/f/d/ld//转换成int、double、float\n```\n\n如果 string 不能转换成一个数值，那么会抛出一个 invalid_argument 的异常。如果转换得到的数值无法用任何类型来表示，则抛出一个 out_of_range 异常。\n\n## 容器适配器\n\n三个容器适配器：stack(栈适配器),queue,priority_queue(队列适配器)。\n\n**定义一个适配器**\n\nstack<int> stk;\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 泛型算法\n\n标准库并未给每个容器都定义成员函数来实现一些特殊的操作，如查找元素、替换或删除元素、重排元素等。而是定义了一组泛型算法。它们实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型，包括内置的数组类型。\n\n\n---\n## 概述\n\n大多数算法定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。\n\n\n通常，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。\n\n\n算法不依赖于容器，但依赖于元素类型的操作。比如，find用元素类型的==运算符完成序列中的元素与给定值的比较。大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符（即使用谓词）。\n\n**迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。**\n\n## 初识泛型算法\n\n附录A按照操作方式列出了所有的算法。\n\n除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。\n\n理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。\n\n### 只读算法\n\n一些算法只会读取其输入范围内的元素，而从不改变元素。比如find、accumulate。\n\n```c++\nint sum = accumulate(vec.cbegin(),vec.cend(),0);//求和，和的初值为0；\nstring sum =accumulate(v.cbegin(),v.cend(),string(\"\"));//string定义了字符串的“+”法，\n//错误，const char *上没有定义+运算符\nstring sum =accumulate(v.cbegin(),v.cend(),\"\");\n```\n**操作两个序列的算法**\n\n举一个列子：equal算法，它比较两个序列中的元素。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：\n\n```c++\n// roster2中的元素数目应该至少与roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());\n```\n这样的算法基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。\n\n### 写容器元素的算法\n\n一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入元素数目（note：如容器大小足够）。\n\n这样的算法比如fill。\n\n**介绍back_inserter**\n\n一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器**（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。\n\n**拷贝算法**\n\n拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。\n\n我们可以用copy实现内置数组的拷贝，如下面代码所示：\n\n```c++\nint al[]={0，1，2，3，4，5，6，7，8，9};\nint a2[sizeof(a1)/sizeof(*al)];//a2与al大小一样\n//ret指向拷贝到a2的尾元素之后的位置\nauto ret=copy(begin(a1)，end(al)，a2);//把a1的内容拷贝给a2\n```\ncopy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。\n\n### 重排元素的算法\n\n某些算法会重排容器中元素的顺序，比如sort，它利用元素类型的<运算符来实现排序。\n\n## 定义操作\n\n很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或==运算符完成比较。标准库为这些算法定义了额外的版本，允许我们提供自己定义的操作来替代默认运算符。\n\n### 向算法传递函数\n\nsort接受第三个参数，此参数是一个谓词（predicate）。\n\n**谓词**\n\n谓词是一个可调用的表达式，其调用结果是一个能用作条件的值。标准库算法使用的谓词分为两类：\n\n- 一元谓词，意味着它们只接受单一参数\n\n- 二元谓词，意味着它们有两个参数\n\n接受谓词的算法对输入序列中的元素调用谓词。\n\n### lambda表达式\n\n我们传递给算法的谓词必须严格接受一个或两个参数，但是有时我们希望进行的操作需要更多的参数，超出了算法对谓词的限制。\n\n**介绍lambda**\n\n我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。\n\n一个lambda表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。\n\n一个lambda表达式具有如下形式：\n\n```c++\n[capture list](parameter list) -> return type { function body }\n```\n\n其中，capture list是一个lambda所在函数中定义的局部变量的列表。\n\n可以忽略返回类型，这时会自动推断返回类型。\n\n```c++\nauto func = [](){ return 42; };\n```\n\n### lambda捕获和返回\n\n当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。类似地，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。\n\n默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。\n\n变量捕获的方式可以是值或引用。值捕获是变量的拷贝，引用捕获是变量的引用。\n\n\t当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。\n\n**建议：**\n\n尽量保持lambda的变量捕获简单化。如果可能的话，应该避免捕获指针或引用。见p351。\n\n**隐式捕获**\n\n可以让编译器根据lambda体中的代码来推断要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。\n\n如：\n\n```c++\n// sz为隐式捕获，值捕获方式\nwc = find_if(words.begin(), words.end(),\n             [=](const string &s) { return s.size() >= sz; } );\n```\n\n详见lambda捕获列表，p352。\n\n**可变lambda**\n\n默认情况下，对于一个值拷贝的变量，lambda不会改变其值。如果希望改变，必须在参数列表后加上关键字mutable。\n\n```c++\nvoid fcn3()\n{\n    size_t v1 = 42;\n    // f可以改变它捕获的变量的值\n    auto f = [v1]() mutable { return ++v1; };\n    v1 = 0;\n    auto j = f(); // j为43\n}\n```\n\n### 参数绑定\n\n对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。\n\n如果lambda的捕获列表为空，通常可以用函数来代替它。但如果捕获列表不为空就不能直接代替了。\n\n**标准库bind函数**\n\n为了解决这个问题，可以使用一个新的名为bind的标准库函数，它定义在头文件functional中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。\n\n```c++\nauto newCallable = bind(callable, arg_list);\n```\n\nnewCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。\n\narg_list中的参数可能包含形如`_n`的名字，这些参数是“占位符”，表示newCallable的参数。比如：`_1`为newCallable的第一个参数，`_2`为第二个参数。\n\n**使用placeholders名字**\n\n名字`_n`都定义在一个名为placeholders的命名空间中，这个命名空间本身定义在std命名空间中。\n\n一种简单的using语句是：\n\n```c++\nusing namespace namespace_name;\n```\n\n这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。如：\n\n```c++\nusing namespace std::placeholders;\n```\n\n这使得placeholders定义的所有名字都可用。\n\n## 再探迭代器\n\n除了每个容器的迭代器，标准库在头文件iterator中还定义了额外几种迭代器。\n\n- 插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。\n\n- 流迭代器：这些迭代器被绑定到输入或输出流上，可以来遍历所关联的IO流。\n\n- 反向迭代器：这些迭代器向后而不是向前移动。\n\n- 移动迭代器：不拷贝其中的元素，而是移动它们。将在13.6.2节（p480页）介绍。\n\n### 插入迭代器\n\n插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。\n\n```c++\nit = t; // 在it指定的当前位置插入值t。\n```\n\n插入迭代器有三种类型，差异在于元素插入的位置：\n\n- back_inserter，创建一个使用push_back的迭代器。\n\n- front_inserter，创建一个使用push_front的迭代器。\n\n- inserter，创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。\n\n```c++\nlist<int> lst = {1,2,3,4};\nliat<int>lst2,lst3;//空的list\n//copy 完成后lst2包含4 3 2 1\ncopy(lst.begin(),lst.end(),front_inserter(lst2));\n//opy 完成后lst3包含1 2 3 4\ncopy(lst.begin(),lst.end(),inserter(lst3,lst3.begin()));\n```\n### iostream迭代器\n\nistream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。\n\n通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。\n\n详细操作见p359。\n\n### 反向迭代器\n\n反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。\n\n可以通过rbegin, rend, crbegin, crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。\n\n## 泛型算法结构\n\n任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别。\n\n\n|迭代器|要求|\n|-|-|\n|输入迭代器|只读，不写；单遍扫描，只能递增|\n|输出迭代器|只写，不读；单遍扫描，只能递增|\n|前向迭代器|可读写；多遍扫描，只能递增|\n|双向迭代器|可读写；多遍扫描，可递增递减|\n|随机访问迭代器|可读写，多遍扫描，支持全部迭代器运算|\n\n### 5类迭代器\n\n类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。\n\n如ostream_iterator只支持递增、解引用和赋值。vector、string、deque的迭代器除了这些操作，还支持递减、关系和算术运算。\n\n除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。\n\n### 算法的形参模式\n大多数算法具有如下4种形式之一：\n\n```c++\nalg(beg, end, other args);\nalg(beg, end, dest, other args);\nalg(beg, end, beg2, other args);\nalg(beg, end, beg2, end2, other args);\n```\n\n其中，alg是算法名字，beg和end表述输入范围。几乎所有算法都有一个输入范围。\n\n**接受单个目标迭代器的算法**\n\ndest参数是一个表示算法可以写入目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。\n\n一般dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因为保证空间是足够的。\n\n**接受第二个输入序列的算法**\n\n接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围。\n\n接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。\n\n### 算法命名规范\n\n除了参数规范，算法还遵循一套命名和重载规范。\n\n**一些算法使用重载形式传递一个谓词**\n\n函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外的谓词参数，来代替<或==：\n\n```c++\nunique(beg, end);\nunique(beg, end, comp);\n```\n\n**\\_if版本的算法**\n\n接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的\\_if前缀：\n\n```c++\nfind(beg, end, val);\nfind_if(beg, end, pred);\n```\n**区分拷贝元素的版本和不拷贝的版本**\n\n默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。\n\n```\nreverse(beg, end);\nreverse_copy(beg, end, dest);\n```\n## 特定容器的算法\n\n链表类型list定义了几个成员函数形式的算法。通用版本的sort要求随机访问迭代器，因此不能用于list。\n\n链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。\n\n这些算法见p369。\n\n**链表特有的操作会改变容器**\n\n多数链表特有的算法与通用版本的很相似，但不完全相同，其中一个至关重要的区别是链表版本的会修改底层的容器。例如， remove 的链表版本会删除指定的元素， unique 的链表版本会删除第二个和后继的重复元素。\n\n\t对于通用版本的，如 std::remove ，不会删除容器的元素。它只会迁移元素。之后需要调用 erase 才能执行确切的删除动作。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 关联容器\n\n关联容器与顺序容器有着根本的不同：\n\n- 关联容器中的元素是按关键字来保存和访问的。\n\n- 顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。\n\n关联容器支持高效的关键字查找和访问，有两个主要的关联容器：\n\n- map，其元素是一些关键字-值对，关键字起到索引作用，值则表示与之相关的数据。\n\n- set，每个元素只包含一个关键字。\n\n标准库提供8个关联容器，如表11.1所示。这8个容器间的不同体现在三个维度上：每个容器  \n1. 或者是一个set，或者是一个map；\n2. 或者要求不重复的关键字，或者允许重复关键字；\n3. 按顺序保存元素，或无序保存。\n\n允许重复关键字的容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头。因此一个unordered multi set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。\n\n\n## 使用关联容器\n\nmap是关键字-值对的集合，通常被称为**关联数组**。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。与之相对，set就是关键字的简单集合。\n```\n//统计每个单词在输入中出现的次数\nmap<string,size_t) word_count;\nstring word;\nwhile(cin>>word)\n\t++word_count[word];\nfor(const auto &a:word_count)\n//打印结果\n\tcout<<a.first<<\"occurs\"<<w.second<<((w.second>1)?\"times\":\"time\"<<endl;\n```\n**使用set**  \n可以使用set忽略我们想要忽略的单词，例如：\n```c++\n\t// 统计每个单词在输入中出现的次数\n\tmap<string, size_t> word_count;\t// string到size_t的空map\n\tset<string> exclude = {\"The\", \"the\", \"And\", \"and\"};\n\n\tstring word;\n\twhile (cin >> word) {\n\t\t// 只统计不在exclude中的单词\n\t\tif (exclude.find(word) == exclude.end())\n\t\t\t++word_count[word];\t// 提取word的计数器并将其加1\n\t}\n\t\n\tfor (const auto &w : word_count) // 对map中的每个元素\n\t\t// 打印结果\n\t\tcout << w.first << \" occurs time: \" << w.second << endl;\n```\n\n## 关联容器概述\n\n关联容器（有序的和无序的）都支持9.2节（第294页）中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front。\n\n除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作（见p388）和类型别名（见p381）。\n\n关联容器的迭代器都是双向的。\n\n### 定义关联容器\n\n```c++\nmap<string, size_t> word_count; // 空容器\nset<string> exclude = {\"the\", \"but\", \"and\"}; // 列表初始化\n\n// 三个元素；authors将姓映射为名\nmap<string, string> authors = {\n    {\"Joyce\", \"James\"},\n    {\"Austen\", \"Jane\"},\n    {\"Dickens\", \"Charles\"}\n};\n```\n\n**初始化multimap或multiset**\n\n一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。\n\nmultimap和multiset没有此限制，它们都允许多个元素具有相同的关键字（这些元素会相邻存储）。\n\n### 关键字类型的要求\n\n对于有序容器，关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。\n\n**使用关键字类型的比较函数**\n\n用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型（比如一个函数指针类型）。\n\n```c++\nbool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)\n{\n    return lhs.isbn() < rhs.isbn();\n}\n\nmultiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);\n```\n\n### pair类型\n\npair类型定义在头文件utility中。\n\n一个pair保存两个数据成员，pair是一个用来生成特定类型的模板。\n\n```c++\npair<string, string> anon; // 保存两个string\npair<string, vector<int>> line; // 保存string和vector<int>\n```\n\npair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：\n\n```c++\npair<string, string> author{\"James\", \"Joyce\"};\n```\n\npair的数据成员是public的，两个成员分别是first，second。\n\n**创建pair对象的函数**\n\n```c++\npair<string, int>\nprocess(vector<string> &v)\n{\n    // 处理v\n    if (!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair<string, int>(); // 隐式构造返回值\n}\n```\n\n## 关联容器操作\n\n除了表9.2(第295页)中列出的类型，关联容器还定义了这些类型：\n\n- key_type, 此容器类型的关键字类型\n\n- mapped_type, 每个关键字关联的类型，只适用于map\n\n- value_type, 对于set，与key_type相同，对于map, 为`pair<const key_type, mapped_type>`\n\n### 关联容器迭代器\n\n当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型。\n\n\t必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。\n\n**set的迭代器是const的**\n\n与不能改名map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。\n\n**遍历关联容器**\n\nmap和set类型都支持begin和end操作，我们可以利用这些函数获取迭代器，然后用迭代器来遍历容器。\n\n```c++\nauto map_it = word_count.cbegin();\nwhile (map_it != word_count.cend()) {\n    // ...\n    ++map_it; // 递增迭代器，移动到下一个元素\n}\n```\n\n!!!note\n\t当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。\n\n**关联容器和算法**\n\n我们通常不对关联容器使用泛型算法。更多讨论见书本p383。\n\n### 添加元素\n\n关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。\n\n**向map添加元素**\n\n对一个map进行insert操作时，必须记住元素类型是pair。\n\n```c++\nword_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair<string, size_t>(word, 1));\nword_count.insert(map<string, size_t>::value_type(word, 1));\nword_count. insert(map<string, size_t>:: value_type(word,1));\n```\n\n**检测insert的返回值**\n\ninsert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。**pair的first成员是一个迭代器**，指向具有给定关键字的元素；second成员是一个boo1值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的boo1部分为false。如果关键字不存在，元素被插入容器中，且boo1值为true。\n\n**展开递增语句**\n\n```c++\n++ret.first->second;\n`++((ret.first)->second)`//等价的表达式\n```\n\n-. ret保存insert返回的值，是一个pair。\n-. ret.first是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素。\n-. ret.first->解引用此迭代器，提取map中的元素，元素也是一个pair。\n-. ret.first->second map中元素的值部分。\n-. ++ret.first->second 递增此值。\n\n\n**向multiset或multimap添加元素**\n\n由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：\n\n```c++\nmultimap<string, string> authors;\n// 插入第一个元素\nauthors.insert({\"Barth, John\", \"Sot-Weed Factor\"});\n// 正确，添加第二个元素\nauthors.insert({\"Barth, John\"}, \"Lost in the Funhouse\");\n```\n\n对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。\n\n### 删除元素\n\n关联容器定义了三个版本的erase：\n\n- 与顺序容器一样，传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围。\n\n- 接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。\n\n对于保存不重复关键字的容器，erase的返回值总是0或1。\n\n对允许重复关键词的容器，删除的元素的数量可能大于1。\n\n### map的下标操作\n\nmap和unordered_map容器提供了下标运算符和一个对应的at函数。\n\nset类型不支持下标操作，不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。\n\nmap下标运算符接受一个索引获取与此关键字相关联的值，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。\n\n**使用下标操作的返回值**\n\n当对一个map进行下标操作时，会获得一个mapped_type对象。\n\n当解引用一个map迭代器时，会得到一个value_type对象。\n\n!!!note\n\t与vector与string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。\n\n### 访问元素\n\n如果我们关心的只不过是一个特定元素是否已在容器中，使用find比较好。\n\n对于不允许重复关键字的容器，可能使用find还是count没什么区别。\n\n`c.find(k)`返回一个迭代器,`c.count(k)`返回关键词等于k的元素的数量。\n\n对于允许重复关键字的容器，count会统计有多少个元素有相同的关键字。\n```c++\nc.count(k);\nc.lower_bound(k);//返回一个迭代器，指向第一个关键词不小于k的元素\nc.upper_bound(k);//返回一个迭代器，指向第一个关键词大于k的元素\nc.equal_bound(k);//返回一个迭代器pair\n```\n\n## 无序容器\n\n无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。\n\n在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。\n# 动态内存\n\n\n我们的程序到目前为止只使用过静态内存或栈内存。\n\n- 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。\n\n- 栈内存用来保存定义在函数内的非static对象。\n\n分配在静态或栈内存中的对象由编译器自动创建和销毁。\n\n- 对于栈对象，仅在其定义的程序块运行时才存在。\n\n- static对象在使用之前分配，在程序结束时销毁。\n\n除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。\n\n动态对象的生存周期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。\n\n\n## 动态内存与智能指针\n\nC++中，动态内存的管理是通过一对运算符来完成的：\n\n- new，在动态内存中为对象分配空间并返回一个指向该对象的指针。\n\n- delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。\n\n为了更容易（同时也更安全）地使用动态内存，新的标准提供了两种智能指针（smart pointer）类型来管理动态对象。\n\n智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：\n\n- shared_ptr允许多个指针指向同一个对象；\n\n- unique_ptr则“独占”所指向的对象。\n\n- 标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。\n\n这些类型定义在memory头文件中。\n\n### shared_ptr类\n\n智能指针也是模板，当创建一个智能指针时，必须提供指向的类型：\n\n```c++\nshared_ptr<string> p1; // shared_ptr, 可以指向string\n```\n\n默认初始化的智能指针中保存着一个空指针。\n\n解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：\n\n```c++\nif (p1) *p1 = \"hi\";\n```\n\n\n**make_shared函数**\n\n最安全的分配和使用动态内存的方法是调用标准库函数make_shared。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。\n\n```c++\n// 指向一个值为42的int的shared_ptr\nshared_ptr<int> p3 = make_shared<int>(42);\n\n// p6指向一个动态分配的空vector<string>\nauto p6 = make_shared<vector<string>>();\n```\n\n类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。\n\n**shared_ptr的拷贝和赋值**\n\n每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：\n\n```c++\nauto p = make_shared<int>(42); // p指向的对象只有p一个引用者\nauto q(p); // p和q指向相同的对象，此对象有两个引用者\n```\n\n可以认为每个shared_ptr都有一个关联的计数器，通常称其为**引用计数**(reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。\n\n一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。\n\n!!!note\n\t到底是由一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。\n\n**使用了动态生存期的资源的类**\n\n程序使用动态内存出于以下三种原因之一：\n\n1. 程序不知道自己需要多少对象\n\n2. 程序不知道所需对象的准确类型\n\n3. 程序需要在多个对象间共享数据\n\n容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因的例子。本章介绍出于第三种原因的例子。\n\n### 直接管理内存\n\nC++提供了new运算符分配内存，delete运算符释放new分配的内存。\n\n相对于智能指针，使用这两个运算符管理内存非常容易出错。\n\n**使用new动态分配和初始化对象**\n\n在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：\n\n```c++\nint *pi = new int; // pi指向一个动态分配的、未初始化的无名对象\n```\n\n默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型将使用默认构造函数进行初始化。\n\n可以使用直接初始化方式来初始化一个动态分配的对象：\n\n```c++\nint *pi = new int(1024);\n\nvector<int> *pv = new vector<int>{1, 2, 3};\n```\n\n**动态分配的const对象**\n\n用new分配const对象是合法的：\n\n```c++\nconst int *pci = new const int(1024);\n```\n\n类似其他任何const对象，一个动态分配的const对象必须进行初始化。\n\n**内存耗尽**\n\n一旦一个程序用光了它所有可用的内存，new表达式就会失败（并返回一个空指针）。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。\n\n我们可以改变使用new的方式来阻止它抛出异常：\n\n```c++\n// 如果分配失败，new返回一个空指针\nint *p1 = new int; // 如果分配失败，new抛出std::bad_alloc\nint *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针\n```\n\n**释放动态内存**\n\n为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。\n\n```c++\ndelete p; // p必须指向一个动态分配的对象或是一个空指针\n```\n\n**指针值和delete**\n释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。\n\n\n```c++\nint i，*pil=&i，*pi2=nullptr;\ndouble*pd = new double(33)，*pd2=pd;\ndelete i；//错误：i不是一个指针\ndelete pi1；//未定义；pi1指向一个局部变量\ndelete pd；//正确\ndelete pd2；//未定义：pd2指向的内存已经被释放了\ndelete pi2；//正确：释放一个空指针总是没有错误的\n```\n\n**动态对象的生存期直到被释放时为止**\n\n如12.1.1节（第402页）所述，由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个由内置指针管理的动态对象，直到被显式释放之前它都是存在的。\n\n返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担—调用者必须记得释放内存：\n\n```c++\n//factory返回一个指针，指向一个动态分配的对象\nFoo* factory(T arg){\n\t//视情况处理arg\n\treturn new Foo(arg);//调用者负责释放此内存\n}\n\n```\n\n\n\t使用new和delete管理动态内存存在三个常见问题：\n\t1.忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。\n\t2.使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。\n\t3.同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。相对于查找和修正这些错误来说，制造出这些错误要简单得多。\n\n\n### shared_ptr和new结合使用\n\n如果不初始化一个智能指针，它就会被初始化为一个空指针。还可以用new返回的指针来初始化智能指针：\n\n```c++\nshared_ptr<int> p2(new int(42)); // p2指向一个值为42的int\n```\n\n接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针：\n\n```c++\nshared_ptr<int> p1 = new int(1024); // 错误：必须使用直接初始化形式\nshared_ptr<int> p2(new int(1024));  // 正确：使用了直接初始化形式\n```\n\np1的初始化隐式地要求编译器用一个new返回的int*来创建一个shared_ptr。由于我们不能进行内置指针到智能指针间的隐式转换，因此这条初始化语句是错误的。出于相同的原因，一个返回 shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：\n\n```c++\nshared ptr<int>clone(int p){\nreturn new int(p)；//错误：隐式转换为shared ptr<int>\n}\n```\n\n我们必须将shared_ptr显式绑定到一个想要返回的指针上：\n\n```c++\nshared ptr<int>clone(int p){\n//正确：显式地用int*创建 shared ptr<int>\nreturn shared_ptr<int>(new int(p))；\n}\n```\n\n默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象（可以提供自己的操作来替代delete）。\n\n更多关于智能指针使用的讨论见p412。\n\n### 智能指针和异常\n\n程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针：\n\n```c++\nvoid f()\n{\n    shared_ptr<int> sp(new int(42)); // 分配一个对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n} // 函数结束时shared_ptr自动释放内存\n```\n\n无论是否发生了异常，局部对象都会被销毁，sp是指向这块内存的唯一指针，因此内存会被释放掉。\n\n如果使用了内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：\n\n```c++\nvoid f()\n{\n    int *ip = new int(42); // 动态分配一个新对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n    delete ip; // 在退出以前释放内存\n}\n```\n\n如果在new和delete之间发生了异常，且异常未在f中被捕获，则内存就永远不会被释放了。\n\n**使用我们自己的释放操作**\n\n这里给一个简单的定义删除器的例子，而具体的讨论见书本p416。\n\n```c++\nauto deleter = [](int* p)\n{   \n\tstd::cout << \"delete data: \" << *p << std::endl;\n\tdelete p;\n};  \n\nstd::shared_ptr<int> p(new int(42), deleter);\n```\n\n智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：\n\n-. 不使用相同的内置指针值初始化（或reset）多个智能指针。\n-. 不delete get（）返回的指针。\n-. 不使用get（）初始化或reset另一个智能指针。\n-. 如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。\n-. 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（参见12.1.4节，第415页和12.1.5节，第419页）。\n\n\n### unique_ptr\n\n与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。\n\n与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。\n\n```c++\nunique_ptr<double> p1; // 可以指向一个double的unique_ptr\nunique_ptr<int> p2(new int(42)); // p2指向一个值为42的int\n```\n\n由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。\n\n更多有关unique_ptr操作的讨论见p418。\n\n### weak_ptr\n\nweak_ptr是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象还是会被释放。\n\n当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：\n\n```c++\nauto p = make_shared<int>(42);\nweak_ptr<int> wp(p); // wp若共享p；p的引用计数未改变\n```\n\n由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。如果存在，lock返回一个指向共享对象的shared_ptr。否则返回一个空shared_ptr。\n\n```c++\nif (shared_ptr<int> np = wp.lock()) { // 如果np不为空则条件成立\n    // 在if中，np与p共享对象\n}\n```\n\n## 动态数组\n\nC++语言和标准库提供了两种一次分配一个对象数组的方法：\n\n- 一种new表达式语法，可以分配并初始化一个对象数组。\n\n- 标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。\n\n!!!note\n\t大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。\n\n### new和数组\n\n为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目：\n\n```c++\n// 调用get_size确定分配多少个int\nint *pia = new int[get_size()]; // pia指向第一个int\n```\n\n方括号中的大小必须是整型，但不必是常量。\n\n**分配一个数组会得到一个元素类型的指针**\n\n当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。\n\n!!!note\n\t要记住我们所说的动态数组并不是数组类型，这是很重要的。\n\n**初始化动态分配对象的数组**\n\n默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：\n\n```c++\nint *pia = new int[10]; // 10个未初始化的int\nint *pia2 = new int[10](); // 10个值初始化为0的int\n```\n\n新标准中，我们还可以提供一个元素初始化器的花括号列表：\n\n```c++\n// 10个int分别用列表中对应的初始化器初始化\nint *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};\n```\n\n**释放动态数组**\n\n为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对：\n\n```c++\ndelete p; // p必须指向一个动态分配的对象或为空\ndelete [] pa; // pa必须指向一个动态分配的数组或为空\n```\n\n数组的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。\n\n**智能指针和动态数组**\n\n标准库提供了一个可以管理new分配的数组的unique_ptr版本：\n\n```c++\n// up指向一个包含10个未初始化int的数组\nunique_ptr<int[]> up(new int[10]);\nup.release(); // 自动用delete[]销毁其指针\n```\n\n> my note: 这里似乎有错误，release方法据p418介绍，是放弃对指针的控制权，返回指针。并不销毁原来指向的对象。另一个事例见：http://zh.cppreference.com/w/cpp/memory/unique_ptr/release\n\n当unique_ptr销毁时，会自动销毁其指向的对象。\n\n### allocator类\n\nnew和delete有一些灵活性上的局限：\n\n- new将内存分配和对象构造组合在了一起。\n\n- delete将对象析构和内存释放组合在了一起。\n\n当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。\n\n**allocator类**\n\n标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。\n\nallocator也是模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定对象类型来确定恰当的内存大小和对齐位置：\n\n```c++\nallocator<string> alloc; // 可以分配string的allocator对象\nauto const p = alloc.allocate(n); // 分配n个未初始化的string\n```\n\n**allocator分配未构造的内存**\n\nallocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。\n\n```c++\nauto q = p; // q指向最后构造元素之后的位置\nalloc.construct(q++); // *q为空字符串\nalloc.construct(q++, \"hi\"); // *q为hi!\n```\n\n还未构造对象的情况下就使用原始内存是错误的。\n\n当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。\n\n```c++\nwhile (q != p)\n    alloc.destroy(--q); // 释放我们真正构造的string\n```\n\n一旦元素被销毁后，就可以重新用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：\n\n```c++\nalloc.deallocate(p, n);\n```\n\n我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。\n\n**拷贝和填充未初始化内存的算法**\n\n标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。见p429。\n# 拷贝控制\n\n一个类通过定义五种特殊的成员函数来控制拷贝、移动、复制、销毁这些操作，包括：**拷贝构造函数、拷贝赋值函数、移动赋值函数、移动构造函数和析构函数。**\n\n## 拷贝、赋值、销毁\n\n### 拷贝构造函数\n\n拷贝构造函数的第一个参数是自身的应用，且额外参数都有默认值。\n\n`拷贝构造函数的第一个参数必须是一个引用类型。`\n\n```c++\nclass Foo{\npublic:\n\tFoo();//默认构造函数\n\tFoo(const Foo&);//拷贝构造函数\n};\n```\n\n**拷贝构造函数通常不应该是explicit的。**\n\n### 合成拷贝构造函数\n\n对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。\n\n```c++\nclass Sales_data{\npublic:\n\tSales_data(const Sales_data&)//合成拷贝构造函数\nprivate:\n\tstring BookNo;\n\tint units_sold = 0;\n\tdouble revenue = 0.0;\n};\n//与Sales_data的合成的拷贝构造函数等价\nSales_data::Sales_data(const Sales_data &orig):\n\t\t\t\t\t\t\t\t\t\t\t\tBookNo(orig.BookNo),\n\t\t\t\t\t\t\t\t\t\t\t\tunits_sold(orig.units_sold),\n\t\t\t\t\t\t\t\t\t\t\t\trevenue(orig.revenue)\n{}\n```\n\n**拷贝初始化**\n\n拷贝初始化通常使用拷贝构造函数完成（有时候为移动构造函数）。\n\n拷贝初始化不仅在我们用=定义变量时发生，在下列情况下也会发生：\n\n*. 将一个对象作为实参传递给一个非引用类型的形参\n\n*. 从一个返回类型为非引用类型的函数返回一个对象\n\n*. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员\n\n**参数和返回值**\n\n当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。\n\n**拷贝初始化的限制**\n\n```c++\nvector<int> v1(10)//正确：直接初始化\nvector<int> v2=10;//错误，接受大小参数的构造函数是显式的\nvoid f(vector<int>);//f的参数进行拷贝初始化\nf(10);//错误；不能用一个显式的构造函数拷贝一个实参\nf(vector<int>(10));//正确，从一个int直接构造一个临时的vector\n```\n\n**编译器可以绕过构造函数**\n\n在拷贝初始化的过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。例如：\n\n```c++\nstring null_book=\"9-999-999999-9\";//拷贝初始化\nstring null_book(\"9-999-999999-9\");//编译器绕过了拷贝构造函数\n```\n\n### 拷贝赋值运算符\n\n**重载赋值运算符**\n\n重载赋值运算符本质是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。\n\n```c++\nclass Foo{\npublic:\n\tFoo& operator=(const Foo&);//赋值运算符\n//...\n}\n```\n\n为了与内置运算符保持一致性，赋值运算符通常返回一个指向其左侧运算对象的引用。\n\n**合成拷贝赋值运算符**\n\n如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。\n\n```c++\nSales_data&\nSales_data::operator=(const Sales_data &rhs){\n\tBookNo = rhs.BookNo;\n\tunits_sold = rhs.units_sold;\n\trevenue = rhs.revenue;\n\treturn *this;\n}\n```\n\n### 析构函数\n\n析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他的工作，析构函数释放对象使用的资源，并销毁对象的非static数据成员。\n\n析构函数没有返回值，也不接受参数。\n\n**析构函数完成什么工作**\n\n在一个人构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序执行。\n\n通常，析构函数释放对象在生存期分配的所有资源。\n\n\t隐式销毁一个内置指针类型的成员不会delete它所指向的对象。\n\n**什么时候会调用析构函数**\n\n无论何时一个对象被销毁，就会自动调用其析构函数：\n\n1. 变量离开其作用域时被销毁\n\n2. 当一个对象被销毁时，其成员被销毁\n\n3. 容器被销毁时，其元素被销毁\n\n4. 对于动态分配的对象，当指向它的指针应用delete运算符时被销毁\n\n5. 对于临时对象，当创建它的完整表达式时被销毁\n\n\t当一个指向对象的引用或者指针离开作用域时，析构函数不会执行。\n\n**合成析构函数**\n\n当一个类未定义自己的析构函数时，编译器便会自动为它自动定义一个合成析构函数。\n\n### 三/五法则\n\n\t如果一个函数需要自定义析构函数，几乎可以肯定他也需要自定义拷贝赋值运算符合拷贝构造函数。\n\n**需要拷贝操作的类也需要赋值操作，反之亦然**\n\n### 使用default\n\n我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。\n\n### 阻止拷贝\n\n\t大多数类应该定义拷贝构造函数、构造函数和拷贝赋值运算符，无论是显式地还是隐式的。\n\n**定义删除的函数**\n\n我们可以通过将拷贝构造函数和拷贝赋值函数定义为删除的函数来阻止拷贝。删除的函数是这样的函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：\n\n```c++\nstruct NoCopy{\nNoCopy()=default;\nNoCopy(const NoCopy&)=delete;//阻止拷贝；\n}\n```\n\n还可以对任何函数指定=delete。\n\n**析构函数不能是删除的函数**\n\n如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。\n\n**合成的拷贝控制成员可能是删除的**\n\n对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。\n\n\n**private拷贝控制**\n\n在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。\n\n## 拷贝控制和资源管理\n\n通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。\n\n为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。\n\n类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。\n\n类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。\n\n### 行为像值的类\n\n对于类管理的资源，每个对象都应该拥有一份自己的拷贝。\n\n为了实现类值的行为，HasPtr需要：\n\n- 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针\n\n- 定义一个析构函数来释放string\n\n- 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string\n\n**类值拷贝赋值运算符**\n\n一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。\n\n这样就可以正确进行自赋值操作。\n\n### 定义行为像指针的类\n\n这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。\n\n令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。\n\n但是有时候我们希望直接管理资源，这种情况下，可以使用**引用计数（reference count）**。\n\n**引用计数**\n\n引用计数的工作方式如下：\n\n- 除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。\n\n- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。\n\n- 析构函数递减计数器，如果变为0，则析构函数释放状态。\n\n- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。\n\n引用计数应该保存在动态内存中，这样才能保证共享引用计数。\n\n## 交换操作\n\n管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。\n\n如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：\n\n```c++\nHasPtr temp = v1;\nv1 = v2;\nv2 = temp;\n```\n\n但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。\n\n```c++\nstring *temp = v1.ps;\nv1.ps = v2.ps;\nv2.ps = temp;\n```\n\nswap函数的存在是为了优化代码。详细定义方法见书本。\n\n**在赋值运算符中使用swap**\n\n定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为**拷贝并交换（copy and swap）**的技术。\n\n```c++\nHasPtr &HasPtr::operator=(HasPtr rhs)\n{\n    swap(*this, rhs);\n    return *this;\n}\n```\n\nrhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。\n\n这种技术自动处理了自赋值的情况且天然就是异常安全的。\n\n## 拷贝控制示例\n\n见习题练习13.33-13.38。\n\n## 动态内存管理类\n\n再看看！\n\n## 对象移动\n\n新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。\n\n使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。\n\n### 右值引用\n\n为了支持移动操作，新标准引入了一种新的类型——**右值引用（rvalue reference）**。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。\n\n```c++\nint i = 42;\nint &r = i;    // 正确：r引用i\nint &&rr = i;  // 错误：不能将一个右值引用绑定到一个左值上\nconst int &r3 = i*42;//正确：我们可以将一个const的引用绑定到一个右值上\nint &&r2 = i * 42; // 正确：将rr2绑定到乘法结果上\n```\n\n**左值持久，右值短暂**\n\n左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。\n\n由于右值引用只能绑定到临时对象，我们得知：\n\n*. 所引用的对象将要被销毁\n\n*. 该对象没有其他用户\n\n这两个特性意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。\n\n**变量是左值**\n\n变量可以看作只有一个运算对象而没有运算符的表达式。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。\n\n因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上：\n\n```c++\nint &&rr1 = 42;     // 正确：字面常量是右值\nint &&rr2 = rr1;    // 错误：表达式rr1是左值！\n```\n\n\t变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行，\n\n**标准库move函数**\n\n虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。\n\n```c++\nint &&rr3 = std::move(i); // OK\n```\n\nmove调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。\n\n\t我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。\n\t使用move的代码应该是std::move而不是move。\n\n### 移动构造函数和移动赋值运算符\n\n移动的版本从给定对象“窃取”资源而不是拷贝资源。\n\n移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。\n\n除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。\n\n```c++\nStrVec::StrVec(StrVec &&s) noexcpet // 移动构造函数不应抛出异常\n // 成员初始化器接管s中的资源\n : elements(s.elements), first_free(s.first_free), cap(s.cap)\n{\n    // 令s进入这样的状态——对其运行析构函数是安全的\n    s.elements = s.first_free = s.cap = nullptr;\n}\n```\n\n**移动操作、标准库容器和异常**\n\n移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。\n\n通知的方法是在构造函数中指明noexcept。\n\n```c++\nclass StrVec{\npublic:\n\tStrVec(StrVec&& ) noexcept;//移动构造函数 \n};\nStrVec::StrVec(StrVec &&s) noexcept:/*成员初始化器*/\n{/*构造函数体*/}\n```\n\n**移动赋值运算符**\n\n移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：\n\n```c++\nStrVec& StrVec::operator=(StrVec &&rhs) noexcept\n{\n    // 直接检测自赋值\n    if (this != &rhs) {\n        free();    // 释放已有资源\n        elements = rhs.elements; // 接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}\n```\n\n**移后源对象必须可析构**\n\n从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。\n\n除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。但是移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。\n\n\t在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。\n\n**合成的移动操作**\n\n如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。\n\n如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的拷贝版本会被定义为删除的。\n\n**移动右值，拷贝左值**\n\n如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。\n\n```c++\nStrVec v1, v2;\nv1 = v2;                    // v2是左值，使用拷贝赋值\nStrVec getVec(istream&);    // getVec返回一个右值\nv2 = getVec(cin);           // getVec(cin)是一个右值；使用移动赋值\n```\n\n**更新三/五法则**\n\n所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。\n\n### 右值引用和成员函数\n\n除了构造函数和赋值运算符之外，成员函数也可以提供拷贝和移动的版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。\n\n```c++\nvoid push_back(const X&);   // 拷贝：绑定到任意类型的X\nvoid push_back(X&&);        // 移动：只能绑定到类型X的可修改的右值\n```\n\n**右值和左值引用成员函数**\n\n我们可以强制左侧运算对象是一个左值。\n\n我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个**引用限定符（reference qualifier）**。\n\n```c++\nclass Foo {\npublic:\n    Foo &operator=(const Foo&) &;   // 只能向可修改的左值赋值\n};\n```\n\n引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。如果存在const限定符，引用限定符必须跟随在const限定符之后。\n\n**重载和引用函数**\n\n我们可以综合引用限定符和const来区分一个成员函数的重载版本。\n\n```c++\nclass Foo{\npublic:\n\tFoo sorted() &&;//可用于可改变的右值\n\tFoo sorted() const &;//可用于任何类型的Foo\nprivate:\n\tvector<int> data;\n};\n//本对象为右值，因此可以原址排序\nFoo Foo::sorted() &&\n{\n\tsort(data.begin(),data.end());\n\treturn *this;\n}\n//本对象是一个左值或者一个const，哪种情况我们都不能对其进行原址排序\nFoo Foo::sorted() const &{\n\tFoo ret(*this);\n\tsort(ret.data.begin(),ret.data.end());\n\treturn ret;\n}\n```\n\n\t如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 重载运算和类型转换\n\n## 基本概念\n\n重载运算符是具有特殊名字的函数：他们的名字由关键字operator和其后要定义的运算符号组成。重载运算符也包含返回类型，参数列表以及函数体。\n\n\t当一个运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。\n\n对于一个运算符函数来是哦，它或者是类的成员，或者至少含有一个类型的参数：\n\n```c++\n//错误，不能为int重定义内置的运算符\nint operator+(int,int);\n```\n\n不能被重载的运算符： .* :: . ? ：\n\n**直接调用一个重载的运算符函数**\n\n调用方法如下：\n\n```c++\n//一个非成员运算符的等价调用\ndata1+data2;//普通的表达式\noperator+(data1,data2);//等价的函数调用\ndata1 += data2;//基于调用的表达式\ndata1.operator+=(data2);//对成员运算符函数的等价调用\n```\n\n将this绑定到data1的位置，将data2作为实参传入函数。\n\n**某些运算符不应该被重载**\n\n\t通常情况下不应该重载逗号，取地址，逻辑与和逻辑或运算符。\n\n**使用与内置类型一致的含义**\n\n**选择作为成员或者非成员函数**\n\n有的运算符必须作为成员，另一些情况下，运算符作为非成员更好：\n\n1. 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）运算符必须作为成员；\n\n2. 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值略有不同；\n\n3. 递增、递减和解引用运算符，一般应该是成员；\n\n4. 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该时普通的非成员函数。\n\n```c++\nstring s = \"world\";\nstring t = s + \"!\";//正确，我们能把一个const char*加到一个string中等价于s.operator+(\"!\")\nstring u = \"Hi\" + s;//错误，等价于：\"Hi\".operator+(s),hi的类型是const char* ，这是一种内置类型，没有成员函数\n```\n\n## 输入和输出运算符\n\n### 重载输出运算符<<\n\n第一个形参通常是一个非常量的ostream对象的引用，之所以ostream是非常量是因为向流写入内容会改变其状态，而引用该形参是因为我们没法直接复制一个ostream对象。\n\n第二个形参通常是一个常量的引用，该常量是我们要输出的类类型。\n\n为了与其他输出运算符保持一致，operator<<通常返回它的ostream形参。例如：\n\n```c++\nclass Salas_data{\nfriend std::ostream& operator<<(ostream&, const Salas_data&);\nfriend std::ostream& operator>>(istream&, const Salas_data&);\n};\n```\n\n\t通常，输出运算符不应该打印换行符，主要负责输出打印的对象而非格式。\n\n**输出输出运算符必须是非成员函数**\n\n### 重载输入运算符>>\n\n通常情况下，输入运算符的第一个实参为将要读取的流的引用，第二个形参为将要读入到的（非常量）对象的引用。该运算符会返回某个流的引用。\n\n\t输入运算符必须处理输入失败的问题，而输出运算符不需要。\n\n## 算术和关系运算符\n\n通常我们把算术和关系运算符作为非成员函数以允许对左侧和右侧的运算对象进行转换。形参都是常量的引用。\n\n```c++\nSalas_data operator+(const Salas_data &lhs,const Salas_data &rhs){\n\tSalas_data sum = lhs;\n\tsum += rhs;\n\treturn sum;\n}\n```\n\n\t如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符来实现。\n\n### 相等运算符\n\n```c++\nbool operator==(const Sales_data &lhs, const Sales_data &rhs)\n{\n\treturn lhs.isbn() == rhs.isbn() &&\n\t       lhs.units_sold == rhs.units_sold &&\n\t       lhs.revenue == rhs.revenue;\n}\n\nbool operator!=(const Sales_data &lhs, const Sales_data &rhs)\n{\n\treturn !(lhs == rhs);\n}\n```\n\n### 关系运算符\n\n如果一个类不存在一种逻辑可靠的<定义，这个类不定义<运算符也许更好。\n\n### 赋值运算符\n\n之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。\n\n比如：\n\n```c++\nvector<string> v;\nv = {\"a\", \"b\", \"c\"};\n```\n\n```c++\nclass StrVec {\npublic:\n\tStrVec& operator=(std::initializer_list<std::string>)\n\t{\n\t\t// ...\n\t}\n};\n```\n\n\t赋值运算符必须为成员函数。\n\n### 复合赋值运算符 \n\n\t赋值运算符必须为成员函数，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。\n\n```c++\n// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针\nSales_data& Sales_data::operator+=(const Sales_data &rhs)\n{\n\tunits_sold += rhs.units_sold;\n\trevenue += rhs.revenue;\n\treturn *this;\n}\n```\n\n### 下标运算符\n\n表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。\n\n\t下标运算符必须是成员函数。\n\n为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。\n\n```c++\nclass StrVec {\npublic:\n\tstd::string& operator[](std::size_t n) { return elements[n]; }\n\n\tconst std::string& operator[](std::size_t n) const { return elements[n]; }\n\nprivate:\n\tstd::string *elements;\t// 指向数组首元素的指针\n};\n```\n\n## 递增递减运算符\n\n在迭代器类中通常会实现递增运算符++和递减运算符--，这两种运算符使得类可以在元素的序列中前后移动。\n\n对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。\n\n```c++\nclass StrBlobPtr {\npublic:\n\tStrBlobPtr& operator++();\t\t// 前置运算符\n\tStrBlobPtr& operator--();\n};\n```\n\n```c++\n//前置版本：返回递增递减对象的引用\nStrBlobPtr& StrBlobPtr::operator++(){\n//如果curr已经指向了容器的尾后位置，则无法递增它\n\tcheck(curr, \"increment past end of StrBlobPtr \")\n\t++curr;\t//将curr在当前状态下向前移动一个元素\n\treturn *this;\n}\n\nStrBlobPtr& StrBlobPtr::operator--(){\n\t//如果curr是0，则继续递减它将产生一个无效下标\n\t--curr;\t\t//将curr在当前状态下向后移动一个元素\n\tcheck(curr, \"decrement past begin of StrBlobPtr\");\n\treturn *this;\n}\n```\n\n**区分前置和后置运算符**\n\n后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。\n\n```c++\nclass StrBlobPtr {\npublic:\n\tStrBlobPtr operator++(int);\t\t// 后置运算符\n\tStrBlobPtr operator--(int);\n};\n```\n\n!!!note\n\t为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。\n\n```c++\n//后置版本：递增递减对象的值但是返回原值\nStrBlobPtr StrBlobPtr::operator++(int){\n\t//此处无须检查有效性，调用前置递增运算符时才需要检查\n\tStrBlobPtr ret = *this;//记录当前的值\n\t++*this;//向前移动一个元素，前置++需要检查递增的有效性\n\treturn ret;//返回之前记录的状态\n}\n\nStrBlobPtr StrBlobPtr::operator--(int){\n\t//此处无须检查有效性，调用前置递减运算符时才需要检查\n\tStrBlobPtr ret = *this\t//记录当前的值\n\t--*this //向后移动一个元素，前置--需要检查递减的有效性\n\treturn ret;\n}\n```\n\n**显式的调用后置运算符**\n\n```c++\nStrBlobPtr p(a1);//p指向a1中的vector\np.operator++(0);//调用后置版本的operator++\np.operator++();//调用前置版本的operator++\n```\n\n## 成员访问运算符\n\n在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。\n\n```c++\nclass StrBlobPtr {\npublic:\n\tstd::string& operator*() const;\n\t{\n\t\tauto p = check(curr,\"dereference past end\");\n\t\treturn (*p)[curr];\n\t}\n\tstd::string* operator->() const\n\t{\n\t\t// 将实际工作委托给解引用运算符\n\t\treturn & this->operator*();\n\t}\n};\n```\n\n**对箭头运算符返回值的限定**\n\n对于形如point->mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator->类的对象。根据point类型的不同，point->分别等价于：\n\n```c++\n(*point).mem;\t\t//point是一个内置的指针类型\npoint.operator()->mem;\t\t//point是一个类对象\n```\n\n除此之外，代码都将发生错误。\n\n## 函数调用运算符\n\n如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更灵活。\n\n```c++\nstruct absInt {\n\tint operator()(int val) const {\n\t\treturn val < 0 ? -val : val;\n\t}\n};\n```\n\n这个类只定义了一种操作：函数调用运算符，它负责接受一个int类型的实参，然后返回该实参的绝对值。\n\n使用调用运算符的方式是令一个absInt对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：\n\n```c++\nint i = -42;\nabsInt absObj;\nint ui = absObj(i);\t\t// 将i传递给absObj.operator()\n```\n\n函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。\n\n如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的行为像函数一样。\n\n\n\n\n### lambda是函数对象\n\n当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符，默认情况下，它是一个const成员函数。\n\n当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象确实存在。因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。\n\n通过值捕获的变量被拷贝到lambda中。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。\n\n### 标准库定义的函数对象\n\n标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作。\n\n这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，`plus<string>`令string的加法运算符作用于string对象。\n\n```c++\nplus<int> intAdd;\t\t\t// 可执行int加法的函数对象\nint sum = intAdd(10, 20);\t// 使用intAdd::operator(int, int)求10和20的和\n```\n\n**在算法中使用标准库函数对象**\n\n表示运算符的函数对象类常用来替换算法中的默认运算符。比如，默认情况下排序算法使用operator<将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个greater类型的对象。\n\n```c++\n// 传入一个临时的函数对象用于执行两个string对象的>比较运算\nsort(svec.begin(), svec.end(), greater<string>());\n```\n\n### 可调用对象与function\n\nC++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。\n\n和其他对象一样，可调用对象也有类型。lambda有它自己唯一的未命名的类类型；函数及函数指针的类型由其返回值和实参类型决定。\n\n然而，两个不同类型的可调用对象却可能共享同一种调用形式（call signature）。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：\n\n```c++\nint(int, int)\n```\n**标准库function函数**\n\nfunction是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，此额外信息是指该function类型能够表示的对象的调用形式：\n\n```c++\nfunction<int(int, int)>\n```\n\n这里声明的function类型，表示接受两个int、返回一个int的可调用对象：\n\n```c++\nfunction<int(int, int)> f1 = add;\t\t\t// 函数指针\nfunction<int(int, int)> f2 = divide();\t\t// 函数对象类的对象\nfunction<int(int, int)> f3 = [](int i, int j) { return i * j; };\t// lambda\n\ncout << f1(4, 2) << endl;\ncout << f2(4, 2) << endl;\ncout << f3(4, 2) << endl;\n```\n\n## 重载、类型转换与运算符\n\n在263页中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。\n\n转换构造函数和类型转换运算符共同定义了**类类型转换（class-type conversions）**。\n\n### 类型转换运算符\n\n**类型转换运算符（conversion  operator）**是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。其一般形式如下：\n\n```c++\noperator type() const;\n```\n\n其中type表示某种类型。类型转换运算符可以面向任意类型（除了void之外）进行定义，只要该类型能作为函数的返回类型，因此我们不允许转换成数组或者函数类型，但允许转换成指针或者引用类型。\n\n\t类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，一般被定义成const成员。\n\n**定义含有类型转换运算符的类**\n\n举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：\n\n```c++\nclass SmallInt {\npublic:\n\tSmallInt(int i = 0) : val(i)\n\t{\n\t\tif (i < 0 || i > 255)\n\t\t\tthrow std::out_of_range(\"Bad SmallInt value\");\n\t}\n\n\toperator int() const { return val; }\nprivate:\n\tstd::size_t val;\n};\n```\n\nSmallInt类的构造函数将算数类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int：\n\n```c++\nSmallInt si;\nsi = 4;\t\t\t// 4 -> SmallInt, 然后调用赋值运算符\nsi + 3;\t\t\t// si -> int，然后执行整数的加法\n```\n\n**类型转换运算符可能产生意外结果**\n\n在实践中，类很少提供类型转换运算符。但有一种例外：对于类来说，定义向bool的类型转换还是比较普遍的现象，但这会遇到一个问题：因为bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中（这不是期望的）。\n\n**显式的类型转换运算符**\n\n为了防止上述异常情况的发生，C++新标准引入了显式的类型转换运算符（explicit conversion operator）：\n\n```c++\nclass SmallInt {\npublic:\n\t// 编译器不会自动执行这一类型转换\n\texplicit operator int() const { return val; }\n};\n```\n\n编译器不会将一个显式的类型转换运算符用于隐式类型转换：\n\n```c++\nSmallInt si = 3;\t\t\t// 正确：SmallInt的构造函数不是显式的\nsi + 3;\t\t\t\t\t\t// 错误：此处需要隐式的类型转换，但类的运算符是显式的\nstatic_cast<int>(si) + 3;\t// 正确：显式地请求类型转换\n```\n\n但，如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它。\n\n\n\t向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的。\n\n### 避免有二义性的类型转换\n\n\t通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。\n\n**实参匹配和相同的类型转换**\n\n\n\n\t我们无法通过强制类型转换来解决二义性问题，因为强制类型转换也面临二义性问题。\n\n### 函数匹配和重载运算符\n\n\n\n\n\n\n\n\n\n\n# 面向对象程序设计\n\n面向对象程序设计基于三个基本概念：数据抽象、继承、动态绑定。\n\n---------\n\n## OOP概述\n\n**面向对象程序设计(object-oriented programming)**的核心思想时数据抽象，继承和动态绑定。通过数据抽象我们可以将类的接口和实现分开，使用继承，我们可以定义相似的类型并对其相似关系建模；使用动态绑定，我们可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。\n\n**继承**\n\n通过继承(inheritance)；联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类(base class)，其他类则间接或直接地从基类继承而来，这些继承而来的类称为派生类(derived class)。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。\n\n```c++\nclass Quote{\npublic:\n\tstd::string isbn() const;\n\tvirtual double net_price(std::size_t n) const;\n};\n\nclass Bulk_Quote:public Quote{\npublic:\n\tdouble net_price(std::size_t n) const override;\n};\n```\n\n**动态绑定**\n\n通过使用动态绑定(dynamic binding)，我们能用用一段代码分别处理Quote和Bulk_Quote的对象。\n\n```c++\n//计算并打印销售给定数量的某种书籍所得的费用\ndouble print_total(ostream &os,const Quote &item,size_t n){\n\t//根据传入item的形参的对象调用Quote::net_price()\n\t//或者Bulk_Quote::net_price\n\tdouble ret = item.net_price(n);\n\tos<<\"ISBN: \"<<item.isbn()<< \"# sold: \"<<n<< \"total due \"<<ret<<endl;\n\treturn ret;\n}\n\n//basic的类型时Quote,bulk的类型是Bulk_Quote\n\nprint_total(cout,basic,20);//调用Quote::net_price()\n\nprint_total(cout,bulk,20);//调用Bulk_Quote::net_price()\n```\n\n\t当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。\n\n## 定义基类和派生类\n\n### 定义基类\n\n```c++\nclass Quote{\npublic:\n\tQuote() = default;\n\tQuote(std::string &book,double sales_price):bookNo(book),price(sales_price){}\n\tstd::string isbn() const {return bookNo;};\n\tvirtual double net_price(size_t n) const {return n*price;}\n\tvirtual ~Quote()\nprivate:\n\tstd::string bookNo;\nprotected:\n\tdouble pricr = 0.0;\n};\n```\n\n\t通常，基类都应该定义一个虚析构函数，即使该函数在不执行任何实际操作也是如此。\n\n**成员函数和继承**\n\n成员函数如果没有被定义为虚函数，则其解析过程在发生编译时而不是运行时。\n\n基类通过在其成员函数的声明语句之前加上关键词virtual使得该函数执行动态绑定。\n\n**访问控制和继承**\n\n派生类可以继承定义在基类的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。派生类可以访问公有成员，而不能访问私有成员。不过，如果基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的(protected)访问运算符说明这样的成员。\n\n### 定义派生类\n\n派生类必须使用类派生列表(class derivation list)明确指出它是从哪个基类继承而来的。\n\n**派生类中的虚函数**\n\nC++新标准允许派生类显式的注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键词后面，或者在引用函数的引用限定符后面添加一个关键词override。\n\n**派生类对象及派生类向基类的类型转换**\n\n因为在派生类对象中含有基类对应的组成部分，所以我们能够把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上。\n\n```c++\nQuote item;\t\t//基类对象\nBulk_Quote bulk;\t\t//派生类对象\nQuote *p = &item;\t\t//p指向Quote对象\np = &bulk;\t\t//p指向bulk的Quote部分\nQuote &r = bulk;\t\tr绑定到bulk的Quote部分\n```\n\n**派生类构造函数**\n\n```c++\nBulk_Quote(const string &book,double p,size_t qty,double disc):\n\t\t\tQuote(book,p),min_qty(qty),discount(dis){}\n```\n\n\t首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。\n\n**派生类使用基类的成员**\n\n派生类可以使用基类的公有和保护成员。\n\n**继承与静态成员**\n\n静态成员遵循通用的访问规则。\n\n**被用作基类的类**\n\n如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明：\n\n```c++\nclass Quote;\t\t//声明但未定义；\n//错误：quote必须被定义\nclass Bulk_Quote:public Quote{...};\n```\n\n**防止继承的发生**\n\n在类名后加一个final可以防止继承的发生。\n\n```c++\nclass NoDerived final{};\n```\n\n### 类型转换与继承\n\n可以将基类的指针或者引用绑定到派生类的对象上有一层极为重要的含义：当使用基类的引用或指针时，实际上我们不知道该引用（指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。\n\n**动态类型与静态类型**\n\n我们必须把一个变量或者表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或者表达式生成的类型；动态类型则是变量或者表达式表示的内存中的对象的类型。动态类型直到运行时才可知。\n\n例如：当print_total调用net_price时`double ret = item.net_price(n);`\n\n我们知道item的静态类型是Quote&，它的动态类型则依赖于item绑定的实参，动态类型直到运行时才可知。\n\n**不存在从基类向派生类的隐式类型转换......**\n\n因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类到派生类的自动类型转换。\n\n```c++\nQuote base;\nBulk_Quote* bulkp = &base;\t\t//错误：不能将基类转换成派生类\nBulk_Quote& bulkref = base;\t\t//错误：不能将基类转换成派生类\nBulk_Quote bulk;\nQuote *itemp = &bulk;\t\t//正确：动态类型是Bulk_Quote\nBulk_Quote *bulkp = itemp;\t\t//错误：不能将基类转换成派生类\n```\n\n**......在对象之间不存在类型转换**\n\n\t当我们用一个派生类为一个基类对象赋值时，只有该派生类对象中的基类部分会被拷贝，移动和赋值，它的派生类部分会被忽略掉。\n\n\n## 虚函数\n\n我们必须为每个虚函数提供定义。\n\n**对虚函数的调用可能在运行时才被解析**\n\n动态绑定只有当我们通过指针或者引用调用虚函数时才会发生。\n\n**派生类中的虚函数**\n\n一旦某个函数被声明为虚函数，则在所有的派生类中它都是虚函数。\n\n\t基类中的虚函数在派生了中隐含地也是一个虚函数。\n\t当派生类覆盖某个虚函数时，该函数的形参必须与派生类的形参严格匹配。\n\t返回类型在返回的是类的指针或者引用时可不一样，但是要求从基类到派生类的类型转换是可访问的。\n\n**final和override说明符**\n\nfinal和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。\n\n**虚函数和默认实参**\n\n\t如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。\n\n**回避虚函数机制**\n\n在某些情况下，我们希望对虚函数的调用不要动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的：\n\n```c++\n//强行调用基类中定义的函数版本而不管baseP的动态类型如何\ndouble undiscount = baseP->Quote::net_price(42);\n```\n\n## 抽象基类\n\n**纯虚函数**\n\n纯虚函数无需定义、我们在函数体的位置书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。\n\n```c++\ndouble net_price(size_t) const =0;\n```\n\n**含有纯虚函数的类是抽象基类**\n\n抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能创建一个抽象基类的对象。因为Disc_quoto将net_price定义为纯虚函数，所以我们不能定义Disc_quote的对象。我们可以定义Disc_quote的派生类的对象。前提是这些类覆盖了net_price函数。\n\n\t我们不能创建抽象基类的对象。\n\n**派生类构造函数只初始化它的直接基类**\n\n## 访问控制与继承\n\n**受保护的成员**\n\nprotected说明符可以看做是public和private中和后的产物：\n\n1. 和私有成员类似，受保护的成员对于类的用户来说是不可访问的\n\n2. 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的\n\n3. **派生类的成员只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护的成员没有任何访问特权**\n\n```c++\nclass Base{\nprotected:\n\tint prot_mem;\n};\n\nclass Sneaky:public Base{\n\tfriend void clobber(Sneaky&);//能访问Sneaky::prot_mem\n\tfriend void clobber(Base&);//不能访问Base::prot_mem\n\tint j;\n};\n\n//正确，clobber能够访问Sneaky对象的private和protected成员\nvoid clobber(Snaaky &s){s.j=s.prot_mem=0;}\n//错误;clobber不能访问Base的protected成员\nvoid clobber(base &s){s.prot_mem=0;}\n```\n\n**公有，私有和受保护继承**\n\n某个类对其继承而来的成员的访问权限受到两个因素的影响：\n\n1. 在基类中该成员的访问说明符\n\n2. 在派生类的派生列表中的访问说明符\n\n派生类说明符的目的是控制派生类影虎对于基类成员的访问权限，还可以控制继承自派生类的新类的访问权限。\n\n**派生类向基类转换的可访问性**\n\n派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：\n\n- 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。\n\n- 不论以什么方式继承B，D的成员和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的。\n\n- 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。\n\n\t对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。\n\n**友元与继承**\n\n友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。\n\n**改变个别成员的可访问性**\n\n有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：\n\n```c++\nclass Base {\npublic:\n\tstd::size_t size() const { return n; }\nprotected:\n\tstd::size_t n;\n};\n\nclass Derived : private Base {\npublic:\n\t// 令size成员保持public访问级别\n\tusing Base::size;\nprotected:\n\tusing Base::n;\n};\n```\n\n因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。\n\n通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中任何可访问成员标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。\n\n\t派生类只能为那些它可以访问的名字提供using声明。\n\n**默认的继承保护级别**\n\n默认情况下，使用class关键词定义的派生类是私有继承，而使用struct关键字定义的派生类为公有继承。\n\n## 继承中的类作用域\n\n每个类定义自己的作用域，在这个作用域内我们定义类的成员。\n\n当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，所以派生类才能像使用自己的成员一样使用基类的成员。\n\n**在编译时进行名字查找**\n\n一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。\n\n**名字冲突和继承**\n\n和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。\n\n\t派生类将隐藏同名的基类成员。\n\n**通过作用域运算符来使用隐藏的成员**\n\n作用域运算符将覆盖掉原有的查找规则。\n\n\t除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。\n\n**名字查找先去类型检查**\n\n```c++\nstruct Base{\n\tBase():mem(0){};\n\tint memfcn();\nprotected:\n\tint mem;\n};\n\nstruct Derived:Base{\n\tDerived(int i):mem(i){};\n\tint memfcn(int);\n\tint get_mem(){return mem;};\nprotected:\n\tint mem;\n};\n\nDerived d;\nBase b;\nb.memfcn();\t\t//调用Base::memfcn\nd.memfcn(10);\t\t//调用Derived::memfcn\nd.memfcn();\t\t//错误：参数列表为空的memfcn被隐藏了\nd.Base::memfcn();\t\t//正确：调用Base::memfcn\n```\n\n**虚函数和作用域**\n\n加入基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数。\n\n**通过基类调用隐藏的虚函数**\n\n## 构造函数与拷贝控制\n\n和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。\n\n### 虚析构函数\n\n当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本。\n\n```c++\nclass Quote {\npublic:\n\t// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数\n\tvirtual ~Quote() = default;\t// 动态绑定析构函数\n};\n```\n\n\t如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。\n\n之前介绍的经验准则说，如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但这里基类的析构函数并不遵顼这个准则，它是一个重要的例外。\n\n虚析构函数还将阻止合成移动操作。\n\n### 合成拷贝控制与继承\n\n基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如：\n\n- 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。\n\n- Quote的默认构造函数将bookNo成员默认初始化为空子行串，同时便用类内例始值将price初始化为0。\n\n- Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化qty和discount。\n\n- Disc quote的构造函数完成后，继续执行Bu1k_quote的构造函数，但是它什么具体工作也不做。\n\n**对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。**\n\n**派生类中删除的拷贝控制与基类的关系**\n\n某些定义为基类的方式也可能导致有的派生类成员成为删除的函数：\n\n-. 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问（参见15.5节，第543页），则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。\n\n-. 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。\n\n-. 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=defau1t请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。\n\n例如：\n\n```c++\nclass B{\npublic:\n\tB();\n\tB(const B&)=delete;\n};\n\nclass D:public B{\n\t//没有声明任何构造函数\n};\n\nD d;\t\t//正确，D的合成默认构造函数使用B的默认构造函数\nD d2(d);\t\t//错误：D的合成拷贝构造函数是被删除的\nD d3(std::move(d));\t\t//错误：隐式的使用D的被删除的拷贝构造函数\n```\n\n**移动操作和继承**\n\n因为基类缺少移动操作会阻止派生类拥有自己的移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。\n\n```c++\nclass Quote{\npublic:\n\tQuote()=default;//对成员依次进行默认初始化\n\tQuote(const Quote&)=default;//对成员依次拷贝\n\tQuote(Quote&&)=default;//对成员依次拷贝\n\tQuote& operator=(const Quote&)=default;//拷贝赋值\n\tQuote& operator=(Quote&&)=default;//拷贝赋值\n\tvirtual ~Quote()=default;//析构函数\n}\n```\n\n### 派生类的拷贝控制成员\n\n派生类的构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要移动和拷贝基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。\n\n和构造函数及赋值运算符不同的是，析构函数只负责销毁自己分配的资源。\n\n\t当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。\n\n**定义派生类的拷贝和移动构造函数**\n\n当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分：\n\n```c++\nclass Base{/* */};\nclass D:public Base{\npublic:\n\t//默认情况下，基类的默认构造函数初始化对象的基类部分\n\t//要想使用拷贝或移动构造函数，我们必须在构造函数初始列表中\n\t//显式的调用该构造函数\n\tD(const D&):Base(d)\t\t//拷贝基类成员\n\t\t\t/*D的成员的初始值*/{ /* */}\n\tD(D&& d):Base(std::move(d))\t\t//移动基类成员\n\t\t\t/*D的成员的初始值*/{ /* */}\n};\n```\n\n\t在默认情况下，其基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝或者移动基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝构造函数。\n\n**派生类赋值运算符**\n\n派生类的赋值运算符也必须显式地为其基类部分赋值。\n\n```c++\n//Base::operator=(const Base&)不会被自动调用\nD &D::operator=(const D &rhs){\n\tBase::operator=(rhs);//为基类部分赋值\n\t//按照过去的方式为派生类的成员赋值\n\t//酌情处理自赋值及释放已有资源等情况\n\treturn *this;\n}\n```\n\n**派生类析构函数**\n\n派生类析构函数只负责销毁由派生类自己分配的资源。\n\n**在构造函数和析构函数中调用虚函数**\n\n### 继承的构造函数\n\n**类不能继承默认、拷贝、移动构造函数**，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。\n\n在C++11新标准中，派生类能够重用其直接基类定义的构造函数。\n\n一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。\n\n派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。\n\n```c++\nclass Bulk_quote : public Disc_quote {\npublic:\n\tusing Disc_quote::Disc_quote; // 继承Disc_quote的构造函数\n\tdouble net_price(std::size_t) const;\n};\n```\n\n通常情况下，using声明语句只是令某个名字在当前作用域内可见。当当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。\n\n在Bulk_quote类中，继承的构造函数等价于：\n\n```c++\nBulk_quote(const std::string &book, double price, std::size_t qty, double disc) :\n\tDisc_quote(book, price, qty, disc) {}\n```\n\n如果派生类含有自己的数据成员，则这些成员将被默认初始化。\n\n**继承的构造函数的特点**\n\n一个构造函数的using声明不会改变该构造函数的访问级别。不能指定explicit和constexpr。\n\n## 容器与继承\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 模板和泛型编程\n\n## 定义模板\n\n### 函数模板\n\n一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板函数可以像这样：\n\n```c++\ntemplate<typename T>\nint compare(const T &v1,const T &v2){\n\treturn  v1 > v2 ? 1 : -1;\n}\n```\n\n模板定义以一个关键词template开始，后跟一个模板参数列表，这是一个逗号分隔或多个模板参数的列表，用< 和 > 包围起来。\n\n\t在模板定义中，模板参数列表不能为空。\n\n**实例化参数模板**\n\n'''c++\ncout<<compare(1,0)<<endl;//T为int\n'''\n\n**模板类型参数**\n\n类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换。\n\n**非类型模板参数**\n\n一个非类型模板参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或者typename来指定非类型参数。\n\n\t非类型模板参数的模板实参必须是常亮表达式。\n\n**inline和constexpr的函数模板**\n\ninline或者constexpr说明符放在参数列表之后，返回类型之前：\n\n```c++\ntemplate<typename T>\ninline T min(const T &a,const T &b)\n```\n\n**编写类型无关的代码**\n\n编写泛型代码的两个重要的原则：\n\n1. 模板中的函数参数是const的引用；\n\n2. 函数体的条件判断仅使用<比较运算。\n\n**模板编译**\n\n## 类模板\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 标准库特殊设施\n\n## tuple类型\n\ntuple是类似pair的模板。每个pair的成员类型都不相同，但是每个pair都恰好有两个成员。不同tuple类型的成员类型也不相同，但是每个tuple可以有任意数量的成员。每个确定的tuple类型的成员数目是固定的，但一个tuple类型的成员数目可以与另一个tuple类型不同。\n\n```c++\ntuple支持的操作\ntuple<T1,T2,...,Tn> t;\ntuple<T1,T2,...,Tn> t(v1,v2,v3,v4,...,vn);\nmake_tuple(v1,v2,...,vn);\nt1==t2;\nt1 relop t2;\nget<i>(t);\n```\n\n### 定义和初始化tuple\n\n当我们定义一个tuple时，需要指出每个成员的类型：\n\n```c++\ntuple<size_t,size_t,size_t> threeD;//三个成员都设置为0\ntuple<string,vector<double>,int,list<int>) someVal(\"contents\",{3.14,2.718},42,{0,1,2,3,4,5})\n```\n\n**访问tuple的成员**\n\n要访问一个tuple的成员，就要使用一个名为get的标准函数模板。\n\n```c++\nauto book = get<0>(item);//返回item成员的第一个成员\nauto cnt = get<1>(item);//返回item成员的第二个成员\n```\n\n如果不知道一个tuple准确的类型细节信息，可以使用辅助类模板来查询tuple成员的类型和数量：\n\n```c++\ntypedef decltype(item) trans;//trans是item的类型\n//返回item类型对象中成员的数量\nsize_t sz = tuple_size<trans>::value;//返回3\n//cnt类型与item中第二个成员相同\ntuple_element<1,trans>::type cnt = get<1>(item);//cnt为int型\n```\n\n### 使用tuple返回多个值\n\n## bitset类型\n\n标准库定义了bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。\n\n### 定义和初始化bitset\n\nbitset类是一个类模板，它类似array类，具有固定的大小。当我们定义一个bitset时，需要声明它包含多少个二进制位。\n\n```c++\nbitset<32> bitvec(1U);\t// 32位；低位为1，其他位为0\n```\n\n二进制位的位置是从0开始编号的，因此，bitvec包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位（low-order），编号到31结束的二进制位被称为高位（high-order）。\n\n\n**使用unsigned值初始化bitset**\n\n当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当作位模式来处理。bitset中的二进制位将是此模式的一个副本。如果bitset的大小大于unsigned long long的位数，则剩余高位被置为0。如果小于，则只使用给定值中的低位，超出bitset大小的高位被丢弃。\n\n**从一个string初始化bitset**\n\n我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符都直接表示位模式。当我们使用字符串表示数时，字符串中下标最小的字符对应高位：\n\n```c++\nbitset<32> bitvec4(\"1100\");\t// 2、3两位为1，剩余两位为0\n```\n\n如果string包含的字符数比bitset少，则bitset的高位被置为0。\n\n\tstring的下标编号习惯于bitset恰好相反：string中下标最大的字符（最右）用来初始化bitset中的低位。\n\n### bitset操作\n\nbitset操作定义了多种检测或设置一个或多个二进制位的方法。\n\n```c++\nbitset<32> bitvec(1U);\nbool is_set = bitvec.any();\t\t\t// true，因为有1位置位\nbool is_not_set = bitvec.none();\t// false，因为有1位置位了\nbool all_set = bitvec.all();\t\t// false，因为只有1位置位了\nsize_t onBits = bitvec.count();\t\t// 返回1\nsize_t sz = bitvec.size();\t\t\t// 返回32\nbitvec.flip();\t\t\t\t\t\t// 翻转bitvec中的所有位\nbitvec.reset();\t\t\t\t\t\t// 将所有位复位\nbitvec.set();\t\t\t\t\t\t// 将所有位置位\n\nbitvec.flip(0);\t\t\t\t\t\t// 翻转第一位\nbitvec.set(0);\t\t\t\t\t\t// 置位第一位\nbitvec.reset(i);\t\t\t\t\t// 复位第i位\nbitvec.test(0);\t\t\t\t\t\t// 返回false，因为第一位已复位\n\nbitvec[0] = 0;\t\t\t\t\t\t// 将第一位复位\nbitvec[31] = bitvec[0];\t\t\t\t// 将最后一位设置为与第一位一样\n~bitvec[0];\t\t\t\t\t\t\t// 翻转第一位\n```\n\n**提取bitset的值**\n\nto_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式，只有当bitset的大小小于等于对应的大小时，我们才能使用这两个操作，否则将会抛出overflow_error异常。\n\n```c++\nunsigned long ulong = bitvec3.to_ulong();\ncout << \"ulong = \" << ulong << endl;\n```\n\n**bitset的IO运算符**\n\n输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的字符数达到对应bitset的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，读取过程才停止。随即用临时string对象来初始化bitset。如果读取的字符数小于bitset的大小，高位被置为0。\n\n```c++\nbitset<16> bits;\ncin >> bits;\t\t// 从cin读取最多16个0或1\ncout << \"bits: \" << bits << endl;\n```\n\n## 正则表达式\n\n正则表达式是一种描述字符序列的方法，是一种及其强大的计算工具。它定义在头文件regex中，它包含多个组件：\n\n|组件|说明|\n|-|-|\n|regex|表示有一个正则表达式的类|\n|regex_match|将一个字符序列与一个正则表达式匹配|\n|regex_search|寻找第一个与正则表达式匹配的子序列|\n|regex_replace|使用给定格式替换一个正则表达式|\n|sregex_iterator|迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串|\n|smatch|容器类，保存在string中搜索的结果|\n|ssub_match|string中匹配的子表达式的结果|\n\nregex类表示一个正则表达式。\n\n函数regex_match和regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个输入序列与表达式匹配，则regex_match返回true；如果输入一个序列中一个子串与表达式匹配，则regex_search返回true。\n\n## 随机数\n\n程序通常需要一个随机数源。在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。此函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。\n\nrand函数有一些问题：即使不是大多数，也有很多程序员需要不同范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。\n\n定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎（random-number engines）和随机数分布类（random-number distribution）。\n\n|组件|说明|\n|-|-|\n|引擎|类型，生成随机unsigned整数序列|\n|分布|类型，使用引擎返回服从特定概率分布的随机数|\n\n!!!note\n\tC++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。\n\n### 随机数引擎和分布\n\n随机数引擎是函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。\n\n```c++\ndefault_random_engine e;\ncout << e() << endl;\t\t// 生成一个随机无符号数\n```\n\n标准库定义了多个随机数引擎类，区别在于性能和随机质量不同。\n\n**分布类型和引擎**\n\n为了得到一个指定范围内的数，我们使用一个分布类型的对象：\n\n```c++\n// 生成0到9之间（包含）均匀分布的随机数\nuniform_int_distribution<unsigned> u(0, 9);\ndefault_random_engine e;\ncout << u(e) << endl;\n```\n\n分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。\n\n\t当我们说随机数发生器时，是指分布对象和引擎对象的组合。\n\n**引擎生成一个数值序列**\n\n随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序它都会返回相同的数值序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。\n\n\n\n**设置随机数发生器种子**\n\n我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子（seed）来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。\n\n```c++\ndefault_random_engine e1;\t\t// 使用默认种子\ne1.seed(42);\t\t\t\t\t// 调用seed设置一个种子值\ndefault_random_engine e2(42);\t// 使用给定的种子值\n```\n\n如果引擎种子相同，将生成相同的序列。\n\n选择一个好种子，是极其困难的，可能最常用的方法是调用系统函数time。它定义在头文件ctime中，它返回从一个特定时刻到当前经过了多少秒。\n\n```c++\ndefault_random_engine e(time(0));\t// 稍微随机些的种子\n```\n\n> my note: 使用random_device引擎为另一个引擎创建一个种子也是一种方法。\n\n后续内容讨论了其他随机数的分布，比如：生成随机实数、生成非均匀分布随机数等。\n\n## IO库再探\n\n### 格式化输入与输出\n\n除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽度等。\n\n标准库定义了一组操纵符来修改流的格式状态。一个操纵符是一个函数或是一个对象，会影响流的状态。\n\n!!!warning\n\t当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。\n\n**控制布尔值的格式**\n\n默认情况下，bool值打印为1或0，通过对流使用boolalpha操纵符来修改原有格式：\n\n```c++\ncout << boolalpha << true << \" \" << false << endl; // 输出：true false\n```\n\n一旦向cout“写入”了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印true或false，为了取消格式的改变，noboolalpha：\n\n```c++\ncout << noboolalpha;\n```\n\n**指定整型值的进制**\n\n默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct、dec将其改为十六进制、八进制或是改回十进制。\n\n```c++\ncout << \"default: \" << 20 << endl;\ncout << \"octal: \" << oct << 20 << endl;\ncout << \"hex: \" << hex << 20 << endl;\ncout << \"decimal: \" << dec << 20 << endl; \n```\n\n**在输出中指出进制**\n\n当对流应用showbase操纵符时，会在输出结果中显示进制：\n\n- 前导0x表示十六进制。\n\n- 前导0表示八进制。\n\n- 无前导字符串表示十进制。\n\n```c++\ncout << showbase;\t// 打印整型值时显示进制\ncout << \"default: \" << 20 << endl;\ncout << \"octal: \" << oct << 20 << endl;\ncout << \"hex: \" << hex << 20 << endl;\ncout << \"decimal: \" << dec << 20 << endl;\ncout << noshowbase; // 恢复流状态 \n```\n\n**指定打印精度**\n\nsetprecision操纵符接受一个参数，用来设置精度。它定义在头文件iomanip中。\n\n```c++\ncout << setprecision(3);\ncout << sqrt(2.0) << endl;\t// 输出：1.41\n```\n\n更多操纵符见p669。\n\n### 未格式化的输入/输出操作\n\n标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这组操作允许我们将一个流当作一个无解释的字节序列来处理。\n\n**单字节操作**\n\n有几个未格式化操作每次一个字节地处理流，它们会读取而不是忽略空白符。\n\n```c++\n// 读写一个字符\nchar ch;\nwhile (cin.get(ch))\n\tcout.put(ch);\n```\n\n|操作|说明|\n|-|-|\n|is.get(ch)|从istream is读取下一个字节存入字符ch中。返回is|\n|os.put(ch)|将字符ch输出到ostream os。返回os|\n|is.get()|将is的下一个字节作为int返回|\n|is.putback(ch)|将字符ch放回is。返回is|\n|is.unget()|将is向后移动一个字节。返回is|\n|is.peek()|将下一个字节作为int返回，但不从流中删除它|\n\n详细讨论见p673。\n\n**多字节操作**\n\n一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。\n\n书中未给出代码案例讲解，具体操作见p674。\n\n### 流随机访问\n\n标准库提供了一对函数，来定位（seek）到流中给定的位置，以及告诉（tell）我们当前的位置。\n\n在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问，因为这种操作对它们没有意义。对这些流调用seek和tell会导致运行时出错，将流置于一个无效状态。\n\n**seek和tell函数**\n\n为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。标准库实际上定义了两对seek和tell函数，差别在于名字的后缀是g还是p，g版本表示我们正在读取数据，而p版本表示我们正在写入数据。\n\n|操作|说明|\n|-|-|\n|tellg() tellp()|返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置|\n|seekg(pos) seekp(pos)|在一个输入流或输出流中奖标记重定位到给定的绝对地址。pos通常是前一个tell返回的值|\n|seekp(off, from) seekg(off, from)|在一个输入流或输出流中，奖标记定位到from之前或之后off个字符，from可以是：beg（流开始位置）, cur（流当前位置）, end（流结尾位置）|\n\n从逻辑上讲，我们只能对istream使用g版本，对ostream使用p版本。iostream则可以使用g版本又可以使用p版本。\n\n\n\n\n\n\n\n\n\n","slug":"2019-cPlusPlusproblemset","published":1,"updated":"2019-09-30T08:37:52.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1awgxek00332wvc0ojfxh0n","content":"<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><p>学习一门新的程序设计语言的最好方法就是练习编写程序。更多的内容可以查看我的github主页<a href=\"https://github.com/HaoxinGuo/CPlusPlusPrimerProblemset\" target=\"_blank\" rel=\"noopener\">C++课后习题集</a></p>\n<img src=\"readme.jpg\" width=\"50%\" height=\"50%\" alt=\"习题集目录\">\n\n<hr>\n<h2 id=\"编写一个简单的C-程序\"><a href=\"#编写一个简单的C-程序\" class=\"headerlink\" title=\"编写一个简单的C++程序\"></a>编写一个简单的C++程序</h2><p>每个C++程序都包含一个或多个函数（function），其中一个必须命名为<strong>main</strong>。操作系统通过调用main来运行C++程序。</p>\n<p>下面是一个简单的main函数，它什么都不做，只是返回给操作系统一个值：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int main()\n{\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>main函数的返回类型必须为int。int类型是一种<strong>内置类型</strong>（built-in type），即语言自身定义的类型。</p>\n<p>函数体是一个以左<strong>花括号</strong>（curly brace）开始，以右花括号结束的语句块（block of statements）。</p>\n<p>return语句结束函数的执行。main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。</p>\n<p><strong>重要概念：类型</strong></p>\n<p>一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。程序所处理的数据都保存在变量中，而每个变量都拥有自己的类型。</p>\n<h3 id=\"编译、运行程序\"><a href=\"#编译、运行程序\" class=\"headerlink\" title=\"编译、运行程序\"></a>编译、运行程序</h3><p>编写好程序后，我们就需要编译它，这依赖于操作系统和编译器。</p>\n<p><strong>程序源文件命名约定</strong></p>\n<p>程序文件通常被称为源文件（source file）。它以一个后缀为结尾，告诉系统这个文件是一个C++程序，比如.cpp。</p>\n<h2 id=\"初识输入输出\"><a href=\"#初识输入输出\" class=\"headerlink\" title=\"初识输入输出\"></a>初识输入输出</h2><p>C++包含了一个全面的<strong>标准库</strong>（standard library）来提供IO机制（以及很多其他设施）。</p>\n<p><strong>iostream</strong>库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。</p>\n<p><strong>标准输入输出对象</strong></p>\n<p>标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为<strong>标准输入</strong>（standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为<strong>标准输出</strong>（standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为<strong>标准错误</strong>（standard error）。clog用来输出程序运行时的一般性消息。</p>\n<p>系统通常将程序所运行的窗口与这些对象关联起来。因此，当读取cin，数据将从程序正在运行的窗口读入，当向cout写入数据时，将会写到同一个窗口。</p>\n<p>!!!note<br>    clog关联到标准错误，默认情况下，写到clog的数据是被缓冲的。写到cerr的数据是不缓冲的。</p>\n<p><strong>一个使用IO库的程序</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">#include <iostream>\nint main()\n{\n        std::cout << \"Enter two numbers:\" << std::endl;\n        int v1 = 0, v2 = 0;\n        std::cin >> v1 >> v2;\n        std::cout << \"The sum of \" << v1 << \" and \" << v2 << \" is \"\n                  << v1 + v2 << std::endl;\n        return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>#include &lt;iostream&gt;</code>告诉编译器我们想要使用iostream库。尖括号中的名字指出了一个<strong>头文件</strong>（header）。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。#include指令一般出现在所有函数之外，源文件的开始位置。</p>\n<p><strong>向流写入数据</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">std::cout << \"Enter two numbers\" << std::endl;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这条语句执行了一个<strong>表达式</strong>（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了<strong>输出运算符</strong>（&lt;&lt;）。</p>\n<p><code>&lt;&lt;</code>运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。</p>\n<p>“Enter two numbers”是一个<strong>字符串字面值常量</strong>（string literal），它是用一对双引号包围的字符序列。</p>\n<p>endl是一个被称为<strong>操纵符</strong>（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。</p>\n<p>!!!note<br>    一个表达式接一个分号就是一条语句。</p>\n<p><strong>使用标准库中的名字</strong></p>\n<p>前缀std::指出名字cout和endl是定义在名为<strong>std</strong>的<strong>命名空间</strong>（namespace）中的。</p>\n<p>命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。</p>\n<p><strong>从流读取数据</strong></p>\n<p>首先定义两个名为v1和v2的<strong>变量</strong>（variable）来保存输入：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int v1 = 0, v2 = 0;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这两个变量被定义为int类型，并<strong>初始化</strong>（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">std::cin >> v1 >> v2;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这条语句读入输入数据。<strong>输入运算符</strong>（&gt;&gt;）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。</p>\n<h2 id=\"注释简介\"><a href=\"#注释简介\" class=\"headerlink\" title=\"注释简介\"></a>注释简介</h2><p>注释（comments）通常用于概述算法，确定变量的用途，或者解释晦涩难懂的代码段。编译器会忽略掉注释，因此注释对程序的行为和性能不会有任何影响。</p>\n<p><strong>C++中注释的种类</strong></p>\n<p>C++中有两种注释：单行注释和界定符注释。</p>\n<p><strong>注释界定符不能嵌套</strong></p>\n<p>界定符对形式的注释是以<code>/*</code>开始，以<code>*/</code>结束的。因此，一个注释不能嵌套在另一个注释之内。</p>\n<p>如果在调试期间要注释掉包含界定符对形式注释的代码，最好的方式是用单行注释方式注释掉代码段的每一行。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// /*\n//  * comments\n//  */<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><p>语句一般是顺序执行的，语句块的第一条语句首先执行，然后是第二条，以此类推。但程序设计语言提供了多种不同的控制语句，允许我们写出更为复杂的执行路径。</p>\n<h3 id=\"while语句\"><a href=\"#while语句\" class=\"headerlink\" title=\"while语句\"></a>while语句</h3><p>while语句反复执行一段代码，直到给定条件为假为止。</p>\n<p>while语句的形式为：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">while (condition)\n    statement<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>while语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假时停止。所谓<strong>条件</strong>就是一个产生真或假的结果的表达式。</p>\n<p>statement可以是语句块，也叫循环体。所谓语句块（block），就是用花括号包围的语句序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。</p>\n<h3 id=\"for语句\"><a href=\"#for语句\" class=\"headerlink\" title=\"for语句\"></a>for语句</h3><p>每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。</p>\n<p>比如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">for (int val = 1; val <= 10; ++val)\n    sum += val;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>for循环的总体执行流程：</p>\n<ol start=\"0\">\n<li><p>创建变量val，将其初始化为1，它仅在循环内部存在。</p>\n</li>\n<li><p>检测val是否小于等于10。如果检测成功，执行循环体。若失败，退出循环。</p>\n</li>\n<li><p>将val的值增加1。</p>\n</li>\n<li><p>重复第二个步骤。</p>\n</li>\n</ol>\n<h3 id=\"读取数量不定的输入数据\"><a href=\"#读取数量不定的输入数据\" class=\"headerlink\" title=\"读取数量不定的输入数据\"></a>读取数量不定的输入数据</h3><p>使用这样的方法连续读入数据，直到遇到文件尾（Linux下，输入CTRL+D）：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">while (std::cin >> value)\n    statement<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>输入运算符返回其左侧对象，因此，此循环条件检测的是std::cin。</p>\n<p>当使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象的状态会变为无效。</p>\n<h3 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h3><p>if也对一个条件求值，书本里有一个完整的例子。</p>\n<p>语法大致如此：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">if (condition) {\n    statements\n} else {\n    statements\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"类简介\"><a href=\"#类简介\" class=\"headerlink\" title=\"类简介\"></a>类简介</h2><p>在C++中，通过定义一个<strong>类</strong>（class）来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。</p>\n<p>类似使用标准库设施，我们也需要使用头文件来自己的类。习惯上，头文件根据类名来命名，使用.h作为头文件的后缀。标准库的头文件通常不带后缀。</p>\n<h3 id=\"初识成员函数\"><a href=\"#初识成员函数\" class=\"headerlink\" title=\"初识成员函数\"></a>初识成员函数</h3><p><strong>什么是成员函数？</strong></p>\n<p>有这样的检测条件：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">item1.isbn() == item2.isbn()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数。</p>\n<p>使用<strong>点运算符（.）</strong>来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。</p>\n<p>我们使用<strong>调用运算符（()）</strong>来调用一个函数，它是一对圆括号，里面放实参列表（可能为空）。# 第二章</p>\n<ol>\n<li>‘void*’<br>是一种特殊的指针类，可以存放任意对象的地址。  </li>\n<li>const 对象必须初始化。 const int buf =10  </li>\n<li>const 指针，其值不能被改变，所有必须初始化。</li>\n<li>顶层const和底层const，顶层const表示指针本身是一个常量，底层const表示指针所指对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。</li>\n</ol>\n<pre><code>int i = 0;\nint *const p1 = &amp;i;    // 不能改变p1的值，p1是一个顶层const\nconst int ci = 42；    // 不能改变ci的值，ci是一个顶层const\nconst int *p2 = &amp;ci;   // 允许改变p2的值，p2是一个底层const\nconst int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const\nconst int &amp;r = ci;     // 用于声明引用的const都是底层const</code></pre><p>C++新标准引入了第二种类型说明符<strong>decltype</strong>，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p>\n<pre><code>decltype(f()) sum = x; // sum的类型就是函数f的返回类型</code></pre><p>编译器并不实际调用f，而是使用当调用发生时f的返回值的类型作为sum的类型。</p>\n<p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：</p>\n<pre><code>const int ci = 0, &amp;cj = ci;\ndecltype(ci) x = 0; // x的类型是const int\ndecltype(cj) y = x; // y的类型是const int&amp;, y绑定到x</code></pre><p><strong>decltype和引用</strong></p>\n<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式向decltype返回一个引用类型，一般来说，意味着该表达式的结果对象能作为一条赋值语句的左值：</p>\n<pre><code>// decltype的结果可以是引用类型\nint i = 42, *p = &amp;i, &amp;r = i;\ndecltype(r + 0) b; // 正确，加法的结果是int，因此b是一个int\ndecltype(*p) c; // 错误，c是int&amp;，必须初始化</code></pre><p>如果表达式的内容是解引用操作，则decltype将得到引用类型。</p>\n<p>有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：</p>\n<pre><code>// decltype的表达式如果是加上了括号的变量，结果是引用\ndecltype((i)) d; // 错误，d是int&amp;，必须初始化\ndecltype(i) e; // 正确，e是一个int。</code></pre><p><strong>auto 和decltype的区别主要有三个方面</strong>：<br>第一，auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。<br>第二，编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。<br>第三，与auto不同，decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。</p>\n<h1 id=\"字符串、向量和数组\"><a href=\"#字符串、向量和数组\" class=\"headerlink\" title=\"字符串、向量和数组\"></a>字符串、向量和数组</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><ol>\n<li><strong>头文件不应包含using声明</strong>  </li>\n<li><strong>初始化string对象的方式：</strong>  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string s1;           // 默认初始化，s1是一个空串\nstring s2(s1);       // s2是s1的副本\nstring s2 = s1;      // 等价于s2(s1)\nstring s3(\"value\");  // s3是字面值\"value\"的副本，不包括最后的空字符\nstring s3 = \"value\"; // 等价于s3(\"value\")\nstring s4(n, 'c');   // 初始化为由n个字符c组成的串<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><strong>直接初始化和拷贝初始化</strong>  </li>\n</ol>\n<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化（copy initialization）</strong>，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是<strong>直接初始化</strong>（direct initialization）。  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string s5 = \"hiya\";  // 拷贝初始化\nstring s6(\"hiya\");   // 直接初始化\nstring s7(10, 'c');  // 直接初始化<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ol start=\"4\">\n<li>getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。  </li>\n</ol>\n<p><strong>string::size_type类型</strong>  </p>\n<p>size函数返回的是一个string::size_type类型的值。这是一个无符号的整数。  </p>\n<ol start=\"5\">\n<li><strong>处理每个字符？使用基于范围的for语句</strong>  </li>\n</ol>\n<p>如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：<strong>范围for</strong>（range for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">for (declaration : expression)\n    statement<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">for (auto c : str)\n    // do something<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>使用下标运算符</strong></p>\n<p><code>[ ]</code>符号叫做下标运算符，范围是<code>[0, s.size())</code>，越界的结果是UB（undefined behavior，未定义行为）。  </p>\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h2><ol>\n<li>vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。  </li>\n<li>vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。  </li>\n<li>vector是模板而非类型，由vector生成的类型必须包含元素的类型，如：  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">vector<int> v;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><strong>vector中存放的是对象，而引用不是对象，故不能存储引用。</strong>  <h3 id=\"定义和初始化vector对象\"><a href=\"#定义和初始化vector对象\" class=\"headerlink\" title=\"定义和初始化vector对象\"></a>定义和初始化vector对象</h3>vector模板控制着初始化向量的方法。定义vector对象的方法有：  </li>\n</ol>\n<ul>\n<li><code>vector&lt;T&gt; v1</code>，默认初始化，v1是一个空的vector  </li>\n<li><code>vector&lt;T&gt; v2(v1)</code>，v2中包含v1所有元素的副本  </li>\n<li><code>vector&lt;T&gt; v2 = v1</code>，等价于v2(v1)  </li>\n<li><code>vector&lt;T&gt; v3(n, val)</code>，v3包含了n个重复的元素，每个元素的值都是val  </li>\n<li><code>vector&lt;T&gt; v4(n)</code>，v4包含了n个执行了值初始化的对象  </li>\n<li><code>vector&lt;T&gt; v5{a,b,c...}</code>，v5里包含了用a,b,c…初始化的元素  </li>\n<li><code>vector&lt;T&gt; v5 = {a,b,c...}</code>，等价于<code>vector&lt;T&gt; v5{a,b,c...}</code>  </li>\n</ul>\n<p><strong>值初始化</strong><br>值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。<br><code>vector&lt;T&gt;(n)</code>中，所有元素将执行值初始化。</p>\n<h3 id=\"向vector中添加元素\"><a href=\"#向vector中添加元素\" class=\"headerlink\" title=\"向vector中添加元素\"></a>向vector中添加元素</h3><p>push_back函数把一个元素压入vector对象的尾端。<br>vector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。<br><strong>一定不能在遍历vector的时候改变vector对象的大小。</strong><br>C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。  </p>\n<h3 id=\"其它vector操作\"><a href=\"#其它vector操作\" class=\"headerlink\" title=\"其它vector操作\"></a>其它vector操作</h3><p>如（很多和string类似）：</p>\n<ul>\n<li><code>v.empty()</code>，如果v不含有任何元素，返回true  </li>\n<li><code>v.size()</code>，返回v中的元素个数  </li>\n<li><code>v[n]</code>，返回v中第n个位置上元素的引用  </li>\n<li><code>v1 = v2</code>，v2中的元素将拷贝替换v1的  </li>\n<li><code>v1 = {a,b,c...}</code>，列表中的元素将拷贝替换v1中的  </li>\n<li><code>v1 == v2</code>, <code>v1 != v2</code>，元素数量相同，对应位置的元素也相等，则相等  </li>\n<li>&lt;,&lt;=,&gt;,&gt;=，比首个相异元素的大小，如都一样，比长度，即字典顺序<br>size返回的类型由vector定义的size_type类型。<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">vector<int>::size_type    // 正确\nvector::size_type         // 错误<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<p><strong>只有当元素的值可比较时，vector对象才能被比较。只能对确已存在的元素执行下标操作。</strong>  </p>\n<h2 id=\"迭代器介绍\"><a href=\"#迭代器介绍\" class=\"headerlink\" title=\"迭代器介绍\"></a>迭代器介绍</h2><p>使用迭代器（iterator）是一种通用的访问容器中元素的方法。<br>迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。</p>\n<h3 id=\"使用迭代器\"><a href=\"#使用迭代器\" class=\"headerlink\" title=\"使用迭代器\"></a>使用迭代器</h3><p>有迭代器的类型同时拥有返回迭代器的成员。<br>标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。<br>end成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫<strong>尾后迭代器（off-the-end iterator）</strong>。<br>如果容器为空，begin和end都返回尾后迭代器。即：<code>v.begin() == v.end()</code><br>如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto b = v.begin();\nauto e = v.end();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>迭代器运算符</strong><br>标准容器迭代器的运算符：  </p>\n<ul>\n<li><code>*iter</code>，返回迭代器所指对象的引用（解引用）  </li>\n<li><code>iter-&gt;mem</code>，解引用iter，并获取其成员mem，等价于<code>(*iter).mem</code>  </li>\n<li><code>++iter</code>，令iter指示容器中的下一个元素  </li>\n<li><code>--iter</code>，令iter指示容器中的上一个元素  </li>\n<li><code>iter1 == iter2</code>，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等<br>迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。  </li>\n</ul>\n<p><strong>迭代器类型</strong><br>标准库类型使用iterator和const_iterator来表示迭代器类型。<br>如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">vector<int>::iterator it1;\nvector<int>::const_iterator it2;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>it1能读写元素，而it2只能读。<br>认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。<br><strong>begin和end运算符</strong>begin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。<br>为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto it = v.cbegin();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>箭头运算符</strong>即<code>-&gt;</code>，它把解引用和成员访问两个操作结合在一起。即：<code>(*iter).mem</code>等价于<code>iter-&gt;mem</code>。<br><strong>某些对vector对象的操作会使迭代器失效</strong>任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。</p>\n<h3 id=\"迭代器运算\"><a href=\"#迭代器运算\" class=\"headerlink\" title=\"迭代器运算\"></a>迭代器运算</h3><p>递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。<br>string和vector的迭代器提供了额外的运算符，有：  </p>\n<ul>\n<li><code>iter + n</code>，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器  </li>\n<li><code>iter - n</code>，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器  </li>\n<li><code>iter1 - iter2</code>，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  </li>\n<li><code>&gt;,&gt;=,&lt;,&lt;=</code>，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置    </li>\n</ul>\n<p><strong>迭代器的算数运算</strong><br>迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。<br>difference_type是一个带符号的整数，string和vector都定义了这个类型。<br><strong>迭代器相加没有意义</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto mid = (beg) +(end-beg)/2;//正确\nauto mid =(beg+end)/2;//错误 迭代器加法不存在<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>string类本身接受无参数的初始化方式，无论数组定义在函数体内部还是外部都被默认初始化为空串，对于内置类型int，数组定义在函数体外部时默认初始化为0，在main函数内部时，将不被初始化。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ol>\n<li>数组是存放相同类型的对象的容器，这些对象是匿名的。  </li>\n<li>数组的大小确定不变。  </li>\n<li>数组是一种内置类型。  <h3 id=\"定义和初始化内置数组\"><a href=\"#定义和初始化内置数组\" class=\"headerlink\" title=\"定义和初始化内置数组\"></a>定义和初始化内置数组</h3>数组是一种复合类型，其声明形如<code>a[N]</code>  。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个<strong>常量表达式</strong>，即其值在编译期间已知。<br>默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。<br>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。  </li>\n</ol>\n<p><strong>显式初始化数组元素</strong><br>即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a1[10] = {0}; // 剩下的元素执行值初始化，即为0\nint a2[] = {1, 2, 3};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>字符数组的特殊性</strong>可以用字符串字面值对此类数组进行初始化。如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">char s[] = \"hello\";<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这样初始化的数组包含结尾的空字符。<br><strong>不允许拷贝和赋值</strong><br>这样的操作是非法的：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a1[] = {1, 2, 3};\nint a2[] = a1; // 非法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>理解复杂的数组声明</strong>  </p>\n<ol>\n<li>定义一个指针数组<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int* a[10] = {};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>定义一个指向数组的指针：  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int (*ptr)[10] = &a;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>定义一个绑定到数组的引用：  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int (&a_ref)[10] = a;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。  <h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3>使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。可以使用范围for语句来遍历数组。  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">for (auto i : arr)\n cout << i << \" \";\ncout << endl;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n</ol>\n<p><strong>得到数组的大小</strong></p>\n<pre><code>sizeof(array/sizeof(array[0];</code></pre><p><strong>检查下标的值</strong><br>与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。  </p>\n<h3 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h3><p>在很多用到数组名字的地方，编译器都会自动地将其替换为一个<strong>指向数组首元素的指针</strong>。<br><strong>decltype</strong><br>下面得到一个数组类型：   </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a1[10] = {};\ndecltype(a1) a2;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>auto</strong><br>下面得到一个整型指针：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a1[10] = {};\nauto a2(a1);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>指针也是迭代器</strong><br>string和vector的迭代器支持的运算，指针都支持。使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。这样可以获取数组尾元素的下一个位置的指针：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int *end = &a[N];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a[10] = {};\nint *beg_p = begin(a);\nint *end_p = end(a);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>这俩函数定义在头文件iterator.h中。尾后指针不能解引用和递增操作。和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。<br><strong>下标和指针</strong><br>对数组执行下标运算其实是对指向数组元素的指针执行下标运算：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int i = ia[2];    // ia转换成指向数组首元素的指针\n                  // ia[2]得到(ia + 2)所指的元素\nint *p = ia;      // p指向ia的首元素\ni = *(p + 2);     // 等价于i = ia[2]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>只要指针指向的是数组中的元素，都可以执行下标运算。<br>内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。  </p>\n<h3 id=\"C风格字符串\"><a href=\"#C风格字符串\" class=\"headerlink\" title=\"C风格字符串\"></a>C风格字符串</h3><p>C风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null terminated）。<br>p109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。<br><strong>c_str函数</strong><br>string可使用c_str函数返回其C风格的字符串，如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string s(\"hello\");\nconst char *c_s = s.c_str();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方<br><strong>使用数组初始化vector对象</strong>如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a[] = {1, 2, 3};\nvector<int> vec(begin(a), end(a));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><p>多维数组，实际上是数组的数组。<br>如：<code>int a[3][4]</code>，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。<br>对于二维数组，常把第一个维度看作行，第二个维度看作列。<br><strong>多维数组的初始化</strong>如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a[3][4] = {\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9, 10, 11}\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>列表初始化中未列出的元素执行值初始化。<br><strong>多维数组的下标引用</strong><br>如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a[3][4] = {};\nint (&row)[4] = a[2]; // row绑定到a的第二个数组上<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>使用范围for语句处理多维数组</strong><br>如果是外层循环，控制变量将得到数组类型。<br>除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。<br><strong>指针和多维数组</strong><br>当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。<br>多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。<br>即：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int a[2][3] = {};\nint (*p)[3] = a;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>还可以使用auto或者begin来得到指向内层数组的指针。<br><strong>类型别名简化多维数组的指针</strong><br>可以这样定义一个数组类型：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">using int_arr = int[4]; // C++11\ntypedef int int_arr[4];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>指针</strong>  </p>\n<ol>\n<li>指针本身的值（value）；</li>\n<li>指针所指的对象（content）；</li>\n<li>指针本身在内存中的储存位置（address）</li>\n</ol>\n<h1 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h1><ol>\n<li><code>*iter.empty()</code>和<code>(*iter).empty()</code>和<code>iter-&gt;empty()</code>的区别  </li>\n<li><code>somevalue ? ++x,++y:--x,--y;</code>等价于<code>(somevalue ? ++x,++y:--x),--y;</code><h1 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h1></li>\n</ol>\n<p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。<br>|运算符|功能|用法|<br>|-|-|-|<br>|<del>|位求反|</del>expr|<br>|&lt;&lt;|左移|expr1 &lt;&lt; expr2|<br>|&gt;&gt;|右移|expr1 &gt;&gt; expr2|<br>|&amp;|位与|expr1 &amp; expr2|<br>|^|位异或|expr1 ^ expr2|<br>|||位或|expr1 | expr2|</p>\n<p>一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。<br>强烈建议将位运算符用于处理无符号类型。<br>一个提升例子就是，如果对char做位运算，它会先被提升为int。<br><strong>移位运算符</strong><br>&lt;&lt;和&gt;&gt;<br>运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。<br>左移运算符&lt;&lt;在右侧插入值为0的二进制位。右移运算符&gt;&gt;的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。  </p>\n<h1 id=\"sizeof运算符\"><a href=\"#sizeof运算符\" class=\"headerlink\" title=\"sizeof运算符\"></a>sizeof运算符</h1><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：  </p>\n<ul>\n<li>sizeof(type)</li>\n<li>sizeof?expr<br>常量表达式意味着在编译期间就能得到计算。<br>第二种形式中，sizeof返回的是表达式结果类型的大小。<br>sizeof运算符的结果部分地依赖于其作用的类型：  </li>\n<li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li>\n<li>对引用类型执行sizeof运算得到被引用对象所占空间大小。</li>\n<li>对指针执行sizeof运算得到指针本身所占空间的大小。</li>\n<li>对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。</li>\n<li>对数组执行sizeof运算得到整个数组所占空间大小。</li>\n<li>对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。<h1 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"?显式转换\"></a>?显式转换</h1></li>\n</ul>\n<p><strong>命名的强制类型转换</strong><br>一个命名的强制类型转换有如下形式：<br>cast-name<type>(expression);<br>其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast,?dynamic_cast,?const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。<br><strong>static_cast</strong><br>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</type></p>\n<pre><code>//?进行强制类型转换以便执行浮点数除法\ndouble?slope?=?static_cast&lt;double&gt;(j)?/?i;</code></pre><p>当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。<br>static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*的指针中的值：  </p>\n<pre><code>void?*p?=?&amp;d;????//?正确，任何非常量对象的地址都能存入void*\n\n//?正确，将void*转换回初始的指针类型\ndouble?*dp?=?static_cast&lt;double*&gt;(p);</code></pre><p>必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。<br><strong>const_cast</strong><br>const_cast只能改变运算对象的底层const：  </p>\n<pre><code>const?char?*pc;\nchar?*p?=?const_cast&lt;char*&gt;(pc);????//?正确，但是通过p写值是未定义的行为</code></pre><p>如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。<br>const_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。<br><strong>reinterpret_cast</strong><br>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：  </p>\n<pre><code>int?*ip;\nchar?*pc?=?reinterpret_cast&lt;char*&gt;(ip);</code></pre><p>我们必须牢记pc所指的真实对象是一个int而非字符。<br>    reinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。<br><strong>旧式的强制类型转换</strong><br>在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：  </p>\n<pre><code>type(expr);???//?函数形式的强制类型转换\n(type)expr;???//?C语言风格的强制类型转换</code></pre><p>根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast,?static_cast或reinterpret_cast相似的行为。<br>    与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。# try语句块<br>try语句块的通用语法形式是：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">try {\n    program-statements\n} catch (exception-declaration) {\n    handler-statements\n} // ...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。<br>try语句块内声明的变量在catch子句内无法访问。<br>一个简要的例子：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">while (cin >> item1 >> item2) {\n    try {\n        // ... 可能抛出一个异常的代码\n    } catch (runtime_error err) {\n        cout << err.what() << \"\\nTry Again? Enter y or n\" << endl;\n        char c;\n        cin >> c;\n        if (!cin || c == 'n')\n            break; // 跳出while循环\n    }\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"throw表达式\"><a href=\"#throw表达式\" class=\"headerlink\" title=\"throw表达式\"></a>throw表达式</h1><p>抛出异常的一个例子是：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">throw runtime_error(\"Data must refer to same ISBN\");<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。  </p>\n<ul>\n<li><strong>throw 表达式（throw expression）</strong>，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw<strong>引发（raise）</strong>了异常。  </li>\n<li><strong>try语句块（try block）</strong>，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个<strong>catch子句（catch clause）</strong>结束。try语句块中代码抛出的异常通常会被某个catch子句处理。  </li>\n<li>一套<strong>异常类（exception class）</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。  <h1 id=\"简单语句\"><a href=\"#简单语句\" class=\"headerlink\" title=\"简单语句\"></a>简单语句</h1>C++语言中的大多数语句都以分号结束，一个表达式，比如ival+5，末尾加上分号就变成了<strong>表达式语句</strong>(expression statement)，表达式语句的作用是执行表达式并丢弃掉求值结果：<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">ival + 5;    // 无意义的表达式语句\ncout << ival;// 有意义的表达式语句<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<p><strong>空语句</strong><br>最简单的语句是<strong>空语句</strong>（null statement），它只有一个分号： </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">; // 空语句<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。<br><strong>复合语句（块）</strong><br>复合语句（compound statement）是指用花括号括起来的语句和声明的序列，复合语句也被称作<strong>块</strong>（block）。一个块就是一个作用域。<br>如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。<br>所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">while (cin >> s && s != sought)\n{}  // 空块<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h1 id=\"语句作用域\"><a href=\"#语句作用域\" class=\"headerlink\" title=\"语句作用域\"></a>语句作用域</h1><p>可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">while (int i = get_num()) // 每次迭代时创建并初始化\n    cout << i << endl;\ni = 0;    // 错误，在循环外部无法访问<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h1><p>C++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流；另一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。  </p>\n<h2 id=\"if语句-1\"><a href=\"#if语句-1\" class=\"headerlink\" title=\"if语句\"></a>if语句</h2><p>if语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。  </p>\n<h2 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h2><p>switch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。  </p>\n<h1 id=\"迭代语句\"><a href=\"#迭代语句\" class=\"headerlink\" title=\"迭代语句\"></a>迭代语句</h1><p>迭代语句通常称之为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。  </p>\n<h2 id=\"while语句-1\"><a href=\"#while语句-1\" class=\"headerlink\" title=\"while语句\"></a>while语句</h2><p>语法格式是：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">while (condition)\n    statement<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>只要condition的求值结果为真就一直执行statement。如果condition第一次求值就是false，statement一次都不执行。<br>while的条件部分可以是一个表达式或者是一个带初始化的变量声明。<br><strong>使用while循环</strong><br>当不确定到底要迭代多少次时，使用while循环比较合适。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。  </p>\n<h2 id=\"传统的for语句\"><a href=\"#传统的for语句\" class=\"headerlink\" title=\"传统的for语句\"></a>传统的for语句</h2><p>for语句的语法形式是  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">for (init-statement: condition; expression)\n    statement<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"范围for语句\"><a href=\"#范围for语句\" class=\"headerlink\" title=\"范围for语句\"></a>范围for语句</h2><p>C++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。<strong>范围for语句</strong>（range for statement）的语法形式是：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">for (declaration : expression)\n    statement<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>expression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。<br>declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。<br>每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。<br>在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。因此不能通过范围for语句增加vector对象的元素。  </p>\n<h2 id=\"do-while语句\"><a href=\"#do-while语句\" class=\"headerlink\" title=\"do while语句\"></a>do while语句</h2><p>do while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少会执行一次循环。do while语句的语法形式如下：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">do\n    statement\nwhile (condition);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h2><p>跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break, continue, goto和return。本章介绍前三种，return在第六章介绍（p199页）。  </p>\n<h2 id=\"break语句\"><a href=\"#break语句\" class=\"headerlink\" title=\"break语句\"></a>break语句</h2><p>break语句负责终止离它最近的while, do while, for或switch语句，并从这些语句之后的第一条语句开始执行。</p>\n<h2 id=\"continue语句\"><a href=\"#continue语句\" class=\"headerlink\" title=\"continue语句\"></a>continue语句</h2><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for, while和do while循环的内部。  </p>\n<h2 id=\"goto语句\"><a href=\"#goto语句\" class=\"headerlink\" title=\"goto语句\"></a>goto语句</h2><p>goto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。  </p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h2 id=\"函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。\"><a href=\"#函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。\" class=\"headerlink\" title=\"函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。  \"></a>函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。  </h2><h2 id=\"函数基础\"><a href=\"#函数基础\" class=\"headerlink\" title=\"函数基础\"></a>函数基础</h2><p>一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。<br>我们通过<strong>调用运算符（call operator）</strong>来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。<br>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，<strong>主调函数</strong>（calling function）的执行暂时被中断，<strong>被调函数</strong>（called function）开始执行。<br>当遇到一条return语句时函数结束执行过程。函数的返回值用于初始化调用表达式的结果。<br><strong>函数返回类型</strong><br>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何类型。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。  </p>\n<h3 id=\"局部对象\"><a href=\"#局部对象\" class=\"headerlink\" title=\"局部对象\"></a>局部对象</h3><p>在C++语言中，名字有作用域，对象有<strong>生命周期（lifetime）</strong>，理解这两个概念非常重要：  </p>\n<ul>\n<li>名字的作用域是程序文本的一部分，名字在其中可见。  </li>\n<li>对象的生命周期是程序执行过程中该对象存在的一段时间。<br>形参和函数体内部定义的变量统称为<strong>局部变量（local variable）</strong>。它们仅在函数的作用域内可见。<br>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。  </li>\n</ul>\n<p><strong>自动对象</strong><br>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为<strong>自动对象（automatic object）</strong>。<br>形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。<br>对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化（内置类型产生未定义的值）。<br><strong>局部静态对象（local static object）</strong>在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。例：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 统计函数被调用了多少次\nsize_t count_calls()\n{\n    static size_t ctr = 0; // 调用结束后，这个值仍然有效\n    return ++ctr;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h3><p>函数的名字必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。<br>函数的声明和定义唯一的区别是<strong>声明无须函数体</strong>，用一个分号替代即可。<br>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作<strong>函数原型（function prototype）</strong>。<br><strong>在头文件中进行函数声明</strong><br>我们建议函数在头文件中声明，在源文件中定义。<br>这是因为如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。<br>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。  </p>\n<h3 id=\"分离式编译\"><a href=\"#分离式编译\" class=\"headerlink\" title=\"分离式编译\"></a>分离式编译</h3><p>C++语言支持所谓的<strong>分离式编译（separate compilation）</strong>。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。  </p>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><p>如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。<br>当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>（passed by reference）或者函数被<strong>传引用调用</strong>（called by reference）。<br>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>（passed by value）或函数被<strong>传值调用</strong>（called by value）。  </p>\n<h3 id=\"传值参数\"><a href=\"#传值参数\" class=\"headerlink\" title=\"传值参数\"></a>传值参数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。<br><strong>指针形参</strong><br>当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。<br>    熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。</p>\n<h3 id=\"传引用参数\"><a href=\"#传引用参数\" class=\"headerlink\" title=\"传引用参数\"></a>传引用参数</h3><p>对于引用的操作实际上是作用于引用所引的对象上，引用形参也是如此。通过使用引用形参，允许函数改变一个或多个实参的值。<br><strong>使用引用避免拷贝</strong><br>拷贝大的类类型对象或者容器对象比较低效。甚至有的类型根本就不支持拷贝操作。此时应该使用引用形参访问该类型的对象。<br>如果函数无须改变引用形参的值，最好将其声明为常量引用。<br><strong>使用引用形参返回额外信息</strong><br>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。那就是通过引用形参并修改它（也就是修改了其引用的对象），从而作为结果传出。  </p>\n<h3 id=\"const形参和实参\"><a href=\"#const形参和实参\" class=\"headerlink\" title=\"const形参和实参\"></a>const形参和实参</h3><p>当形参是const时，必须注意关于顶层const的讨论（p57）。<br>当用实参初始化形参时会忽略形参的顶层const。即当形参有顶层const时，传递给它常量对象或者非常量对象都是可以的。<br>忽略形参的顶层const可能产生意想不到的结果：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void fcn(const int i) {}\nvoid fcn(int i) {}    // 错误：重复定义<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表有明显的区别。因为顶层const被忽略了，所以在上面的代码中传入两个fcn函数的参数可以完全一样（从而编译器不知道该调用哪一个）。<br><strong>指针或引用形参与const</strong><br>我们可以使用非常量初始化一个底层const，但是反过来不行（不能用一个常量初始化一个非底层const）；同时一个普通的引用必须用同类型的对象初始化。<br><strong>尽量使用常量引用</strong><br>把函数不会改变的形参定义成（普通的）引用是一种常见错误，这么做给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型（比如无法传入一个常量对象了）。<br>比如下面这个例子将导致编译错误（p192）：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 不良设计，第一个形参的类型应该是const string&\nstring::size_type find_char(string &s, char c, string::size_type &occurs);\n//...\nfind_char(\"Hello World\", 'o', ctr); // 无法编译通过<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"数组形参\"><a href=\"#数组形参\" class=\"headerlink\" title=\"数组形参\"></a>数组形参</h3><p>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。<br>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);    // 可以看出来，函数的意图是作用于一个数组\nvoid print(const int[10]);  // 这里的维度表示我们期望数组含有多少元素，实际不一定<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。  </code></pre><p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技术。  </p>\n<ol>\n<li>使用标记指定数组长度，如C风格字符串。  </li>\n<li>使用标准库规范，如传递首元素和尾后元素的指针，来表示一个范围。  </li>\n<li>显示传递一个表示数组大小的形参。  </li>\n</ol>\n<p><strong>数组形参和const</strong><br>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。<br><strong>数组引用形参</strong><br>C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 正确，形参是数组的引用，维度是类型的一部分\nvoid print(int (&arr)[10])\n{\n    for (auto elem : arr)\n        cout << elem << endl;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>但这一用法也限制了print函数的可用性，我们只能将函数作用于大小为10的数组。<br><strong>传递多维数组</strong><br>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，也就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// matrix指向数组的首元素，该数组的元素是由10个整数构成的数组\nvoid print(int (*matrix)[10], int rowSize) { /* ... */ }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre><code>`*matrix`两端的括号必不可少：`int *matrix[10]//10个指针构成的数组`；`int (*matrix)[10]//指向含有10个整数的数组的指针`。</code></pre><p>也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 等价定义\nvoid print(int matrix[][10], int rowSize) { /* ... */ }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。  </p>\n<h3 id=\"main-处理命令行选项\"><a href=\"#main-处理命令行选项\" class=\"headerlink\" title=\"main: 处理命令行选项\"></a>main: 处理命令行选项</h3><p>有时候我们需要给main函数传递实参。一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">prog -d -o ofile data0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这些命令行选项通过两个（可选的）形参传递给main函数。  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int main(int argc, char *argv[]) { ... }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量；argc至少为1。<br>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。<br>以上面的为例，argc应该等于5，argv应该包含如下的C风格字符串：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">argv[0] = \"prog\";    // 或者argv[0]也可以指向一个空字符串\nargv[1] = \"-d\";\nargv[2] = \"-o\";\nargv[3] = \"ofile\";\nargv[4] = \"data0\";\nargv[5] = 0;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>当使用argv中的实参时，一定要记得可选的实参从`argv[1]`开始；`argv[0]`保存程序的名字，而非用户的输入。</code></pre><h3 id=\"含有可变形参的函数\"><a href=\"#含有可变形参的函数\" class=\"headerlink\" title=\"含有可变形参的函数\"></a>含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：</p>\n<ol>\n<li>如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；  </li>\n<li>如果实参的类型不同，我们可以编写一种可变参数模板，其细节将在16.4节介绍（p618）。<br>C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序。  </li>\n</ol>\n<p><strong>initializer_list形参</strong><br>initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。<br>与vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。<br><strong>省略符形参</strong><br>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的。<br>    省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。<br>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void foo(param_list, ...);\nvoid foo(...);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"返回类型和return语句\"><a href=\"#返回类型和return语句\" class=\"headerlink\" title=\"返回类型和return语句\"></a>返回类型和return语句</h2><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。<br>return语句有两种形式：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">return;\nreturn expression;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"无返回值函数\"><a href=\"#无返回值函数\" class=\"headerlink\" title=\"无返回值函数\"></a>无返回值函数</h3><p>没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。  </p>\n<h3 id=\"有返回值函数\"><a href=\"#有返回值函数\" class=\"headerlink\" title=\"有返回值函数\"></a>有返回值函数</h3><p>只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。<br><strong>值是如何被返回的</strong><br>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。<br>如果函数返回引用，则该引用仅是它所引对象的一个别名。<br><strong>不要返回局部对象的引用或指针</strong><br>函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。<br><strong>返回类类型的函数和调用运算符</strong><br>调用运算符的优先级和点运算符、箭头运算符相同，并且符合左结合律。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//调用string对象的size成员，该string对象有shorterstring函数返回\nauto sz = shorterstring(s1,s2).size();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>引用返回左值</strong><br>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">char &get_val(string &str,string::size_type ix){\n    return str[ix];\n}\nint main(){\n    string s(\"a value\");\n    cout<<s<<endl;\n    get_val(s,0)='A';\n    cout<<s<<endl;\n    return 0;    \n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>列表初始化返回值</strong><br>C++11新标准规定，函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。<br><strong>主函数main的返回值</strong><br>我们允许main函数没有return语句直接结束，这样编译器将隐式地插入一条返回0的return语句，表示执行成功。<br>为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，可以用来表示成功与失败：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int main()\n{\n    if (some_failure)\n        return EXIT_FAILURE;\n    else\n        return EXIT_SUCCESS;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>递归</strong><br>如果函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为<strong>递归函数</strong>（recursive function）。<br>在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。<br>    main函数不能调用它自己。  </p>\n<h3 id=\"返回数组指针\"><a href=\"#返回数组指针\" class=\"headerlink\" title=\"返回数组指针\"></a>返回数组指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。使用<strong>类型别名</strong>（p60）可以简化这种返回类型：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef int arrT[10];    // arrT是一个类型别名，表示含有10个整数的数组\nusing arrT = int[10];    // arrT的等价声明\narrT* func(int i);       // func返回一个指向含有10个整数的数组的指针<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>声明一个返回数组指针的函数</strong><br>返回数组指针的函数形式如下：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Type (*function(param_list))[dimension]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（*表示返回的是一个指针。）例：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int (*func(int i))[10];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>可以按照以下的顺序来逐层理解该声明的含义：  </p>\n<ul>\n<li><code>func(int i)</code>表示调用func函数时需要一个int类型的实参。  </li>\n<li><code>(*func(int i))</code>意味着我们可以对函数的调用结果执行解引用操作。  </li>\n<li><code>(*func(int i))[10]</code>表示解引用func的调用将得到一个大小是10的数组。  </li>\n<li><code>int (*func(int i))[10]</code>表示数组中的元素是int类型。  </li>\n</ul>\n<p><strong>使用尾置返回类型</strong><br>C++新标准提供了另一种简化上述func声明的方法，就是使用<strong>尾置返回类型（trailing return type）</strong>。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。<br>尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<code>auto</code>：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -> int(*)[10];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>使用decltype</strong><br>如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型（即获得一个数组类型）。例：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *arrPtr(int i)\n{\n    return (i % 2) ? &odd : &even;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code> decltype并不负责把数组类型转换成对应的指针，所以decltype的结果只是一个数组，要想表示arrptr返回指针还必须在函数声明时加一个`*`的符号。</code></pre><h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载（overload）函数</strong>。比如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void print(const char *cp);\nvoid print(const int *beg, const int *end);\nvoid print(const int ia[], size_t size);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。<br>函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。<br>main函数不能重载。<br>不允许两个函数除了返回类型以外其他所有的要素都相同。比如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Record lookup(const Account&);\nbool lookup(const Account&);    // 错误，与上一个函数相比只有返回类型不同<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre><code> my note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。  </code></pre><p><strong>重载和const形参</strong><br>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Record lookup(Phone);\nRecord lookup(const Phone);    // 重复声明<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Record lookup(Account&);       // 此函数作用于Account的引用\nRecord lookup(const Account&); // 新函数，作用于常量引用<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。<br><strong>const_cast和重载</strong><br>const_cast在重载函数的情境中最有用。比如这两个重载函数：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 比较两个string对象的长度，返回较短的那个引用\nconst string &shorterString(const string &s1, const string &s2)\n{\n    return s1.size() <= s2.size() ? s1 : s2; \n}\n\n// 重载\nstring &shorterString(string &s1, string &s2)\n{\n    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));\n    return const_cast<string&>(r);\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const&amp;，这显然是安全的。<br>    传入非常量的实参将调用非常量的版本。<br><strong>调用重载的函数</strong><br>定义了一组重载函数后，我们需要以合理的实参调用它们。<strong>函数匹配（function matching）</strong>是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。<br>当调用重载函数时有三种可能的结果：  </p>\n<ul>\n<li>编译器找到一个与实参<strong>最佳匹配（best match）</strong>的函数，并生成调用该函数的代码。</li>\n<li>找不到任何一个函数与调用的实参匹配，此时编译器发出<strong>无匹配（no match）</strong>的错误信息。</li>\n<li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用（ambiguous call）</strong>。<h3 id=\"重载与作用域\"><a href=\"#重载与作用域\" class=\"headerlink\" title=\"重载与作用域\"></a>重载与作用域</h3>一般来说，将函数声明置于局部作用域内不是一个明智的选择。<br>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。  <h2 id=\"特殊用途语言特性\"><a href=\"#特殊用途语言特性\" class=\"headerlink\" title=\"特殊用途语言特性\"></a>特殊用途语言特性</h2><h3 id=\"默认实参\"><a href=\"#默认实参\" class=\"headerlink\" title=\"默认实参\"></a>默认实参</h3>这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的<strong>默认实参</strong>（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef string::size_type sz;\nstring screen(sz ht = 24, sz wid = 80, char backrnd = ' ');<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。  </li>\n</ul>\n<p><strong>使用默认实参调用函数</strong><br>如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string window;\nwindow = screen();    // 等价于screen(24, 80, ' ');\nwindow = stcreen(66); // 等价于screen(66, 80, ' ');<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。<br>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。<br><strong>默认实参初始值</strong><br>局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。<br>如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int g_a = 0;\nvoid f(int a = g_a);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"内联函数和constexpr函数\"><a href=\"#内联函数和constexpr函数\" class=\"headerlink\" title=\"内联函数和constexpr函数\"></a>内联函数和constexpr函数</h3><p>调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。<br><strong>内联函数可以避免函数调用的开销</strong><br>将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。<br>内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。<br>内联机制用于优化规模小，流程直接，频繁调用的函数。<br><strong>constexpr函数</strong><br>是指能用于<strong>常量表达式</strong>的函数。<br>函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">constexpr int new_sz() { return 8; }\nconstexpr int foo = new_sz();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>constexpr函数被隐式地指定为内联函数。<br><strong>把内联函数和constexpr函数放在头文件内</strong><br>这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。  </p>\n<h3 id=\"调试帮助\"><a href=\"#调试帮助\" class=\"headerlink\" title=\"调试帮助\"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。<br><strong>assert预处理宏</strong><br>assert是一种<strong>预处理宏（preprocessor macro）</strong>。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">assert(expr);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。<br>assert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无需提供using声明。<br>assert宏常用于检查“不能发生”的条件。<br><strong>NDEBUG预处理变量</strong><br>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。<br>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">$ CC -D NDEBUG main.c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。<br>我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。<br>除了用于assert，也可以使用NDEBUG编写自己的调试代码。<br>比如：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void print(const int ia[], size_t size)\n{\n#ifndef NDEBUG\n    // __func__是编译器定义的一个局部静态变量，用于存放函数的名字\n    cerr << __func__ << \"\": array size is: \" << size << endl;\n#endif\n\n// ...\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>编译器为每个函数都定义了<code>__func__</code>，除此之外，预处理器还定义了4个对于调试程序很有用的名字：  </p>\n<ul>\n<li><code>__FILE__</code>, 存放文件名的字符串字面值。  </li>\n<li><code>__LINE__</code>, 存放当前行号的整型字面值。  </li>\n<li><code>__TIME__</code>, 存放文件编译时间的字符串字面值。  </li>\n<li><code>__DATA__</code>, 存放文件编译日期的字符串字面值。  <h2 id=\"函数匹配\"><a href=\"#函数匹配\" class=\"headerlink\" title=\"函数匹配\"></a>函数匹配</h2>以下述这组函数及其调用为例,讲述编译器如何确定调用哪个重载函数:  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void f();\nvoid f(int);\nvoid f(int, int);\nvoid f(double, double = 3.14);\nf(5.6);    // 调用void f(double, double);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<p><strong>确定候选函数和可行函数</strong><br>函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为<strong>候选函数（candidate function）</strong>。候选函数具备两个特征：  </p>\n<ol>\n<li>与被调用函数同名。  </li>\n<li>其声明在调用点可见。<br>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为<strong>可行函数（viable function）</strong>。可行函数也有两个特征：  </li>\n<li>其形参数量与本次调用提供的实参数量相等。  </li>\n<li>每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。<br> 如果没有找到可行函数，编译器将报告无匹配函数的错误。</li>\n</ol>\n<p><strong>寻找最佳匹配（如果有的话）</strong><br>第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。<br>如果有且只有一个函数满足下列条件，则匹配成功：  </p>\n<ul>\n<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。  </li>\n<li>至少有一个实参的匹配优于其他可行函数提供的匹配。<br>  如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。  <h3 id=\"实参类型转换\"><a href=\"#实参类型转换\" class=\"headerlink\" title=\"实参类型转换\"></a>实参类型转换</h3>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：  </li>\n</ul>\n<ol>\n<li>精确匹配，包括以下情况：  </li>\n</ol>\n<ul>\n<li>实参类型和形参类型相同。  </li>\n<li>实参从数组类型或函数类型转换成对应的指针类型。  </li>\n<li>向实参添加顶层const或者从实参中删除顶层const。  </li>\n</ul>\n<ol start=\"2\">\n<li>通过const转换实现的匹配（p143）。  </li>\n<li>通过类型提升实现的匹配（p142）。  </li>\n<li>通过算数类型转换或指针转换实现的匹配（p142）。  </li>\n<li>通过类类型转换实现的匹配（参见14.9节，p514）。</li>\n</ol>\n<p><strong>需要类型提升和算术类型转换的匹配</strong><br><strong>函数匹配和const实参</strong>  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int calc(char*,char*)\nint calc(const char*,const char*)\n//区别是他们的指针类型的形参是否指向了常量，属于底层const，合法定义<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int calc(char*,char*)\nint calc(char* const,char* const)\n//区别是他们的指针类型的形参是否是常量，属于顶层const,非法定义<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：   </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">bool lengthCompare(const string&, const string&);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>该函数的类型是：<code>bool (const string&amp;, const string&amp;);</code><br>要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">bool (*pf)(const string&, const string&);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>使用函数指针</strong><br>当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。<br>例如，可以这样给把函数地址赋值给指针：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">pf = lengthCompare; // pf指向名为lengthCompare的函数\npf = &lengthCompare; // 等价的赋值语句，取地址符是可选的<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>可以直接对指向函数的指针调用该函数，无须解引用指针：  </p>\n<pre><code>bool b1 = pf(&quot;Hello&quot;, &quot;Hi&quot;);\nbool b2 = (*pf)(&quot;Hello&quot;, &quot;Hi&quot;); // 等价调用\nbool b3 = lengthCompare(&quot;Hello&quot;, &quot;Hi&quot;); // 等价调用</code></pre><p>可以给函数指针赋一个nullptr或0，表示没有指向任何函数。<br><strong>重载函数的指针</strong><br>当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。<br><strong>函数指针形参</strong><br>不能定义函数类型的形参，但是形参可以是指向函数的指针。<br>当把函数名作为实参使用，它会自动转换成指针。<br>定义一个函数（以及指针）类型的方法有：  </p>\n<ul>\n<li>typedef  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef bool Func(int); // Func是函数类型\ntypedef bool (*FuncP)(int); // FuncP是函数指针类型<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li>decltype<br>假如已经有了一个函数：<code>bool Foo(int);</code>  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">decltype(Foo) Func;\ndecltype(Foo) *FuncP;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li>using  <pre class=\"line-numbers language-c++\"><code class=\"language-c++\">using Func = bool(int);\nusing FuncP = bool(*)(int);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<p><strong>返回指针函数的指针</strong><br>和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名：  </p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">using F=int(int*，int)；//F是函数类型，不是指针\nusing PF=int(*)(int*，int)；//PF是指针类型<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针：  </p>\n<pre><code>PF f1(int);//正确：PF是指向函数的指针，f1返回指向函数的指针\nF f1(int);//错误：F是函数类型，f1不能返回一个函数\nF *f1(int);//正确：显式地指定返回类型是指向函数的指针</code></pre><pre><code>出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式(参见6.3.3节，第206页)声明一个返回函数指针的函数：</code></pre><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto fl(int)->int(*)(int*，int);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>将auto和decltype用于函数指针类型</strong>  </p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>类的基本思想是<strong>数据抽象</strong>(data abstraction)和<strong>封装</strong>(encapsulation)。</p>\n<p>数据抽象就是<strong>接口(interface)与实现(implementation)分离</strong>的技术。</p>\n<p>接口就是暴露给用户的操作，比如公有的成员函数。</p>\n<p>实现就是数据成员、接口的实现、私有的成员函数。</p>\n<p>通过<strong>抽象数据类型(abstract data type)</strong>，来实现数据抽象和封装。</p>\n<h2 id=\"定义抽象数据类型\"><a href=\"#定义抽象数据类型\" class=\"headerlink\" title=\"定义抽象数据类型\"></a>定义抽象数据类型</h2><p>封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。</p>\n<p><strong>定义成员函数</strong></p>\n<p>类内的所有成员必须声明在类的内部。</p>\n<p>类的成员函数可以定义在类的内部，也可以定义在类的外部。</p>\n<pre><code>定义在类内部的函数是隐式的inline函数。</code></pre><p><strong>引入this</strong></p>\n<p>当调用一个成员函数时，实际上是替某个对象调用它。</p>\n<p>成员函数通过名为<strong>this</strong>的隐式参数来访问此对象。this指向了此对象的地址。</p>\n<p>在成员函数内部，可以省略this来访问成员。</p>\n<p>this是一个常量指针，不能够修改其值。</p>\n<p>当成员函数中调用另一个成员函数时，将隐式传递this指针。</p>\n<pre><code>std::string isbn() const {return this-&gt;bookNo;}</code></pre><p><strong>引入const成员函数</strong></p>\n<p>参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。</p>\n<p>const对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。</p>\n<p>C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。</p>\n<pre><code>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</code></pre><p><strong>类作用域和成员函数</strong></p>\n<p>类本身就是一个作用域。</p>\n<p>成员函数的定义必须包含其所属的类名（使用作用域运算符）。</p>\n<p>如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。</p>\n<p>成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。</p>\n<p><strong>定义一个返回this对象的函数</strong></p>\n<p>可以使用如下语句返回this对象：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">return *this;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>返回类型使用引用类型，表明返回的就是this所指的对象。</p>\n<p>一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。</p>\n<h3 id=\"定义类相关的非成员函数\"><a href=\"#定义类相关的非成员函数\" class=\"headerlink\" title=\"定义类相关的非成员函数\"></a>定义类相关的非成员函数</h3><p>有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。</p>\n<p>可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。</p>\n<p>有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫<strong>构造函数（constructor）</strong>。</p>\n<p>每当类对象被创建，构造函数就会被执行。</p>\n<p>构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。</p>\n<p>对于const对象，构造函数执行完毕后，它才获得const属性。</p>\n<p><strong>合成的默认构造函数</strong></p>\n<p>如果对象没有初始值，它将执行默认初始化。</p>\n<p>类通过<strong>默认构造函数(default constructor)</strong>来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。</p>\n<p>合成的默认构造函数根据如下规则初始化类成员：</p>\n<ul>\n<li><p>如果存在类内初始值，使用它来初始化成员</p>\n</li>\n<li><p>否则，对成员执行默认初始化</p>\n</li>\n</ul>\n<p><strong>某些类不能依赖合成的默认构造函数</strong></p>\n<p>所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：</p>\n<ul>\n<li><p>如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。</p>\n</li>\n<li><p>默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。</p>\n</li>\n<li><p>有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。</p>\n</li>\n</ul>\n<p><strong>=default的含义</strong></p>\n<p>C++11中，使用这种语句来让编译器生成一个默认构造函数：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">SalesData() = default;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<pre><code>这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。</code></pre><p><strong>构造函数初始值列表</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Sales_data(const std::string &s):\n                        bookNo(s){}\nSales_data(const std::string &s,unsigned n,double p):\n                        bookNo(s),units_sold(n),revenue(p*n){}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。</p>\n<p>它负责为对象的成员变量赋初值。</p>\n<p>如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。</p>\n<pre><code>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</code></pre><p><strong>在类的外部定义构造函数</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Sales data:：Sales data（std:：istream&is）\n{\nread（is，*this）；//read函数的作用是从is中读取一条交易信息然后\n        //存入this对象中\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>为了更好地理解调用函数 read的意义，要特别注意read的第二个参数是一个Sales data对象的引用。在7.1.2节（第232页）中曾经提到过，使用this来把对象当成一个整体访问，而非直接访问对象的某个成员。因此在此例中，我们使用*this将<br>“this”对象作为实参传递给read函数。</p>\n<h3 id=\"拷贝、赋值和析构\"><a href=\"#拷贝、赋值和析构\" class=\"headerlink\" title=\"拷贝、赋值和析构\"></a>拷贝、赋值和析构</h3><p>拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。</p>\n<p>赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。</p>\n<p>析构函数，当一个变量不在存在时，会执行析构。</p>\n<p>这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。</p>\n<p><strong>某些类不能依赖合成的版本</strong></p>\n<p>如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。</p>\n<p>可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。</p>\n<h2 id=\"访问控制与封装\"><a href=\"#访问控制与封装\" class=\"headerlink\" title=\"访问控制与封装\"></a>访问控制与封装</h2><p>使用<strong>访问说明符（access specifiers）</strong>加强类的封装性。</p>\n<ul>\n<li><p>public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。</p>\n</li>\n<li><p>private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。</p>\n</li>\n</ul>\n<p><strong>class和struct</strong></p>\n<p>其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。</p>\n<pre><code>作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。</code></pre><h3 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。即在函数或类前面加friend关键字。</p>\n<p>友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。</p>\n<p>一般来说，最好在类定义的开始或结束前的位置集中声明友元。</p>\n<p>“封装的益处”<br>    封装有两个重要的优点：</p>\n<pre><code>- 确保用户代码不会无意间破坏封装对象的状态。\n\n- 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。</code></pre><h2 id=\"类的其它特性\"><a href=\"#类的其它特性\" class=\"headerlink\" title=\"类的其它特性\"></a>类的其它特性</h2><h3 id=\"类成员再探\"><a href=\"#类成员再探\" class=\"headerlink\" title=\"类成员再探\"></a>类成员再探</h3><p><strong>定义一个类型成员</strong></p>\n<p>可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。</p>\n<p>通常放在类的开头位置。</p>\n<p><strong>令成员作为内联函数</strong></p>\n<p>规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。</p>\n<p>如果定义在类内的函数，默认就是inline的。</p>\n<p>inline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。</p>\n<p><strong>重载成员函数</strong></p>\n<p>和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。</p>\n<p>如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。</p>\n<p><strong>类数据成员的初始值</strong></p>\n<p>可以给类数据成员一个类内初始值。使用等号或者花括号。</p>\n<h3 id=\"返回-this的成员函数\"><a href=\"#返回-this的成员函数\" class=\"headerlink\" title=\"返回*this的成员函数\"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数（返回*this）返回的是对象本身而非对象的副本。</p>\n<pre><code>一个const成员函数如果以引用的形式返回\\*this，那么它的返回类型将是常量引用。</code></pre><p>但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是<strong>重载一个非常量版本的接口</strong>，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。</p>\n<p>建议：对于公共代码使用私有功能函数。</p>\n<h3 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a>类类型</h3><p>每个类是一个唯一的类型，即使其内容完全一样。</p>\n<p><strong>类的声明</strong></p>\n<p>可以暂时声明类而不定义它，这叫前置声明（forward declaration）。</p>\n<p>这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：</p>\n<ul>\n<li><p>定义指向这种类型的指针or引用</p>\n</li>\n<li><p>声明以不完全类型为参数or返回值的函数</p>\n</li>\n</ul>\n<p>要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。</p>\n<p>只有被定义，才能访问其成员。</p>\n<p>声明一个前置类型的方法：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class A;\nstruct B;\nnamespace game\n{\n    class C;    // 前置声明一个在命名空间中的类\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"友元再探\"><a href=\"#友元再探\" class=\"headerlink\" title=\"友元再探\"></a>友元再探</h3><p>类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。</p>\n<p>友元类有权访问本类的非公有成员。</p>\n<h2 id=\"类的作用域\"><a href=\"#类的作用域\" class=\"headerlink\" title=\"类的作用域\"></a>类的作用域</h2><p>一个类就是一个作用域。</p>\n<p>类的作用域之外，普通的成员只能通过对象、引用or指针访问。对于类型成员的访问，需要使用域运算符<code>::</code>来访问。</p>\n<h3 id=\"名字查找与类的作用域\"><a href=\"#名字查找与类的作用域\" class=\"headerlink\" title=\"名字查找与类的作用域\"></a>名字查找与类的作用域</h3><p>编译器处理完类的全部声明后，才会处理成员函数的定义。因此成员函数体中可以使用类中定义的任何位置的名字。</p>\n<p><strong>成员函数中的名字查找</strong></p>\n<p>按如下方式解析：</p>\n<ul>\n<li><p>在块内查找声明</p>\n</li>\n<li><p>在类内查找，所有成员都可以被考虑</p>\n</li>\n<li><p>在类的外围作用域中查找</p>\n</li>\n</ul>\n<h2 id=\"构造函数再探\"><a href=\"#构造函数再探\" class=\"headerlink\" title=\"构造函数再探\"></a>构造函数再探</h2><h3 id=\"构造函数初始值列表\"><a href=\"#构造函数初始值列表\" class=\"headerlink\" title=\"构造函数初始值列表\"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显示初始化成员，那么该成员将执行默认初始化。</p>\n<pre><code>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。</code></pre><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class ConstRef{\npublic:\n    ConstRef(int ii);\nprivate:\n    int i;\n    const int ci;\n    int &i;\n};\nConstRef::ConstRef(int ii){\n    i = ii;// 正确\n    ci = ii; //错误，不能给const赋值\n    ri = i; //错误：ri未被初始化\n}\n//正确形式\nConstRef::ConstRef(int ii)::i(ii),ci(ii),ri(i){}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>成员初始化的顺序</strong></p>\n<p>成员的初始化顺序和它们在类内的定义顺序一致。</p>\n<p>而非其在初始值列表中的顺序，初始值列表只是做了初始化的工作。所以要让初始值列表中的成员顺序与定义顺序一致。</p>\n<pre><code>最好使构造函数初始值的顺序与成员声明的顺序一致，尽量避免用某些成员初始化其他成员。</code></pre><p><strong>有默认实参的构造函数</strong></p>\n<p>如果构造函数的所有实参都有默认实参，那么它实际上也同时定义了默认构造函数。</p>\n<h3 id=\"委托构造函数\"><a href=\"#委托构造函数\" class=\"headerlink\" title=\"委托构造函数\"></a>委托构造函数</h3><p>C++11可以定义委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。</p>\n<p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</p>\n<pre><code> 即先执行受委托的构造函数内容，再执行自己的。</code></pre><h3 id=\"默认构造函数的作用\"><a href=\"#默认构造函数的作用\" class=\"headerlink\" title=\"默认构造函数的作用\"></a>默认构造函数的作用</h3><p>当对象被默认初始化或值初始化时，自动执行默认构造函数。</p>\n<p>默认构造函数在以下情况发生：</p>\n<ul>\n<li><p>不使用初始值定义一个非静态变量或者数组时</p>\n</li>\n<li><p>当类含有类类型的成员且使用合成的默认构造函数时</p>\n</li>\n<li><p>当类类型的成员没有在构造函数初始值列表中显式初始化时</p>\n</li>\n</ul>\n<p>值初始化在以下情况下发生：</p>\n<ul>\n<li><p>数组初始化时，若提供的初始值少于数组大小时</p>\n</li>\n<li><p>不使用初始值定义一个局部静态变量时</p>\n</li>\n<li><p>书写形如T()的表达式显式请求值初始化时</p>\n</li>\n</ul>\n<h3 id=\"隐式的类类型转换\"><a href=\"#隐式的类类型转换\" class=\"headerlink\" title=\"隐式的类类型转换\"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了<strong>转换构造函数（converting constructor）</strong>。</p>\n<p>即定义了一个隐式转换机制。如string的接受一个const char*版本的构造函数。</p>\n<p>使用explicit阻止这种隐式转换机制，explicit只能放到类内声明构造函数里。</p>\n<p><strong>只允许一步类类型转换</strong></p>\n<h3 id=\"聚合类\"><a href=\"#聚合类\" class=\"headerlink\" title=\"聚合类\"></a>聚合类</h3><p>聚合类（aggregate class）使得用户可以直接访问其成员。当类满足如下条件时，是聚合的：</p>\n<ul>\n<li><p>所有成员都是public的</p>\n</li>\n<li><p>没有定义任何构造函数</p>\n</li>\n<li><p>没有类内初始值</p>\n</li>\n<li><p>没有基类，没有virtual函数</p>\n</li>\n</ul>\n<p>可以使用花括号括起来的成员初始值列表来初始化聚合类对象。</p>\n<h3 id=\"字面值常量类（-Literal-Classes）\"><a href=\"#字面值常量类（-Literal-Classes）\" class=\"headerlink\" title=\"字面值常量类（ Literal Classes）\"></a>字面值常量类（ Literal Classes）</h3><p>类也可以是字面值类型。</p>\n<p>这样的类可以含有constexpr函数成员，且符合constexpr函数的所有要求，且是隐式const的。</p>\n<p>数据成员都是字面值类型的聚合类是字面值常量类。</p>\n<p>如果不是聚合类，满足如下条件也是一个字面值常量类：</p>\n<ul>\n<li><p>数据成员都是字面值类型</p>\n</li>\n<li><p>至少含有一个constexpr构造函数</p>\n</li>\n<li><p>如果数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；类类型成员必须使用自己的constexpr构造函数</p>\n</li>\n<li><p>类必须使用析构函数的默认定义</p>\n</li>\n</ul>\n<p><strong>声明静态成员</strong></p>\n<p>在声明前加static关键字。</p>\n<p>静态成员可以是public或private。数据成员可以是常量，引用，指针，类类型等。</p>\n<p>对象不包含与静态数据成员有关的数据。</p>\n<p>静态函数不包含this指针。</p>\n<p><strong>使用类的静态成员</strong></p>\n<p>使用作用域运算符访问静态成员。</p>\n<p>类的对象、引用或指针可以访问静态成员。</p>\n<p>类的成员函数可以直接访问静态成员。</p>\n<p><strong>定义静态成员</strong></p>\n<p>static只能出现在类的内部，不能出现在外部。</p>\n<p>静态数据成员不属于类的对象，不是有构造函数初始化的。静态数据成员定义在函数体之外，一旦定义，就一直存在于程序的整个生命周期中。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">double T::a = 1; // 定义并初始化一个静态成员<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>静态成员的类内初始化</strong></p>\n<p>通常，不应该在类内初始化静态数据成员。</p>\n<p>不过，可以为静态成员提供const整数类型的类内初始值，且要求静态成员必须是字面值常量类型。</p>\n<h1 id=\"IO库\"><a href=\"#IO库\" class=\"headerlink\" title=\"IO库\"></a>IO库</h1><h2 id=\"IO类\"><a href=\"#IO类\" class=\"headerlink\" title=\"IO类\"></a>IO类</h2><p>为了支持不同种类的IO处理操作，标准库定义了这几种类型：</p>\n<ul>\n<li><p>iostream 定义了用于读写流的基本类型</p>\n</li>\n<li><p>fstream 定义了读写命名文件的类型</p>\n</li>\n<li><p>sstream 定义了读写内存string对象的类型</p>\n</li>\n</ul>\n<p>它们分别定义在同名的头文件中。</p>\n<p><strong>IO类型间的关系</strong></p>\n<p>类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。</p>\n<h3 id=\"IO对象无拷贝或赋值\"><a href=\"#IO对象无拷贝或赋值\" class=\"headerlink\" title=\"IO对象无拷贝或赋值\"></a>IO对象无拷贝或赋值</h3><p>由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。</p>\n<p>读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>\n<h3 id=\"条件状态\"><a href=\"#条件状态\" class=\"headerlink\" title=\"条件状态\"></a>条件状态</h3><p>IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。<br>一个IO错误的例子：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int ival;\ncin >> ival;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。</p>\n<p>如果输入一个文件结束符标识，cin也会进入错误状态。</p>\n<p>一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">while (cin >> word)\n    // ok<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"管理输出缓冲\"><a href=\"#管理输出缓冲\" class=\"headerlink\" title=\"管理输出缓冲\"></a>管理输出缓冲</h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">os << \"please enter a value: \";<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。</p>\n<p>导致缓冲区刷新的原因有：</p>\n<ul>\n<li><p>程序正常结束</p>\n</li>\n<li><p>缓冲区满时</p>\n</li>\n<li><p>使用操纵符，如endl，来显式刷新缓冲区</p>\n</li>\n<li><p>读cin或写cerr，都会导致cout的缓冲区被刷新</p>\n</li>\n</ul>\n<p><strong>刷新输出缓冲区</strong></p>\n<p>IO库还提供了两个操纵符用于刷新缓冲区：</p>\n<ul>\n<li><p>flush 刷新缓冲区，但不输出任何额外字符</p>\n</li>\n<li><p>ends 向缓冲区插入一个空字符，然后刷新缓冲区</p>\n</li>\n</ul>\n<p><strong>unitbuf操纵符</strong></p>\n<p>如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">cout << unitbuf;    // 所有输出操作后都会立即刷新缓冲区\ncout << nounitbuf;  // 回到正常的缓冲方式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre><code>如果程序崩溃，输出缓冲区不会刷新</code></pre><h2 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h2><p>除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。</p>\n<h3 id=\"使用文件流对象\"><a href=\"#使用文件流对象\" class=\"headerlink\" title=\"使用文件流对象\"></a>使用文件流对象</h3><p>当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。</p>\n<p>每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。</p>\n<p>创建文件流对象时，如果提供了一个文件名，则open会被自动调用：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">ifstream in(file);    // 构造一个ifstream并打开给定的文件\nofstream out;         // 输出文件流未关联到任何文件<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre><code>当一个fstream对象被销毁时，close会自动被调用。</code></pre><h3 id=\"文件模式\"><a href=\"#文件模式\" class=\"headerlink\" title=\"文件模式\"></a>文件模式</h3><p>每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。</p>\n<p>每个文件流类型都定义了一个默认的文件模式，当未指定文件模式时，就使用此默认模式。</p>\n<ul>\n<li><p>与ifstream关联的文件默认以in模式打开；</p>\n</li>\n<li><p>与ofstream关联的文件默认以out模式打开；</p>\n</li>\n<li><p>与fstream关联的文件默认以in和out模式打开。</p>\n</li>\n</ul>\n<p><strong>以out模式打开文件会丢失已有数据</strong></p>\n<p>默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。</p>\n<p>阻止丢弃的方法是同时指定app模式：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">ofstream out(\"file1\");    // 文件被截断\nofstream app(\"file2\", ofstream::app);    // 保留文件内容，写操作在文件末尾进行<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"string流\"><a href=\"#string流\" class=\"headerlink\" title=\"string流\"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO：</p>\n<ul>\n<li><p>istringstream从string读取数据。</p>\n</li>\n<li><p>ostringstream向string写入数据。</p>\n</li>\n<li><p>stringstream既可以从string读数据，也可以向string写数据。</p>\n</li>\n</ul>\n<p>sstream增加了一些成员来管理与流相关联的string。见p287。</p>\n<h3 id=\"使用istringstream\"><a href=\"#使用istringstream\" class=\"headerlink\" title=\"使用istringstream\"></a>使用istringstream</h3><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。</p>\n<h3 id=\"使用ostringstream\"><a href=\"#使用ostringstream\" class=\"headerlink\" title=\"使用ostringstream\"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。</p>\n<h1 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h1><h2 id=\"顺序容器概述\"><a href=\"#顺序容器概述\" class=\"headerlink\" title=\"顺序容器概述\"></a>顺序容器概述</h2><p>所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>\n<p>-. 向容器添加或从容器中删除元素的代价</p>\n<p>-. 非顺序访问容器中元素的代价</p>\n<p>顺序容器有：vector, deque, list, forward_list, array, string。</p>\n<p>string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在其中间添加或删除元素就会非常耗时，因为这需要移动插入或删除位置之后的所有元素。而且，添加元素可能导致分配额外的存储空间，这种情况下，每个元素都会移动到新的存储空间中。</p>\n<p>list和forward_list两个容器添加和删除操作都很快速。作为代价，它们不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。与vector、deque和array相比，这两个容器的额外内存开销也很大。</p>\n<p>deque支持快速随机访问，在deque的中间位置插入或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的。</p>\n<p>forward_1ist和array是新C++标准增加的类型。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list 没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size保证是一个快速的常量时间的操作。</p>\n<p><strong>确定使用哪种容器</strong></p>\n<pre><code>通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。</code></pre><h2 id=\"容器库概览\"><a href=\"#容器库概览\" class=\"headerlink\" title=\"容器库概览\"></a>容器库概览</h2><p><strong>对容器可以保存的元素类型的限制</strong></p>\n<p>顺序容器几乎可以保存任意类型的元素。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。比如解引用操作。</p>\n<p>表3.6（96页）列出了容器迭代器支持的所有操作。表3.7（99页）列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array。</p>\n<p><strong>迭代器范围</strong></p>\n<p>迭代器范围由一对迭代器表示，通常被称为begin和end，它们标记了容器中元素的一个范围。这个范围被称为左闭合区间：<code>[begin, end)</code></p>\n<p><strong>使用左闭合区间蕴含的编程假定</strong></p>\n<p>假定begin和end构成一个合法的迭代器范围，则：</p>\n<ul>\n<li><p>如果begin与end相等，则范围为空</p>\n</li>\n<li><p>如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</p>\n</li>\n<li><p>我们可以对begin递增若干次，使得begin == end</p>\n</li>\n</ul>\n<h3 id=\"容器定义和初始化\"><a href=\"#容器定义和初始化\" class=\"headerlink\" title=\"容器定义和初始化\"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以指定容器大小和元素初始值的参数。</p>\n<p><strong>将一个容器初始化为另一个容器的拷贝</strong></p>\n<p>方法有两种：</p>\n<ul>\n<li><p>直接拷贝整个容器，两个容器的类型和元素的类型都必须匹配。</p>\n</li>\n<li><p>拷贝一个迭代器范围，容器类型不一定匹配，且元素类型只要能够转换即可。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//每个容器有三个元素，用给定的初始化器进行初始化\nlist<string> authors={\"Milton\"，\"Shakespeare\"，\"Austen\"};\nvector<const char*> articles={\"a\"，\"an\"，\"the\"};\n1ist<string>1ist2(authors);//正确：类型匹配\ndeque<string>authList(authors);//错误：容器类型不匹配\nvector<string>words(articles);//错误：容器类型必须匹配\n//正确：可以将const char*元素转换为\nstring forward_list<string> words(articles.begin()，articles.end());<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>列表初始化</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">list<const char *> articles = {\"a\",\"an\",\"the\"};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>标准库array具有固定大小</strong></p>\n<p>为了使用array类型，我们必须同时指定元素类型和大小，</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">array<int,10>::size_type i;//数组类型包括元素类型和大小；<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"赋值和swap\"><a href=\"#赋值和swap\" class=\"headerlink\" title=\"赋值和swap\"></a>赋值和swap</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">c1 = c2;\nca = {a,b,c};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">array<int，10>al={0，1，2，3，4，5，6，7，8，9};\narray<int，10>a2={0};//所有元素值均为0\nal=a2;//替换a1中的元素\na2={0};//错误：不能将一个花括号列表赋予数组<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持asign，也不允许用花括号包围的值列表进行赋值。</strong></p>\n<p><strong>使用assign(仅顺序容器)</strong></p>\n<p>赋值运算要求两边容器类型和元素类型相同。顺序容器（除了array）还定义了一个名为assign的成员，允许从一个相容的序列中赋值。</p>\n<p><strong>使用swap</strong></p>\n<p>调用swap操作后，两个容器中的元素将会交换。</p>\n<p>除了array，交换两个容器的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构。</p>\n<h3 id=\"容器大小操作\"><a href=\"#容器大小操作\" class=\"headerlink\" title=\"容器大小操作\"></a>容器大小操作</h3><p>每个容器都支持这些大小相关的操作：</p>\n<ul>\n<li><p>成员函数size，返回容器中元素的数目，forward_list不支持；</p>\n</li>\n<li><p>empty，当size为0时返回true，否则返回false；</p>\n</li>\n<li><p>max_size，返回一个大于或等于该容器所能容纳的最大元素数的值，这是一个很大的值。</p>\n</li>\n</ul>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（&gt;, &gt;=, &lt;, &lt;=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。</p>\n<p>比较两个容器实际上是进行元素的逐对比较。</p>\n<pre><code>只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符比较两个容器。</code></pre><h2 id=\"顺序容器操作\"><a href=\"#顺序容器操作\" class=\"headerlink\" title=\"顺序容器操作\"></a>顺序容器操作</h2><p>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加及删除。</p>\n<h3 id=\"向顺序容器添加元素\"><a href=\"#向顺序容器添加元素\" class=\"headerlink\" title=\"向顺序容器添加元素\"></a>向顺序容器添加元素</h3><p>标准库容器提供了灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。表9.5，p305。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">这些操作会改变容器的大小；array不支持这些操作。\nforward_list有自己专有版本的insert和emplace；参见9.3.4节（第312页）。\nforward_1ist不支持 push_back和emplace_back。\nvector和string不支持push front和emplace front。\nc. push back(t);\nc. emplace back(args);\nc. push_front(t);\nc. emplace_front(args);\nc. insert(p,t);\nc. emplace(p, args);\nc. insert(p,n,t)c. insert(p,b,e);\nc. insert(p, il);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>向一个deque、string或vector插入元素会使所有指向容器的迭代器、引用和指针失效。\n\n将元素插入到deque、string或vector中的任何位置都是合法的。然而，这样做可能很耗时。</code></pre><p><strong>关键概念：容器元素是拷贝</strong></p>\n<p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝。</p>\n<h3 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h3><p>表9.6（p310）列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。</p>\n<p><strong>访问成员函数返回的是引用</strong></p>\n<p>在容器中访问元素的成员函数(即，front、back、下标和at)返回的都是引用。</p>\n<p>如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">if(！c.empty()){\nC.front()=42;//将42赋予c中的第一个元素\nauto&v=c.back();//获得指向最后一个元素的引用\nv=1024;//改变c中的元素\nauto v2=c.back();//v2不是一个引用，它是c.back()的一个拷贝\nv2=0;//未改变c中的元素<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>下标操作和安全的随机访问</strong></p>\n<p>提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。保证下标合法是程序员的责任，编译器不检查越界错误。</p>\n<p>如果想确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，如果下标越界，at会抛出一个out_of_range异常。</p>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><pre><code>删除deque中除首尾之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。\n\n删除元素之前，程序员必须确保它们是存在的。</code></pre><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">这些操作会改变容器的大小，所以不适用于array。\nforward list 有特殊版本的erase，参见9.3.4节（第312页）。\nforward_list 不支持 popback；vector和string不支持pop_front。\nc.pop_back()\nc.pop_front()\nc.erase(p)\nc.erase(b,e)\nc.clear()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"改变容器大小\"><a href=\"#改变容器大小\" class=\"headerlink\" title=\"改变容器大小\"></a>改变容器大小</h3><p>可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。</p>\n<p>resize接受一个可选的元素指参数，用来初始化新添加的元素。如果未提供，新元素进行值初始化。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">c.resize(n);\nc.resize(n,t);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"容器操作可能使迭代器失效\"><a href=\"#容器操作可能使迭代器失效\" class=\"headerlink\" title=\"容器操作可能使迭代器失效\"></a>容器操作可能使迭代器失效</h3><p>使用失效的迭代器、引用、或指针是一种严重的错误。</p>\n<p>向容器添加元素后：</p>\n<ul>\n<li><p>如果容器是vector或string，且存储空间被重新分配，那么所有的迭代器都会失效。如果空间未重新分配，指向插入位置之前的元素的迭代器仍有效，但之后的迭代器会失效。</p>\n</li>\n<li><p>对于list和forward_list，指向容器的迭代器仍有效。</p>\n</li>\n</ul>\n<p>当从容器中删除元素后：</p>\n<ul>\n<li><p>对于list和forward_list，指向容器其他位置的迭代器仍有效。</p>\n</li>\n<li><p>对于string和vector，被删除元素之前的元素的迭代器仍有效。</p>\n</li>\n</ul>\n<h2 id=\"vector对象是如何增长的\"><a href=\"#vector对象是如何增长的\" class=\"headerlink\" title=\"vector对象是如何增长的\"></a>vector对象是如何增长的</h2><p><strong>管理容量的成员函数</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//shrink to_fit 只适用于vector、string 和deque。\n//capacity和 reserve 只适用于vector和string。\nc.shrink_to_fit();//请将 capacity()减少为与size()相同大小\nc.capacity();//不重新分配内存空间的话，c可以保存多少元素\nC.reserve(n);//分配至少能容纳n个元素的内存空间<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"额外的-string-操作\"><a href=\"#额外的-string-操作\" class=\"headerlink\" title=\"额外的 string 操作\"></a>额外的 string 操作</h2><p>除了顺序容器共同的操作之外， string 类型还提供了一些额外的操作。</p>\n<h3 id=\"构造-string-的其他方法\"><a href=\"#构造-string-的其他方法\" class=\"headerlink\" title=\"构造 string 的其他方法\"></a>构造 string 的其他方法</h3><p>使用下面这些方法可以构造 string ：</p>\n<p>以下 n, len2, pos2 都是无符号值。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string s(cp, n)</td>\n<td>s是cp指向的数组中前n个字符的拷贝</td>\n</tr>\n<tr>\n<td>string s(s2, pos2)</td>\n<td>s是 string s2 从下标 pos2 开始的字符拷贝</td>\n</tr>\n<tr>\n<td>string s(s2, pos2, len2)</td>\n<td>s是 string s2 从下标 pos2 开始 len2 个字符的拷贝，不管 len2 的值是多少，构造函数至多拷贝 s2.size() - pos2 个字符</td>\n</tr>\n<tr>\n<td><strong>substr 操作</strong></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>substr 返回一个 string ，它是原始 string 的一部分或全部的拷贝。</p>\n<p><code>s.substr(pos, n)</code> 返回一个 string ，包含s中从pos开始的n个字符的拷贝。pos默认为0,n默认为 s.size() - pos ，即拷贝从 pos 开始的所有字符。</p>\n<h3 id=\"改变-string-的其他方法\"><a href=\"#改变-string-的其他方法\" class=\"headerlink\" title=\"改变 string 的其他方法\"></a>改变 string 的其他方法</h3><p>string 类型支持顺序容器的赋值运算符以及 assign, insert, erase 操作。除此之外，它还定义了额外的 insert 和 erase 版本。即使用下标的版本。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">s.insert(s.size(),5,\"!\");//在s末尾插入五个！<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这些函数都拥有许多重载的版本。</p>\n<p>assign 版本还接受C风格字符串：<strong>需要以空格结尾</strong></p>\n<p>append 和 replace 是额外的成员函数， append 在 string 末尾进行插入操作， replace 替换内容，它是调用 erase 和 insert 的一种简写形式：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string s(\"C++ Primer 4th Ed.\");\n//从位置11开始，删除三个字符并插入Fifth;\ns.replace(11,3,\"Fifth)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"string-搜索操作\"><a href=\"#string-搜索操作\" class=\"headerlink\" title=\"string 搜索操作\"></a>string 搜索操作</h3><p>string 提供了6个搜索函数，它们都有4个重载版本。它们都返回一个 string::size_type 的值作为匹配位置（下标）。如果搜索失败，返回 string::npos ，其值为 -1 。</p>\n<p>可以给函数一个搜索的起始位置 pos ，它默认值是0：<br><code>auto pos = s.find_first_of(numbers, pos);</code></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string name(\"guohaoxin01236578\");\nauto pos1 = name.find(\"guo\");//pos1==0返回字符串guo第一次出现的位置\nnumbers = \"0123456789\";\nauto pos2 = name.find_first_of(numbers);//寻找numbers字符串中任意字符出现的位置，find_first_not_of<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>指定从哪里开始搜索</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string size_type pos = 0;\nwhile((pos=name.find_first_of(numbers,pos))!=string::npos){\n    cout<<\"found number at index:\"<<pos<<\" element is \"<<name[pos]<<endl;\n    ++pos;//移动到下一字符\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"compare-函数\"><a href=\"#compare-函数\" class=\"headerlink\" title=\"compare 函数\"></a>compare 函数</h3><p>这是字符串比较函数，和C标准库的 strcmp 很相似。</p>\n<h3 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h3><p>标准库提供了数值转换的函数。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">to_string(val)\nstoi/l/ul/ll/ull/f/d/ld//转换成int、double、float<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>如果 string 不能转换成一个数值，那么会抛出一个 invalid_argument 的异常。如果转换得到的数值无法用任何类型来表示，则抛出一个 out_of_range 异常。</p>\n<h2 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><p>三个容器适配器：stack(栈适配器),queue,priority_queue(队列适配器)。</p>\n<p><strong>定义一个适配器</strong></p>\n<p>stack<int> stk;</int></p>\n<h1 id=\"泛型算法\"><a href=\"#泛型算法\" class=\"headerlink\" title=\"泛型算法\"></a>泛型算法</h1><p>标准库并未给每个容器都定义成员函数来实现一些特殊的操作，如查找元素、替换或删除元素、重排元素等。而是定义了一组泛型算法。它们实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型，包括内置的数组类型。</p>\n<hr>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>大多数算法定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。</p>\n<p>通常，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>\n<p>算法不依赖于容器，但依赖于元素类型的操作。比如，find用元素类型的==运算符完成序列中的元素与给定值的比较。大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符（即使用谓词）。</p>\n<p><strong>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。</strong></p>\n<h2 id=\"初识泛型算法\"><a href=\"#初识泛型算法\" class=\"headerlink\" title=\"初识泛型算法\"></a>初识泛型算法</h2><p>附录A按照操作方式列出了所有的算法。</p>\n<p>除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。</p>\n<p>理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。</p>\n<h3 id=\"只读算法\"><a href=\"#只读算法\" class=\"headerlink\" title=\"只读算法\"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素，而从不改变元素。比如find、accumulate。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int sum = accumulate(vec.cbegin(),vec.cend(),0);//求和，和的初值为0；\nstring sum =accumulate(v.cbegin(),v.cend(),string(\"\"));//string定义了字符串的“+”法，\n//错误，const char *上没有定义+运算符\nstring sum =accumulate(v.cbegin(),v.cend(),\"\");<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>操作两个序列的算法</strong></p>\n<p>举一个列子：equal算法，它比较两个序列中的元素。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// roster2中的元素数目应该至少与roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这样的算法基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。</p>\n<h3 id=\"写容器元素的算法\"><a href=\"#写容器元素的算法\" class=\"headerlink\" title=\"写容器元素的算法\"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入元素数目（note：如容器大小足够）。</p>\n<p>这样的算法比如fill。</p>\n<p><strong>介绍back_inserter</strong></p>\n<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</p>\n<p><strong>拷贝算法</strong></p>\n<p>拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。</p>\n<p>我们可以用copy实现内置数组的拷贝，如下面代码所示：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int al[]={0，1，2，3，4，5，6，7，8，9};\nint a2[sizeof(a1)/sizeof(*al)];//a2与al大小一样\n//ret指向拷贝到a2的尾元素之后的位置\nauto ret=copy(begin(a1)，end(al)，a2);//把a1的内容拷贝给a2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。</p>\n<h3 id=\"重排元素的算法\"><a href=\"#重排元素的算法\" class=\"headerlink\" title=\"重排元素的算法\"></a>重排元素的算法</h3><p>某些算法会重排容器中元素的顺序，比如sort，它利用元素类型的&lt;运算符来实现排序。</p>\n<h2 id=\"定义操作\"><a href=\"#定义操作\" class=\"headerlink\" title=\"定义操作\"></a>定义操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的&lt;或==运算符完成比较。标准库为这些算法定义了额外的版本，允许我们提供自己定义的操作来替代默认运算符。</p>\n<h3 id=\"向算法传递函数\"><a href=\"#向算法传递函数\" class=\"headerlink\" title=\"向算法传递函数\"></a>向算法传递函数</h3><p>sort接受第三个参数，此参数是一个谓词（predicate）。</p>\n<p><strong>谓词</strong></p>\n<p>谓词是一个可调用的表达式，其调用结果是一个能用作条件的值。标准库算法使用的谓词分为两类：</p>\n<ul>\n<li><p>一元谓词，意味着它们只接受单一参数</p>\n</li>\n<li><p>二元谓词，意味着它们有两个参数</p>\n</li>\n</ul>\n<p>接受谓词的算法对输入序列中的元素调用谓词。</p>\n<h3 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h3><p>我们传递给算法的谓词必须严格接受一个或两个参数，但是有时我们希望进行的操作需要更多的参数，超出了算法对谓词的限制。</p>\n<p><strong>介绍lambda</strong></p>\n<p>我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。</p>\n<p>一个lambda表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。</p>\n<p>一个lambda表达式具有如下形式：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">[capture list](parameter list) -> return type { function body }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>其中，capture list是一个lambda所在函数中定义的局部变量的列表。</p>\n<p>可以忽略返回类型，这时会自动推断返回类型。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto func = [](){ return 42; };<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"lambda捕获和返回\"><a href=\"#lambda捕获和返回\" class=\"headerlink\" title=\"lambda捕获和返回\"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。类似地，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。</p>\n<p>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。</p>\n<p>变量捕获的方式可以是值或引用。值捕获是变量的拷贝，引用捕获是变量的引用。</p>\n<pre><code>当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。</code></pre><p><strong>建议：</strong></p>\n<p>尽量保持lambda的变量捕获简单化。如果可能的话，应该避免捕获指针或引用。见p351。</p>\n<p><strong>隐式捕获</strong></p>\n<p>可以让编译器根据lambda体中的代码来推断要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。</p>\n<p>如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// sz为隐式捕获，值捕获方式\nwc = find_if(words.begin(), words.end(),\n             [=](const string &s) { return s.size() >= sz; } );<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>详见lambda捕获列表，p352。</p>\n<p><strong>可变lambda</strong></p>\n<p>默认情况下，对于一个值拷贝的变量，lambda不会改变其值。如果希望改变，必须在参数列表后加上关键字mutable。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void fcn3()\n{\n    size_t v1 = 42;\n    // f可以改变它捕获的变量的值\n    auto f = [v1]() mutable { return ++v1; };\n    v1 = 0;\n    auto j = f(); // j为43\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"参数绑定\"><a href=\"#参数绑定\" class=\"headerlink\" title=\"参数绑定\"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。</p>\n<p>如果lambda的捕获列表为空，通常可以用函数来代替它。但如果捕获列表不为空就不能直接代替了。</p>\n<p><strong>标准库bind函数</strong></p>\n<p>为了解决这个问题，可以使用一个新的名为bind的标准库函数，它定义在头文件functional中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto newCallable = bind(callable, arg_list);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。</p>\n<p>arg_list中的参数可能包含形如<code>_n</code>的名字，这些参数是“占位符”，表示newCallable的参数。比如：<code>_1</code>为newCallable的第一个参数，<code>_2</code>为第二个参数。</p>\n<p><strong>使用placeholders名字</strong></p>\n<p>名字<code>_n</code>都定义在一个名为placeholders的命名空间中，这个命名空间本身定义在std命名空间中。</p>\n<p>一种简单的using语句是：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">using namespace namespace_name;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">using namespace std::placeholders;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这使得placeholders定义的所有名字都可用。</p>\n<h2 id=\"再探迭代器\"><a href=\"#再探迭代器\" class=\"headerlink\" title=\"再探迭代器\"></a>再探迭代器</h2><p>除了每个容器的迭代器，标准库在头文件iterator中还定义了额外几种迭代器。</p>\n<ul>\n<li><p>插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。</p>\n</li>\n<li><p>流迭代器：这些迭代器被绑定到输入或输出流上，可以来遍历所关联的IO流。</p>\n</li>\n<li><p>反向迭代器：这些迭代器向后而不是向前移动。</p>\n</li>\n<li><p>移动迭代器：不拷贝其中的元素，而是移动它们。将在13.6.2节（p480页）介绍。</p>\n</li>\n</ul>\n<h3 id=\"插入迭代器\"><a href=\"#插入迭代器\" class=\"headerlink\" title=\"插入迭代器\"></a>插入迭代器</h3><p>插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">it = t; // 在it指定的当前位置插入值t。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>插入迭代器有三种类型，差异在于元素插入的位置：</p>\n<ul>\n<li><p>back_inserter，创建一个使用push_back的迭代器。</p>\n</li>\n<li><p>front_inserter，创建一个使用push_front的迭代器。</p>\n</li>\n<li><p>inserter，创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">list<int> lst = {1,2,3,4};\nliat<int>lst2,lst3;//空的list\n//copy 完成后lst2包含4 3 2 1\ncopy(lst.begin(),lst.end(),front_inserter(lst2));\n//opy 完成后lst3包含1 2 3 4\ncopy(lst.begin(),lst.end(),inserter(lst3,lst3.begin()));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"iostream迭代器\"><a href=\"#iostream迭代器\" class=\"headerlink\" title=\"iostream迭代器\"></a>iostream迭代器</h3><p>istream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。</p>\n<p>通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。</p>\n<p>详细操作见p359。</p>\n<h3 id=\"反向迭代器\"><a href=\"#反向迭代器\" class=\"headerlink\" title=\"反向迭代器\"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。</p>\n<p>可以通过rbegin, rend, crbegin, crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。</p>\n<h2 id=\"泛型算法结构\"><a href=\"#泛型算法结构\" class=\"headerlink\" title=\"泛型算法结构\"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别。</p>\n<table>\n<thead>\n<tr>\n<th>迭代器</th>\n<th>要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>输入迭代器</td>\n<td>只读，不写；单遍扫描，只能递增</td>\n</tr>\n<tr>\n<td>输出迭代器</td>\n<td>只写，不读；单遍扫描，只能递增</td>\n</tr>\n<tr>\n<td>前向迭代器</td>\n<td>可读写；多遍扫描，只能递增</td>\n</tr>\n<tr>\n<td>双向迭代器</td>\n<td>可读写；多遍扫描，可递增递减</td>\n</tr>\n<tr>\n<td>随机访问迭代器</td>\n<td>可读写，多遍扫描，支持全部迭代器运算</td>\n</tr>\n</tbody></table>\n<h3 id=\"5类迭代器\"><a href=\"#5类迭代器\" class=\"headerlink\" title=\"5类迭代器\"></a>5类迭代器</h3><p>类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。</p>\n<p>如ostream_iterator只支持递增、解引用和赋值。vector、string、deque的迭代器除了这些操作，还支持递减、关系和算术运算。</p>\n<p>除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。</p>\n<h3 id=\"算法的形参模式\"><a href=\"#算法的形参模式\" class=\"headerlink\" title=\"算法的形参模式\"></a>算法的形参模式</h3><p>大多数算法具有如下4种形式之一：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">alg(beg, end, other args);\nalg(beg, end, dest, other args);\nalg(beg, end, beg2, other args);\nalg(beg, end, beg2, end2, other args);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中，alg是算法名字，beg和end表述输入范围。几乎所有算法都有一个输入范围。</p>\n<p><strong>接受单个目标迭代器的算法</strong></p>\n<p>dest参数是一个表示算法可以写入目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。</p>\n<p>一般dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因为保证空间是足够的。</p>\n<p><strong>接受第二个输入序列的算法</strong></p>\n<p>接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围。</p>\n<p>接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。</p>\n<h3 id=\"算法命名规范\"><a href=\"#算法命名规范\" class=\"headerlink\" title=\"算法命名规范\"></a>算法命名规范</h3><p>除了参数规范，算法还遵循一套命名和重载规范。</p>\n<p><strong>一些算法使用重载形式传递一个谓词</strong></p>\n<p>函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外的谓词参数，来代替&lt;或==：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">unique(beg, end);\nunique(beg, end, comp);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>_if版本的算法</strong></p>\n<p>接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">find(beg, end, val);\nfind_if(beg, end, pred);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>区分拷贝元素的版本和不拷贝的版本</strong></p>\n<p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。</p>\n<pre><code>reverse(beg, end);\nreverse_copy(beg, end, dest);</code></pre><h2 id=\"特定容器的算法\"><a href=\"#特定容器的算法\" class=\"headerlink\" title=\"特定容器的算法\"></a>特定容器的算法</h2><p>链表类型list定义了几个成员函数形式的算法。通用版本的sort要求随机访问迭代器，因此不能用于list。</p>\n<p>链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。</p>\n<p>这些算法见p369。</p>\n<p><strong>链表特有的操作会改变容器</strong></p>\n<p>多数链表特有的算法与通用版本的很相似，但不完全相同，其中一个至关重要的区别是链表版本的会修改底层的容器。例如， remove 的链表版本会删除指定的元素， unique 的链表版本会删除第二个和后继的重复元素。</p>\n<pre><code>对于通用版本的，如 std::remove ，不会删除容器的元素。它只会迁移元素。之后需要调用 erase 才能执行确切的删除动作。</code></pre><h1 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h1><p>关联容器与顺序容器有着根本的不同：</p>\n<ul>\n<li><p>关联容器中的元素是按关键字来保存和访问的。</p>\n</li>\n<li><p>顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>\n</li>\n</ul>\n<p>关联容器支持高效的关键字查找和访问，有两个主要的关联容器：</p>\n<ul>\n<li><p>map，其元素是一些关键字-值对，关键字起到索引作用，值则表示与之相关的数据。</p>\n</li>\n<li><p>set，每个元素只包含一个关键字。</p>\n</li>\n</ul>\n<p>标准库提供8个关联容器，如表11.1所示。这8个容器间的不同体现在三个维度上：每个容器  </p>\n<ol>\n<li>或者是一个set，或者是一个map；</li>\n<li>或者要求不重复的关键字，或者允许重复关键字；</li>\n<li>按顺序保存元素，或无序保存。</li>\n</ol>\n<p>允许重复关键字的容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头。因此一个unordered multi set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。</p>\n<h2 id=\"使用关联容器\"><a href=\"#使用关联容器\" class=\"headerlink\" title=\"使用关联容器\"></a>使用关联容器</h2><p>map是关键字-值对的集合，通常被称为<strong>关联数组</strong>。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。与之相对，set就是关键字的简单集合。</p>\n<pre><code>//统计每个单词在输入中出现的次数\nmap&lt;string,size_t) word_count;\nstring word;\nwhile(cin&gt;&gt;word)\n    ++word_count[word];\nfor(const auto &amp;a:word_count)\n//打印结果\n    cout&lt;&lt;a.first&lt;&lt;&quot;occurs&quot;&lt;&lt;w.second&lt;&lt;((w.second&gt;1)?&quot;times&quot;:&quot;time&quot;&lt;&lt;endl;</code></pre><p><strong>使用set</strong><br>可以使用set忽略我们想要忽略的单词，例如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">    // 统计每个单词在输入中出现的次数\n    map<string, size_t> word_count;    // string到size_t的空map\n    set<string> exclude = {\"The\", \"the\", \"And\", \"and\"};\n\n    string word;\n    while (cin >> word) {\n        // 只统计不在exclude中的单词\n        if (exclude.find(word) == exclude.end())\n            ++word_count[word];    // 提取word的计数器并将其加1\n    }\n\n    for (const auto &w : word_count) // 对map中的每个元素\n        // 打印结果\n        cout << w.first << \" occurs time: \" << w.second << endl;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"关联容器概述\"><a href=\"#关联容器概述\" class=\"headerlink\" title=\"关联容器概述\"></a>关联容器概述</h2><p>关联容器（有序的和无序的）都支持9.2节（第294页）中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front。</p>\n<p>除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作（见p388）和类型别名（见p381）。</p>\n<p>关联容器的迭代器都是双向的。</p>\n<h3 id=\"定义关联容器\"><a href=\"#定义关联容器\" class=\"headerlink\" title=\"定义关联容器\"></a>定义关联容器</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">map<string, size_t> word_count; // 空容器\nset<string> exclude = {\"the\", \"but\", \"and\"}; // 列表初始化\n\n// 三个元素；authors将姓映射为名\nmap<string, string> authors = {\n    {\"Joyce\", \"James\"},\n    {\"Austen\", \"Jane\"},\n    {\"Dickens\", \"Charles\"}\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>初始化multimap或multiset</strong></p>\n<p>一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。</p>\n<p>multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字（这些元素会相邻存储）。</p>\n<h3 id=\"关键字类型的要求\"><a href=\"#关键字类型的要求\" class=\"headerlink\" title=\"关键字类型的要求\"></a>关键字类型的要求</h3><p>对于有序容器，关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>\n<p><strong>使用关键字类型的比较函数</strong></p>\n<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型（比如一个函数指针类型）。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)\n{\n    return lhs.isbn() < rhs.isbn();\n}\n\nmultiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"pair类型\"><a href=\"#pair类型\" class=\"headerlink\" title=\"pair类型\"></a>pair类型</h3><p>pair类型定义在头文件utility中。</p>\n<p>一个pair保存两个数据成员，pair是一个用来生成特定类型的模板。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">pair<string, string> anon; // 保存两个string\npair<string, vector<int>> line; // 保存string和vector<int><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>pair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">pair<string, string> author{\"James\", \"Joyce\"};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>pair的数据成员是public的，两个成员分别是first，second。</p>\n<p><strong>创建pair对象的函数</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">pair<string, int>\nprocess(vector<string> &v)\n{\n    // 处理v\n    if (!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair<string, int>(); // 隐式构造返回值\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"关联容器操作\"><a href=\"#关联容器操作\" class=\"headerlink\" title=\"关联容器操作\"></a>关联容器操作</h2><p>除了表9.2(第295页)中列出的类型，关联容器还定义了这些类型：</p>\n<ul>\n<li><p>key_type, 此容器类型的关键字类型</p>\n</li>\n<li><p>mapped_type, 每个关键字关联的类型，只适用于map</p>\n</li>\n<li><p>value_type, 对于set，与key_type相同，对于map, 为<code>pair&lt;const key_type, mapped_type&gt;</code></p>\n</li>\n</ul>\n<h3 id=\"关联容器迭代器\"><a href=\"#关联容器迭代器\" class=\"headerlink\" title=\"关联容器迭代器\"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型。</p>\n<pre><code>必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。</code></pre><p><strong>set的迭代器是const的</strong></p>\n<p>与不能改名map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。</p>\n<p><strong>遍历关联容器</strong></p>\n<p>map和set类型都支持begin和end操作，我们可以利用这些函数获取迭代器，然后用迭代器来遍历容器。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto map_it = word_count.cbegin();\nwhile (map_it != word_count.cend()) {\n    // ...\n    ++map_it; // 递增迭代器，移动到下一个元素\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>!!!note<br>    当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。</p>\n<p><strong>关联容器和算法</strong></p>\n<p>我们通常不对关联容器使用泛型算法。更多讨论见书本p383。</p>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。</p>\n<p><strong>向map添加元素</strong></p>\n<p>对一个map进行insert操作时，必须记住元素类型是pair。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">word_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair<string, size_t>(word, 1));\nword_count.insert(map<string, size_t>::value_type(word, 1));\nword_count. insert(map<string, size_t>:: value_type(word,1));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>检测insert的返回值</strong></p>\n<p>insert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。<strong>pair的first成员是一个迭代器</strong>，指向具有给定关键字的元素；second成员是一个boo1值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的boo1部分为false。如果关键字不存在，元素被插入容器中，且boo1值为true。</p>\n<p><strong>展开递增语句</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">++ret.first->second;\n`++((ret.first)->second)`//等价的表达式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>-. ret保存insert返回的值，是一个pair。<br>-. ret.first是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素。<br>-. ret.first-&gt;解引用此迭代器，提取map中的元素，元素也是一个pair。<br>-. ret.first-&gt;second map中元素的值部分。<br>-. ++ret.first-&gt;second 递增此值。</p>\n<p><strong>向multiset或multimap添加元素</strong></p>\n<p>由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">multimap<string, string> authors;\n// 插入第一个元素\nauthors.insert({\"Barth, John\", \"Sot-Weed Factor\"});\n// 正确，添加第二个元素\nauthors.insert({\"Barth, John\"}, \"Lost in the Funhouse\");<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。</p>\n<h3 id=\"删除元素-1\"><a href=\"#删除元素-1\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p>关联容器定义了三个版本的erase：</p>\n<ul>\n<li><p>与顺序容器一样，传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围。</p>\n</li>\n<li><p>接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。</p>\n</li>\n</ul>\n<p>对于保存不重复关键字的容器，erase的返回值总是0或1。</p>\n<p>对允许重复关键词的容器，删除的元素的数量可能大于1。</p>\n<h3 id=\"map的下标操作\"><a href=\"#map的下标操作\" class=\"headerlink\" title=\"map的下标操作\"></a>map的下标操作</h3><p>map和unordered_map容器提供了下标运算符和一个对应的at函数。</p>\n<p>set类型不支持下标操作，不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。</p>\n<p>map下标运算符接受一个索引获取与此关键字相关联的值，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。</p>\n<p><strong>使用下标操作的返回值</strong></p>\n<p>当对一个map进行下标操作时，会获得一个mapped_type对象。</p>\n<p>当解引用一个map迭代器时，会得到一个value_type对象。</p>\n<p>!!!note<br>    与vector与string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。</p>\n<h3 id=\"访问元素-1\"><a href=\"#访问元素-1\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h3><p>如果我们关心的只不过是一个特定元素是否已在容器中，使用find比较好。</p>\n<p>对于不允许重复关键字的容器，可能使用find还是count没什么区别。</p>\n<p><code>c.find(k)</code>返回一个迭代器,<code>c.count(k)</code>返回关键词等于k的元素的数量。</p>\n<p>对于允许重复关键字的容器，count会统计有多少个元素有相同的关键字。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">c.count(k);\nc.lower_bound(k);//返回一个迭代器，指向第一个关键词不小于k的元素\nc.upper_bound(k);//返回一个迭代器，指向第一个关键词大于k的元素\nc.equal_bound(k);//返回一个迭代器pair<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"无序容器\"><a href=\"#无序容器\" class=\"headerlink\" title=\"无序容器\"></a>无序容器</h2><p>无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。</p>\n<p>在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。</p>\n<h1 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h1><p>我们的程序到目前为止只使用过静态内存或栈内存。</p>\n<ul>\n<li><p>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。</p>\n</li>\n<li><p>栈内存用来保存定义在函数内的非static对象。</p>\n</li>\n</ul>\n<p>分配在静态或栈内存中的对象由编译器自动创建和销毁。</p>\n<ul>\n<li><p>对于栈对象，仅在其定义的程序块运行时才存在。</p>\n</li>\n<li><p>static对象在使用之前分配，在程序结束时销毁。</p>\n</li>\n</ul>\n<p>除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。</p>\n<p>动态对象的生存周期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。</p>\n<h2 id=\"动态内存与智能指针\"><a href=\"#动态内存与智能指针\" class=\"headerlink\" title=\"动态内存与智能指针\"></a>动态内存与智能指针</h2><p>C++中，动态内存的管理是通过一对运算符来完成的：</p>\n<ul>\n<li><p>new，在动态内存中为对象分配空间并返回一个指向该对象的指针。</p>\n</li>\n<li><p>delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>\n</li>\n</ul>\n<p>为了更容易（同时也更安全）地使用动态内存，新的标准提供了两种智能指针（smart pointer）类型来管理动态对象。</p>\n<p>智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：</p>\n<ul>\n<li><p>shared_ptr允许多个指针指向同一个对象；</p>\n</li>\n<li><p>unique_ptr则“独占”所指向的对象。</p>\n</li>\n<li><p>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</p>\n</li>\n</ul>\n<p>这些类型定义在memory头文件中。</p>\n<h3 id=\"shared-ptr类\"><a href=\"#shared-ptr类\" class=\"headerlink\" title=\"shared_ptr类\"></a>shared_ptr类</h3><p>智能指针也是模板，当创建一个智能指针时，必须提供指向的类型：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">shared_ptr<string> p1; // shared_ptr, 可以指向string<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>默认初始化的智能指针中保存着一个空指针。</p>\n<p>解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">if (p1) *p1 = \"hi\";<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>make_shared函数</strong></p>\n<p>最安全的分配和使用动态内存的方法是调用标准库函数make_shared。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 指向一个值为42的int的shared_ptr\nshared_ptr<int> p3 = make_shared<int>(42);\n\n// p6指向一个动态分配的空vector<string>\nauto p6 = make_shared<vector<string>>();<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。</p>\n<p><strong>shared_ptr的拷贝和赋值</strong></p>\n<p>每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto p = make_shared<int>(42); // p指向的对象只有p一个引用者\nauto q(p); // p和q指向相同的对象，此对象有两个引用者<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>可以认为每个shared_ptr都有一个关联的计数器，通常称其为<strong>引用计数</strong>(reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。</p>\n<p>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</p>\n<p>!!!note<br>    到底是由一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。</p>\n<p><strong>使用了动态生存期的资源的类</strong></p>\n<p>程序使用动态内存出于以下三种原因之一：</p>\n<ol>\n<li><p>程序不知道自己需要多少对象</p>\n</li>\n<li><p>程序不知道所需对象的准确类型</p>\n</li>\n<li><p>程序需要在多个对象间共享数据</p>\n</li>\n</ol>\n<p>容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因的例子。本章介绍出于第三种原因的例子。</p>\n<h3 id=\"直接管理内存\"><a href=\"#直接管理内存\" class=\"headerlink\" title=\"直接管理内存\"></a>直接管理内存</h3><p>C++提供了new运算符分配内存，delete运算符释放new分配的内存。</p>\n<p>相对于智能指针，使用这两个运算符管理内存非常容易出错。</p>\n<p><strong>使用new动态分配和初始化对象</strong></p>\n<p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int *pi = new int; // pi指向一个动态分配的、未初始化的无名对象<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型将使用默认构造函数进行初始化。</p>\n<p>可以使用直接初始化方式来初始化一个动态分配的对象：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int *pi = new int(1024);\n\nvector<int> *pv = new vector<int>{1, 2, 3};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>动态分配的const对象</strong></p>\n<p>用new分配const对象是合法的：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">const int *pci = new const int(1024);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>类似其他任何const对象，一个动态分配的const对象必须进行初始化。</p>\n<p><strong>内存耗尽</strong></p>\n<p>一旦一个程序用光了它所有可用的内存，new表达式就会失败（并返回一个空指针）。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。</p>\n<p>我们可以改变使用new的方式来阻止它抛出异常：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 如果分配失败，new返回一个空指针\nint *p1 = new int; // 如果分配失败，new抛出std::bad_alloc\nint *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>释放动态内存</strong></p>\n<p>为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">delete p; // p必须指向一个动态分配的对象或是一个空指针<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>指针值和delete</strong><br>释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int i，*pil=&i，*pi2=nullptr;\ndouble*pd = new double(33)，*pd2=pd;\ndelete i；//错误：i不是一个指针\ndelete pi1；//未定义；pi1指向一个局部变量\ndelete pd；//正确\ndelete pd2；//未定义：pd2指向的内存已经被释放了\ndelete pi2；//正确：释放一个空指针总是没有错误的<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>动态对象的生存期直到被释放时为止</strong></p>\n<p>如12.1.1节（第402页）所述，由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个由内置指针管理的动态对象，直到被显式释放之前它都是存在的。</p>\n<p>返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担—调用者必须记得释放内存：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//factory返回一个指针，指向一个动态分配的对象\nFoo* factory(T arg){\n    //视情况处理arg\n    return new Foo(arg);//调用者负责释放此内存\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>使用new和delete管理动态内存存在三个常见问题：\n1.忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。\n2.使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。\n3.同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。相对于查找和修正这些错误来说，制造出这些错误要简单得多。</code></pre><h3 id=\"shared-ptr和new结合使用\"><a href=\"#shared-ptr和new结合使用\" class=\"headerlink\" title=\"shared_ptr和new结合使用\"></a>shared_ptr和new结合使用</h3><p>如果不初始化一个智能指针，它就会被初始化为一个空指针。还可以用new返回的指针来初始化智能指针：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">shared_ptr<int> p2(new int(42)); // p2指向一个值为42的int<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">shared_ptr<int> p1 = new int(1024); // 错误：必须使用直接初始化形式\nshared_ptr<int> p2(new int(1024));  // 正确：使用了直接初始化形式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>p1的初始化隐式地要求编译器用一个new返回的int*来创建一个shared_ptr。由于我们不能进行内置指针到智能指针间的隐式转换，因此这条初始化语句是错误的。出于相同的原因，一个返回 shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">shared ptr<int>clone(int p){\nreturn new int(p)；//错误：隐式转换为shared ptr<int>\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>我们必须将shared_ptr显式绑定到一个想要返回的指针上：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">shared ptr<int>clone(int p){\n//正确：显式地用int*创建 shared ptr<int>\nreturn shared_ptr<int>(new int(p))；\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象（可以提供自己的操作来替代delete）。</p>\n<p>更多关于智能指针使用的讨论见p412。</p>\n<h3 id=\"智能指针和异常\"><a href=\"#智能指针和异常\" class=\"headerlink\" title=\"智能指针和异常\"></a>智能指针和异常</h3><p>程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void f()\n{\n    shared_ptr<int> sp(new int(42)); // 分配一个对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n} // 函数结束时shared_ptr自动释放内存<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>无论是否发生了异常，局部对象都会被销毁，sp是指向这块内存的唯一指针，因此内存会被释放掉。</p>\n<p>如果使用了内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void f()\n{\n    int *ip = new int(42); // 动态分配一个新对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n    delete ip; // 在退出以前释放内存\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果在new和delete之间发生了异常，且异常未在f中被捕获，则内存就永远不会被释放了。</p>\n<p><strong>使用我们自己的释放操作</strong></p>\n<p>这里给一个简单的定义删除器的例子，而具体的讨论见书本p416。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto deleter = [](int* p)\n{   \n    std::cout << \"delete data: \" << *p << std::endl;\n    delete p;\n};  \n\nstd::shared_ptr<int> p(new int(42), deleter);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：</p>\n<p>-. 不使用相同的内置指针值初始化（或reset）多个智能指针。<br>-. 不delete get（）返回的指针。<br>-. 不使用get（）初始化或reset另一个智能指针。<br>-. 如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。<br>-. 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（参见12.1.4节，第415页和12.1.5节，第419页）。</p>\n<h3 id=\"unique-ptr\"><a href=\"#unique-ptr\" class=\"headerlink\" title=\"unique_ptr\"></a>unique_ptr</h3><p>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p>\n<p>与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">unique_ptr<double> p1; // 可以指向一个double的unique_ptr\nunique_ptr<int> p2(new int(42)); // p2指向一个值为42的int<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。</p>\n<p>更多有关unique_ptr操作的讨论见p418。</p>\n<h3 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象还是会被释放。</p>\n<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto p = make_shared<int>(42);\nweak_ptr<int> wp(p); // wp若共享p；p的引用计数未改变<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。如果存在，lock返回一个指向共享对象的shared_ptr。否则返回一个空shared_ptr。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">if (shared_ptr<int> np = wp.lock()) { // 如果np不为空则条件成立\n    // 在if中，np与p共享对象\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"动态数组\"><a href=\"#动态数组\" class=\"headerlink\" title=\"动态数组\"></a>动态数组</h2><p>C++语言和标准库提供了两种一次分配一个对象数组的方法：</p>\n<ul>\n<li><p>一种new表达式语法，可以分配并初始化一个对象数组。</p>\n</li>\n<li><p>标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</p>\n</li>\n</ul>\n<p>!!!note<br>    大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</p>\n<h3 id=\"new和数组\"><a href=\"#new和数组\" class=\"headerlink\" title=\"new和数组\"></a>new和数组</h3><p>为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 调用get_size确定分配多少个int\nint *pia = new int[get_size()]; // pia指向第一个int<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>方括号中的大小必须是整型，但不必是常量。</p>\n<p><strong>分配一个数组会得到一个元素类型的指针</strong></p>\n<p>当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。</p>\n<p>!!!note<br>    要记住我们所说的动态数组并不是数组类型，这是很重要的。</p>\n<p><strong>初始化动态分配对象的数组</strong></p>\n<p>默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int *pia = new int[10]; // 10个未初始化的int\nint *pia2 = new int[10](); // 10个值初始化为0的int<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>新标准中，我们还可以提供一个元素初始化器的花括号列表：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 10个int分别用列表中对应的初始化器初始化\nint *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>释放动态数组</strong></p>\n<p>为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">delete p; // p必须指向一个动态分配的对象或为空\ndelete [] pa; // pa必须指向一个动态分配的数组或为空<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>数组的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。</p>\n<p><strong>智能指针和动态数组</strong></p>\n<p>标准库提供了一个可以管理new分配的数组的unique_ptr版本：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// up指向一个包含10个未初始化int的数组\nunique_ptr<int[]> up(new int[10]);\nup.release(); // 自动用delete[]销毁其指针<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<blockquote>\n<p>my note: 这里似乎有错误，release方法据p418介绍，是放弃对指针的控制权，返回指针。并不销毁原来指向的对象。另一个事例见：<a href=\"http://zh.cppreference.com/w/cpp/memory/unique_ptr/release\" target=\"_blank\" rel=\"noopener\">http://zh.cppreference.com/w/cpp/memory/unique_ptr/release</a></p>\n</blockquote>\n<p>当unique_ptr销毁时，会自动销毁其指向的对象。</p>\n<h3 id=\"allocator类\"><a href=\"#allocator类\" class=\"headerlink\" title=\"allocator类\"></a>allocator类</h3><p>new和delete有一些灵活性上的局限：</p>\n<ul>\n<li><p>new将内存分配和对象构造组合在了一起。</p>\n</li>\n<li><p>delete将对象析构和内存释放组合在了一起。</p>\n</li>\n</ul>\n<p>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</p>\n<p><strong>allocator类</strong></p>\n<p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。</p>\n<p>allocator也是模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定对象类型来确定恰当的内存大小和对齐位置：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">allocator<string> alloc; // 可以分配string的allocator对象\nauto const p = alloc.allocate(n); // 分配n个未初始化的string<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>allocator分配未构造的内存</strong></p>\n<p>allocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto q = p; // q指向最后构造元素之后的位置\nalloc.construct(q++); // *q为空字符串\nalloc.construct(q++, \"hi\"); // *q为hi!<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>还未构造对象的情况下就使用原始内存是错误的。</p>\n<p>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">while (q != p)\n    alloc.destroy(--q); // 释放我们真正构造的string<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>一旦元素被销毁后，就可以重新用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">alloc.deallocate(p, n);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。</p>\n<p><strong>拷贝和填充未初始化内存的算法</strong></p>\n<p>标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。见p429。</p>\n<h1 id=\"拷贝控制\"><a href=\"#拷贝控制\" class=\"headerlink\" title=\"拷贝控制\"></a>拷贝控制</h1><p>一个类通过定义五种特殊的成员函数来控制拷贝、移动、复制、销毁这些操作，包括：<strong>拷贝构造函数、拷贝赋值函数、移动赋值函数、移动构造函数和析构函数。</strong></p>\n<h2 id=\"拷贝、赋值、销毁\"><a href=\"#拷贝、赋值、销毁\" class=\"headerlink\" title=\"拷贝、赋值、销毁\"></a>拷贝、赋值、销毁</h2><h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>拷贝构造函数的第一个参数是自身的应用，且额外参数都有默认值。</p>\n<p><code>拷贝构造函数的第一个参数必须是一个引用类型。</code></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Foo{\npublic:\n    Foo();//默认构造函数\n    Foo(const Foo&);//拷贝构造函数\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>拷贝构造函数通常不应该是explicit的。</strong></p>\n<h3 id=\"合成拷贝构造函数\"><a href=\"#合成拷贝构造函数\" class=\"headerlink\" title=\"合成拷贝构造函数\"></a>合成拷贝构造函数</h3><p>对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Sales_data{\npublic:\n    Sales_data(const Sales_data&)//合成拷贝构造函数\nprivate:\n    string BookNo;\n    int units_sold = 0;\n    double revenue = 0.0;\n};\n//与Sales_data的合成的拷贝构造函数等价\nSales_data::Sales_data(const Sales_data &orig):\n                                                BookNo(orig.BookNo),\n                                                units_sold(orig.units_sold),\n                                                revenue(orig.revenue)\n{}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>拷贝初始化</strong></p>\n<p>拷贝初始化通常使用拷贝构造函数完成（有时候为移动构造函数）。</p>\n<p>拷贝初始化不仅在我们用=定义变量时发生，在下列情况下也会发生：</p>\n<p>*. 将一个对象作为实参传递给一个非引用类型的形参</p>\n<p>*. 从一个返回类型为非引用类型的函数返回一个对象</p>\n<p>*. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员</p>\n<p><strong>参数和返回值</strong></p>\n<p>当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。</p>\n<p><strong>拷贝初始化的限制</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">vector<int> v1(10)//正确：直接初始化\nvector<int> v2=10;//错误，接受大小参数的构造函数是显式的\nvoid f(vector<int>);//f的参数进行拷贝初始化\nf(10);//错误；不能用一个显式的构造函数拷贝一个实参\nf(vector<int>(10));//正确，从一个int直接构造一个临时的vector<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>编译器可以绕过构造函数</strong></p>\n<p>在拷贝初始化的过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。例如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string null_book=\"9-999-999999-9\";//拷贝初始化\nstring null_book(\"9-999-999999-9\");//编译器绕过了拷贝构造函数<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"拷贝赋值运算符\"><a href=\"#拷贝赋值运算符\" class=\"headerlink\" title=\"拷贝赋值运算符\"></a>拷贝赋值运算符</h3><p><strong>重载赋值运算符</strong></p>\n<p>重载赋值运算符本质是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Foo{\npublic:\n    Foo& operator=(const Foo&);//赋值运算符\n//...\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>为了与内置运算符保持一致性，赋值运算符通常返回一个指向其左侧运算对象的引用。</p>\n<p><strong>合成拷贝赋值运算符</strong></p>\n<p>如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Sales_data&\nSales_data::operator=(const Sales_data &rhs){\n    BookNo = rhs.BookNo;\n    units_sold = rhs.units_sold;\n    revenue = rhs.revenue;\n    return *this;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他的工作，析构函数释放对象使用的资源，并销毁对象的非static数据成员。</p>\n<p>析构函数没有返回值，也不接受参数。</p>\n<p><strong>析构函数完成什么工作</strong></p>\n<p>在一个人构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序执行。</p>\n<p>通常，析构函数释放对象在生存期分配的所有资源。</p>\n<pre><code>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。</code></pre><p><strong>什么时候会调用析构函数</strong></p>\n<p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>\n<ol>\n<li><p>变量离开其作用域时被销毁</p>\n</li>\n<li><p>当一个对象被销毁时，其成员被销毁</p>\n</li>\n<li><p>容器被销毁时，其元素被销毁</p>\n</li>\n<li><p>对于动态分配的对象，当指向它的指针应用delete运算符时被销毁</p>\n</li>\n<li><p>对于临时对象，当创建它的完整表达式时被销毁</p>\n<p> 当一个指向对象的引用或者指针离开作用域时，析构函数不会执行。</p>\n</li>\n</ol>\n<p><strong>合成析构函数</strong></p>\n<p>当一个类未定义自己的析构函数时，编译器便会自动为它自动定义一个合成析构函数。</p>\n<h3 id=\"三-五法则\"><a href=\"#三-五法则\" class=\"headerlink\" title=\"三/五法则\"></a>三/五法则</h3><pre><code>如果一个函数需要自定义析构函数，几乎可以肯定他也需要自定义拷贝赋值运算符合拷贝构造函数。</code></pre><p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong></p>\n<h3 id=\"使用default\"><a href=\"#使用default\" class=\"headerlink\" title=\"使用default\"></a>使用default</h3><p>我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。</p>\n<h3 id=\"阻止拷贝\"><a href=\"#阻止拷贝\" class=\"headerlink\" title=\"阻止拷贝\"></a>阻止拷贝</h3><pre><code>大多数类应该定义拷贝构造函数、构造函数和拷贝赋值运算符，无论是显式地还是隐式的。</code></pre><p><strong>定义删除的函数</strong></p>\n<p>我们可以通过将拷贝构造函数和拷贝赋值函数定义为删除的函数来阻止拷贝。删除的函数是这样的函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">struct NoCopy{\nNoCopy()=default;\nNoCopy(const NoCopy&)=delete;//阻止拷贝；\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>还可以对任何函数指定=delete。</p>\n<p><strong>析构函数不能是删除的函数</strong></p>\n<p>如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。</p>\n<p><strong>合成的拷贝控制成员可能是删除的</strong></p>\n<p>对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>\n<p><strong>private拷贝控制</strong></p>\n<p>在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。</p>\n<h2 id=\"拷贝控制和资源管理\"><a href=\"#拷贝控制和资源管理\" class=\"headerlink\" title=\"拷贝控制和资源管理\"></a>拷贝控制和资源管理</h2><p>通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>\n<p>为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p>\n<p>类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。</p>\n<p>类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。</p>\n<h3 id=\"行为像值的类\"><a href=\"#行为像值的类\" class=\"headerlink\" title=\"行为像值的类\"></a>行为像值的类</h3><p>对于类管理的资源，每个对象都应该拥有一份自己的拷贝。</p>\n<p>为了实现类值的行为，HasPtr需要：</p>\n<ul>\n<li><p>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针</p>\n</li>\n<li><p>定义一个析构函数来释放string</p>\n</li>\n<li><p>定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string</p>\n</li>\n</ul>\n<p><strong>类值拷贝赋值运算符</strong></p>\n<p>一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。</p>\n<p>这样就可以正确进行自赋值操作。</p>\n<h3 id=\"定义行为像指针的类\"><a href=\"#定义行为像指针的类\" class=\"headerlink\" title=\"定义行为像指针的类\"></a>定义行为像指针的类</h3><p>这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。</p>\n<p>令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。</p>\n<p>但是有时候我们希望直接管理资源，这种情况下，可以使用<strong>引用计数（reference count）</strong>。</p>\n<p><strong>引用计数</strong></p>\n<p>引用计数的工作方式如下：</p>\n<ul>\n<li><p>除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。</p>\n</li>\n<li><p>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。</p>\n</li>\n<li><p>析构函数递减计数器，如果变为0，则析构函数释放状态。</p>\n</li>\n<li><p>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。</p>\n</li>\n</ul>\n<p>引用计数应该保存在动态内存中，这样才能保证共享引用计数。</p>\n<h2 id=\"交换操作\"><a href=\"#交换操作\" class=\"headerlink\" title=\"交换操作\"></a>交换操作</h2><p>管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。</p>\n<p>如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">HasPtr temp = v1;\nv1 = v2;\nv2 = temp;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string *temp = v1.ps;\nv1.ps = v2.ps;\nv2.ps = temp;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>swap函数的存在是为了优化代码。详细定义方法见书本。</p>\n<p><strong>在赋值运算符中使用swap</strong></p>\n<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为<strong>拷贝并交换（copy and swap）</strong>的技术。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">HasPtr &HasPtr::operator=(HasPtr rhs)\n{\n    swap(*this, rhs);\n    return *this;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>rhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。</p>\n<p>这种技术自动处理了自赋值的情况且天然就是异常安全的。</p>\n<h2 id=\"拷贝控制示例\"><a href=\"#拷贝控制示例\" class=\"headerlink\" title=\"拷贝控制示例\"></a>拷贝控制示例</h2><p>见习题练习13.33-13.38。</p>\n<h2 id=\"动态内存管理类\"><a href=\"#动态内存管理类\" class=\"headerlink\" title=\"动态内存管理类\"></a>动态内存管理类</h2><p>再看看！</p>\n<h2 id=\"对象移动\"><a href=\"#对象移动\" class=\"headerlink\" title=\"对象移动\"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。</p>\n<p>使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。</p>\n<h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><p>为了支持移动操作，新标准引入了一种新的类型——<strong>右值引用（rvalue reference）</strong>。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int i = 42;\nint &r = i;    // 正确：r引用i\nint &&rr = i;  // 错误：不能将一个右值引用绑定到一个左值上\nconst int &r3 = i*42;//正确：我们可以将一个const的引用绑定到一个右值上\nint &&r2 = i * 42; // 正确：将rr2绑定到乘法结果上<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>左值持久，右值短暂</strong></p>\n<p>左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>\n<p>由于右值引用只能绑定到临时对象，我们得知：</p>\n<p>*. 所引用的对象将要被销毁</p>\n<p>*. 该对象没有其他用户</p>\n<p>这两个特性意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。</p>\n<p><strong>变量是左值</strong></p>\n<p>变量可以看作只有一个运算对象而没有运算符的表达式。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。</p>\n<p>因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int &&rr1 = 42;     // 正确：字面常量是右值\nint &&rr2 = rr1;    // 错误：表达式rr1是左值！<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre><code>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行，</code></pre><p><strong>标准库move函数</strong></p>\n<p>虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int &&rr3 = std::move(i); // OK<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。</p>\n<pre><code>我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。\n使用move的代码应该是std::move而不是move。</code></pre><h3 id=\"移动构造函数和移动赋值运算符\"><a href=\"#移动构造函数和移动赋值运算符\" class=\"headerlink\" title=\"移动构造函数和移动赋值运算符\"></a>移动构造函数和移动赋值运算符</h3><p>移动的版本从给定对象“窃取”资源而不是拷贝资源。</p>\n<p>移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。</p>\n<p>除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">StrVec::StrVec(StrVec &&s) noexcpet // 移动构造函数不应抛出异常\n // 成员初始化器接管s中的资源\n : elements(s.elements), first_free(s.first_free), cap(s.cap)\n{\n    // 令s进入这样的状态——对其运行析构函数是安全的\n    s.elements = s.first_free = s.cap = nullptr;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>移动操作、标准库容器和异常</strong></p>\n<p>移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。</p>\n<p>通知的方法是在构造函数中指明noexcept。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class StrVec{\npublic:\n    StrVec(StrVec&& ) noexcept;//移动构造函数 \n};\nStrVec::StrVec(StrVec &&s) noexcept:/*成员初始化器*/\n{/*构造函数体*/}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>移动赋值运算符</strong></p>\n<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">StrVec& StrVec::operator=(StrVec &&rhs) noexcept\n{\n    // 直接检测自赋值\n    if (this != &rhs) {\n        free();    // 释放已有资源\n        elements = rhs.elements; // 接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>移后源对象必须可析构</strong></p>\n<p>从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。</p>\n<p>除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。但是移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。</p>\n<pre><code>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</code></pre><p><strong>合成的移动操作</strong></p>\n<p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>\n<p>如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的拷贝版本会被定义为删除的。</p>\n<p><strong>移动右值，拷贝左值</strong></p>\n<p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">StrVec v1, v2;\nv1 = v2;                    // v2是左值，使用拷贝赋值\nStrVec getVec(istream&);    // getVec返回一个右值\nv2 = getVec(cin);           // getVec(cin)是一个右值；使用移动赋值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>更新三/五法则</strong></p>\n<p>所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p>\n<h3 id=\"右值引用和成员函数\"><a href=\"#右值引用和成员函数\" class=\"headerlink\" title=\"右值引用和成员函数\"></a>右值引用和成员函数</h3><p>除了构造函数和赋值运算符之外，成员函数也可以提供拷贝和移动的版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">void push_back(const X&);   // 拷贝：绑定到任意类型的X\nvoid push_back(X&&);        // 移动：只能绑定到类型X的可修改的右值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>右值和左值引用成员函数</strong></p>\n<p>我们可以强制左侧运算对象是一个左值。</p>\n<p>我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个<strong>引用限定符（reference qualifier）</strong>。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Foo {\npublic:\n    Foo &operator=(const Foo&) &;   // 只能向可修改的左值赋值\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值。如果存在const限定符，引用限定符必须跟随在const限定符之后。</p>\n<p><strong>重载和引用函数</strong></p>\n<p>我们可以综合引用限定符和const来区分一个成员函数的重载版本。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Foo{\npublic:\n    Foo sorted() &&;//可用于可改变的右值\n    Foo sorted() const &;//可用于任何类型的Foo\nprivate:\n    vector<int> data;\n};\n//本对象为右值，因此可以原址排序\nFoo Foo::sorted() &&\n{\n    sort(data.begin(),data.end());\n    return *this;\n}\n//本对象是一个左值或者一个const，哪种情况我们都不能对其进行原址排序\nFoo Foo::sorted() const &{\n    Foo ret(*this);\n    sort(ret.data.begin(),ret.data.end());\n    return ret;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</code></pre><h1 id=\"重载运算和类型转换\"><a href=\"#重载运算和类型转换\" class=\"headerlink\" title=\"重载运算和类型转换\"></a>重载运算和类型转换</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>重载运算符是具有特殊名字的函数：他们的名字由关键字operator和其后要定义的运算符号组成。重载运算符也包含返回类型，参数列表以及函数体。</p>\n<pre><code>当一个运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。</code></pre><p>对于一个运算符函数来是哦，它或者是类的成员，或者至少含有一个类型的参数：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//错误，不能为int重定义内置的运算符\nint operator+(int,int);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>不能被重载的运算符： .* :: . ? ：</p>\n<p><strong>直接调用一个重载的运算符函数</strong></p>\n<p>调用方法如下：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//一个非成员运算符的等价调用\ndata1+data2;//普通的表达式\noperator+(data1,data2);//等价的函数调用\ndata1 += data2;//基于调用的表达式\ndata1.operator+=(data2);//对成员运算符函数的等价调用<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>将this绑定到data1的位置，将data2作为实参传入函数。</p>\n<p><strong>某些运算符不应该被重载</strong></p>\n<pre><code>通常情况下不应该重载逗号，取地址，逻辑与和逻辑或运算符。</code></pre><p><strong>使用与内置类型一致的含义</strong></p>\n<p><strong>选择作为成员或者非成员函数</strong></p>\n<p>有的运算符必须作为成员，另一些情况下，运算符作为非成员更好：</p>\n<ol>\n<li><p>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符必须作为成员；</p>\n</li>\n<li><p>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值略有不同；</p>\n</li>\n<li><p>递增、递减和解引用运算符，一般应该是成员；</p>\n</li>\n<li><p>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该时普通的非成员函数。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">string s = \"world\";\nstring t = s + \"!\";//正确，我们能把一个const char*加到一个string中等价于s.operator+(\"!\")\nstring u = \"Hi\" + s;//错误，等价于：\"Hi\".operator+(s),hi的类型是const char* ，这是一种内置类型，没有成员函数<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"输入和输出运算符\"><a href=\"#输入和输出运算符\" class=\"headerlink\" title=\"输入和输出运算符\"></a>输入和输出运算符</h2><h3 id=\"重载输出运算符-lt-lt\"><a href=\"#重载输出运算符-lt-lt\" class=\"headerlink\" title=\"重载输出运算符&lt;&lt;\"></a>重载输出运算符&lt;&lt;</h3><p>第一个形参通常是一个非常量的ostream对象的引用，之所以ostream是非常量是因为向流写入内容会改变其状态，而引用该形参是因为我们没法直接复制一个ostream对象。</p>\n<p>第二个形参通常是一个常量的引用，该常量是我们要输出的类类型。</p>\n<p>为了与其他输出运算符保持一致，operator&lt;&lt;通常返回它的ostream形参。例如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Salas_data{\nfriend std::ostream& operator<<(ostream&, const Salas_data&);\nfriend std::ostream& operator>>(istream&, const Salas_data&);\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>通常，输出运算符不应该打印换行符，主要负责输出打印的对象而非格式。</code></pre><p><strong>输出输出运算符必须是非成员函数</strong></p>\n<h3 id=\"重载输入运算符-gt-gt\"><a href=\"#重载输入运算符-gt-gt\" class=\"headerlink\" title=\"重载输入运算符&gt;&gt;\"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个实参为将要读取的流的引用，第二个形参为将要读入到的（非常量）对象的引用。该运算符会返回某个流的引用。</p>\n<pre><code>输入运算符必须处理输入失败的问题，而输出运算符不需要。</code></pre><h2 id=\"算术和关系运算符\"><a href=\"#算术和关系运算符\" class=\"headerlink\" title=\"算术和关系运算符\"></a>算术和关系运算符</h2><p>通常我们把算术和关系运算符作为非成员函数以允许对左侧和右侧的运算对象进行转换。形参都是常量的引用。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Salas_data operator+(const Salas_data &lhs,const Salas_data &rhs){\n    Salas_data sum = lhs;\n    sum += rhs;\n    return sum;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符来实现。</code></pre><h3 id=\"相等运算符\"><a href=\"#相等运算符\" class=\"headerlink\" title=\"相等运算符\"></a>相等运算符</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">bool operator==(const Sales_data &lhs, const Sales_data &rhs)\n{\n    return lhs.isbn() == rhs.isbn() &&\n           lhs.units_sold == rhs.units_sold &&\n           lhs.revenue == rhs.revenue;\n}\n\nbool operator!=(const Sales_data &lhs, const Sales_data &rhs)\n{\n    return !(lhs == rhs);\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"关系运算符-1\"><a href=\"#关系运算符-1\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>如果一个类不存在一种逻辑可靠的&lt;定义，这个类不定义&lt;运算符也许更好。</p>\n<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><p>之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。</p>\n<p>比如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">vector<string> v;\nv = {\"a\", \"b\", \"c\"};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class StrVec {\npublic:\n    StrVec& operator=(std::initializer_list<std::string>)\n    {\n        // ...\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>赋值运算符必须为成员函数。</code></pre><h3 id=\"复合赋值运算符\"><a href=\"#复合赋值运算符\" class=\"headerlink\" title=\"复合赋值运算符\"></a>复合赋值运算符</h3><pre><code>赋值运算符必须为成员函数，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</code></pre><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针\nSales_data& Sales_data::operator+=(const Sales_data &rhs)\n{\n    units_sold += rhs.units_sold;\n    revenue += rhs.revenue;\n    return *this;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"下标运算符\"><a href=\"#下标运算符\" class=\"headerlink\" title=\"下标运算符\"></a>下标运算符</h3><p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。</p>\n<pre><code>下标运算符必须是成员函数。</code></pre><p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class StrVec {\npublic:\n    std::string& operator[](std::size_t n) { return elements[n]; }\n\n    const std::string& operator[](std::size_t n) const { return elements[n]; }\n\nprivate:\n    std::string *elements;    // 指向数组首元素的指针\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"递增递减运算符\"><a href=\"#递增递减运算符\" class=\"headerlink\" title=\"递增递减运算符\"></a>递增递减运算符</h2><p>在迭代器类中通常会实现递增运算符++和递减运算符–，这两种运算符使得类可以在元素的序列中前后移动。</p>\n<p>对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class StrBlobPtr {\npublic:\n    StrBlobPtr& operator++();        // 前置运算符\n    StrBlobPtr& operator--();\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//前置版本：返回递增递减对象的引用\nStrBlobPtr& StrBlobPtr::operator++(){\n//如果curr已经指向了容器的尾后位置，则无法递增它\n    check(curr, \"increment past end of StrBlobPtr \")\n    ++curr;    //将curr在当前状态下向前移动一个元素\n    return *this;\n}\n\nStrBlobPtr& StrBlobPtr::operator--(){\n    //如果curr是0，则继续递减它将产生一个无效下标\n    --curr;        //将curr在当前状态下向后移动一个元素\n    check(curr, \"decrement past begin of StrBlobPtr\");\n    return *this;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>区分前置和后置运算符</strong></p>\n<p>后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class StrBlobPtr {\npublic:\n    StrBlobPtr operator++(int);        // 后置运算符\n    StrBlobPtr operator--(int);\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>!!!note<br>    为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//后置版本：递增递减对象的值但是返回原值\nStrBlobPtr StrBlobPtr::operator++(int){\n    //此处无须检查有效性，调用前置递增运算符时才需要检查\n    StrBlobPtr ret = *this;//记录当前的值\n    ++*this;//向前移动一个元素，前置++需要检查递增的有效性\n    return ret;//返回之前记录的状态\n}\n\nStrBlobPtr StrBlobPtr::operator--(int){\n    //此处无须检查有效性，调用前置递减运算符时才需要检查\n    StrBlobPtr ret = *this    //记录当前的值\n    --*this //向后移动一个元素，前置--需要检查递减的有效性\n    return ret;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>显式的调用后置运算符</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">StrBlobPtr p(a1);//p指向a1中的vector\np.operator++(0);//调用后置版本的operator++\np.operator++();//调用前置版本的operator++<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"成员访问运算符\"><a href=\"#成员访问运算符\" class=\"headerlink\" title=\"成员访问运算符\"></a>成员访问运算符</h2><p>在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class StrBlobPtr {\npublic:\n    std::string& operator*() const;\n    {\n        auto p = check(curr,\"dereference past end\");\n        return (*p)[curr];\n    }\n    std::string* operator->() const\n    {\n        // 将实际工作委托给解引用运算符\n        return & this->operator*();\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>对箭头运算符返回值的限定</strong></p>\n<p>对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator-&gt;类的对象。根据point类型的不同，point-&gt;分别等价于：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">(*point).mem;        //point是一个内置的指针类型\npoint.operator()->mem;        //point是一个类对象<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>除此之外，代码都将发生错误。</p>\n<h2 id=\"函数调用运算符\"><a href=\"#函数调用运算符\" class=\"headerlink\" title=\"函数调用运算符\"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更灵活。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">struct absInt {\n    int operator()(int val) const {\n        return val < 0 ? -val : val;\n    }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个类只定义了一种操作：函数调用运算符，它负责接受一个int类型的实参，然后返回该实参的绝对值。</p>\n<p>使用调用运算符的方式是令一个absInt对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int i = -42;\nabsInt absObj;\nint ui = absObj(i);        // 将i传递给absObj.operator()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</p>\n<p>如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的行为像函数一样。</p>\n<h3 id=\"lambda是函数对象\"><a href=\"#lambda是函数对象\" class=\"headerlink\" title=\"lambda是函数对象\"></a>lambda是函数对象</h3><p>当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符，默认情况下，它是一个const成员函数。</p>\n<p>当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象确实存在。因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。</p>\n<p>通过值捕获的变量被拷贝到lambda中。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</p>\n<h3 id=\"标准库定义的函数对象\"><a href=\"#标准库定义的函数对象\" class=\"headerlink\" title=\"标准库定义的函数对象\"></a>标准库定义的函数对象</h3><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作。</p>\n<p>这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，<code>plus&lt;string&gt;</code>令string的加法运算符作用于string对象。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">plus<int> intAdd;            // 可执行int加法的函数对象\nint sum = intAdd(10, 20);    // 使用intAdd::operator(int, int)求10和20的和<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>在算法中使用标准库函数对象</strong></p>\n<p>表示运算符的函数对象类常用来替换算法中的默认运算符。比如，默认情况下排序算法使用operator&lt;将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个greater类型的对象。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 传入一个临时的函数对象用于执行两个string对象的>比较运算\nsort(svec.begin(), svec.end(), greater<string>());<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"可调用对象与function\"><a href=\"#可调用对象与function\" class=\"headerlink\" title=\"可调用对象与function\"></a>可调用对象与function</h3><p>C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。</p>\n<p>和其他对象一样，可调用对象也有类型。lambda有它自己唯一的未命名的类类型；函数及函数指针的类型由其返回值和实参类型决定。</p>\n<p>然而，两个不同类型的可调用对象却可能共享同一种调用形式（call signature）。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">int(int, int)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>标准库function函数</strong></p>\n<p>function是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，此额外信息是指该function类型能够表示的对象的调用形式：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">function<int(int, int)><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这里声明的function类型，表示接受两个int、返回一个int的可调用对象：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">function<int(int, int)> f1 = add;            // 函数指针\nfunction<int(int, int)> f2 = divide();        // 函数对象类的对象\nfunction<int(int, int)> f3 = [](int i, int j) { return i * j; };    // lambda\n\ncout << f1(4, 2) << endl;\ncout << f2(4, 2) << endl;\ncout << f3(4, 2) << endl;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"重载、类型转换与运算符\"><a href=\"#重载、类型转换与运算符\" class=\"headerlink\" title=\"重载、类型转换与运算符\"></a>重载、类型转换与运算符</h2><p>在263页中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。</p>\n<p>转换构造函数和类型转换运算符共同定义了<strong>类类型转换（class-type conversions）</strong>。</p>\n<h3 id=\"类型转换运算符\"><a href=\"#类型转换运算符\" class=\"headerlink\" title=\"类型转换运算符\"></a>类型转换运算符</h3><p><strong>类型转换运算符（conversion  operator）</strong>是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。其一般形式如下：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">operator type() const;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>其中type表示某种类型。类型转换运算符可以面向任意类型（除了void之外）进行定义，只要该类型能作为函数的返回类型，因此我们不允许转换成数组或者函数类型，但允许转换成指针或者引用类型。</p>\n<pre><code>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，一般被定义成const成员。</code></pre><p><strong>定义含有类型转换运算符的类</strong></p>\n<p>举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class SmallInt {\npublic:\n    SmallInt(int i = 0) : val(i)\n    {\n        if (i < 0 || i > 255)\n            throw std::out_of_range(\"Bad SmallInt value\");\n    }\n\n    operator int() const { return val; }\nprivate:\n    std::size_t val;\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>SmallInt类的构造函数将算数类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">SmallInt si;\nsi = 4;            // 4 -> SmallInt, 然后调用赋值运算符\nsi + 3;            // si -> int，然后执行整数的加法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>类型转换运算符可能产生意外结果</strong></p>\n<p>在实践中，类很少提供类型转换运算符。但有一种例外：对于类来说，定义向bool的类型转换还是比较普遍的现象，但这会遇到一个问题：因为bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中（这不是期望的）。</p>\n<p><strong>显式的类型转换运算符</strong></p>\n<p>为了防止上述异常情况的发生，C++新标准引入了显式的类型转换运算符（explicit conversion operator）：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class SmallInt {\npublic:\n    // 编译器不会自动执行这一类型转换\n    explicit operator int() const { return val; }\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>编译器不会将一个显式的类型转换运算符用于隐式类型转换：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">SmallInt si = 3;            // 正确：SmallInt的构造函数不是显式的\nsi + 3;                        // 错误：此处需要隐式的类型转换，但类的运算符是显式的\nstatic_cast<int>(si) + 3;    // 正确：显式地请求类型转换<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>但，如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它。</p>\n<pre><code>向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的。</code></pre><h3 id=\"避免有二义性的类型转换\"><a href=\"#避免有二义性的类型转换\" class=\"headerlink\" title=\"避免有二义性的类型转换\"></a>避免有二义性的类型转换</h3><pre><code>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</code></pre><p><strong>实参匹配和相同的类型转换</strong></p>\n<pre><code>我们无法通过强制类型转换来解决二义性问题，因为强制类型转换也面临二义性问题。</code></pre><h3 id=\"函数匹配和重载运算符\"><a href=\"#函数匹配和重载运算符\" class=\"headerlink\" title=\"函数匹配和重载运算符\"></a>函数匹配和重载运算符</h3><h1 id=\"面向对象程序设计\"><a href=\"#面向对象程序设计\" class=\"headerlink\" title=\"面向对象程序设计\"></a>面向对象程序设计</h1><p>面向对象程序设计基于三个基本概念：数据抽象、继承、动态绑定。</p>\n<hr>\n<h2 id=\"OOP概述\"><a href=\"#OOP概述\" class=\"headerlink\" title=\"OOP概述\"></a>OOP概述</h2><p><strong>面向对象程序设计(object-oriented programming)</strong>的核心思想时数据抽象，继承和动态绑定。通过数据抽象我们可以将类的接口和实现分开，使用继承，我们可以定义相似的类型并对其相似关系建模；使用动态绑定，我们可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>\n<p><strong>继承</strong></p>\n<p>通过继承(inheritance)；联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类(base class)，其他类则间接或直接地从基类继承而来，这些继承而来的类称为派生类(derived class)。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Quote{\npublic:\n    std::string isbn() const;\n    virtual double net_price(std::size_t n) const;\n};\n\nclass Bulk_Quote:public Quote{\npublic:\n    double net_price(std::size_t n) const override;\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>动态绑定</strong></p>\n<p>通过使用动态绑定(dynamic binding)，我们能用用一段代码分别处理Quote和Bulk_Quote的对象。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//计算并打印销售给定数量的某种书籍所得的费用\ndouble print_total(ostream &os,const Quote &item,size_t n){\n    //根据传入item的形参的对象调用Quote::net_price()\n    //或者Bulk_Quote::net_price\n    double ret = item.net_price(n);\n    os<<\"ISBN: \"<<item.isbn()<< \"# sold: \"<<n<< \"total due \"<<ret<<endl;\n    return ret;\n}\n\n//basic的类型时Quote,bulk的类型是Bulk_Quote\n\nprint_total(cout,basic,20);//调用Quote::net_price()\n\nprint_total(cout,bulk,20);//调用Bulk_Quote::net_price()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。</code></pre><h2 id=\"定义基类和派生类\"><a href=\"#定义基类和派生类\" class=\"headerlink\" title=\"定义基类和派生类\"></a>定义基类和派生类</h2><h3 id=\"定义基类\"><a href=\"#定义基类\" class=\"headerlink\" title=\"定义基类\"></a>定义基类</h3><pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Quote{\npublic:\n    Quote() = default;\n    Quote(std::string &book,double sales_price):bookNo(book),price(sales_price){}\n    std::string isbn() const {return bookNo;};\n    virtual double net_price(size_t n) const {return n*price;}\n    virtual ~Quote()\nprivate:\n    std::string bookNo;\nprotected:\n    double pricr = 0.0;\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>通常，基类都应该定义一个虚析构函数，即使该函数在不执行任何实际操作也是如此。</code></pre><p><strong>成员函数和继承</strong></p>\n<p>成员函数如果没有被定义为虚函数，则其解析过程在发生编译时而不是运行时。</p>\n<p>基类通过在其成员函数的声明语句之前加上关键词virtual使得该函数执行动态绑定。</p>\n<p><strong>访问控制和继承</strong></p>\n<p>派生类可以继承定义在基类的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。派生类可以访问公有成员，而不能访问私有成员。不过，如果基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的(protected)访问运算符说明这样的成员。</p>\n<h3 id=\"定义派生类\"><a href=\"#定义派生类\" class=\"headerlink\" title=\"定义派生类\"></a>定义派生类</h3><p>派生类必须使用类派生列表(class derivation list)明确指出它是从哪个基类继承而来的。</p>\n<p><strong>派生类中的虚函数</strong></p>\n<p>C++新标准允许派生类显式的注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键词后面，或者在引用函数的引用限定符后面添加一个关键词override。</p>\n<p><strong>派生类对象及派生类向基类的类型转换</strong></p>\n<p>因为在派生类对象中含有基类对应的组成部分，所以我们能够把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Quote item;        //基类对象\nBulk_Quote bulk;        //派生类对象\nQuote *p = &item;        //p指向Quote对象\np = &bulk;        //p指向bulk的Quote部分\nQuote &r = bulk;        r绑定到bulk的Quote部分<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>派生类构造函数</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Bulk_Quote(const string &book,double p,size_t qty,double disc):\n            Quote(book,p),min_qty(qty),discount(dis){}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<pre><code>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</code></pre><p><strong>派生类使用基类的成员</strong></p>\n<p>派生类可以使用基类的公有和保护成员。</p>\n<p><strong>继承与静态成员</strong></p>\n<p>静态成员遵循通用的访问规则。</p>\n<p><strong>被用作基类的类</strong></p>\n<p>如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Quote;        //声明但未定义；\n//错误：quote必须被定义\nclass Bulk_Quote:public Quote{...};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>防止继承的发生</strong></p>\n<p>在类名后加一个final可以防止继承的发生。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class NoDerived final{};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"类型转换与继承\"><a href=\"#类型转换与继承\" class=\"headerlink\" title=\"类型转换与继承\"></a>类型转换与继承</h3><p>可以将基类的指针或者引用绑定到派生类的对象上有一层极为重要的含义：当使用基类的引用或指针时，实际上我们不知道该引用（指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>\n<p><strong>动态类型与静态类型</strong></p>\n<p>我们必须把一个变量或者表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或者表达式生成的类型；动态类型则是变量或者表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>\n<p>例如：当print_total调用net_price时<code>double ret = item.net_price(n);</code></p>\n<p>我们知道item的静态类型是Quote&amp;，它的动态类型则依赖于item绑定的实参，动态类型直到运行时才可知。</p>\n<p><strong>不存在从基类向派生类的隐式类型转换……</strong></p>\n<p>因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类到派生类的自动类型转换。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Quote base;\nBulk_Quote* bulkp = &base;        //错误：不能将基类转换成派生类\nBulk_Quote& bulkref = base;        //错误：不能将基类转换成派生类\nBulk_Quote bulk;\nQuote *itemp = &bulk;        //正确：动态类型是Bulk_Quote\nBulk_Quote *bulkp = itemp;        //错误：不能将基类转换成派生类<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>……在对象之间不存在类型转换</strong></p>\n<pre><code>当我们用一个派生类为一个基类对象赋值时，只有该派生类对象中的基类部分会被拷贝，移动和赋值，它的派生类部分会被忽略掉。</code></pre><h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>我们必须为每个虚函数提供定义。</p>\n<p><strong>对虚函数的调用可能在运行时才被解析</strong></p>\n<p>动态绑定只有当我们通过指针或者引用调用虚函数时才会发生。</p>\n<p><strong>派生类中的虚函数</strong></p>\n<p>一旦某个函数被声明为虚函数，则在所有的派生类中它都是虚函数。</p>\n<pre><code>基类中的虚函数在派生了中隐含地也是一个虚函数。\n当派生类覆盖某个虚函数时，该函数的形参必须与派生类的形参严格匹配。\n返回类型在返回的是类的指针或者引用时可不一样，但是要求从基类到派生类的类型转换是可访问的。</code></pre><p><strong>final和override说明符</strong></p>\n<p>final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。</p>\n<p><strong>虚函数和默认实参</strong></p>\n<pre><code>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</code></pre><p><strong>回避虚函数机制</strong></p>\n<p>在某些情况下，我们希望对虚函数的调用不要动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//强行调用基类中定义的函数版本而不管baseP的动态类型如何\ndouble undiscount = baseP->Quote::net_price(42);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"抽象基类\"><a href=\"#抽象基类\" class=\"headerlink\" title=\"抽象基类\"></a>抽象基类</h2><p><strong>纯虚函数</strong></p>\n<p>纯虚函数无需定义、我们在函数体的位置书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">double net_price(size_t) const =0;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>含有纯虚函数的类是抽象基类</strong></p>\n<p>抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能创建一个抽象基类的对象。因为Disc_quoto将net_price定义为纯虚函数，所以我们不能定义Disc_quote的对象。我们可以定义Disc_quote的派生类的对象。前提是这些类覆盖了net_price函数。</p>\n<pre><code>我们不能创建抽象基类的对象。</code></pre><p><strong>派生类构造函数只初始化它的直接基类</strong></p>\n<h2 id=\"访问控制与继承\"><a href=\"#访问控制与继承\" class=\"headerlink\" title=\"访问控制与继承\"></a>访问控制与继承</h2><p><strong>受保护的成员</strong></p>\n<p>protected说明符可以看做是public和private中和后的产物：</p>\n<ol>\n<li><p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的</p>\n</li>\n<li><p>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的</p>\n</li>\n<li><p><strong>派生类的成员只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护的成员没有任何访问特权</strong></p>\n</li>\n</ol>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Base{\nprotected:\n    int prot_mem;\n};\n\nclass Sneaky:public Base{\n    friend void clobber(Sneaky&);//能访问Sneaky::prot_mem\n    friend void clobber(Base&);//不能访问Base::prot_mem\n    int j;\n};\n\n//正确，clobber能够访问Sneaky对象的private和protected成员\nvoid clobber(Snaaky &s){s.j=s.prot_mem=0;}\n//错误;clobber不能访问Base的protected成员\nvoid clobber(base &s){s.prot_mem=0;}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>公有，私有和受保护继承</strong></p>\n<p>某个类对其继承而来的成员的访问权限受到两个因素的影响：</p>\n<ol>\n<li><p>在基类中该成员的访问说明符</p>\n</li>\n<li><p>在派生类的派生列表中的访问说明符</p>\n</li>\n</ol>\n<p>派生类说明符的目的是控制派生类影虎对于基类成员的访问权限，还可以控制继承自派生类的新类的访问权限。</p>\n<p><strong>派生类向基类转换的可访问性</strong></p>\n<p>派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：</p>\n<ul>\n<li><p>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</p>\n</li>\n<li><p>不论以什么方式继承B，D的成员和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的。</p>\n</li>\n<li><p>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。</p>\n<p>  对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>\n</li>\n</ul>\n<p><strong>友元与继承</strong></p>\n<p>友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。</p>\n<p><strong>改变个别成员的可访问性</strong></p>\n<p>有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Base {\npublic:\n    std::size_t size() const { return n; }\nprotected:\n    std::size_t n;\n};\n\nclass Derived : private Base {\npublic:\n    // 令size成员保持public访问级别\n    using Base::size;\nprotected:\n    using Base::n;\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。</p>\n<p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中任何可访问成员标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。</p>\n<pre><code>派生类只能为那些它可以访问的名字提供using声明。</code></pre><p><strong>默认的继承保护级别</strong></p>\n<p>默认情况下，使用class关键词定义的派生类是私有继承，而使用struct关键字定义的派生类为公有继承。</p>\n<h2 id=\"继承中的类作用域\"><a href=\"#继承中的类作用域\" class=\"headerlink\" title=\"继承中的类作用域\"></a>继承中的类作用域</h2><p>每个类定义自己的作用域，在这个作用域内我们定义类的成员。</p>\n<p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，所以派生类才能像使用自己的成员一样使用基类的成员。</p>\n<p><strong>在编译时进行名字查找</strong></p>\n<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。</p>\n<p><strong>名字冲突和继承</strong></p>\n<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。</p>\n<pre><code>派生类将隐藏同名的基类成员。</code></pre><p><strong>通过作用域运算符来使用隐藏的成员</strong></p>\n<p>作用域运算符将覆盖掉原有的查找规则。</p>\n<pre><code>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</code></pre><p><strong>名字查找先去类型检查</strong></p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">struct Base{\n    Base():mem(0){};\n    int memfcn();\nprotected:\n    int mem;\n};\n\nstruct Derived:Base{\n    Derived(int i):mem(i){};\n    int memfcn(int);\n    int get_mem(){return mem;};\nprotected:\n    int mem;\n};\n\nDerived d;\nBase b;\nb.memfcn();        //调用Base::memfcn\nd.memfcn(10);        //调用Derived::memfcn\nd.memfcn();        //错误：参数列表为空的memfcn被隐藏了\nd.Base::memfcn();        //正确：调用Base::memfcn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>虚函数和作用域</strong></p>\n<p>加入基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数。</p>\n<p><strong>通过基类调用隐藏的虚函数</strong></p>\n<h2 id=\"构造函数与拷贝控制\"><a href=\"#构造函数与拷贝控制\" class=\"headerlink\" title=\"构造函数与拷贝控制\"></a>构造函数与拷贝控制</h2><p>和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。</p>\n<h3 id=\"虚析构函数\"><a href=\"#虚析构函数\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h3><p>当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Quote {\npublic:\n    // 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数\n    virtual ~Quote() = default;    // 动态绑定析构函数\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</code></pre><p>之前介绍的经验准则说，如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但这里基类的析构函数并不遵顼这个准则，它是一个重要的例外。</p>\n<p>虚析构函数还将阻止合成移动操作。</p>\n<h3 id=\"合成拷贝控制与继承\"><a href=\"#合成拷贝控制与继承\" class=\"headerlink\" title=\"合成拷贝控制与继承\"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如：</p>\n<ul>\n<li><p>合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。</p>\n</li>\n<li><p>Quote的默认构造函数将bookNo成员默认初始化为空子行串，同时便用类内例始值将price初始化为0。</p>\n</li>\n<li><p>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化qty和discount。</p>\n</li>\n<li><p>Disc quote的构造函数完成后，继续执行Bu1k_quote的构造函数，但是它什么具体工作也不做。</p>\n</li>\n</ul>\n<p><strong>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</strong></p>\n<p><strong>派生类中删除的拷贝控制与基类的关系</strong></p>\n<p>某些定义为基类的方式也可能导致有的派生类成员成为删除的函数：</p>\n<p>-. 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问（参见15.5节，第543页），则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。</p>\n<p>-. 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。</p>\n<p>-. 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=defau1t请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class B{\npublic:\n    B();\n    B(const B&)=delete;\n};\n\nclass D:public B{\n    //没有声明任何构造函数\n};\n\nD d;        //正确，D的合成默认构造函数使用B的默认构造函数\nD d2(d);        //错误：D的合成拷贝构造函数是被删除的\nD d3(std::move(d));        //错误：隐式的使用D的被删除的拷贝构造函数<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>移动操作和继承</strong></p>\n<p>因为基类缺少移动操作会阻止派生类拥有自己的移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Quote{\npublic:\n    Quote()=default;//对成员依次进行默认初始化\n    Quote(const Quote&)=default;//对成员依次拷贝\n    Quote(Quote&&)=default;//对成员依次拷贝\n    Quote& operator=(const Quote&)=default;//拷贝赋值\n    Quote& operator=(Quote&&)=default;//拷贝赋值\n    virtual ~Quote()=default;//析构函数\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"派生类的拷贝控制成员\"><a href=\"#派生类的拷贝控制成员\" class=\"headerlink\" title=\"派生类的拷贝控制成员\"></a>派生类的拷贝控制成员</h3><p>派生类的构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要移动和拷贝基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>\n<p>和构造函数及赋值运算符不同的是，析构函数只负责销毁自己分配的资源。</p>\n<pre><code>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</code></pre><p><strong>定义派生类的拷贝和移动构造函数</strong></p>\n<p>当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Base{/* */};\nclass D:public Base{\npublic:\n    //默认情况下，基类的默认构造函数初始化对象的基类部分\n    //要想使用拷贝或移动构造函数，我们必须在构造函数初始列表中\n    //显式的调用该构造函数\n    D(const D&):Base(d)        //拷贝基类成员\n            /*D的成员的初始值*/{ /* */}\n    D(D&& d):Base(std::move(d))        //移动基类成员\n            /*D的成员的初始值*/{ /* */}\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre><code>在默认情况下，其基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝或者移动基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝构造函数。</code></pre><p><strong>派生类赋值运算符</strong></p>\n<p>派生类的赋值运算符也必须显式地为其基类部分赋值。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">//Base::operator=(const Base&)不会被自动调用\nD &D::operator=(const D &rhs){\n    Base::operator=(rhs);//为基类部分赋值\n    //按照过去的方式为派生类的成员赋值\n    //酌情处理自赋值及释放已有资源等情况\n    return *this;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>派生类析构函数</strong></p>\n<p>派生类析构函数只负责销毁由派生类自己分配的资源。</p>\n<p><strong>在构造函数和析构函数中调用虚函数</strong></p>\n<h3 id=\"继承的构造函数\"><a href=\"#继承的构造函数\" class=\"headerlink\" title=\"继承的构造函数\"></a>继承的构造函数</h3><p><strong>类不能继承默认、拷贝、移动构造函数</strong>，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>\n<p>在C++11新标准中，派生类能够重用其直接基类定义的构造函数。</p>\n<p>一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>\n<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">class Bulk_quote : public Disc_quote {\npublic:\n    using Disc_quote::Disc_quote; // 继承Disc_quote的构造函数\n    double net_price(std::size_t) const;\n};<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。当当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>\n<p>在Bulk_quote类中，继承的构造函数等价于：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">Bulk_quote(const std::string &book, double price, std::size_t qty, double disc) :\n    Disc_quote(book, price, qty, disc) {}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</p>\n<p><strong>继承的构造函数的特点</strong></p>\n<p>一个构造函数的using声明不会改变该构造函数的访问级别。不能指定explicit和constexpr。</p>\n<h2 id=\"容器与继承\"><a href=\"#容器与继承\" class=\"headerlink\" title=\"容器与继承\"></a>容器与继承</h2><h1 id=\"模板和泛型编程\"><a href=\"#模板和泛型编程\" class=\"headerlink\" title=\"模板和泛型编程\"></a>模板和泛型编程</h1><h2 id=\"定义模板\"><a href=\"#定义模板\" class=\"headerlink\" title=\"定义模板\"></a>定义模板</h2><h3 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h3><p>一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板函数可以像这样：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">template<typename T>\nint compare(const T &v1,const T &v2){\n    return  v1 > v2 ? 1 : -1;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>模板定义以一个关键词template开始，后跟一个模板参数列表，这是一个逗号分隔或多个模板参数的列表，用&lt; 和 &gt; 包围起来。</p>\n<pre><code>在模板定义中，模板参数列表不能为空。</code></pre><p><strong>实例化参数模板</strong></p>\n<p>‘’’c++<br>cout&lt;&lt;compare(1,0)&lt;&lt;endl;//T为int<br>‘’’</p>\n<p><strong>模板类型参数</strong></p>\n<p>类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换。</p>\n<p><strong>非类型模板参数</strong></p>\n<p>一个非类型模板参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或者typename来指定非类型参数。</p>\n<pre><code>非类型模板参数的模板实参必须是常亮表达式。</code></pre><p><strong>inline和constexpr的函数模板</strong></p>\n<p>inline或者constexpr说明符放在参数列表之后，返回类型之前：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">template<typename T>\ninline T min(const T &a,const T &b)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>编写类型无关的代码</strong></p>\n<p>编写泛型代码的两个重要的原则：</p>\n<ol>\n<li><p>模板中的函数参数是const的引用；</p>\n</li>\n<li><p>函数体的条件判断仅使用&lt;比较运算。</p>\n</li>\n</ol>\n<p><strong>模板编译</strong></p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h1 id=\"标准库特殊设施\"><a href=\"#标准库特殊设施\" class=\"headerlink\" title=\"标准库特殊设施\"></a>标准库特殊设施</h1><h2 id=\"tuple类型\"><a href=\"#tuple类型\" class=\"headerlink\" title=\"tuple类型\"></a>tuple类型</h2><p>tuple是类似pair的模板。每个pair的成员类型都不相同，但是每个pair都恰好有两个成员。不同tuple类型的成员类型也不相同，但是每个tuple可以有任意数量的成员。每个确定的tuple类型的成员数目是固定的，但一个tuple类型的成员数目可以与另一个tuple类型不同。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">tuple支持的操作\ntuple<T1,T2,...,Tn> t;\ntuple<T1,T2,...,Tn> t(v1,v2,v3,v4,...,vn);\nmake_tuple(v1,v2,...,vn);\nt1==t2;\nt1 relop t2;\nget<i>(t);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"定义和初始化tuple\"><a href=\"#定义和初始化tuple\" class=\"headerlink\" title=\"定义和初始化tuple\"></a>定义和初始化tuple</h3><p>当我们定义一个tuple时，需要指出每个成员的类型：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">tuple<size_t,size_t,size_t> threeD;//三个成员都设置为0\ntuple<string,vector<double>,int,list<int>) someVal(\"contents\",{3.14,2.718},42,{0,1,2,3,4,5})<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>访问tuple的成员</strong></p>\n<p>要访问一个tuple的成员，就要使用一个名为get的标准函数模板。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">auto book = get<0>(item);//返回item成员的第一个成员\nauto cnt = get<1>(item);//返回item成员的第二个成员<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>如果不知道一个tuple准确的类型细节信息，可以使用辅助类模板来查询tuple成员的类型和数量：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">typedef decltype(item) trans;//trans是item的类型\n//返回item类型对象中成员的数量\nsize_t sz = tuple_size<trans>::value;//返回3\n//cnt类型与item中第二个成员相同\ntuple_element<1,trans>::type cnt = get<1>(item);//cnt为int型<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"使用tuple返回多个值\"><a href=\"#使用tuple返回多个值\" class=\"headerlink\" title=\"使用tuple返回多个值\"></a>使用tuple返回多个值</h3><h2 id=\"bitset类型\"><a href=\"#bitset类型\" class=\"headerlink\" title=\"bitset类型\"></a>bitset类型</h2><p>标准库定义了bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。</p>\n<h3 id=\"定义和初始化bitset\"><a href=\"#定义和初始化bitset\" class=\"headerlink\" title=\"定义和初始化bitset\"></a>定义和初始化bitset</h3><p>bitset类是一个类模板，它类似array类，具有固定的大小。当我们定义一个bitset时，需要声明它包含多少个二进制位。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">bitset<32> bitvec(1U);    // 32位；低位为1，其他位为0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>二进制位的位置是从0开始编号的，因此，bitvec包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位（low-order），编号到31结束的二进制位被称为高位（high-order）。</p>\n<p><strong>使用unsigned值初始化bitset</strong></p>\n<p>当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当作位模式来处理。bitset中的二进制位将是此模式的一个副本。如果bitset的大小大于unsigned long long的位数，则剩余高位被置为0。如果小于，则只使用给定值中的低位，超出bitset大小的高位被丢弃。</p>\n<p><strong>从一个string初始化bitset</strong></p>\n<p>我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符都直接表示位模式。当我们使用字符串表示数时，字符串中下标最小的字符对应高位：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">bitset<32> bitvec4(\"1100\");    // 2、3两位为1，剩余两位为0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果string包含的字符数比bitset少，则bitset的高位被置为0。</p>\n<pre><code>string的下标编号习惯于bitset恰好相反：string中下标最大的字符（最右）用来初始化bitset中的低位。</code></pre><h3 id=\"bitset操作\"><a href=\"#bitset操作\" class=\"headerlink\" title=\"bitset操作\"></a>bitset操作</h3><p>bitset操作定义了多种检测或设置一个或多个二进制位的方法。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">bitset<32> bitvec(1U);\nbool is_set = bitvec.any();            // true，因为有1位置位\nbool is_not_set = bitvec.none();    // false，因为有1位置位了\nbool all_set = bitvec.all();        // false，因为只有1位置位了\nsize_t onBits = bitvec.count();        // 返回1\nsize_t sz = bitvec.size();            // 返回32\nbitvec.flip();                        // 翻转bitvec中的所有位\nbitvec.reset();                        // 将所有位复位\nbitvec.set();                        // 将所有位置位\n\nbitvec.flip(0);                        // 翻转第一位\nbitvec.set(0);                        // 置位第一位\nbitvec.reset(i);                    // 复位第i位\nbitvec.test(0);                        // 返回false，因为第一位已复位\n\nbitvec[0] = 0;                        // 将第一位复位\nbitvec[31] = bitvec[0];                // 将最后一位设置为与第一位一样\n~bitvec[0];                            // 翻转第一位<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>提取bitset的值</strong></p>\n<p>to_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式，只有当bitset的大小小于等于对应的大小时，我们才能使用这两个操作，否则将会抛出overflow_error异常。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">unsigned long ulong = bitvec3.to_ulong();\ncout << \"ulong = \" << ulong << endl;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>bitset的IO运算符</strong></p>\n<p>输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的字符数达到对应bitset的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，读取过程才停止。随即用临时string对象来初始化bitset。如果读取的字符数小于bitset的大小，高位被置为0。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">bitset<16> bits;\ncin >> bits;        // 从cin读取最多16个0或1\ncout << \"bits: \" << bits << endl;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>正则表达式是一种描述字符序列的方法，是一种及其强大的计算工具。它定义在头文件regex中，它包含多个组件：</p>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>regex</td>\n<td>表示有一个正则表达式的类</td>\n</tr>\n<tr>\n<td>regex_match</td>\n<td>将一个字符序列与一个正则表达式匹配</td>\n</tr>\n<tr>\n<td>regex_search</td>\n<td>寻找第一个与正则表达式匹配的子序列</td>\n</tr>\n<tr>\n<td>regex_replace</td>\n<td>使用给定格式替换一个正则表达式</td>\n</tr>\n<tr>\n<td>sregex_iterator</td>\n<td>迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串</td>\n</tr>\n<tr>\n<td>smatch</td>\n<td>容器类，保存在string中搜索的结果</td>\n</tr>\n<tr>\n<td>ssub_match</td>\n<td>string中匹配的子表达式的结果</td>\n</tr>\n</tbody></table>\n<p>regex类表示一个正则表达式。</p>\n<p>函数regex_match和regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个输入序列与表达式匹配，则regex_match返回true；如果输入一个序列中一个子串与表达式匹配，则regex_search返回true。</p>\n<h2 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h2><p>程序通常需要一个随机数源。在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。此函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。</p>\n<p>rand函数有一些问题：即使不是大多数，也有很多程序员需要不同范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。</p>\n<p>定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎（random-number engines）和随机数分布类（random-number distribution）。</p>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>引擎</td>\n<td>类型，生成随机unsigned整数序列</td>\n</tr>\n<tr>\n<td>分布</td>\n<td>类型，使用引擎返回服从特定概率分布的随机数</td>\n</tr>\n</tbody></table>\n<p>!!!note<br>    C++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。</p>\n<h3 id=\"随机数引擎和分布\"><a href=\"#随机数引擎和分布\" class=\"headerlink\" title=\"随机数引擎和分布\"></a>随机数引擎和分布</h3><p>随机数引擎是函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">default_random_engine e;\ncout << e() << endl;        // 生成一个随机无符号数<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>标准库定义了多个随机数引擎类，区别在于性能和随机质量不同。</p>\n<p><strong>分布类型和引擎</strong></p>\n<p>为了得到一个指定范围内的数，我们使用一个分布类型的对象：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 生成0到9之间（包含）均匀分布的随机数\nuniform_int_distribution<unsigned> u(0, 9);\ndefault_random_engine e;\ncout << u(e) << endl;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。</p>\n<pre><code>当我们说随机数发生器时，是指分布对象和引擎对象的组合。</code></pre><p><strong>引擎生成一个数值序列</strong></p>\n<p>随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序它都会返回相同的数值序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p>\n<p><strong>设置随机数发生器种子</strong></p>\n<p>我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子（seed）来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">default_random_engine e1;        // 使用默认种子\ne1.seed(42);                    // 调用seed设置一个种子值\ndefault_random_engine e2(42);    // 使用给定的种子值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>如果引擎种子相同，将生成相同的序列。</p>\n<p>选择一个好种子，是极其困难的，可能最常用的方法是调用系统函数time。它定义在头文件ctime中，它返回从一个特定时刻到当前经过了多少秒。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">default_random_engine e(time(0));    // 稍微随机些的种子<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<blockquote>\n<p>my note: 使用random_device引擎为另一个引擎创建一个种子也是一种方法。</p>\n</blockquote>\n<p>后续内容讨论了其他随机数的分布，比如：生成随机实数、生成非均匀分布随机数等。</p>\n<h2 id=\"IO库再探\"><a href=\"#IO库再探\" class=\"headerlink\" title=\"IO库再探\"></a>IO库再探</h2><h3 id=\"格式化输入与输出\"><a href=\"#格式化输入与输出\" class=\"headerlink\" title=\"格式化输入与输出\"></a>格式化输入与输出</h3><p>除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽度等。</p>\n<p>标准库定义了一组操纵符来修改流的格式状态。一个操纵符是一个函数或是一个对象，会影响流的状态。</p>\n<p>!!!warning<br>    当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。</p>\n<p><strong>控制布尔值的格式</strong></p>\n<p>默认情况下，bool值打印为1或0，通过对流使用boolalpha操纵符来修改原有格式：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">cout << boolalpha << true << \" \" << false << endl; // 输出：true false<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>一旦向cout“写入”了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印true或false，为了取消格式的改变，noboolalpha：</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">cout << noboolalpha;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>指定整型值的进制</strong></p>\n<p>默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct、dec将其改为十六进制、八进制或是改回十进制。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">cout << \"default: \" << 20 << endl;\ncout << \"octal: \" << oct << 20 << endl;\ncout << \"hex: \" << hex << 20 << endl;\ncout << \"decimal: \" << dec << 20 << endl; <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>在输出中指出进制</strong></p>\n<p>当对流应用showbase操纵符时，会在输出结果中显示进制：</p>\n<ul>\n<li><p>前导0x表示十六进制。</p>\n</li>\n<li><p>前导0表示八进制。</p>\n</li>\n<li><p>无前导字符串表示十进制。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">cout << showbase;    // 打印整型值时显示进制\ncout << \"default: \" << 20 << endl;\ncout << \"octal: \" << oct << 20 << endl;\ncout << \"hex: \" << hex << 20 << endl;\ncout << \"decimal: \" << dec << 20 << endl;\ncout << noshowbase; // 恢复流状态 <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>指定打印精度</strong></p>\n<p>setprecision操纵符接受一个参数，用来设置精度。它定义在头文件iomanip中。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">cout << setprecision(3);\ncout << sqrt(2.0) << endl;    // 输出：1.41<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>更多操纵符见p669。</p>\n<h3 id=\"未格式化的输入-输出操作\"><a href=\"#未格式化的输入-输出操作\" class=\"headerlink\" title=\"未格式化的输入/输出操作\"></a>未格式化的输入/输出操作</h3><p>标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这组操作允许我们将一个流当作一个无解释的字节序列来处理。</p>\n<p><strong>单字节操作</strong></p>\n<p>有几个未格式化操作每次一个字节地处理流，它们会读取而不是忽略空白符。</p>\n<pre class=\"line-numbers language-c++\"><code class=\"language-c++\">// 读写一个字符\nchar ch;\nwhile (cin.get(ch))\n    cout.put(ch);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>is.get(ch)</td>\n<td>从istream is读取下一个字节存入字符ch中。返回is</td>\n</tr>\n<tr>\n<td>os.put(ch)</td>\n<td>将字符ch输出到ostream os。返回os</td>\n</tr>\n<tr>\n<td>is.get()</td>\n<td>将is的下一个字节作为int返回</td>\n</tr>\n<tr>\n<td>is.putback(ch)</td>\n<td>将字符ch放回is。返回is</td>\n</tr>\n<tr>\n<td>is.unget()</td>\n<td>将is向后移动一个字节。返回is</td>\n</tr>\n<tr>\n<td>is.peek()</td>\n<td>将下一个字节作为int返回，但不从流中删除它</td>\n</tr>\n</tbody></table>\n<p>详细讨论见p673。</p>\n<p><strong>多字节操作</strong></p>\n<p>一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。</p>\n<p>书中未给出代码案例讲解，具体操作见p674。</p>\n<h3 id=\"流随机访问\"><a href=\"#流随机访问\" class=\"headerlink\" title=\"流随机访问\"></a>流随机访问</h3><p>标准库提供了一对函数，来定位（seek）到流中给定的位置，以及告诉（tell）我们当前的位置。</p>\n<p>在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问，因为这种操作对它们没有意义。对这些流调用seek和tell会导致运行时出错，将流置于一个无效状态。</p>\n<p><strong>seek和tell函数</strong></p>\n<p>为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。标准库实际上定义了两对seek和tell函数，差别在于名字的后缀是g还是p，g版本表示我们正在读取数据，而p版本表示我们正在写入数据。</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tellg() tellp()</td>\n<td>返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置</td>\n</tr>\n<tr>\n<td>seekg(pos) seekp(pos)</td>\n<td>在一个输入流或输出流中奖标记重定位到给定的绝对地址。pos通常是前一个tell返回的值</td>\n</tr>\n<tr>\n<td>seekp(off, from) seekg(off, from)</td>\n<td>在一个输入流或输出流中，奖标记定位到from之前或之后off个字符，from可以是：beg（流开始位置）, cur（流当前位置）, end（流结尾位置）</td>\n</tr>\n</tbody></table>\n<p>从逻辑上讲，我们只能对istream使用g版本，对ostream使用p版本。iostream则可以使用g版本又可以使用p版本。</p>\n","site":{"data":{"friends":[{"name":"github主页","url":"https://github.com/HaoxinGuo","title":"访问主页","introduction":"我的Github主页","avatar":"/medias/avatars/myzhihu.png"}],"musics":[{"name":"你的意义","artist":"IU","url":"/medias/music/nideyiyi.mp3","cover":"/medias/music/avatars/nideyiyi.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"光年之外","artist":"邓紫棋","url":"/medias/music/guangnianzhiwai.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"}]}},"excerpt":"","more":"<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><p>学习一门新的程序设计语言的最好方法就是练习编写程序。更多的内容可以查看我的github主页<a href=\"https://github.com/HaoxinGuo/CPlusPlusPrimerProblemset\" target=\"_blank\" rel=\"noopener\">C++课后习题集</a></p>\n<img src=\"readme.jpg\" width=\"50%\" height=\"50%\" alt=\"习题集目录\">\n\n<hr>\n<h2 id=\"编写一个简单的C-程序\"><a href=\"#编写一个简单的C-程序\" class=\"headerlink\" title=\"编写一个简单的C++程序\"></a>编写一个简单的C++程序</h2><p>每个C++程序都包含一个或多个函数（function），其中一个必须命名为<strong>main</strong>。操作系统通过调用main来运行C++程序。</p>\n<p>下面是一个简单的main函数，它什么都不做，只是返回给操作系统一个值：</p>\n<pre><code class=\"c++\">int main()\n{\n    return 0;\n}</code></pre>\n<p>main函数的返回类型必须为int。int类型是一种<strong>内置类型</strong>（built-in type），即语言自身定义的类型。</p>\n<p>函数体是一个以左<strong>花括号</strong>（curly brace）开始，以右花括号结束的语句块（block of statements）。</p>\n<p>return语句结束函数的执行。main的返回值被用来指示状态。返回值0表明成功，非0的返回值的含义由系统定义，通常用来指出错误类型。</p>\n<p><strong>重要概念：类型</strong></p>\n<p>一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。程序所处理的数据都保存在变量中，而每个变量都拥有自己的类型。</p>\n<h3 id=\"编译、运行程序\"><a href=\"#编译、运行程序\" class=\"headerlink\" title=\"编译、运行程序\"></a>编译、运行程序</h3><p>编写好程序后，我们就需要编译它，这依赖于操作系统和编译器。</p>\n<p><strong>程序源文件命名约定</strong></p>\n<p>程序文件通常被称为源文件（source file）。它以一个后缀为结尾，告诉系统这个文件是一个C++程序，比如.cpp。</p>\n<h2 id=\"初识输入输出\"><a href=\"#初识输入输出\" class=\"headerlink\" title=\"初识输入输出\"></a>初识输入输出</h2><p>C++包含了一个全面的<strong>标准库</strong>（standard library）来提供IO机制（以及很多其他设施）。</p>\n<p><strong>iostream</strong>库包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。</p>\n<p><strong>标准输入输出对象</strong></p>\n<p>标准库定义了4个IO对象。为了处理输入，使用名为cin的istream类型的对象。这个对象被称为<strong>标准输入</strong>（standard input）。对于输出，使用名为cout的ostream类型的对象。这个对象被称为<strong>标准输出</strong>（standard output）。另外还有其他两个ostream对象，名为cerr和clog，cerr通常用来输出警告和错误消息，因此被称为<strong>标准错误</strong>（standard error）。clog用来输出程序运行时的一般性消息。</p>\n<p>系统通常将程序所运行的窗口与这些对象关联起来。因此，当读取cin，数据将从程序正在运行的窗口读入，当向cout写入数据时，将会写到同一个窗口。</p>\n<p>!!!note<br>    clog关联到标准错误，默认情况下，写到clog的数据是被缓冲的。写到cerr的数据是不缓冲的。</p>\n<p><strong>一个使用IO库的程序</strong></p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\nint main()\n{\n        std::cout &lt;&lt; &quot;Enter two numbers:&quot; &lt;&lt; std::endl;\n        int v1 = 0, v2 = 0;\n        std::cin &gt;&gt; v1 &gt;&gt; v2;\n        std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; &quot; is &quot;\n                  &lt;&lt; v1 + v2 &lt;&lt; std::endl;\n        return 0;\n}</code></pre>\n<p><code>#include &lt;iostream&gt;</code>告诉编译器我们想要使用iostream库。尖括号中的名字指出了一个<strong>头文件</strong>（header）。每个使用标准库设施的程序都必须包含相关的头文件。#include指令和头文件的名字必须写在同一行中。#include指令一般出现在所有函数之外，源文件的开始位置。</p>\n<p><strong>向流写入数据</strong></p>\n<pre><code class=\"c++\">std::cout &lt;&lt; &quot;Enter two numbers&quot; &lt;&lt; std::endl;</code></pre>\n<p>这条语句执行了一个<strong>表达式</strong>（expression）。在C++中，一个表达式产生一个计算结果，它由一个或多个运算对象和（通常是）一个运算符组成。这条语句中的表达式使用了<strong>输出运算符</strong>（&lt;&lt;）。</p>\n<p><code>&lt;&lt;</code>运算符接受两个运算对象：左侧必须是一个ostream对象；右侧是要打印的值。此运算符将给定的值写到给定的ostream对象中。计算结果是左侧的ostream对象。</p>\n<p>“Enter two numbers”是一个<strong>字符串字面值常量</strong>（string literal），它是用一对双引号包围的字符序列。</p>\n<p>endl是一个被称为<strong>操纵符</strong>（manipulator）的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。</p>\n<p>!!!note<br>    一个表达式接一个分号就是一条语句。</p>\n<p><strong>使用标准库中的名字</strong></p>\n<p>前缀std::指出名字cout和endl是定义在名为<strong>std</strong>的<strong>命名空间</strong>（namespace）中的。</p>\n<p>命名空间可以帮助我们避免不经意的名字定义冲突。标准库定义的所有名字都在命名空间std中。</p>\n<p><strong>从流读取数据</strong></p>\n<p>首先定义两个名为v1和v2的<strong>变量</strong>（variable）来保存输入：</p>\n<pre><code class=\"c++\">int v1 = 0, v2 = 0;</code></pre>\n<p>这两个变量被定义为int类型，并<strong>初始化</strong>（initialize）为0。初始化一个变量，就是在变量创建的同时为它赋予一个值。</p>\n<pre><code class=\"c++\">std::cin &gt;&gt; v1 &gt;&gt; v2;</code></pre>\n<p>这条语句读入输入数据。<strong>输入运算符</strong>（&gt;&gt;）接受一个istream作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的istream读入数据，并存入给定对象中。输入运算符返回其左侧运算对象作为计算结果。</p>\n<h2 id=\"注释简介\"><a href=\"#注释简介\" class=\"headerlink\" title=\"注释简介\"></a>注释简介</h2><p>注释（comments）通常用于概述算法，确定变量的用途，或者解释晦涩难懂的代码段。编译器会忽略掉注释，因此注释对程序的行为和性能不会有任何影响。</p>\n<p><strong>C++中注释的种类</strong></p>\n<p>C++中有两种注释：单行注释和界定符注释。</p>\n<p><strong>注释界定符不能嵌套</strong></p>\n<p>界定符对形式的注释是以<code>/*</code>开始，以<code>*/</code>结束的。因此，一个注释不能嵌套在另一个注释之内。</p>\n<p>如果在调试期间要注释掉包含界定符对形式注释的代码，最好的方式是用单行注释方式注释掉代码段的每一行。</p>\n<pre><code class=\"c++\">// /*\n//  * comments\n//  */</code></pre>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><p>语句一般是顺序执行的，语句块的第一条语句首先执行，然后是第二条，以此类推。但程序设计语言提供了多种不同的控制语句，允许我们写出更为复杂的执行路径。</p>\n<h3 id=\"while语句\"><a href=\"#while语句\" class=\"headerlink\" title=\"while语句\"></a>while语句</h3><p>while语句反复执行一段代码，直到给定条件为假为止。</p>\n<p>while语句的形式为：</p>\n<pre><code class=\"c++\">while (condition)\n    statement</code></pre>\n<p>while语句的执行过程是交替地检测condition条件和执行关联的语句statement，直至condition为假时停止。所谓<strong>条件</strong>就是一个产生真或假的结果的表达式。</p>\n<p>statement可以是语句块，也叫循环体。所谓语句块（block），就是用花括号包围的语句序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。</p>\n<h3 id=\"for语句\"><a href=\"#for语句\" class=\"headerlink\" title=\"for语句\"></a>for语句</h3><p>每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。</p>\n<p>比如：</p>\n<pre><code class=\"c++\">for (int val = 1; val &lt;= 10; ++val)\n    sum += val;</code></pre>\n<p>for循环的总体执行流程：</p>\n<ol start=\"0\">\n<li><p>创建变量val，将其初始化为1，它仅在循环内部存在。</p>\n</li>\n<li><p>检测val是否小于等于10。如果检测成功，执行循环体。若失败，退出循环。</p>\n</li>\n<li><p>将val的值增加1。</p>\n</li>\n<li><p>重复第二个步骤。</p>\n</li>\n</ol>\n<h3 id=\"读取数量不定的输入数据\"><a href=\"#读取数量不定的输入数据\" class=\"headerlink\" title=\"读取数量不定的输入数据\"></a>读取数量不定的输入数据</h3><p>使用这样的方法连续读入数据，直到遇到文件尾（Linux下，输入CTRL+D）：</p>\n<pre><code class=\"c++\">while (std::cin &gt;&gt; value)\n    statement</code></pre>\n<p>输入运算符返回其左侧对象，因此，此循环条件检测的是std::cin。</p>\n<p>当使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时，istream对象的状态会变为无效。</p>\n<h3 id=\"if语句\"><a href=\"#if语句\" class=\"headerlink\" title=\"if语句\"></a>if语句</h3><p>if也对一个条件求值，书本里有一个完整的例子。</p>\n<p>语法大致如此：</p>\n<pre><code class=\"c++\">if (condition) {\n    statements\n} else {\n    statements\n}</code></pre>\n<h2 id=\"类简介\"><a href=\"#类简介\" class=\"headerlink\" title=\"类简介\"></a>类简介</h2><p>在C++中，通过定义一个<strong>类</strong>（class）来定义自己的数据结构。一个类定义了一个类型，以及与其关联的一组操作。</p>\n<p>类似使用标准库设施，我们也需要使用头文件来自己的类。习惯上，头文件根据类名来命名，使用.h作为头文件的后缀。标准库的头文件通常不带后缀。</p>\n<h3 id=\"初识成员函数\"><a href=\"#初识成员函数\" class=\"headerlink\" title=\"初识成员函数\"></a>初识成员函数</h3><p><strong>什么是成员函数？</strong></p>\n<p>有这样的检测条件：</p>\n<pre><code class=\"c++\">item1.isbn() == item2.isbn()</code></pre>\n<p>调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数。</p>\n<p>使用<strong>点运算符（.）</strong>来表达我们需要“名为item1的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。</p>\n<p>我们使用<strong>调用运算符（()）</strong>来调用一个函数，它是一对圆括号，里面放实参列表（可能为空）。# 第二章</p>\n<ol>\n<li>‘void*’<br>是一种特殊的指针类，可以存放任意对象的地址。  </li>\n<li>const 对象必须初始化。 const int buf =10  </li>\n<li>const 指针，其值不能被改变，所有必须初始化。</li>\n<li>顶层const和底层const，顶层const表示指针本身是一个常量，底层const表示指针所指对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。</li>\n</ol>\n<pre><code>int i = 0;\nint *const p1 = &amp;i;    // 不能改变p1的值，p1是一个顶层const\nconst int ci = 42；    // 不能改变ci的值，ci是一个顶层const\nconst int *p2 = &amp;ci;   // 允许改变p2的值，p2是一个底层const\nconst int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const\nconst int &amp;r = ci;     // 用于声明引用的const都是底层const</code></pre><p>C++新标准引入了第二种类型说明符<strong>decltype</strong>，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p>\n<pre><code>decltype(f()) sum = x; // sum的类型就是函数f的返回类型</code></pre><p>编译器并不实际调用f，而是使用当调用发生时f的返回值的类型作为sum的类型。</p>\n<p>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：</p>\n<pre><code>const int ci = 0, &amp;cj = ci;\ndecltype(ci) x = 0; // x的类型是const int\ndecltype(cj) y = x; // y的类型是const int&amp;, y绑定到x</code></pre><p><strong>decltype和引用</strong></p>\n<p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式向decltype返回一个引用类型，一般来说，意味着该表达式的结果对象能作为一条赋值语句的左值：</p>\n<pre><code>// decltype的结果可以是引用类型\nint i = 42, *p = &amp;i, &amp;r = i;\ndecltype(r + 0) b; // 正确，加法的结果是int，因此b是一个int\ndecltype(*p) c; // 错误，c是int&amp;，必须初始化</code></pre><p>如果表达式的内容是解引用操作，则decltype将得到引用类型。</p>\n<p>有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，编译器就会把它当成一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：</p>\n<pre><code>// decltype的表达式如果是加上了括号的变量，结果是引用\ndecltype((i)) d; // 错误，d是int&amp;，必须初始化\ndecltype(i) e; // 正确，e是一个int。</code></pre><p><strong>auto 和decltype的区别主要有三个方面</strong>：<br>第一，auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。<br>第二，编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。<br>第三，与auto不同，decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。</p>\n<h1 id=\"字符串、向量和数组\"><a href=\"#字符串、向量和数组\" class=\"headerlink\" title=\"字符串、向量和数组\"></a>字符串、向量和数组</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><ol>\n<li><strong>头文件不应包含using声明</strong>  </li>\n<li><strong>初始化string对象的方式：</strong>  <pre><code class=\"c++\">string s1;           // 默认初始化，s1是一个空串\nstring s2(s1);       // s2是s1的副本\nstring s2 = s1;      // 等价于s2(s1)\nstring s3(&quot;value&quot;);  // s3是字面值&quot;value&quot;的副本，不包括最后的空字符\nstring s3 = &quot;value&quot;; // 等价于s3(&quot;value&quot;)\nstring s4(n, &#39;c&#39;);   // 初始化为由n个字符c组成的串</code></pre>\n</li>\n<li><strong>直接初始化和拷贝初始化</strong>  </li>\n</ol>\n<p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化（copy initialization）</strong>，编译器把等号右侧的对象初始值拷贝到新创建的对象中去。如果不适用等号，则执行的是<strong>直接初始化</strong>（direct initialization）。  </p>\n<pre><code class=\"c++\">string s5 = &quot;hiya&quot;;  // 拷贝初始化\nstring s6(&quot;hiya&quot;);   // 直接初始化\nstring s7(10, &#39;c&#39;);  // 直接初始化</code></pre>\n<ol start=\"4\">\n<li>getline函数会读取换行符，但不会把它存入字符串中。getline返回输入流。  </li>\n</ol>\n<p><strong>string::size_type类型</strong>  </p>\n<p>size函数返回的是一个string::size_type类型的值。这是一个无符号的整数。  </p>\n<ol start=\"5\">\n<li><strong>处理每个字符？使用基于范围的for语句</strong>  </li>\n</ol>\n<p>如果想对string对象中的每个字符做点儿什么操作，目前最好的办法是使用C++11新标准提供的一种语句：<strong>范围for</strong>（range for）语句。这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作，其语法格式是：  </p>\n<pre><code class=\"c++\">for (declaration : expression)\n    statement</code></pre>\n<p>如：  </p>\n<pre><code class=\"c++\">for (auto c : str)\n    // do something</code></pre>\n<p><strong>使用下标运算符</strong></p>\n<p><code>[ ]</code>符号叫做下标运算符，范围是<code>[0, s.size())</code>，越界的结果是UB（undefined behavior，未定义行为）。  </p>\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h2><ol>\n<li>vector是对象的集合，也叫容器（container）。集合中的每个对象都有一个索引，索引用于访问对象。  </li>\n<li>vector是一个类模板。模板是为编译器提供的一份生成类或函数的说明。  </li>\n<li>vector是模板而非类型，由vector生成的类型必须包含元素的类型，如：  <pre><code class=\"c++\">vector&lt;int&gt; v;</code></pre>\n</li>\n<li><strong>vector中存放的是对象，而引用不是对象，故不能存储引用。</strong>  <h3 id=\"定义和初始化vector对象\"><a href=\"#定义和初始化vector对象\" class=\"headerlink\" title=\"定义和初始化vector对象\"></a>定义和初始化vector对象</h3>vector模板控制着初始化向量的方法。定义vector对象的方法有：  </li>\n</ol>\n<ul>\n<li><code>vector&lt;T&gt; v1</code>，默认初始化，v1是一个空的vector  </li>\n<li><code>vector&lt;T&gt; v2(v1)</code>，v2中包含v1所有元素的副本  </li>\n<li><code>vector&lt;T&gt; v2 = v1</code>，等价于v2(v1)  </li>\n<li><code>vector&lt;T&gt; v3(n, val)</code>，v3包含了n个重复的元素，每个元素的值都是val  </li>\n<li><code>vector&lt;T&gt; v4(n)</code>，v4包含了n个执行了值初始化的对象  </li>\n<li><code>vector&lt;T&gt; v5{a,b,c...}</code>，v5里包含了用a,b,c…初始化的元素  </li>\n<li><code>vector&lt;T&gt; v5 = {a,b,c...}</code>，等价于<code>vector&lt;T&gt; v5{a,b,c...}</code>  </li>\n</ul>\n<p><strong>值初始化</strong><br>值初始化（value initialize），是指如果是内置类型，则初始值为0；如果是类类型，执行类默认初始化。<br><code>vector&lt;T&gt;(n)</code>中，所有元素将执行值初始化。</p>\n<h3 id=\"向vector中添加元素\"><a href=\"#向vector中添加元素\" class=\"headerlink\" title=\"向vector中添加元素\"></a>向vector中添加元素</h3><p>push_back函数把一个元素压入vector对象的尾端。<br>vector的对象能高效地增长，因此更常见的情况是：创建一个空vector，然后在运行时再利用vector的成员函数push_back向其中添加元素。<br><strong>一定不能在遍历vector的时候改变vector对象的大小。</strong><br>C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小就没有什么必要了，只有一种例外，即当所有元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。  </p>\n<h3 id=\"其它vector操作\"><a href=\"#其它vector操作\" class=\"headerlink\" title=\"其它vector操作\"></a>其它vector操作</h3><p>如（很多和string类似）：</p>\n<ul>\n<li><code>v.empty()</code>，如果v不含有任何元素，返回true  </li>\n<li><code>v.size()</code>，返回v中的元素个数  </li>\n<li><code>v[n]</code>，返回v中第n个位置上元素的引用  </li>\n<li><code>v1 = v2</code>，v2中的元素将拷贝替换v1的  </li>\n<li><code>v1 = {a,b,c...}</code>，列表中的元素将拷贝替换v1中的  </li>\n<li><code>v1 == v2</code>, <code>v1 != v2</code>，元素数量相同，对应位置的元素也相等，则相等  </li>\n<li>&lt;,&lt;=,&gt;,&gt;=，比首个相异元素的大小，如都一样，比长度，即字典顺序<br>size返回的类型由vector定义的size_type类型。<pre><code class=\"c++\">vector&lt;int&gt;::size_type    // 正确\nvector::size_type         // 错误</code></pre>\n</li>\n</ul>\n<p><strong>只有当元素的值可比较时，vector对象才能被比较。只能对确已存在的元素执行下标操作。</strong>  </p>\n<h2 id=\"迭代器介绍\"><a href=\"#迭代器介绍\" class=\"headerlink\" title=\"迭代器介绍\"></a>迭代器介绍</h2><p>使用迭代器（iterator）是一种通用的访问容器中元素的方法。<br>迭代器有有效和无效之分。有效的迭代器指向某个元素，或指向尾元素的下一个位置，其它情况都属于无效。</p>\n<h3 id=\"使用迭代器\"><a href=\"#使用迭代器\" class=\"headerlink\" title=\"使用迭代器\"></a>使用迭代器</h3><p>有迭代器的类型同时拥有返回迭代器的成员。<br>标准库容器都拥有名为begin和end的成员（函数）。其中begin成员负责返回指向第一个元素的迭代器。<br>end成员负责返回指向容器“尾元素的下一个位置”的迭代器。叫<strong>尾后迭代器（off-the-end iterator）</strong>。<br>如果容器为空，begin和end都返回尾后迭代器。即：<code>v.begin() == v.end()</code><br>如：  </p>\n<pre><code class=\"c++\">auto b = v.begin();\nauto e = v.end();</code></pre>\n<p><strong>迭代器运算符</strong><br>标准容器迭代器的运算符：  </p>\n<ul>\n<li><code>*iter</code>，返回迭代器所指对象的引用（解引用）  </li>\n<li><code>iter-&gt;mem</code>，解引用iter，并获取其成员mem，等价于<code>(*iter).mem</code>  </li>\n<li><code>++iter</code>，令iter指示容器中的下一个元素  </li>\n<li><code>--iter</code>，令iter指示容器中的上一个元素  </li>\n<li><code>iter1 == iter2</code>，如果两个迭代器指示的是同一个元素，或者它们都是尾后迭代器，则相等，反之不相等<br>迭代器指示一个元素时，才可对其解引用。对尾后迭代器或者无效迭代器解引用的结果是UB。  </li>\n</ul>\n<p><strong>迭代器类型</strong><br>标准库类型使用iterator和const_iterator来表示迭代器类型。<br>如：</p>\n<pre><code class=\"c++\">vector&lt;int&gt;::iterator it1;\nvector&lt;int&gt;::const_iterator it2;</code></pre>\n<p>it1能读写元素，而it2只能读。<br>认定某个类型是迭代器类型当且仅当它支持一套操作，这套操作使得我们能访问容器的元素，或者从某个元素移动到另外一个元素。<br><strong>begin和end运算符</strong>begin和end返回的具体类型由对象是否是常量决定。如果对象是常量，返回const_iterator，否则返回iterator。<br>为了专门得到const_iterator类型的迭代器，C++11中可以使用cbegin和cend：  </p>\n<pre><code class=\"c++\">auto it = v.cbegin();</code></pre>\n<p><strong>箭头运算符</strong>即<code>-&gt;</code>，它把解引用和成员访问两个操作结合在一起。即：<code>(*iter).mem</code>等价于<code>iter-&gt;mem</code>。<br><strong>某些对vector对象的操作会使迭代器失效</strong>任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。</p>\n<h3 id=\"迭代器运算\"><a href=\"#迭代器运算\" class=\"headerlink\" title=\"迭代器运算\"></a>迭代器运算</h3><p>递增运算令迭代器每次移动一个元素，所有的标准库容器的迭代器都支持递增运算，也支持==和!=运算。<br>string和vector的迭代器提供了额外的运算符，有：  </p>\n<ul>\n<li><code>iter + n</code>，新迭代器向前移动若干个元素，它指向容器的一个元素，或是尾后迭代器  </li>\n<li><code>iter - n</code>，新迭代器向后移动若干个元素，它指向容器的一个元素，或是尾后迭代器  </li>\n<li><code>iter1 - iter2</code>，得到迭代器之间的距离，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置  </li>\n<li><code>&gt;,&gt;=,&lt;,&lt;=</code>，比较迭代器所处的位置，前面的小于后面的，参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置    </li>\n</ul>\n<p><strong>迭代器的算数运算</strong><br>迭代器相减的结果的类型是difference_type，表示右侧的迭代器要移动多少个位置才能到达左侧的。<br>difference_type是一个带符号的整数，string和vector都定义了这个类型。<br><strong>迭代器相加没有意义</strong></p>\n<pre><code class=\"c++\">auto mid = (beg) +(end-beg)/2;//正确\nauto mid =(beg+end)/2;//错误 迭代器加法不存在</code></pre>\n<p>string类本身接受无参数的初始化方式，无论数组定义在函数体内部还是外部都被默认初始化为空串，对于内置类型int，数组定义在函数体外部时默认初始化为0，在main函数内部时，将不被初始化。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><ol>\n<li>数组是存放相同类型的对象的容器，这些对象是匿名的。  </li>\n<li>数组的大小确定不变。  </li>\n<li>数组是一种内置类型。  <h3 id=\"定义和初始化内置数组\"><a href=\"#定义和初始化内置数组\" class=\"headerlink\" title=\"定义和初始化内置数组\"></a>定义和初始化内置数组</h3>数组是一种复合类型，其声明形如<code>a[N]</code>  。N叫维度，说明了数组中元素的个数，必须大于0，且必须是一个<strong>常量表达式</strong>，即其值在编译期间已知。<br>默认情况下，数组的元素执行默认初始化，这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组，其元素的值未定义。<br>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。数组的元素应为对象，所以不存在存储引用的数组。  </li>\n</ol>\n<p><strong>显式初始化数组元素</strong><br>即列表初始化，此时可以忽略数组的维度，维度由编译器推断出来。如：  </p>\n<pre><code class=\"c++\">int a1[10] = {0}; // 剩下的元素执行值初始化，即为0\nint a2[] = {1, 2, 3};</code></pre>\n<p><strong>字符数组的特殊性</strong>可以用字符串字面值对此类数组进行初始化。如：  </p>\n<pre><code class=\"c++\">char s[] = &quot;hello&quot;;</code></pre>\n<p>这样初始化的数组包含结尾的空字符。<br><strong>不允许拷贝和赋值</strong><br>这样的操作是非法的：  </p>\n<pre><code class=\"c++\">int a1[] = {1, 2, 3};\nint a2[] = a1; // 非法</code></pre>\n<p><strong>理解复杂的数组声明</strong>  </p>\n<ol>\n<li>定义一个指针数组<pre><code class=\"c++\">int* a[10] = {};</code></pre>\n</li>\n<li>定义一个指向数组的指针：  <pre><code class=\"c++\">int (*ptr)[10] = &amp;a;</code></pre>\n</li>\n<li>定义一个绑定到数组的引用：  <pre><code class=\"c++\">int (&amp;a_ref)[10] = a;</code></pre>\n默认情况下，类型修饰符从右向左依次绑定。不过理解数组的复杂声明时，应该由内向外理解。即从数组的名字开始按照由内向外的顺序阅读。  <h3 id=\"访问数组元素\"><a href=\"#访问数组元素\" class=\"headerlink\" title=\"访问数组元素\"></a>访问数组元素</h3>使用数组下标的时候，通常将其定义为size_t类型，这是一种机器相关的无符号类型。定义在cstddef头文件中，是C标准库stddef.h头文件的C++版本。可以使用范围for语句来遍历数组。  <pre><code class=\"c++\">for (auto i : arr)\n cout &lt;&lt; i &lt;&lt; &quot; &quot;;\ncout &lt;&lt; endl;</code></pre>\n</li>\n</ol>\n<p><strong>得到数组的大小</strong></p>\n<pre><code>sizeof(array/sizeof(array[0];</code></pre><p><strong>检查下标的值</strong><br>与string和vector一样，数组的下标是否在合理范围之内由程序员负责检查。  </p>\n<h3 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h3><p>在很多用到数组名字的地方，编译器都会自动地将其替换为一个<strong>指向数组首元素的指针</strong>。<br><strong>decltype</strong><br>下面得到一个数组类型：   </p>\n<pre><code class=\"c++\">int a1[10] = {};\ndecltype(a1) a2;</code></pre>\n<p><strong>auto</strong><br>下面得到一个整型指针：</p>\n<pre><code class=\"c++\">int a1[10] = {};\nauto a2(a1);</code></pre>\n<p><strong>指针也是迭代器</strong><br>string和vector的迭代器支持的运算，指针都支持。使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上。这样可以获取数组尾元素的下一个位置的指针：</p>\n<pre><code class=\"c++\">int *end = &amp;a[N];</code></pre>\n<p>不过C++11提供了begin和end函数，可以获取数组首元素的指针和尾后指针：</p>\n<pre><code class=\"c++\">int a[10] = {};\nint *beg_p = begin(a);\nint *end_p = end(a);</code></pre>\n<p>这俩函数定义在头文件iterator.h中。尾后指针不能解引用和递增操作。和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素。<br><strong>下标和指针</strong><br>对数组执行下标运算其实是对指向数组元素的指针执行下标运算：  </p>\n<pre><code class=\"c++\">int i = ia[2];    // ia转换成指向数组首元素的指针\n                  // ia[2]得到(ia + 2)所指的元素\nint *p = ia;      // p指向ia的首元素\ni = *(p + 2);     // 等价于i = ia[2]</code></pre>\n<p>只要指针指向的是数组中的元素，都可以执行下标运算。<br>内置的下标运算符可以处理负值，这和标准库类型的下标不一样（必须是无符号的）。  </p>\n<h3 id=\"C风格字符串\"><a href=\"#C风格字符串\" class=\"headerlink\" title=\"C风格字符串\"></a>C风格字符串</h3><p>C风格的字符串即是字符串字面量，也是一种字符数组，并以空字符结尾（null terminated）。<br>p109列举了C语言标准库提供的一组函数，可以操作C风格字符串，他们定义在cstring头文件中。<br><strong>c_str函数</strong><br>string可使用c_str函数返回其C风格的字符串，如：  </p>\n<pre><code class=\"c++\">string s(&quot;hello&quot;);\nconst char *c_s = s.c_str();</code></pre>\n<p>无法保证返回的C风格字符串一直有效，因此通常在返回后再把它拷贝到另一个地方<br><strong>使用数组初始化vector对象</strong>如：  </p>\n<pre><code class=\"c++\">int a[] = {1, 2, 3};\nvector&lt;int&gt; vec(begin(a), end(a));</code></pre>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><p>多维数组，实际上是数组的数组。<br>如：<code>int a[3][4]</code>，可由内而外理解，a是一个含有3个元素的数组，每个元素又是一个含有4个元素的数组。<br>对于二维数组，常把第一个维度看作行，第二个维度看作列。<br><strong>多维数组的初始化</strong>如：  </p>\n<pre><code class=\"c++\">int a[3][4] = {\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n    {8, 9, 10, 11}\n};</code></pre>\n<p>列表初始化中未列出的元素执行值初始化。<br><strong>多维数组的下标引用</strong><br>如果表达式含有的下标运算符数量和维度一样多，该表达式的结果将是给定类型的元素；否则表达式的结果是内层数组</p>\n<pre><code class=\"c++\">int a[3][4] = {};\nint (&amp;row)[4] = a[2]; // row绑定到a的第二个数组上</code></pre>\n<p><strong>使用范围for语句处理多维数组</strong><br>如果是外层循环，控制变量将得到数组类型。<br>除了最内层的循环外，其他所有循环控制变量都应该是引用类型（因为若不是引用，编译器会认为外层控制变量是指针类型，而无法遍历一个指针）。<br><strong>指针和多维数组</strong><br>当程序使用多维数组名字时，也会自动将其转换成指向数组首元素的指针。<br>多维数组的首元素是一个内层数组，故使用多维数组名将得到一个指向内层数组的指针。<br>即：</p>\n<pre><code class=\"c++\">int a[2][3] = {};\nint (*p)[3] = a;</code></pre>\n<p>还可以使用auto或者begin来得到指向内层数组的指针。<br><strong>类型别名简化多维数组的指针</strong><br>可以这样定义一个数组类型：</p>\n<pre><code class=\"c++\">using int_arr = int[4]; // C++11\ntypedef int int_arr[4];</code></pre>\n<p><strong>指针</strong>  </p>\n<ol>\n<li>指针本身的值（value）；</li>\n<li>指针所指的对象（content）；</li>\n<li>指针本身在内存中的储存位置（address）</li>\n</ol>\n<h1 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h1><ol>\n<li><code>*iter.empty()</code>和<code>(*iter).empty()</code>和<code>iter-&gt;empty()</code>的区别  </li>\n<li><code>somevalue ? ++x,++y:--x,--y;</code>等价于<code>(somevalue ? ++x,++y:--x),--y;</code><h1 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h1></li>\n</ol>\n<p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。<br>|运算符|功能|用法|<br>|-|-|-|<br>|<del>|位求反|</del>expr|<br>|&lt;&lt;|左移|expr1 &lt;&lt; expr2|<br>|&gt;&gt;|右移|expr1 &gt;&gt; expr2|<br>|&amp;|位与|expr1 &amp; expr2|<br>|^|位异或|expr1 ^ expr2|<br>|||位或|expr1 | expr2|</p>\n<p>一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算如何处理运算对象的“符号位”依赖于机器。<br>强烈建议将位运算符用于处理无符号类型。<br>一个提升例子就是，如果对char做位运算，它会先被提升为int。<br><strong>移位运算符</strong><br>&lt;&lt;和&gt;&gt;<br>运算符的内置含义是对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位数被舍弃掉了。<br>左移运算符&lt;&lt;在右侧插入值为0的二进制位。右移运算符&gt;&gt;的行为依赖于左侧运算对象的类型：如果是无符号的，在左侧插入值为0的二进制位；如果是带符号的，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定。  </p>\n<h1 id=\"sizeof运算符\"><a href=\"#sizeof运算符\" class=\"headerlink\" title=\"sizeof运算符\"></a>sizeof运算符</h1><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。它有两种形式：  </p>\n<ul>\n<li>sizeof(type)</li>\n<li>sizeof?expr<br>常量表达式意味着在编译期间就能得到计算。<br>第二种形式中，sizeof返回的是表达式结果类型的大小。<br>sizeof运算符的结果部分地依赖于其作用的类型：  </li>\n<li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li>\n<li>对引用类型执行sizeof运算得到被引用对象所占空间大小。</li>\n<li>对指针执行sizeof运算得到指针本身所占空间的大小。</li>\n<li>对解引用指针执行sizeof运算得到指针指向对象所占空间的大小，指针不需要有效。</li>\n<li>对数组执行sizeof运算得到整个数组所占空间大小。</li>\n<li>对string对象或vector执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。<h1 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"?显式转换\"></a>?显式转换</h1></li>\n</ul>\n<p><strong>命名的强制类型转换</strong><br>一个命名的强制类型转换有如下形式：<br>cast-name<type>(expression);<br>其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast,?dynamic_cast,?const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时识别，直到19章（p730）才会讲解。<br><strong>static_cast</strong><br>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</type></p>\n<pre><code>//?进行强制类型转换以便执行浮点数除法\ndouble?slope?=?static_cast&lt;double&gt;(j)?/?i;</code></pre><p>当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换表示，我们知道并且不在乎潜在的精度损失。<br>static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*的指针中的值：  </p>\n<pre><code>void?*p?=?&amp;d;????//?正确，任何非常量对象的地址都能存入void*\n\n//?正确，将void*转换回初始的指针类型\ndouble?*dp?=?static_cast&lt;double*&gt;(p);</code></pre><p>必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。<br><strong>const_cast</strong><br>const_cast只能改变运算对象的底层const：  </p>\n<pre><code>const?char?*pc;\nchar?*p?=?const_cast&lt;char*&gt;(pc);????//?正确，但是通过p写值是未定义的行为</code></pre><p>如果对象本身是一个非常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，执行写操作就会产生未定义的后果。<br>const_cast常常用于有函数重载的上下文中，这将在第6章介绍（p208）。<br><strong>reinterpret_cast</strong><br>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。比如：  </p>\n<pre><code>int?*ip;\nchar?*pc?=?reinterpret_cast&lt;char*&gt;(ip);</code></pre><p>我们必须牢记pc所指的真实对象是一个int而非字符。<br>    reinterpret_cast非常危险，书中建议尽量避免使用。因为它本质上依赖于机器。且没有介绍应用场景。另外，书中也建议尽量避免其他的强制类型转换，强制类型转换应当在其合适的应用场景中使用。<br><strong>旧式的强制类型转换</strong><br>在早期版本的C++语言中，显式地进行强制类型转换包含两种形式：  </p>\n<pre><code>type(expr);???//?函数形式的强制类型转换\n(type)expr;???//?C语言风格的强制类型转换</code></pre><p>根据所涉及的类型不同，旧式的强制类型转换分别具有const_cast,?static_cast或reinterpret_cast相似的行为。<br>    与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。# try语句块<br>try语句块的通用语法形式是：  </p>\n<pre><code class=\"c++\">try {\n    program-statements\n} catch (exception-declaration) {\n    handler-statements\n} // ...</code></pre>\n<p>当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。<br>try语句块内声明的变量在catch子句内无法访问。<br>一个简要的例子：  </p>\n<pre><code class=\"c++\">while (cin &gt;&gt; item1 &gt;&gt; item2) {\n    try {\n        // ... 可能抛出一个异常的代码\n    } catch (runtime_error err) {\n        cout &lt;&lt; err.what() &lt;&lt; &quot;\\nTry Again? Enter y or n&quot; &lt;&lt; endl;\n        char c;\n        cin &gt;&gt; c;\n        if (!cin || c == &#39;n&#39;)\n            break; // 跳出while循环\n    }\n}</code></pre>\n<h1 id=\"throw表达式\"><a href=\"#throw表达式\" class=\"headerlink\" title=\"throw表达式\"></a>throw表达式</h1><p>抛出异常的一个例子是：  </p>\n<pre><code class=\"c++\">throw runtime_error(&quot;Data must refer to same ISBN&quot;);</code></pre>\n<p>该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。  </p>\n<ul>\n<li><strong>throw 表达式（throw expression）</strong>，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw<strong>引发（raise）</strong>了异常。  </li>\n<li><strong>try语句块（try block）</strong>，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个<strong>catch子句（catch clause）</strong>结束。try语句块中代码抛出的异常通常会被某个catch子句处理。  </li>\n<li>一套<strong>异常类（exception class）</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。  <h1 id=\"简单语句\"><a href=\"#简单语句\" class=\"headerlink\" title=\"简单语句\"></a>简单语句</h1>C++语言中的大多数语句都以分号结束，一个表达式，比如ival+5，末尾加上分号就变成了<strong>表达式语句</strong>(expression statement)，表达式语句的作用是执行表达式并丢弃掉求值结果：<pre><code class=\"c++\">ival + 5;    // 无意义的表达式语句\ncout &lt;&lt; ival;// 有意义的表达式语句</code></pre>\n</li>\n</ul>\n<p><strong>空语句</strong><br>最简单的语句是<strong>空语句</strong>（null statement），它只有一个分号： </p>\n<pre><code class=\"c++\">; // 空语句</code></pre>\n<p>如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。<br><strong>复合语句（块）</strong><br>复合语句（compound statement）是指用花括号括起来的语句和声明的序列，复合语句也被称作<strong>块</strong>（block）。一个块就是一个作用域。<br>如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。<br>所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句：  </p>\n<pre><code class=\"c++\">while (cin &gt;&gt; s &amp;&amp; s != sought)\n{}  // 空块</code></pre>\n<h1 id=\"语句作用域\"><a href=\"#语句作用域\" class=\"headerlink\" title=\"语句作用域\"></a>语句作用域</h1><p>可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：  </p>\n<pre><code class=\"c++\">while (int i = get_num()) // 每次迭代时创建并初始化\n    cout &lt;&lt; i &lt;&lt; endl;\ni = 0;    // 错误，在循环外部无法访问</code></pre>\n<h1 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h1><p>C++语言提供了两种按条件执行的语句。一种是if语句，它根据条件决定控制流；另一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。  </p>\n<h2 id=\"if语句-1\"><a href=\"#if语句-1\" class=\"headerlink\" title=\"if语句\"></a>if语句</h2><p>if语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行另外一条语句。  </p>\n<h2 id=\"switch语句\"><a href=\"#switch语句\" class=\"headerlink\" title=\"switch语句\"></a>switch语句</h2><p>switch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择。  </p>\n<h1 id=\"迭代语句\"><a href=\"#迭代语句\" class=\"headerlink\" title=\"迭代语句\"></a>迭代语句</h1><p>迭代语句通常称之为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。  </p>\n<h2 id=\"while语句-1\"><a href=\"#while语句-1\" class=\"headerlink\" title=\"while语句\"></a>while语句</h2><p>语法格式是：  </p>\n<pre><code class=\"c++\">while (condition)\n    statement</code></pre>\n<p>只要condition的求值结果为真就一直执行statement。如果condition第一次求值就是false，statement一次都不执行。<br>while的条件部分可以是一个表达式或者是一个带初始化的变量声明。<br><strong>使用while循环</strong><br>当不确定到底要迭代多少次时，使用while循环比较合适。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。  </p>\n<h2 id=\"传统的for语句\"><a href=\"#传统的for语句\" class=\"headerlink\" title=\"传统的for语句\"></a>传统的for语句</h2><p>for语句的语法形式是  </p>\n<pre><code class=\"c++\">for (init-statement: condition; expression)\n    statement</code></pre>\n<h2 id=\"范围for语句\"><a href=\"#范围for语句\" class=\"headerlink\" title=\"范围for语句\"></a>范围for语句</h2><p>C++11新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。<strong>范围for语句</strong>（range for statement）的语法形式是：</p>\n<pre><code class=\"c++\">for (declaration : expression)\n    statement</code></pre>\n<p>expression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。<br>declaration定义一个变量，序列中的每个元素都能转换成该变量的类型。<br>每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。<br>在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。因此不能通过范围for语句增加vector对象的元素。  </p>\n<h2 id=\"do-while语句\"><a href=\"#do-while语句\" class=\"headerlink\" title=\"do while语句\"></a>do while语句</h2><p>do while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少会执行一次循环。do while语句的语法形式如下：  </p>\n<pre><code class=\"c++\">do\n    statement\nwhile (condition);</code></pre>\n<h2 id=\"跳转语句\"><a href=\"#跳转语句\" class=\"headerlink\" title=\"跳转语句\"></a>跳转语句</h2><p>跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break, continue, goto和return。本章介绍前三种，return在第六章介绍（p199页）。  </p>\n<h2 id=\"break语句\"><a href=\"#break语句\" class=\"headerlink\" title=\"break语句\"></a>break语句</h2><p>break语句负责终止离它最近的while, do while, for或switch语句，并从这些语句之后的第一条语句开始执行。</p>\n<h2 id=\"continue语句\"><a href=\"#continue语句\" class=\"headerlink\" title=\"continue语句\"></a>continue语句</h2><p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for, while和do while循环的内部。  </p>\n<h2 id=\"goto语句\"><a href=\"#goto语句\" class=\"headerlink\" title=\"goto语句\"></a>goto语句</h2><p>goto语句（goto statement）的作用是从goto语句无条件跳转到同一函数内的另一条语句。  </p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h2 id=\"函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。\"><a href=\"#函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。\" class=\"headerlink\" title=\"函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。  \"></a>函数是一个命名了的代码块，我们通过调用函数执行相应的代码。函数可以有0个或多个参数，而且（通常）会产生一个结果。  </h2><h2 id=\"函数基础\"><a href=\"#函数基础\" class=\"headerlink\" title=\"函数基础\"></a>函数基础</h2><p>一个典型的函数（function）定义包括以下部分：返回类型（return type）、函数名字、由0个或多个形参（parameter）组成的列表以及函数体。<br>我们通过<strong>调用运算符（call operator）</strong>来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。<br>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，<strong>主调函数</strong>（calling function）的执行暂时被中断，<strong>被调函数</strong>（called function）开始执行。<br>当遇到一条return语句时函数结束执行过程。函数的返回值用于初始化调用表达式的结果。<br><strong>函数返回类型</strong><br>大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何类型。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。  </p>\n<h3 id=\"局部对象\"><a href=\"#局部对象\" class=\"headerlink\" title=\"局部对象\"></a>局部对象</h3><p>在C++语言中，名字有作用域，对象有<strong>生命周期（lifetime）</strong>，理解这两个概念非常重要：  </p>\n<ul>\n<li>名字的作用域是程序文本的一部分，名字在其中可见。  </li>\n<li>对象的生命周期是程序执行过程中该对象存在的一段时间。<br>形参和函数体内部定义的变量统称为<strong>局部变量（local variable）</strong>。它们仅在函数的作用域内可见。<br>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。  </li>\n</ul>\n<p><strong>自动对象</strong><br>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为<strong>自动对象（automatic object）</strong>。<br>形参是一种自动对象。函数开始时为形参申请存储空间，函数一旦终止，形参就被销毁。<br>对于局部变量对应的自动对象来说，如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化（内置类型产生未定义的值）。<br><strong>局部静态对象（local static object）</strong>在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。例：  </p>\n<pre><code class=\"c++\">// 统计函数被调用了多少次\nsize_t count_calls()\n{\n    static size_t ctr = 0; // 调用结束后，这个值仍然有效\n    return ++ctr;\n}</code></pre>\n<h3 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h3><p>函数的名字必须在使用之前声明。类似于变量，函数只能定义一次，但可以声明多次。<br>函数的声明和定义唯一的区别是<strong>声明无须函数体</strong>，用一个分号替代即可。<br>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作<strong>函数原型（function prototype）</strong>。<br><strong>在头文件中进行函数声明</strong><br>我们建议函数在头文件中声明，在源文件中定义。<br>这是因为如果把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需改变一条声明即可。<br>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。  </p>\n<h3 id=\"分离式编译\"><a href=\"#分离式编译\" class=\"headerlink\" title=\"分离式编译\"></a>分离式编译</h3><p>C++语言支持所谓的<strong>分离式编译（separate compilation）</strong>。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。  </p>\n<h2 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h2><p>如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。<br>当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>（passed by reference）或者函数被<strong>传引用调用</strong>（called by reference）。<br>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>（passed by value）或函数被<strong>传值调用</strong>（called by value）。  </p>\n<h3 id=\"传值参数\"><a href=\"#传值参数\" class=\"headerlink\" title=\"传值参数\"></a>传值参数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。<br><strong>指针形参</strong><br>当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。<br>    熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。</p>\n<h3 id=\"传引用参数\"><a href=\"#传引用参数\" class=\"headerlink\" title=\"传引用参数\"></a>传引用参数</h3><p>对于引用的操作实际上是作用于引用所引的对象上，引用形参也是如此。通过使用引用形参，允许函数改变一个或多个实参的值。<br><strong>使用引用避免拷贝</strong><br>拷贝大的类类型对象或者容器对象比较低效。甚至有的类型根本就不支持拷贝操作。此时应该使用引用形参访问该类型的对象。<br>如果函数无须改变引用形参的值，最好将其声明为常量引用。<br><strong>使用引用形参返回额外信息</strong><br>一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。那就是通过引用形参并修改它（也就是修改了其引用的对象），从而作为结果传出。  </p>\n<h3 id=\"const形参和实参\"><a href=\"#const形参和实参\" class=\"headerlink\" title=\"const形参和实参\"></a>const形参和实参</h3><p>当形参是const时，必须注意关于顶层const的讨论（p57）。<br>当用实参初始化形参时会忽略形参的顶层const。即当形参有顶层const时，传递给它常量对象或者非常量对象都是可以的。<br>忽略形参的顶层const可能产生意想不到的结果：  </p>\n<pre><code class=\"c++\">void fcn(const int i) {}\nvoid fcn(int i) {}    // 错误：重复定义</code></pre>\n<p>在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表有明显的区别。因为顶层const被忽略了，所以在上面的代码中传入两个fcn函数的参数可以完全一样（从而编译器不知道该调用哪一个）。<br><strong>指针或引用形参与const</strong><br>我们可以使用非常量初始化一个底层const，但是反过来不行（不能用一个常量初始化一个非底层const）；同时一个普通的引用必须用同类型的对象初始化。<br><strong>尽量使用常量引用</strong><br>把函数不会改变的形参定义成（普通的）引用是一种常见错误，这么做给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型（比如无法传入一个常量对象了）。<br>比如下面这个例子将导致编译错误（p192）：</p>\n<pre><code class=\"c++\">// 不良设计，第一个形参的类型应该是const string&amp;\nstring::size_type find_char(string &amp;s, char c, string::size_type &amp;occurs);\n//...\nfind_char(&quot;Hello World&quot;, &#39;o&#39;, ctr); // 无法编译通过</code></pre>\n<h3 id=\"数组形参\"><a href=\"#数组形参\" class=\"headerlink\" title=\"数组形参\"></a>数组形参</h3><p>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。<br>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：  </p>\n<pre><code class=\"c++\">// 每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);    // 可以看出来，函数的意图是作用于一个数组\nvoid print(const int[10]);  // 这里的维度表示我们期望数组含有多少元素，实际不一定</code></pre>\n<pre><code>和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。  </code></pre><p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用技术。  </p>\n<ol>\n<li>使用标记指定数组长度，如C风格字符串。  </li>\n<li>使用标准库规范，如传递首元素和尾后元素的指针，来表示一个范围。  </li>\n<li>显示传递一个表示数组大小的形参。  </li>\n</ol>\n<p><strong>数组形参和const</strong><br>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。<br><strong>数组引用形参</strong><br>C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。  </p>\n<pre><code class=\"c++\">// 正确，形参是数组的引用，维度是类型的一部分\nvoid print(int (&amp;arr)[10])\n{\n    for (auto elem : arr)\n        cout &lt;&lt; elem &lt;&lt; endl;\n}</code></pre>\n<p>但这一用法也限制了print函数的可用性，我们只能将函数作用于大小为10的数组。<br><strong>传递多维数组</strong><br>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针，也就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：  </p>\n<pre><code class=\"c++\">// matrix指向数组的首元素，该数组的元素是由10个整数构成的数组\nvoid print(int (*matrix)[10], int rowSize) { /* ... */ }</code></pre>\n<pre><code>`*matrix`两端的括号必不可少：`int *matrix[10]//10个指针构成的数组`；`int (*matrix)[10]//指向含有10个整数的数组的指针`。</code></pre><p>也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：  </p>\n<pre><code class=\"c++\">// 等价定义\nvoid print(int matrix[][10], int rowSize) { /* ... */ }</code></pre>\n<p>matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。  </p>\n<h3 id=\"main-处理命令行选项\"><a href=\"#main-处理命令行选项\" class=\"headerlink\" title=\"main: 处理命令行选项\"></a>main: 处理命令行选项</h3><p>有时候我们需要给main函数传递实参。一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如：  </p>\n<pre><code class=\"c++\">prog -d -o ofile data0</code></pre>\n<p>这些命令行选项通过两个（可选的）形参传递给main函数。  </p>\n<pre><code class=\"c++\">int main(int argc, char *argv[]) { ... }</code></pre>\n<p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量；argc至少为1。<br>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。<br>以上面的为例，argc应该等于5，argv应该包含如下的C风格字符串：  </p>\n<pre><code class=\"c++\">argv[0] = &quot;prog&quot;;    // 或者argv[0]也可以指向一个空字符串\nargv[1] = &quot;-d&quot;;\nargv[2] = &quot;-o&quot;;\nargv[3] = &quot;ofile&quot;;\nargv[4] = &quot;data0&quot;;\nargv[5] = 0;</code></pre>\n<pre><code>当使用argv中的实参时，一定要记得可选的实参从`argv[1]`开始；`argv[0]`保存程序的名字，而非用户的输入。</code></pre><h3 id=\"含有可变形参的函数\"><a href=\"#含有可变形参的函数\" class=\"headerlink\" title=\"含有可变形参的函数\"></a>含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：</p>\n<ol>\n<li>如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；  </li>\n<li>如果实参的类型不同，我们可以编写一种可变参数模板，其细节将在16.4节介绍（p618）。<br>C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。这种功能一般只用于与C函数交互的接口程序。  </li>\n</ol>\n<p><strong>initializer_list形参</strong><br>initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。<br>与vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。<br><strong>省略符形参</strong><br>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的。<br>    省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。<br>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：  </p>\n<pre><code class=\"c++\">void foo(param_list, ...);\nvoid foo(...);</code></pre>\n<h2 id=\"返回类型和return语句\"><a href=\"#返回类型和return语句\" class=\"headerlink\" title=\"返回类型和return语句\"></a>返回类型和return语句</h2><p>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。<br>return语句有两种形式：  </p>\n<pre><code class=\"c++\">return;\nreturn expression;</code></pre>\n<h3 id=\"无返回值函数\"><a href=\"#无返回值函数\" class=\"headerlink\" title=\"无返回值函数\"></a>无返回值函数</h3><p>没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式地执行return。  </p>\n<h3 id=\"有返回值函数\"><a href=\"#有返回值函数\" class=\"headerlink\" title=\"有返回值函数\"></a>有返回值函数</h3><p>只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。<br><strong>值是如何被返回的</strong><br>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。<br>如果函数返回引用，则该引用仅是它所引对象的一个别名。<br><strong>不要返回局部对象的引用或指针</strong><br>函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。<br><strong>返回类类型的函数和调用运算符</strong><br>调用运算符的优先级和点运算符、箭头运算符相同，并且符合左结合律。</p>\n<pre><code class=\"c++\">//调用string对象的size成员，该string对象有shorterstring函数返回\nauto sz = shorterstring(s1,s2).size();</code></pre>\n<p><strong>引用返回左值</strong><br>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。  </p>\n<pre><code class=\"c++\">char &amp;get_val(string &amp;str,string::size_type ix){\n    return str[ix];\n}\nint main(){\n    string s(&quot;a value&quot;);\n    cout&lt;&lt;s&lt;&lt;endl;\n    get_val(s,0)=&#39;A&#39;;\n    cout&lt;&lt;s&lt;&lt;endl;\n    return 0;    \n}</code></pre>\n<p><strong>列表初始化返回值</strong><br>C++11新标准规定，函数可以返回花括号包围的值的列表。此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。<br><strong>主函数main的返回值</strong><br>我们允许main函数没有return语句直接结束，这样编译器将隐式地插入一条返回0的return语句，表示执行成功。<br>为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，可以用来表示成功与失败：  </p>\n<pre><code class=\"c++\">int main()\n{\n    if (some_failure)\n        return EXIT_FAILURE;\n    else\n        return EXIT_SUCCESS;\n}</code></pre>\n<p><strong>递归</strong><br>如果函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为<strong>递归函数</strong>（recursive function）。<br>在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。<br>    main函数不能调用它自己。  </p>\n<h3 id=\"返回数组指针\"><a href=\"#返回数组指针\" class=\"headerlink\" title=\"返回数组指针\"></a>返回数组指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。使用<strong>类型别名</strong>（p60）可以简化这种返回类型：  </p>\n<pre><code class=\"c++\">typedef int arrT[10];    // arrT是一个类型别名，表示含有10个整数的数组\nusing arrT = int[10];    // arrT的等价声明\narrT* func(int i);       // func返回一个指向含有10个整数的数组的指针</code></pre>\n<p><strong>声明一个返回数组指针的函数</strong><br>返回数组指针的函数形式如下：  </p>\n<pre><code class=\"c++\">Type (*function(param_list))[dimension]</code></pre>\n<p>类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（*表示返回的是一个指针。）例：  </p>\n<pre><code class=\"c++\">int (*func(int i))[10];</code></pre>\n<p>可以按照以下的顺序来逐层理解该声明的含义：  </p>\n<ul>\n<li><code>func(int i)</code>表示调用func函数时需要一个int类型的实参。  </li>\n<li><code>(*func(int i))</code>意味着我们可以对函数的调用结果执行解引用操作。  </li>\n<li><code>(*func(int i))[10]</code>表示解引用func的调用将得到一个大小是10的数组。  </li>\n<li><code>int (*func(int i))[10]</code>表示数组中的元素是int类型。  </li>\n</ul>\n<p><strong>使用尾置返回类型</strong><br>C++新标准提供了另一种简化上述func声明的方法，就是使用<strong>尾置返回类型（trailing return type）</strong>。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。<br>尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<code>auto</code>：  </p>\n<pre><code class=\"c++\">// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组\nauto func(int i) -&gt; int(*)[10];</code></pre>\n<p><strong>使用decltype</strong><br>如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型（即获得一个数组类型）。例：  </p>\n<pre><code class=\"c++\">int odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *arrPtr(int i)\n{\n    return (i % 2) ? &amp;odd : &amp;even;\n}</code></pre>\n<pre><code> decltype并不负责把数组类型转换成对应的指针，所以decltype的结果只是一个数组，要想表示arrptr返回指针还必须在函数声明时加一个`*`的符号。</code></pre><h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载（overload）函数</strong>。比如：  </p>\n<pre><code class=\"c++\">void print(const char *cp);\nvoid print(const int *beg, const int *end);\nvoid print(const int ia[], size_t size);</code></pre>\n<p>这些函数接受的形参类型不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。<br>函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。<br>main函数不能重载。<br>不允许两个函数除了返回类型以外其他所有的要素都相同。比如：  </p>\n<pre><code class=\"c++\">Record lookup(const Account&amp;);\nbool lookup(const Account&amp;);    // 错误，与上一个函数相比只有返回类型不同</code></pre>\n<pre><code> my note: 返回类型不同的函数，也可以是重载的。只要函数名相同而形参有明显的不同。  </code></pre><p><strong>重载和const形参</strong><br>顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：  </p>\n<pre><code class=\"c++\">Record lookup(Phone);\nRecord lookup(const Phone);    // 重复声明</code></pre>\n<p>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：  </p>\n<pre><code class=\"c++\">Record lookup(Account&amp;);       // 此函数作用于Account的引用\nRecord lookup(const Account&amp;); // 新函数，作用于常量引用</code></pre>\n<p>这种情况下，当我们传递一个非常量对象时，编译器会优先选用非常量版本的函数（尽管传给常量版本的也可以）。<br><strong>const_cast和重载</strong><br>const_cast在重载函数的情境中最有用。比如这两个重载函数：  </p>\n<pre><code class=\"c++\">// 比较两个string对象的长度，返回较短的那个引用\nconst string &amp;shorterString(const string &amp;s1, const string &amp;s2)\n{\n    return s1.size() &lt;= s2.size() ? s1 : s2; \n}\n\n// 重载\nstring &amp;shorterString(string &amp;s1, string &amp;s2)\n{\n    auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1), const_cast&lt;const string&amp;&gt;(s2));\n    return const_cast&lt;string&amp;&gt;(r);\n}</code></pre>\n<p>下面重载的版本中，首先将它的实参强制转换成了对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在一个非常量实参上。因此，可以再将其转换回普通的const&amp;，这显然是安全的。<br>    传入非常量的实参将调用非常量的版本。<br><strong>调用重载的函数</strong><br>定义了一组重载函数后，我们需要以合理的实参调用它们。<strong>函数匹配（function matching）</strong>是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来。编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。<br>当调用重载函数时有三种可能的结果：  </p>\n<ul>\n<li>编译器找到一个与实参<strong>最佳匹配（best match）</strong>的函数，并生成调用该函数的代码。</li>\n<li>找不到任何一个函数与调用的实参匹配，此时编译器发出<strong>无匹配（no match）</strong>的错误信息。</li>\n<li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用（ambiguous call）</strong>。<h3 id=\"重载与作用域\"><a href=\"#重载与作用域\" class=\"headerlink\" title=\"重载与作用域\"></a>重载与作用域</h3>一般来说，将函数声明置于局部作用域内不是一个明智的选择。<br>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。对于函数而言也是如此。如果在内层作用域声明了一个函数，那么外层的同名的函数都将变得不可见，因此无法找到外层的重载版本。  <h2 id=\"特殊用途语言特性\"><a href=\"#特殊用途语言特性\" class=\"headerlink\" title=\"特殊用途语言特性\"></a>特殊用途语言特性</h2><h3 id=\"默认实参\"><a href=\"#默认实参\" class=\"headerlink\" title=\"默认实参\"></a>默认实参</h3>这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的<strong>默认实参</strong>（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。如：  <pre><code class=\"c++\">typedef string::size_type sz;\nstring screen(sz ht = 24, sz wid = 80, char backrnd = &#39; &#39;);</code></pre>\n一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。  </li>\n</ul>\n<p><strong>使用默认实参调用函数</strong><br>如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。如：  </p>\n<pre><code class=\"c++\">string window;\nwindow = screen();    // 等价于screen(24, 80, &#39; &#39;);\nwindow = stcreen(66); // 等价于screen(66, 80, &#39; &#39;);</code></pre>\n<p>函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。<br>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。<br><strong>默认实参初始值</strong><br>局部变量不可以作为默认实参。另外只要表达式的类型可以转换成形参类型，该表达式就可以作为默认实参。<br>如：</p>\n<pre><code class=\"c++\">int g_a = 0;\nvoid f(int a = g_a);</code></pre>\n<h3 id=\"内联函数和constexpr函数\"><a href=\"#内联函数和constexpr函数\" class=\"headerlink\" title=\"内联函数和constexpr函数\"></a>内联函数和constexpr函数</h3><p>调用普通函数比直接写其语句要慢，这是因为调用函数包含一些额外的工作。<br><strong>内联函数可以避免函数调用的开销</strong><br>将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。<br>内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。<br>内联机制用于优化规模小，流程直接，频繁调用的函数。<br><strong>constexpr函数</strong><br>是指能用于<strong>常量表达式</strong>的函数。<br>函数的返回类型及所有形参都得是字面值类型，且函数体内必须有且只有一条return语句。如：  </p>\n<pre><code class=\"c++\">constexpr int new_sz() { return 8; }\nconstexpr int foo = new_sz();</code></pre>\n<p>constexpr函数被隐式地指定为内联函数。<br><strong>把内联函数和constexpr函数放在头文件内</strong><br>这是因为内联函数和constexpr函数可以多次定义，且必须完全一致。所以把它们都定义在头文件内。  </p>\n<h3 id=\"调试帮助\"><a href=\"#调试帮助\" class=\"headerlink\" title=\"调试帮助\"></a>调试帮助</h3><p>程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。<br><strong>assert预处理宏</strong><br>assert是一种<strong>预处理宏（preprocessor macro）</strong>。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：  </p>\n<pre><code class=\"c++\">assert(expr);</code></pre>\n<p>首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。<br>assert宏定义在cassert头文件中。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无需提供using声明。<br>assert宏常用于检查“不能发生”的条件。<br><strong>NDEBUG预处理变量</strong><br>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。<br>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。或者使用编译器提供的命令行选项定义预处理变量：  </p>\n<pre><code class=\"c++\">$ CC -D NDEBUG main.c</code></pre>\n<p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。<br>我们可以把assert当成调试程序的一种辅助手段，但是不能用它代替真正的运行时逻辑检查，也不能代替程序本身应该包含的错误检查。<br>除了用于assert，也可以使用NDEBUG编写自己的调试代码。<br>比如：  </p>\n<pre><code class=\"c++\">void print(const int ia[], size_t size)\n{\n#ifndef NDEBUG\n    // __func__是编译器定义的一个局部静态变量，用于存放函数的名字\n    cerr &lt;&lt; __func__ &lt;&lt; &quot;&quot;: array size is: &quot; &lt;&lt; size &lt;&lt; endl;\n#endif\n\n// ...\n}</code></pre>\n<p>编译器为每个函数都定义了<code>__func__</code>，除此之外，预处理器还定义了4个对于调试程序很有用的名字：  </p>\n<ul>\n<li><code>__FILE__</code>, 存放文件名的字符串字面值。  </li>\n<li><code>__LINE__</code>, 存放当前行号的整型字面值。  </li>\n<li><code>__TIME__</code>, 存放文件编译时间的字符串字面值。  </li>\n<li><code>__DATA__</code>, 存放文件编译日期的字符串字面值。  <h2 id=\"函数匹配\"><a href=\"#函数匹配\" class=\"headerlink\" title=\"函数匹配\"></a>函数匹配</h2>以下述这组函数及其调用为例,讲述编译器如何确定调用哪个重载函数:  <pre><code class=\"c++\">void f();\nvoid f(int);\nvoid f(int, int);\nvoid f(double, double = 3.14);\nf(5.6);    // 调用void f(double, double);</code></pre>\n</li>\n</ul>\n<p><strong>确定候选函数和可行函数</strong><br>函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数成为<strong>候选函数（candidate function）</strong>。候选函数具备两个特征：  </p>\n<ol>\n<li>与被调用函数同名。  </li>\n<li>其声明在调用点可见。<br>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为<strong>可行函数（viable function）</strong>。可行函数也有两个特征：  </li>\n<li>其形参数量与本次调用提供的实参数量相等。  </li>\n<li>每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。<br> 如果没有找到可行函数，编译器将报告无匹配函数的错误。</li>\n</ol>\n<p><strong>寻找最佳匹配（如果有的话）</strong><br>第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。<br>如果有且只有一个函数满足下列条件，则匹配成功：  </p>\n<ul>\n<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配。  </li>\n<li>至少有一个实参的匹配优于其他可行函数提供的匹配。<br>  如果编译器检查了每一个可行函数，没有一个能脱颖而出，则会报告二义性调用错误。  <h3 id=\"实参类型转换\"><a href=\"#实参类型转换\" class=\"headerlink\" title=\"实参类型转换\"></a>实参类型转换</h3>为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：  </li>\n</ul>\n<ol>\n<li>精确匹配，包括以下情况：  </li>\n</ol>\n<ul>\n<li>实参类型和形参类型相同。  </li>\n<li>实参从数组类型或函数类型转换成对应的指针类型。  </li>\n<li>向实参添加顶层const或者从实参中删除顶层const。  </li>\n</ul>\n<ol start=\"2\">\n<li>通过const转换实现的匹配（p143）。  </li>\n<li>通过类型提升实现的匹配（p142）。  </li>\n<li>通过算数类型转换或指针转换实现的匹配（p142）。  </li>\n<li>通过类类型转换实现的匹配（参见14.9节，p514）。</li>\n</ol>\n<p><strong>需要类型提升和算术类型转换的匹配</strong><br><strong>函数匹配和const实参</strong>  </p>\n<pre><code class=\"c++\">int calc(char*,char*)\nint calc(const char*,const char*)\n//区别是他们的指针类型的形参是否指向了常量，属于底层const，合法定义</code></pre>\n<pre><code class=\"c++\">int calc(char*,char*)\nint calc(char* const,char* const)\n//区别是他们的指针类型的形参是否是常量，属于顶层const,非法定义</code></pre>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：   </p>\n<pre><code class=\"c++\">bool lengthCompare(const string&amp;, const string&amp;);</code></pre>\n<p>该函数的类型是：<code>bool (const string&amp;, const string&amp;);</code><br>要想声明一个指向该函数的指针，只需要将函数名替换成指针即可：  </p>\n<pre><code class=\"c++\">bool (*pf)(const string&amp;, const string&amp;);</code></pre>\n<p><strong>使用函数指针</strong><br>当我们把函数名作为一个值使用的时候，该函数名自动转换成指针（指向该函数的）。<br>例如，可以这样给把函数地址赋值给指针：  </p>\n<pre><code class=\"c++\">pf = lengthCompare; // pf指向名为lengthCompare的函数\npf = &amp;lengthCompare; // 等价的赋值语句，取地址符是可选的</code></pre>\n<p>可以直接对指向函数的指针调用该函数，无须解引用指针：  </p>\n<pre><code>bool b1 = pf(&quot;Hello&quot;, &quot;Hi&quot;);\nbool b2 = (*pf)(&quot;Hello&quot;, &quot;Hi&quot;); // 等价调用\nbool b3 = lengthCompare(&quot;Hello&quot;, &quot;Hi&quot;); // 等价调用</code></pre><p>可以给函数指针赋一个nullptr或0，表示没有指向任何函数。<br><strong>重载函数的指针</strong><br>当使用了重载函数时，编译器必须确定一个能和指针类型精确匹配的函数，即返回类型和形参列表都要一样。<br><strong>函数指针形参</strong><br>不能定义函数类型的形参，但是形参可以是指向函数的指针。<br>当把函数名作为实参使用，它会自动转换成指针。<br>定义一个函数（以及指针）类型的方法有：  </p>\n<ul>\n<li>typedef  <pre><code class=\"c++\">typedef bool Func(int); // Func是函数类型\ntypedef bool (*FuncP)(int); // FuncP是函数指针类型</code></pre>\n</li>\n<li>decltype<br>假如已经有了一个函数：<code>bool Foo(int);</code>  <pre><code class=\"c++\">decltype(Foo) Func;\ndecltype(Foo) *FuncP;</code></pre>\n</li>\n<li>using  <pre><code class=\"c++\">using Func = bool(int);\nusing FuncP = bool(*)(int);</code></pre>\n</li>\n</ul>\n<p><strong>返回指针函数的指针</strong><br>和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名：  </p>\n<pre><code class=\"c++\">using F=int(int*，int)；//F是函数类型，不是指针\nusing PF=int(*)(int*，int)；//PF是指针类型</code></pre>\n<p>其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针：  </p>\n<pre><code>PF f1(int);//正确：PF是指向函数的指针，f1返回指向函数的指针\nF f1(int);//错误：F是函数类型，f1不能返回一个函数\nF *f1(int);//正确：显式地指定返回类型是指向函数的指针</code></pre><pre><code>出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式(参见6.3.3节，第206页)声明一个返回函数指针的函数：</code></pre><pre><code class=\"c++\">auto fl(int)-&gt;int(*)(int*，int);</code></pre>\n<p><strong>将auto和decltype用于函数指针类型</strong>  </p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>类的基本思想是<strong>数据抽象</strong>(data abstraction)和<strong>封装</strong>(encapsulation)。</p>\n<p>数据抽象就是<strong>接口(interface)与实现(implementation)分离</strong>的技术。</p>\n<p>接口就是暴露给用户的操作，比如公有的成员函数。</p>\n<p>实现就是数据成员、接口的实现、私有的成员函数。</p>\n<p>通过<strong>抽象数据类型(abstract data type)</strong>，来实现数据抽象和封装。</p>\n<h2 id=\"定义抽象数据类型\"><a href=\"#定义抽象数据类型\" class=\"headerlink\" title=\"定义抽象数据类型\"></a>定义抽象数据类型</h2><p>封装就是隐藏，抽象数据类型隐藏了自己的成员变量，外部只能使用其接口来间接访问其成员。</p>\n<p><strong>定义成员函数</strong></p>\n<p>类内的所有成员必须声明在类的内部。</p>\n<p>类的成员函数可以定义在类的内部，也可以定义在类的外部。</p>\n<pre><code>定义在类内部的函数是隐式的inline函数。</code></pre><p><strong>引入this</strong></p>\n<p>当调用一个成员函数时，实际上是替某个对象调用它。</p>\n<p>成员函数通过名为<strong>this</strong>的隐式参数来访问此对象。this指向了此对象的地址。</p>\n<p>在成员函数内部，可以省略this来访问成员。</p>\n<p>this是一个常量指针，不能够修改其值。</p>\n<p>当成员函数中调用另一个成员函数时，将隐式传递this指针。</p>\n<pre><code>std::string isbn() const {return this-&gt;bookNo;}</code></pre><p><strong>引入const成员函数</strong></p>\n<p>参数列表之后，添加const关键字，表明传入的this指针是一个指向常量对象的指针。故此成员函数内，不能修改成员变量的内容。</p>\n<p>const对象只能调用const版本的成员函数（因此如果函数不修改成员变量，那么为了提高灵活性，应该把函数声明成const版本的）。</p>\n<p>C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。</p>\n<pre><code>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</code></pre><p><strong>类作用域和成员函数</strong></p>\n<p>类本身就是一个作用域。</p>\n<p>成员函数的定义必须包含其所属的类名（使用作用域运算符）。</p>\n<p>如果成员函数声明为const版本的，其定义时，也要在参数列表后加const。</p>\n<p>成员函数体可以随意使用类中的成员，无须在意成员出现的顺序，这是因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。</p>\n<p><strong>定义一个返回this对象的函数</strong></p>\n<p>可以使用如下语句返回this对象：</p>\n<pre><code class=\"c++\">return *this;</code></pre>\n<p>返回类型使用引用类型，表明返回的就是this所指的对象。</p>\n<p>一般来说，当我们定义的函数类似于某个内置运算符时，应该令函数的行为尽量模仿这个运算符。比如说内置的赋值运算符把它的左侧运算对象当成左值返回，这种情况下，函数就可以返回this对象的引用。</p>\n<h3 id=\"定义类相关的非成员函数\"><a href=\"#定义类相关的非成员函数\" class=\"headerlink\" title=\"定义类相关的非成员函数\"></a>定义类相关的非成员函数</h3><p>有些函数也提供了操作类对象的方法，但他们不属于类的成员函数。</p>\n<p>可以把这些函数放到类的头文件中声明。这些函数也可以看成是类的接口。</p>\n<p>有可能会把这些函数声明称友元，从而方便它们直接操作成员变量。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>类通过一个或几个特殊的成员函数初始化其成员变量，这些函数叫<strong>构造函数（constructor）</strong>。</p>\n<p>每当类对象被创建，构造函数就会被执行。</p>\n<p>构造函数名和类名一致，无返回类型，可能有多个（参数个数差异），不能是const的。</p>\n<p>对于const对象，构造函数执行完毕后，它才获得const属性。</p>\n<p><strong>合成的默认构造函数</strong></p>\n<p>如果对象没有初始值，它将执行默认初始化。</p>\n<p>类通过<strong>默认构造函数(default constructor)</strong>来执行默认初始化。如果没有显示定义过构造函数，编译器就会自动生成一个，叫做合成的默认构造函数。</p>\n<p>合成的默认构造函数根据如下规则初始化类成员：</p>\n<ul>\n<li><p>如果存在类内初始值，使用它来初始化成员</p>\n</li>\n<li><p>否则，对成员执行默认初始化</p>\n</li>\n</ul>\n<p><strong>某些类不能依赖合成的默认构造函数</strong></p>\n<p>所谓不能依赖，就是不可以让编译器生成默认构造函数，要自己定义一个。其原因可能是：</p>\n<ul>\n<li><p>如果定义了自己的构造函数，那么编译器就不会生成默认的构造函数，此类就没有了默认构造函数。</p>\n</li>\n<li><p>默认构造函数可能执行的是错误的操作，比如内置类型若没有类内初始值，则进行默认初始化，其值未定义。</p>\n</li>\n<li><p>有时候，编译器无法生成默认构造函数，比如类成员中有类，而此类有可能没有默认构造函数。</p>\n</li>\n</ul>\n<p><strong>=default的含义</strong></p>\n<p>C++11中，使用这种语句来让编译器生成一个默认构造函数：</p>\n<pre><code class=\"c++\">SalesData() = default;</code></pre>\n<pre><code>这种情况下，应当对内置类型的数据成员提供类内初始值，否则应当使用构造函数初始值列表形式的默认构造函数。</code></pre><p><strong>构造函数初始值列表</strong></p>\n<pre><code class=\"c++\">Sales_data(const std::string &amp;s):\n                        bookNo(s){}\nSales_data(const std::string &amp;s,unsigned n,double p):\n                        bookNo(s),units_sold(n),revenue(p*n){}</code></pre>\n<p>参数列表后，函数体前的一部分内容叫构造函数初始值列表（constructor initialize list）。</p>\n<p>它负责为对象的成员变量赋初值。</p>\n<p>如果成员不在初始化列表中，它用类内初始值初始化（如果存在），否则执行默认初始化。</p>\n<pre><code>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</code></pre><p><strong>在类的外部定义构造函数</strong></p>\n<pre><code class=\"c++\">Sales data:：Sales data（std:：istream&amp;is）\n{\nread（is，*this）；//read函数的作用是从is中读取一条交易信息然后\n        //存入this对象中\n}</code></pre>\n<p>为了更好地理解调用函数 read的意义，要特别注意read的第二个参数是一个Sales data对象的引用。在7.1.2节（第232页）中曾经提到过，使用this来把对象当成一个整体访问，而非直接访问对象的某个成员。因此在此例中，我们使用*this将<br>“this”对象作为实参传递给read函数。</p>\n<h3 id=\"拷贝、赋值和析构\"><a href=\"#拷贝、赋值和析构\" class=\"headerlink\" title=\"拷贝、赋值和析构\"></a>拷贝、赋值和析构</h3><p>拷贝构造函数，当初始化变量时以值传递或函数返回一个对象时，会发生拷贝。</p>\n<p>赋值运算，当使用了赋值运算符时，会发生对象的赋值操作。</p>\n<p>析构函数，当一个变量不在存在时，会执行析构。</p>\n<p>这些操作如果不显示定义，编译器就会合成一个，合成的拷贝赋值版本只是做了浅拷贝操作。</p>\n<p><strong>某些类不能依赖合成的版本</strong></p>\n<p>如果类中有成员绑定了外部的对象（比如动态内存），那么就不可依赖合成的版本。</p>\n<p>可使用容器管理必要的存储空间，当发生拷贝等操作时，容器也会执行正确的拷贝。</p>\n<h2 id=\"访问控制与封装\"><a href=\"#访问控制与封装\" class=\"headerlink\" title=\"访问控制与封装\"></a>访问控制与封装</h2><p>使用<strong>访问说明符（access specifiers）</strong>加强类的封装性。</p>\n<ul>\n<li><p>public说明符之后的成员对外可见，外部可访问，public成员定义类的接口。</p>\n</li>\n<li><p>private说明符之后的成员对内可见，外部无法访问，即隐藏了实现细节。</p>\n</li>\n</ul>\n<p><strong>class和struct</strong></p>\n<p>其区别仅仅在于默认的访问权限。class默认为private，struct默认是public。</p>\n<pre><code>作为接口，应当是public的，而实现细节（数据成员或相关函数）应当为private的。</code></pre><h3 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。即在函数或类前面加friend关键字。</p>\n<p>友元声明只能出现在类的内部。它并非函数声明，函数声明还要在别的地方声明。</p>\n<p>一般来说，最好在类定义的开始或结束前的位置集中声明友元。</p>\n<p>“封装的益处”<br>    封装有两个重要的优点：</p>\n<pre><code>- 确保用户代码不会无意间破坏封装对象的状态。\n\n- 被封装的类的具体实现可以随时改变，而无须调整用户级别的代码。</code></pre><h2 id=\"类的其它特性\"><a href=\"#类的其它特性\" class=\"headerlink\" title=\"类的其它特性\"></a>类的其它特性</h2><h3 id=\"类成员再探\"><a href=\"#类成员再探\" class=\"headerlink\" title=\"类成员再探\"></a>类成员再探</h3><p><strong>定义一个类型成员</strong></p>\n<p>可以在类的内部定义一个类型（使用typedef或using），这个类型也有访问限制。</p>\n<p>通常放在类的开头位置。</p>\n<p><strong>令成员作为内联函数</strong></p>\n<p>规模较小的成员函数适合声明成内联函数（定义时在前面加inline即可）。</p>\n<p>如果定义在类内的函数，默认就是inline的。</p>\n<p>inline成员函数通常定义到类的头文件中，即声明和定义在同一个文件中。</p>\n<p><strong>重载成员函数</strong></p>\n<p>和普通函数的重载规则一样。只要参数的数量or类型有区别，就可以重载。</p>\n<p>如果是const版本的成员函数（传入const this），那么也可以重载。因为本质上，其隐式参数this的类型改变了。</p>\n<p><strong>类数据成员的初始值</strong></p>\n<p>可以给类数据成员一个类内初始值。使用等号或者花括号。</p>\n<h3 id=\"返回-this的成员函数\"><a href=\"#返回-this的成员函数\" class=\"headerlink\" title=\"返回*this的成员函数\"></a>返回*this的成员函数</h3><p>返回引用的函数是左值的，意味着这些函数（返回*this）返回的是对象本身而非对象的副本。</p>\n<pre><code>一个const成员函数如果以引用的形式返回\\*this，那么它的返回类型将是常量引用。</code></pre><p>但是如此一来（const成员函数返回const引用），就无法继续让返回的对象调用非常量版本的成员函数。一个解决的办法就是<strong>重载一个非常量版本的接口</strong>，定义一个私有的常量版本的函数，负责具体工作，而非常量版本的接口负责调用它，并返回非常量引用。</p>\n<p>建议：对于公共代码使用私有功能函数。</p>\n<h3 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a>类类型</h3><p>每个类是一个唯一的类型，即使其内容完全一样。</p>\n<p><strong>类的声明</strong></p>\n<p>可以暂时声明类而不定义它，这叫前置声明（forward declaration）。</p>\n<p>这种类型，在没有定义前是一个不完全类型（incomplete type）。这种类型只能在有限的情况下使用：</p>\n<ul>\n<li><p>定义指向这种类型的指针or引用</p>\n</li>\n<li><p>声明以不完全类型为参数or返回值的函数</p>\n</li>\n</ul>\n<p>要创建一个类的对象，则必须已经定义好了这个类，这是因为编译器需要知道类的存储空间大小。</p>\n<p>只有被定义，才能访问其成员。</p>\n<p>声明一个前置类型的方法：</p>\n<pre><code class=\"c++\">class A;\nstruct B;\nnamespace game\n{\n    class C;    // 前置声明一个在命名空间中的类\n}</code></pre>\n<h3 id=\"友元再探\"><a href=\"#友元再探\" class=\"headerlink\" title=\"友元再探\"></a>友元再探</h3><p>类可以把普通函数定义成友元，也可以把类，类的成员函数定义成友元。</p>\n<p>友元类有权访问本类的非公有成员。</p>\n<h2 id=\"类的作用域\"><a href=\"#类的作用域\" class=\"headerlink\" title=\"类的作用域\"></a>类的作用域</h2><p>一个类就是一个作用域。</p>\n<p>类的作用域之外，普通的成员只能通过对象、引用or指针访问。对于类型成员的访问，需要使用域运算符<code>::</code>来访问。</p>\n<h3 id=\"名字查找与类的作用域\"><a href=\"#名字查找与类的作用域\" class=\"headerlink\" title=\"名字查找与类的作用域\"></a>名字查找与类的作用域</h3><p>编译器处理完类的全部声明后，才会处理成员函数的定义。因此成员函数体中可以使用类中定义的任何位置的名字。</p>\n<p><strong>成员函数中的名字查找</strong></p>\n<p>按如下方式解析：</p>\n<ul>\n<li><p>在块内查找声明</p>\n</li>\n<li><p>在类内查找，所有成员都可以被考虑</p>\n</li>\n<li><p>在类的外围作用域中查找</p>\n</li>\n</ul>\n<h2 id=\"构造函数再探\"><a href=\"#构造函数再探\" class=\"headerlink\" title=\"构造函数再探\"></a>构造函数再探</h2><h3 id=\"构造函数初始值列表\"><a href=\"#构造函数初始值列表\" class=\"headerlink\" title=\"构造函数初始值列表\"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显示初始化成员，那么该成员将执行默认初始化。</p>\n<pre><code>如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。</code></pre><pre><code class=\"c++\">class ConstRef{\npublic:\n    ConstRef(int ii);\nprivate:\n    int i;\n    const int ci;\n    int &amp;i;\n};\nConstRef::ConstRef(int ii){\n    i = ii;// 正确\n    ci = ii; //错误，不能给const赋值\n    ri = i; //错误：ri未被初始化\n}\n//正确形式\nConstRef::ConstRef(int ii)::i(ii),ci(ii),ri(i){}</code></pre>\n<p><strong>成员初始化的顺序</strong></p>\n<p>成员的初始化顺序和它们在类内的定义顺序一致。</p>\n<p>而非其在初始值列表中的顺序，初始值列表只是做了初始化的工作。所以要让初始值列表中的成员顺序与定义顺序一致。</p>\n<pre><code>最好使构造函数初始值的顺序与成员声明的顺序一致，尽量避免用某些成员初始化其他成员。</code></pre><p><strong>有默认实参的构造函数</strong></p>\n<p>如果构造函数的所有实参都有默认实参，那么它实际上也同时定义了默认构造函数。</p>\n<h3 id=\"委托构造函数\"><a href=\"#委托构造函数\" class=\"headerlink\" title=\"委托构造函数\"></a>委托构造函数</h3><p>C++11可以定义委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数。</p>\n<p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。</p>\n<pre><code> 即先执行受委托的构造函数内容，再执行自己的。</code></pre><h3 id=\"默认构造函数的作用\"><a href=\"#默认构造函数的作用\" class=\"headerlink\" title=\"默认构造函数的作用\"></a>默认构造函数的作用</h3><p>当对象被默认初始化或值初始化时，自动执行默认构造函数。</p>\n<p>默认构造函数在以下情况发生：</p>\n<ul>\n<li><p>不使用初始值定义一个非静态变量或者数组时</p>\n</li>\n<li><p>当类含有类类型的成员且使用合成的默认构造函数时</p>\n</li>\n<li><p>当类类型的成员没有在构造函数初始值列表中显式初始化时</p>\n</li>\n</ul>\n<p>值初始化在以下情况下发生：</p>\n<ul>\n<li><p>数组初始化时，若提供的初始值少于数组大小时</p>\n</li>\n<li><p>不使用初始值定义一个局部静态变量时</p>\n</li>\n<li><p>书写形如T()的表达式显式请求值初始化时</p>\n</li>\n</ul>\n<h3 id=\"隐式的类类型转换\"><a href=\"#隐式的类类型转换\" class=\"headerlink\" title=\"隐式的类类型转换\"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了<strong>转换构造函数（converting constructor）</strong>。</p>\n<p>即定义了一个隐式转换机制。如string的接受一个const char*版本的构造函数。</p>\n<p>使用explicit阻止这种隐式转换机制，explicit只能放到类内声明构造函数里。</p>\n<p><strong>只允许一步类类型转换</strong></p>\n<h3 id=\"聚合类\"><a href=\"#聚合类\" class=\"headerlink\" title=\"聚合类\"></a>聚合类</h3><p>聚合类（aggregate class）使得用户可以直接访问其成员。当类满足如下条件时，是聚合的：</p>\n<ul>\n<li><p>所有成员都是public的</p>\n</li>\n<li><p>没有定义任何构造函数</p>\n</li>\n<li><p>没有类内初始值</p>\n</li>\n<li><p>没有基类，没有virtual函数</p>\n</li>\n</ul>\n<p>可以使用花括号括起来的成员初始值列表来初始化聚合类对象。</p>\n<h3 id=\"字面值常量类（-Literal-Classes）\"><a href=\"#字面值常量类（-Literal-Classes）\" class=\"headerlink\" title=\"字面值常量类（ Literal Classes）\"></a>字面值常量类（ Literal Classes）</h3><p>类也可以是字面值类型。</p>\n<p>这样的类可以含有constexpr函数成员，且符合constexpr函数的所有要求，且是隐式const的。</p>\n<p>数据成员都是字面值类型的聚合类是字面值常量类。</p>\n<p>如果不是聚合类，满足如下条件也是一个字面值常量类：</p>\n<ul>\n<li><p>数据成员都是字面值类型</p>\n</li>\n<li><p>至少含有一个constexpr构造函数</p>\n</li>\n<li><p>如果数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；类类型成员必须使用自己的constexpr构造函数</p>\n</li>\n<li><p>类必须使用析构函数的默认定义</p>\n</li>\n</ul>\n<p><strong>声明静态成员</strong></p>\n<p>在声明前加static关键字。</p>\n<p>静态成员可以是public或private。数据成员可以是常量，引用，指针，类类型等。</p>\n<p>对象不包含与静态数据成员有关的数据。</p>\n<p>静态函数不包含this指针。</p>\n<p><strong>使用类的静态成员</strong></p>\n<p>使用作用域运算符访问静态成员。</p>\n<p>类的对象、引用或指针可以访问静态成员。</p>\n<p>类的成员函数可以直接访问静态成员。</p>\n<p><strong>定义静态成员</strong></p>\n<p>static只能出现在类的内部，不能出现在外部。</p>\n<p>静态数据成员不属于类的对象，不是有构造函数初始化的。静态数据成员定义在函数体之外，一旦定义，就一直存在于程序的整个生命周期中。</p>\n<pre><code class=\"c++\">double T::a = 1; // 定义并初始化一个静态成员</code></pre>\n<p><strong>静态成员的类内初始化</strong></p>\n<p>通常，不应该在类内初始化静态数据成员。</p>\n<p>不过，可以为静态成员提供const整数类型的类内初始值，且要求静态成员必须是字面值常量类型。</p>\n<h1 id=\"IO库\"><a href=\"#IO库\" class=\"headerlink\" title=\"IO库\"></a>IO库</h1><h2 id=\"IO类\"><a href=\"#IO类\" class=\"headerlink\" title=\"IO类\"></a>IO类</h2><p>为了支持不同种类的IO处理操作，标准库定义了这几种类型：</p>\n<ul>\n<li><p>iostream 定义了用于读写流的基本类型</p>\n</li>\n<li><p>fstream 定义了读写命名文件的类型</p>\n</li>\n<li><p>sstream 定义了读写内存string对象的类型</p>\n</li>\n</ul>\n<p>它们分别定义在同名的头文件中。</p>\n<p><strong>IO类型间的关系</strong></p>\n<p>类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。</p>\n<h3 id=\"IO对象无拷贝或赋值\"><a href=\"#IO对象无拷贝或赋值\" class=\"headerlink\" title=\"IO对象无拷贝或赋值\"></a>IO对象无拷贝或赋值</h3><p>由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。</p>\n<p>读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>\n<h3 id=\"条件状态\"><a href=\"#条件状态\" class=\"headerlink\" title=\"条件状态\"></a>条件状态</h3><p>IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。<br>一个IO错误的例子：</p>\n<pre><code class=\"c++\">int ival;\ncin &gt;&gt; ival;</code></pre>\n<p>如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。</p>\n<p>如果输入一个文件结束符标识，cin也会进入错误状态。</p>\n<p>一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：</p>\n<pre><code class=\"c++\">while (cin &gt;&gt; word)\n    // ok</code></pre>\n<h3 id=\"管理输出缓冲\"><a href=\"#管理输出缓冲\" class=\"headerlink\" title=\"管理输出缓冲\"></a>管理输出缓冲</h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：</p>\n<pre><code class=\"c++\">os &lt;&lt; &quot;please enter a value: &quot;;</code></pre>\n<p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。</p>\n<p>导致缓冲区刷新的原因有：</p>\n<ul>\n<li><p>程序正常结束</p>\n</li>\n<li><p>缓冲区满时</p>\n</li>\n<li><p>使用操纵符，如endl，来显式刷新缓冲区</p>\n</li>\n<li><p>读cin或写cerr，都会导致cout的缓冲区被刷新</p>\n</li>\n</ul>\n<p><strong>刷新输出缓冲区</strong></p>\n<p>IO库还提供了两个操纵符用于刷新缓冲区：</p>\n<ul>\n<li><p>flush 刷新缓冲区，但不输出任何额外字符</p>\n</li>\n<li><p>ends 向缓冲区插入一个空字符，然后刷新缓冲区</p>\n</li>\n</ul>\n<p><strong>unitbuf操纵符</strong></p>\n<p>如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。</p>\n<pre><code class=\"c++\">cout &lt;&lt; unitbuf;    // 所有输出操作后都会立即刷新缓冲区\ncout &lt;&lt; nounitbuf;  // 回到正常的缓冲方式</code></pre>\n<pre><code>如果程序崩溃，输出缓冲区不会刷新</code></pre><h2 id=\"文件输入输出\"><a href=\"#文件输入输出\" class=\"headerlink\" title=\"文件输入输出\"></a>文件输入输出</h2><p>除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。</p>\n<h3 id=\"使用文件流对象\"><a href=\"#使用文件流对象\" class=\"headerlink\" title=\"使用文件流对象\"></a>使用文件流对象</h3><p>当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。</p>\n<p>每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。</p>\n<p>创建文件流对象时，如果提供了一个文件名，则open会被自动调用：</p>\n<pre><code class=\"c++\">ifstream in(file);    // 构造一个ifstream并打开给定的文件\nofstream out;         // 输出文件流未关联到任何文件</code></pre>\n<pre><code>当一个fstream对象被销毁时，close会自动被调用。</code></pre><h3 id=\"文件模式\"><a href=\"#文件模式\" class=\"headerlink\" title=\"文件模式\"></a>文件模式</h3><p>每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。</p>\n<p>每个文件流类型都定义了一个默认的文件模式，当未指定文件模式时，就使用此默认模式。</p>\n<ul>\n<li><p>与ifstream关联的文件默认以in模式打开；</p>\n</li>\n<li><p>与ofstream关联的文件默认以out模式打开；</p>\n</li>\n<li><p>与fstream关联的文件默认以in和out模式打开。</p>\n</li>\n</ul>\n<p><strong>以out模式打开文件会丢失已有数据</strong></p>\n<p>默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。</p>\n<p>阻止丢弃的方法是同时指定app模式：</p>\n<pre><code class=\"c++\">ofstream out(&quot;file1&quot;);    // 文件被截断\nofstream app(&quot;file2&quot;, ofstream::app);    // 保留文件内容，写操作在文件末尾进行</code></pre>\n<h2 id=\"string流\"><a href=\"#string流\" class=\"headerlink\" title=\"string流\"></a>string流</h2><p>sstream头文件定义了三个类型来支持内存IO：</p>\n<ul>\n<li><p>istringstream从string读取数据。</p>\n</li>\n<li><p>ostringstream向string写入数据。</p>\n</li>\n<li><p>stringstream既可以从string读数据，也可以向string写数据。</p>\n</li>\n</ul>\n<p>sstream增加了一些成员来管理与流相关联的string。见p287。</p>\n<h3 id=\"使用istringstream\"><a href=\"#使用istringstream\" class=\"headerlink\" title=\"使用istringstream\"></a>使用istringstream</h3><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。</p>\n<h3 id=\"使用ostringstream\"><a href=\"#使用ostringstream\" class=\"headerlink\" title=\"使用ostringstream\"></a>使用ostringstream</h3><p>当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。</p>\n<h1 id=\"顺序容器\"><a href=\"#顺序容器\" class=\"headerlink\" title=\"顺序容器\"></a>顺序容器</h1><h2 id=\"顺序容器概述\"><a href=\"#顺序容器概述\" class=\"headerlink\" title=\"顺序容器概述\"></a>顺序容器概述</h2><p>所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>\n<p>-. 向容器添加或从容器中删除元素的代价</p>\n<p>-. 非顺序访问容器中元素的代价</p>\n<p>顺序容器有：vector, deque, list, forward_list, array, string。</p>\n<p>string和vector将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在其中间添加或删除元素就会非常耗时，因为这需要移动插入或删除位置之后的所有元素。而且，添加元素可能导致分配额外的存储空间，这种情况下，每个元素都会移动到新的存储空间中。</p>\n<p>list和forward_list两个容器添加和删除操作都很快速。作为代价，它们不支持元素的随机访问，为了访问一个元素，只能遍历整个容器。与vector、deque和array相比，这两个容器的额外内存开销也很大。</p>\n<p>deque支持快速随机访问，在deque的中间位置插入或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的。</p>\n<p>forward_1ist和array是新C++标准增加的类型。与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list 没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，size保证是一个快速的常量时间的操作。</p>\n<p><strong>确定使用哪种容器</strong></p>\n<pre><code>通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。</code></pre><h2 id=\"容器库概览\"><a href=\"#容器库概览\" class=\"headerlink\" title=\"容器库概览\"></a>容器库概览</h2><p><strong>对容器可以保存的元素类型的限制</strong></p>\n<p>顺序容器几乎可以保存任意类型的元素。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。比如解引用操作。</p>\n<p>表3.6（96页）列出了容器迭代器支持的所有操作。表3.7（99页）列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array。</p>\n<p><strong>迭代器范围</strong></p>\n<p>迭代器范围由一对迭代器表示，通常被称为begin和end，它们标记了容器中元素的一个范围。这个范围被称为左闭合区间：<code>[begin, end)</code></p>\n<p><strong>使用左闭合区间蕴含的编程假定</strong></p>\n<p>假定begin和end构成一个合法的迭代器范围，则：</p>\n<ul>\n<li><p>如果begin与end相等，则范围为空</p>\n</li>\n<li><p>如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</p>\n</li>\n<li><p>我们可以对begin递增若干次，使得begin == end</p>\n</li>\n</ul>\n<h3 id=\"容器定义和初始化\"><a href=\"#容器定义和初始化\" class=\"headerlink\" title=\"容器定义和初始化\"></a>容器定义和初始化</h3><p>每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以指定容器大小和元素初始值的参数。</p>\n<p><strong>将一个容器初始化为另一个容器的拷贝</strong></p>\n<p>方法有两种：</p>\n<ul>\n<li><p>直接拷贝整个容器，两个容器的类型和元素的类型都必须匹配。</p>\n</li>\n<li><p>拷贝一个迭代器范围，容器类型不一定匹配，且元素类型只要能够转换即可。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">//每个容器有三个元素，用给定的初始化器进行初始化\nlist&lt;string&gt; authors={&quot;Milton&quot;，&quot;Shakespeare&quot;，&quot;Austen&quot;};\nvector&lt;const char*&gt; articles={&quot;a&quot;，&quot;an&quot;，&quot;the&quot;};\n1ist&lt;string&gt;1ist2(authors);//正确：类型匹配\ndeque&lt;string&gt;authList(authors);//错误：容器类型不匹配\nvector&lt;string&gt;words(articles);//错误：容器类型必须匹配\n//正确：可以将const char*元素转换为\nstring forward_list&lt;string&gt; words(articles.begin()，articles.end());</code></pre>\n<p><strong>列表初始化</strong></p>\n<pre><code class=\"c++\">list&lt;const char *&gt; articles = {&quot;a&quot;,&quot;an&quot;,&quot;the&quot;};</code></pre>\n<p><strong>标准库array具有固定大小</strong></p>\n<p>为了使用array类型，我们必须同时指定元素类型和大小，</p>\n<pre><code class=\"c++\">array&lt;int,10&gt;::size_type i;//数组类型包括元素类型和大小；</code></pre>\n<h3 id=\"赋值和swap\"><a href=\"#赋值和swap\" class=\"headerlink\" title=\"赋值和swap\"></a>赋值和swap</h3><p>赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝。</p>\n<pre><code class=\"c++\">c1 = c2;\nca = {a,b,c};</code></pre>\n<p>与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型：</p>\n<pre><code class=\"c++\">array&lt;int，10&gt;al={0，1，2，3，4，5，6，7，8，9};\narray&lt;int，10&gt;a2={0};//所有元素值均为0\nal=a2;//替换a1中的元素\na2={0};//错误：不能将一个花括号列表赋予数组</code></pre>\n<p><strong>由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持asign，也不允许用花括号包围的值列表进行赋值。</strong></p>\n<p><strong>使用assign(仅顺序容器)</strong></p>\n<p>赋值运算要求两边容器类型和元素类型相同。顺序容器（除了array）还定义了一个名为assign的成员，允许从一个相容的序列中赋值。</p>\n<p><strong>使用swap</strong></p>\n<p>调用swap操作后，两个容器中的元素将会交换。</p>\n<p>除了array，交换两个容器的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构。</p>\n<h3 id=\"容器大小操作\"><a href=\"#容器大小操作\" class=\"headerlink\" title=\"容器大小操作\"></a>容器大小操作</h3><p>每个容器都支持这些大小相关的操作：</p>\n<ul>\n<li><p>成员函数size，返回容器中元素的数目，forward_list不支持；</p>\n</li>\n<li><p>empty，当size为0时返回true，否则返回false；</p>\n</li>\n<li><p>max_size，返回一个大于或等于该容器所能容纳的最大元素数的值，这是一个很大的值。</p>\n</li>\n</ul>\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>每个容器都支持相等运算符（==和!=），除了无序关联容器外的所有容器都支持关系运算符（&gt;, &gt;=, &lt;, &lt;=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。</p>\n<p>比较两个容器实际上是进行元素的逐对比较。</p>\n<pre><code>只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符比较两个容器。</code></pre><h2 id=\"顺序容器操作\"><a href=\"#顺序容器操作\" class=\"headerlink\" title=\"顺序容器操作\"></a>顺序容器操作</h2><p>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加及删除。</p>\n<h3 id=\"向顺序容器添加元素\"><a href=\"#向顺序容器添加元素\" class=\"headerlink\" title=\"向顺序容器添加元素\"></a>向顺序容器添加元素</h3><p>标准库容器提供了灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。表9.5，p305。</p>\n<pre><code class=\"c++\">这些操作会改变容器的大小；array不支持这些操作。\nforward_list有自己专有版本的insert和emplace；参见9.3.4节（第312页）。\nforward_1ist不支持 push_back和emplace_back。\nvector和string不支持push front和emplace front。\nc. push back(t);\nc. emplace back(args);\nc. push_front(t);\nc. emplace_front(args);\nc. insert(p,t);\nc. emplace(p, args);\nc. insert(p,n,t)c. insert(p,b,e);\nc. insert(p, il);</code></pre>\n<pre><code>向一个deque、string或vector插入元素会使所有指向容器的迭代器、引用和指针失效。\n\n将元素插入到deque、string或vector中的任何位置都是合法的。然而，这样做可能很耗时。</code></pre><p><strong>关键概念：容器元素是拷贝</strong></p>\n<p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝。</p>\n<h3 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h3><p>表9.6（p310）列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。</p>\n<p><strong>访问成员函数返回的是引用</strong></p>\n<p>在容器中访问元素的成员函数(即，front、back、下标和at)返回的都是引用。</p>\n<p>如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值：</p>\n<pre><code class=\"c++\">if(！c.empty()){\nC.front()=42;//将42赋予c中的第一个元素\nauto&amp;v=c.back();//获得指向最后一个元素的引用\nv=1024;//改变c中的元素\nauto v2=c.back();//v2不是一个引用，它是c.back()的一个拷贝\nv2=0;//未改变c中的元素</code></pre>\n<p><strong>下标操作和安全的随机访问</strong></p>\n<p>提供快速随机访问的容器（string、vector、deque和array）也都提供下标运算符。保证下标合法是程序员的责任，编译器不检查越界错误。</p>\n<p>如果想确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，如果下标越界，at会抛出一个out_of_range异常。</p>\n<h3 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><pre><code>删除deque中除首尾之外的任何元素都会使所有迭代器、引用、指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。\n\n删除元素之前，程序员必须确保它们是存在的。</code></pre><pre><code class=\"c++\">这些操作会改变容器的大小，所以不适用于array。\nforward list 有特殊版本的erase，参见9.3.4节（第312页）。\nforward_list 不支持 popback；vector和string不支持pop_front。\nc.pop_back()\nc.pop_front()\nc.erase(p)\nc.erase(b,e)\nc.clear()</code></pre>\n<h3 id=\"改变容器大小\"><a href=\"#改变容器大小\" class=\"headerlink\" title=\"改变容器大小\"></a>改变容器大小</h3><p>可以使用resize来增大或缩小容器。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。</p>\n<p>resize接受一个可选的元素指参数，用来初始化新添加的元素。如果未提供，新元素进行值初始化。</p>\n<pre><code class=\"c++\">c.resize(n);\nc.resize(n,t);</code></pre>\n<h3 id=\"容器操作可能使迭代器失效\"><a href=\"#容器操作可能使迭代器失效\" class=\"headerlink\" title=\"容器操作可能使迭代器失效\"></a>容器操作可能使迭代器失效</h3><p>使用失效的迭代器、引用、或指针是一种严重的错误。</p>\n<p>向容器添加元素后：</p>\n<ul>\n<li><p>如果容器是vector或string，且存储空间被重新分配，那么所有的迭代器都会失效。如果空间未重新分配，指向插入位置之前的元素的迭代器仍有效，但之后的迭代器会失效。</p>\n</li>\n<li><p>对于list和forward_list，指向容器的迭代器仍有效。</p>\n</li>\n</ul>\n<p>当从容器中删除元素后：</p>\n<ul>\n<li><p>对于list和forward_list，指向容器其他位置的迭代器仍有效。</p>\n</li>\n<li><p>对于string和vector，被删除元素之前的元素的迭代器仍有效。</p>\n</li>\n</ul>\n<h2 id=\"vector对象是如何增长的\"><a href=\"#vector对象是如何增长的\" class=\"headerlink\" title=\"vector对象是如何增长的\"></a>vector对象是如何增长的</h2><p><strong>管理容量的成员函数</strong></p>\n<pre><code class=\"c++\">//shrink to_fit 只适用于vector、string 和deque。\n//capacity和 reserve 只适用于vector和string。\nc.shrink_to_fit();//请将 capacity()减少为与size()相同大小\nc.capacity();//不重新分配内存空间的话，c可以保存多少元素\nC.reserve(n);//分配至少能容纳n个元素的内存空间</code></pre>\n<h2 id=\"额外的-string-操作\"><a href=\"#额外的-string-操作\" class=\"headerlink\" title=\"额外的 string 操作\"></a>额外的 string 操作</h2><p>除了顺序容器共同的操作之外， string 类型还提供了一些额外的操作。</p>\n<h3 id=\"构造-string-的其他方法\"><a href=\"#构造-string-的其他方法\" class=\"headerlink\" title=\"构造 string 的其他方法\"></a>构造 string 的其他方法</h3><p>使用下面这些方法可以构造 string ：</p>\n<p>以下 n, len2, pos2 都是无符号值。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string s(cp, n)</td>\n<td>s是cp指向的数组中前n个字符的拷贝</td>\n</tr>\n<tr>\n<td>string s(s2, pos2)</td>\n<td>s是 string s2 从下标 pos2 开始的字符拷贝</td>\n</tr>\n<tr>\n<td>string s(s2, pos2, len2)</td>\n<td>s是 string s2 从下标 pos2 开始 len2 个字符的拷贝，不管 len2 的值是多少，构造函数至多拷贝 s2.size() - pos2 个字符</td>\n</tr>\n<tr>\n<td><strong>substr 操作</strong></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>substr 返回一个 string ，它是原始 string 的一部分或全部的拷贝。</p>\n<p><code>s.substr(pos, n)</code> 返回一个 string ，包含s中从pos开始的n个字符的拷贝。pos默认为0,n默认为 s.size() - pos ，即拷贝从 pos 开始的所有字符。</p>\n<h3 id=\"改变-string-的其他方法\"><a href=\"#改变-string-的其他方法\" class=\"headerlink\" title=\"改变 string 的其他方法\"></a>改变 string 的其他方法</h3><p>string 类型支持顺序容器的赋值运算符以及 assign, insert, erase 操作。除此之外，它还定义了额外的 insert 和 erase 版本。即使用下标的版本。</p>\n<pre><code class=\"c++\">s.insert(s.size(),5,&quot;!&quot;);//在s末尾插入五个！</code></pre>\n<p>这些函数都拥有许多重载的版本。</p>\n<p>assign 版本还接受C风格字符串：<strong>需要以空格结尾</strong></p>\n<p>append 和 replace 是额外的成员函数， append 在 string 末尾进行插入操作， replace 替换内容，它是调用 erase 和 insert 的一种简写形式：</p>\n<pre><code class=\"c++\">string s(&quot;C++ Primer 4th Ed.&quot;);\n//从位置11开始，删除三个字符并插入Fifth;\ns.replace(11,3,&quot;Fifth)</code></pre>\n<h3 id=\"string-搜索操作\"><a href=\"#string-搜索操作\" class=\"headerlink\" title=\"string 搜索操作\"></a>string 搜索操作</h3><p>string 提供了6个搜索函数，它们都有4个重载版本。它们都返回一个 string::size_type 的值作为匹配位置（下标）。如果搜索失败，返回 string::npos ，其值为 -1 。</p>\n<p>可以给函数一个搜索的起始位置 pos ，它默认值是0：<br><code>auto pos = s.find_first_of(numbers, pos);</code></p>\n<pre><code class=\"c++\">string name(&quot;guohaoxin01236578&quot;);\nauto pos1 = name.find(&quot;guo&quot;);//pos1==0返回字符串guo第一次出现的位置\nnumbers = &quot;0123456789&quot;;\nauto pos2 = name.find_first_of(numbers);//寻找numbers字符串中任意字符出现的位置，find_first_not_of</code></pre>\n<p><strong>指定从哪里开始搜索</strong></p>\n<pre><code class=\"c++\">string size_type pos = 0;\nwhile((pos=name.find_first_of(numbers,pos))!=string::npos){\n    cout&lt;&lt;&quot;found number at index:&quot;&lt;&lt;pos&lt;&lt;&quot; element is &quot;&lt;&lt;name[pos]&lt;&lt;endl;\n    ++pos;//移动到下一字符\n}</code></pre>\n<h3 id=\"compare-函数\"><a href=\"#compare-函数\" class=\"headerlink\" title=\"compare 函数\"></a>compare 函数</h3><p>这是字符串比较函数，和C标准库的 strcmp 很相似。</p>\n<h3 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h3><p>标准库提供了数值转换的函数。</p>\n<pre><code class=\"c++\">to_string(val)\nstoi/l/ul/ll/ull/f/d/ld//转换成int、double、float</code></pre>\n<p>如果 string 不能转换成一个数值，那么会抛出一个 invalid_argument 的异常。如果转换得到的数值无法用任何类型来表示，则抛出一个 out_of_range 异常。</p>\n<h2 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h2><p>三个容器适配器：stack(栈适配器),queue,priority_queue(队列适配器)。</p>\n<p><strong>定义一个适配器</strong></p>\n<p>stack<int> stk;</int></p>\n<h1 id=\"泛型算法\"><a href=\"#泛型算法\" class=\"headerlink\" title=\"泛型算法\"></a>泛型算法</h1><p>标准库并未给每个容器都定义成员函数来实现一些特殊的操作，如查找元素、替换或删除元素、重排元素等。而是定义了一组泛型算法。它们实现了一些经典算法的公共接口，可以用于不同类型的元素和多种容器类型，包括内置的数组类型。</p>\n<hr>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>大多数算法定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。</p>\n<p>通常，算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>\n<p>算法不依赖于容器，但依赖于元素类型的操作。比如，find用元素类型的==运算符完成序列中的元素与给定值的比较。大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符（即使用谓词）。</p>\n<p><strong>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。</strong></p>\n<h2 id=\"初识泛型算法\"><a href=\"#初识泛型算法\" class=\"headerlink\" title=\"初识泛型算法\"></a>初识泛型算法</h2><p>附录A按照操作方式列出了所有的算法。</p>\n<p>除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。</p>\n<p>理解算法的最基本的方法就是了解它们是否读取元素、改变元素或是重排元素顺序。</p>\n<h3 id=\"只读算法\"><a href=\"#只读算法\" class=\"headerlink\" title=\"只读算法\"></a>只读算法</h3><p>一些算法只会读取其输入范围内的元素，而从不改变元素。比如find、accumulate。</p>\n<pre><code class=\"c++\">int sum = accumulate(vec.cbegin(),vec.cend(),0);//求和，和的初值为0；\nstring sum =accumulate(v.cbegin(),v.cend(),string(&quot;&quot;));//string定义了字符串的“+”法，\n//错误，const char *上没有定义+运算符\nstring sum =accumulate(v.cbegin(),v.cend(),&quot;&quot;);</code></pre>\n<p><strong>操作两个序列的算法</strong></p>\n<p>举一个列子：equal算法，它比较两个序列中的元素。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：</p>\n<pre><code class=\"c++\">// roster2中的元素数目应该至少与roster1一样多\nequal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</code></pre>\n<p>这样的算法基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。</p>\n<h3 id=\"写容器元素的算法\"><a href=\"#写容器元素的算法\" class=\"headerlink\" title=\"写容器元素的算法\"></a>写容器元素的算法</h3><p>一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入元素数目（note：如容器大小足够）。</p>\n<p>这样的算法比如fill。</p>\n<p><strong>介绍back_inserter</strong></p>\n<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</p>\n<p><strong>拷贝算法</strong></p>\n<p>拷贝(copy)算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素，这一点很重要。</p>\n<p>我们可以用copy实现内置数组的拷贝，如下面代码所示：</p>\n<pre><code class=\"c++\">int al[]={0，1，2，3，4，5，6，7，8，9};\nint a2[sizeof(a1)/sizeof(*al)];//a2与al大小一样\n//ret指向拷贝到a2的尾元素之后的位置\nauto ret=copy(begin(a1)，end(al)，a2);//把a1的内容拷贝给a2</code></pre>\n<p>copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。</p>\n<h3 id=\"重排元素的算法\"><a href=\"#重排元素的算法\" class=\"headerlink\" title=\"重排元素的算法\"></a>重排元素的算法</h3><p>某些算法会重排容器中元素的顺序，比如sort，它利用元素类型的&lt;运算符来实现排序。</p>\n<h2 id=\"定义操作\"><a href=\"#定义操作\" class=\"headerlink\" title=\"定义操作\"></a>定义操作</h2><p>很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的&lt;或==运算符完成比较。标准库为这些算法定义了额外的版本，允许我们提供自己定义的操作来替代默认运算符。</p>\n<h3 id=\"向算法传递函数\"><a href=\"#向算法传递函数\" class=\"headerlink\" title=\"向算法传递函数\"></a>向算法传递函数</h3><p>sort接受第三个参数，此参数是一个谓词（predicate）。</p>\n<p><strong>谓词</strong></p>\n<p>谓词是一个可调用的表达式，其调用结果是一个能用作条件的值。标准库算法使用的谓词分为两类：</p>\n<ul>\n<li><p>一元谓词，意味着它们只接受单一参数</p>\n</li>\n<li><p>二元谓词，意味着它们有两个参数</p>\n</li>\n</ul>\n<p>接受谓词的算法对输入序列中的元素调用谓词。</p>\n<h3 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h3><p>我们传递给算法的谓词必须严格接受一个或两个参数，但是有时我们希望进行的操作需要更多的参数，超出了算法对谓词的限制。</p>\n<p><strong>介绍lambda</strong></p>\n<p>我们可以向一个算法传递任何类别的可调用对象，对于一个对象或一个表达式，如果可以对其使用可调用运算符，则称它为可调用的。</p>\n<p>一个lambda表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。一个lambda表达式具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可以定义在函数内部。</p>\n<p>一个lambda表达式具有如下形式：</p>\n<pre><code class=\"c++\">[capture list](parameter list) -&gt; return type { function body }</code></pre>\n<p>其中，capture list是一个lambda所在函数中定义的局部变量的列表。</p>\n<p>可以忽略返回类型，这时会自动推断返回类型。</p>\n<pre><code class=\"c++\">auto func = [](){ return 42; };</code></pre>\n<h3 id=\"lambda捕获和返回\"><a href=\"#lambda捕获和返回\" class=\"headerlink\" title=\"lambda捕获和返回\"></a>lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。类似地，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。</p>\n<p>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。</p>\n<p>变量捕获的方式可以是值或引用。值捕获是变量的拷贝，引用捕获是变量的引用。</p>\n<pre><code>当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。</code></pre><p><strong>建议：</strong></p>\n<p>尽量保持lambda的变量捕获简单化。如果可能的话，应该避免捕获指针或引用。见p351。</p>\n<p><strong>隐式捕获</strong></p>\n<p>可以让编译器根据lambda体中的代码来推断要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。</p>\n<p>如：</p>\n<pre><code class=\"c++\">// sz为隐式捕获，值捕获方式\nwc = find_if(words.begin(), words.end(),\n             [=](const string &amp;s) { return s.size() &gt;= sz; } );</code></pre>\n<p>详见lambda捕获列表，p352。</p>\n<p><strong>可变lambda</strong></p>\n<p>默认情况下，对于一个值拷贝的变量，lambda不会改变其值。如果希望改变，必须在参数列表后加上关键字mutable。</p>\n<pre><code class=\"c++\">void fcn3()\n{\n    size_t v1 = 42;\n    // f可以改变它捕获的变量的值\n    auto f = [v1]() mutable { return ++v1; };\n    v1 = 0;\n    auto j = f(); // j为43\n}</code></pre>\n<h3 id=\"参数绑定\"><a href=\"#参数绑定\" class=\"headerlink\" title=\"参数绑定\"></a>参数绑定</h3><p>对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果需要在很多地方使用相同的操作，或者一个操作需要很多语句完成，通常应该定义一个函数。</p>\n<p>如果lambda的捕获列表为空，通常可以用函数来代替它。但如果捕获列表不为空就不能直接代替了。</p>\n<p><strong>标准库bind函数</strong></p>\n<p>为了解决这个问题，可以使用一个新的名为bind的标准库函数，它定义在头文件functional中。它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>\n<pre><code class=\"c++\">auto newCallable = bind(callable, arg_list);</code></pre>\n<p>newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。</p>\n<p>arg_list中的参数可能包含形如<code>_n</code>的名字，这些参数是“占位符”，表示newCallable的参数。比如：<code>_1</code>为newCallable的第一个参数，<code>_2</code>为第二个参数。</p>\n<p><strong>使用placeholders名字</strong></p>\n<p>名字<code>_n</code>都定义在一个名为placeholders的命名空间中，这个命名空间本身定义在std命名空间中。</p>\n<p>一种简单的using语句是：</p>\n<pre><code class=\"c++\">using namespace namespace_name;</code></pre>\n<p>这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。如：</p>\n<pre><code class=\"c++\">using namespace std::placeholders;</code></pre>\n<p>这使得placeholders定义的所有名字都可用。</p>\n<h2 id=\"再探迭代器\"><a href=\"#再探迭代器\" class=\"headerlink\" title=\"再探迭代器\"></a>再探迭代器</h2><p>除了每个容器的迭代器，标准库在头文件iterator中还定义了额外几种迭代器。</p>\n<ul>\n<li><p>插入迭代器：这些迭代器被绑定到一个容器上，可以用来向容器插入元素。</p>\n</li>\n<li><p>流迭代器：这些迭代器被绑定到输入或输出流上，可以来遍历所关联的IO流。</p>\n</li>\n<li><p>反向迭代器：这些迭代器向后而不是向前移动。</p>\n</li>\n<li><p>移动迭代器：不拷贝其中的元素，而是移动它们。将在13.6.2节（p480页）介绍。</p>\n</li>\n</ul>\n<h3 id=\"插入迭代器\"><a href=\"#插入迭代器\" class=\"headerlink\" title=\"插入迭代器\"></a>插入迭代器</h3><p>插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。</p>\n<pre><code class=\"c++\">it = t; // 在it指定的当前位置插入值t。</code></pre>\n<p>插入迭代器有三种类型，差异在于元素插入的位置：</p>\n<ul>\n<li><p>back_inserter，创建一个使用push_back的迭代器。</p>\n</li>\n<li><p>front_inserter，创建一个使用push_front的迭代器。</p>\n</li>\n<li><p>inserter，创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">list&lt;int&gt; lst = {1,2,3,4};\nliat&lt;int&gt;lst2,lst3;//空的list\n//copy 完成后lst2包含4 3 2 1\ncopy(lst.begin(),lst.end(),front_inserter(lst2));\n//opy 完成后lst3包含1 2 3 4\ncopy(lst.begin(),lst.end(),inserter(lst3,lst3.begin()));</code></pre>\n<h3 id=\"iostream迭代器\"><a href=\"#iostream迭代器\" class=\"headerlink\" title=\"iostream迭代器\"></a>iostream迭代器</h3><p>istream_iterator读取输入流，ostream_iterator向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。</p>\n<p>通过使用流迭代器，我们可以使用泛型算法从流对象读取数据以及向其写入数据。</p>\n<p>详细操作见p359。</p>\n<h3 id=\"反向迭代器\"><a href=\"#反向迭代器\" class=\"headerlink\" title=\"反向迭代器\"></a>反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。</p>\n<p>可以通过rbegin, rend, crbegin, crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。</p>\n<h2 id=\"泛型算法结构\"><a href=\"#泛型算法结构\" class=\"headerlink\" title=\"泛型算法结构\"></a>泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。算法所要求的迭代器操作可以分为5个迭代器类别。</p>\n<table>\n<thead>\n<tr>\n<th>迭代器</th>\n<th>要求</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>输入迭代器</td>\n<td>只读，不写；单遍扫描，只能递增</td>\n</tr>\n<tr>\n<td>输出迭代器</td>\n<td>只写，不读；单遍扫描，只能递增</td>\n</tr>\n<tr>\n<td>前向迭代器</td>\n<td>可读写；多遍扫描，只能递增</td>\n</tr>\n<tr>\n<td>双向迭代器</td>\n<td>可读写；多遍扫描，可递增递减</td>\n</tr>\n<tr>\n<td>随机访问迭代器</td>\n<td>可读写，多遍扫描，支持全部迭代器运算</td>\n</tr>\n</tbody></table>\n<h3 id=\"5类迭代器\"><a href=\"#5类迭代器\" class=\"headerlink\" title=\"5类迭代器\"></a>5类迭代器</h3><p>类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。</p>\n<p>如ostream_iterator只支持递增、解引用和赋值。vector、string、deque的迭代器除了这些操作，还支持递减、关系和算术运算。</p>\n<p>除了输出迭代器之外，一个高层类别的迭代器支持低层类别迭代器的所有操作。</p>\n<h3 id=\"算法的形参模式\"><a href=\"#算法的形参模式\" class=\"headerlink\" title=\"算法的形参模式\"></a>算法的形参模式</h3><p>大多数算法具有如下4种形式之一：</p>\n<pre><code class=\"c++\">alg(beg, end, other args);\nalg(beg, end, dest, other args);\nalg(beg, end, beg2, other args);\nalg(beg, end, beg2, end2, other args);</code></pre>\n<p>其中，alg是算法名字，beg和end表述输入范围。几乎所有算法都有一个输入范围。</p>\n<p><strong>接受单个目标迭代器的算法</strong></p>\n<p>dest参数是一个表示算法可以写入目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。</p>\n<p>一般dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因为保证空间是足够的。</p>\n<p><strong>接受第二个输入序列的算法</strong></p>\n<p>接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围。</p>\n<p>接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。</p>\n<h3 id=\"算法命名规范\"><a href=\"#算法命名规范\" class=\"headerlink\" title=\"算法命名规范\"></a>算法命名规范</h3><p>除了参数规范，算法还遵循一套命名和重载规范。</p>\n<p><strong>一些算法使用重载形式传递一个谓词</strong></p>\n<p>函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外的谓词参数，来代替&lt;或==：</p>\n<pre><code class=\"c++\">unique(beg, end);\nunique(beg, end, comp);</code></pre>\n<p><strong>_if版本的算法</strong></p>\n<p>接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀：</p>\n<pre><code class=\"c++\">find(beg, end, val);\nfind_if(beg, end, pred);</code></pre>\n<p><strong>区分拷贝元素的版本和不拷贝的版本</strong></p>\n<p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。</p>\n<pre><code>reverse(beg, end);\nreverse_copy(beg, end, dest);</code></pre><h2 id=\"特定容器的算法\"><a href=\"#特定容器的算法\" class=\"headerlink\" title=\"特定容器的算法\"></a>特定容器的算法</h2><p>链表类型list定义了几个成员函数形式的算法。通用版本的sort要求随机访问迭代器，因此不能用于list。</p>\n<p>链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。</p>\n<p>这些算法见p369。</p>\n<p><strong>链表特有的操作会改变容器</strong></p>\n<p>多数链表特有的算法与通用版本的很相似，但不完全相同，其中一个至关重要的区别是链表版本的会修改底层的容器。例如， remove 的链表版本会删除指定的元素， unique 的链表版本会删除第二个和后继的重复元素。</p>\n<pre><code>对于通用版本的，如 std::remove ，不会删除容器的元素。它只会迁移元素。之后需要调用 erase 才能执行确切的删除动作。</code></pre><h1 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h1><p>关联容器与顺序容器有着根本的不同：</p>\n<ul>\n<li><p>关联容器中的元素是按关键字来保存和访问的。</p>\n</li>\n<li><p>顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>\n</li>\n</ul>\n<p>关联容器支持高效的关键字查找和访问，有两个主要的关联容器：</p>\n<ul>\n<li><p>map，其元素是一些关键字-值对，关键字起到索引作用，值则表示与之相关的数据。</p>\n</li>\n<li><p>set，每个元素只包含一个关键字。</p>\n</li>\n</ul>\n<p>标准库提供8个关联容器，如表11.1所示。这8个容器间的不同体现在三个维度上：每个容器  </p>\n<ol>\n<li>或者是一个set，或者是一个map；</li>\n<li>或者要求不重复的关键字，或者允许重复关键字；</li>\n<li>按顺序保存元素，或无序保存。</li>\n</ol>\n<p>允许重复关键字的容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头。因此一个unordered multi set是一个允许重复关键字，元素无序保存的集合，而一个set则是一个要求不重复关键字，有序存储的集合。无序容器使用哈希函数来组织元素。</p>\n<h2 id=\"使用关联容器\"><a href=\"#使用关联容器\" class=\"headerlink\" title=\"使用关联容器\"></a>使用关联容器</h2><p>map是关键字-值对的集合，通常被称为<strong>关联数组</strong>。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。与之相对，set就是关键字的简单集合。</p>\n<pre><code>//统计每个单词在输入中出现的次数\nmap&lt;string,size_t) word_count;\nstring word;\nwhile(cin&gt;&gt;word)\n    ++word_count[word];\nfor(const auto &amp;a:word_count)\n//打印结果\n    cout&lt;&lt;a.first&lt;&lt;&quot;occurs&quot;&lt;&lt;w.second&lt;&lt;((w.second&gt;1)?&quot;times&quot;:&quot;time&quot;&lt;&lt;endl;</code></pre><p><strong>使用set</strong><br>可以使用set忽略我们想要忽略的单词，例如：</p>\n<pre><code class=\"c++\">    // 统计每个单词在输入中出现的次数\n    map&lt;string, size_t&gt; word_count;    // string到size_t的空map\n    set&lt;string&gt; exclude = {&quot;The&quot;, &quot;the&quot;, &quot;And&quot;, &quot;and&quot;};\n\n    string word;\n    while (cin &gt;&gt; word) {\n        // 只统计不在exclude中的单词\n        if (exclude.find(word) == exclude.end())\n            ++word_count[word];    // 提取word的计数器并将其加1\n    }\n\n    for (const auto &amp;w : word_count) // 对map中的每个元素\n        // 打印结果\n        cout &lt;&lt; w.first &lt;&lt; &quot; occurs time: &quot; &lt;&lt; w.second &lt;&lt; endl;</code></pre>\n<h2 id=\"关联容器概述\"><a href=\"#关联容器概述\" class=\"headerlink\" title=\"关联容器概述\"></a>关联容器概述</h2><p>关联容器（有序的和无序的）都支持9.2节（第294页）中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front。</p>\n<p>除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作（见p388）和类型别名（见p381）。</p>\n<p>关联容器的迭代器都是双向的。</p>\n<h3 id=\"定义关联容器\"><a href=\"#定义关联容器\" class=\"headerlink\" title=\"定义关联容器\"></a>定义关联容器</h3><pre><code class=\"c++\">map&lt;string, size_t&gt; word_count; // 空容器\nset&lt;string&gt; exclude = {&quot;the&quot;, &quot;but&quot;, &quot;and&quot;}; // 列表初始化\n\n// 三个元素；authors将姓映射为名\nmap&lt;string, string&gt; authors = {\n    {&quot;Joyce&quot;, &quot;James&quot;},\n    {&quot;Austen&quot;, &quot;Jane&quot;},\n    {&quot;Dickens&quot;, &quot;Charles&quot;}\n};</code></pre>\n<p><strong>初始化multimap或multiset</strong></p>\n<p>一个map或set中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。</p>\n<p>multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字（这些元素会相邻存储）。</p>\n<h3 id=\"关键字类型的要求\"><a href=\"#关键字类型的要求\" class=\"headerlink\" title=\"关键字类型的要求\"></a>关键字类型的要求</h3><p>对于有序容器，关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。</p>\n<p><strong>使用关键字类型的比较函数</strong></p>\n<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型（比如一个函数指针类型）。</p>\n<pre><code class=\"c++\">bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs)\n{\n    return lhs.isbn() &lt; rhs.isbn();\n}\n\nmultiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);</code></pre>\n<h3 id=\"pair类型\"><a href=\"#pair类型\" class=\"headerlink\" title=\"pair类型\"></a>pair类型</h3><p>pair类型定义在头文件utility中。</p>\n<p>一个pair保存两个数据成员，pair是一个用来生成特定类型的模板。</p>\n<pre><code class=\"c++\">pair&lt;string, string&gt; anon; // 保存两个string\npair&lt;string, vector&lt;int&gt;&gt; line; // 保存string和vector&lt;int&gt;</code></pre>\n<p>pair的默认构造函数对数据成员进行值初始化。也可以为每个成员提供初始化器：</p>\n<pre><code class=\"c++\">pair&lt;string, string&gt; author{&quot;James&quot;, &quot;Joyce&quot;};</code></pre>\n<p>pair的数据成员是public的，两个成员分别是first，second。</p>\n<p><strong>创建pair对象的函数</strong></p>\n<pre><code class=\"c++\">pair&lt;string, int&gt;\nprocess(vector&lt;string&gt; &amp;v)\n{\n    // 处理v\n    if (!v.empty())\n        return {v.back(), v.back().size()}; // 列表初始化\n    else\n        return pair&lt;string, int&gt;(); // 隐式构造返回值\n}</code></pre>\n<h2 id=\"关联容器操作\"><a href=\"#关联容器操作\" class=\"headerlink\" title=\"关联容器操作\"></a>关联容器操作</h2><p>除了表9.2(第295页)中列出的类型，关联容器还定义了这些类型：</p>\n<ul>\n<li><p>key_type, 此容器类型的关键字类型</p>\n</li>\n<li><p>mapped_type, 每个关键字关联的类型，只适用于map</p>\n</li>\n<li><p>value_type, 对于set，与key_type相同，对于map, 为<code>pair&lt;const key_type, mapped_type&gt;</code></p>\n</li>\n</ul>\n<h3 id=\"关联容器迭代器\"><a href=\"#关联容器迭代器\" class=\"headerlink\" title=\"关联容器迭代器\"></a>关联容器迭代器</h3><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型。</p>\n<pre><code>必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。</code></pre><p><strong>set的迭代器是const的</strong></p>\n<p>与不能改名map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改。</p>\n<p><strong>遍历关联容器</strong></p>\n<p>map和set类型都支持begin和end操作，我们可以利用这些函数获取迭代器，然后用迭代器来遍历容器。</p>\n<pre><code class=\"c++\">auto map_it = word_count.cbegin();\nwhile (map_it != word_count.cend()) {\n    // ...\n    ++map_it; // 递增迭代器，移动到下一个元素\n}</code></pre>\n<p>!!!note<br>    当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。</p>\n<p><strong>关联容器和算法</strong></p>\n<p>我们通常不对关联容器使用泛型算法。更多讨论见书本p383。</p>\n<h3 id=\"添加元素\"><a href=\"#添加元素\" class=\"headerlink\" title=\"添加元素\"></a>添加元素</h3><p>关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。</p>\n<p><strong>向map添加元素</strong></p>\n<p>对一个map进行insert操作时，必须记住元素类型是pair。</p>\n<pre><code class=\"c++\">word_count.insert({word, 1});\nword_count.insert(make_pair(word, 1));\nword_count.insert(pair&lt;string, size_t&gt;(word, 1));\nword_count.insert(map&lt;string, size_t&gt;::value_type(word, 1));\nword_count. insert(map&lt;string, size_t&gt;:: value_type(word,1));</code></pre>\n<p><strong>检测insert的返回值</strong></p>\n<p>insert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。<strong>pair的first成员是一个迭代器</strong>，指向具有给定关键字的元素；second成员是一个boo1值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的boo1部分为false。如果关键字不存在，元素被插入容器中，且boo1值为true。</p>\n<p><strong>展开递增语句</strong></p>\n<pre><code class=\"c++\">++ret.first-&gt;second;\n`++((ret.first)-&gt;second)`//等价的表达式</code></pre>\n<p>-. ret保存insert返回的值，是一个pair。<br>-. ret.first是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素。<br>-. ret.first-&gt;解引用此迭代器，提取map中的元素，元素也是一个pair。<br>-. ret.first-&gt;second map中元素的值部分。<br>-. ++ret.first-&gt;second 递增此值。</p>\n<p><strong>向multiset或multimap添加元素</strong></p>\n<p>由于一个multi容器中的关键字不必唯一，在这些类型上调用insert总会插入一个元素：</p>\n<pre><code class=\"c++\">multimap&lt;string, string&gt; authors;\n// 插入第一个元素\nauthors.insert({&quot;Barth, John&quot;, &quot;Sot-Weed Factor&quot;});\n// 正确，添加第二个元素\nauthors.insert({&quot;Barth, John&quot;}, &quot;Lost in the Funhouse&quot;);</code></pre>\n<p>对允许重复关键字的容器，接受单个元素的insert操作返回一个指向新元素的迭代器。</p>\n<h3 id=\"删除元素-1\"><a href=\"#删除元素-1\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h3><p>关联容器定义了三个版本的erase：</p>\n<ul>\n<li><p>与顺序容器一样，传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围。</p>\n</li>\n<li><p>接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。</p>\n</li>\n</ul>\n<p>对于保存不重复关键字的容器，erase的返回值总是0或1。</p>\n<p>对允许重复关键词的容器，删除的元素的数量可能大于1。</p>\n<h3 id=\"map的下标操作\"><a href=\"#map的下标操作\" class=\"headerlink\" title=\"map的下标操作\"></a>map的下标操作</h3><p>map和unordered_map容器提供了下标运算符和一个对应的at函数。</p>\n<p>set类型不支持下标操作，不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。</p>\n<p>map下标运算符接受一个索引获取与此关键字相关联的值，如果关键字不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。</p>\n<p><strong>使用下标操作的返回值</strong></p>\n<p>当对一个map进行下标操作时，会获得一个mapped_type对象。</p>\n<p>当解引用一个map迭代器时，会得到一个value_type对象。</p>\n<p>!!!note<br>    与vector与string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。</p>\n<h3 id=\"访问元素-1\"><a href=\"#访问元素-1\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h3><p>如果我们关心的只不过是一个特定元素是否已在容器中，使用find比较好。</p>\n<p>对于不允许重复关键字的容器，可能使用find还是count没什么区别。</p>\n<p><code>c.find(k)</code>返回一个迭代器,<code>c.count(k)</code>返回关键词等于k的元素的数量。</p>\n<p>对于允许重复关键字的容器，count会统计有多少个元素有相同的关键字。</p>\n<pre><code class=\"c++\">c.count(k);\nc.lower_bound(k);//返回一个迭代器，指向第一个关键词不小于k的元素\nc.upper_bound(k);//返回一个迭代器，指向第一个关键词大于k的元素\nc.equal_bound(k);//返回一个迭代器pair</code></pre>\n<h2 id=\"无序容器\"><a href=\"#无序容器\" class=\"headerlink\" title=\"无序容器\"></a>无序容器</h2><p>无序容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。</p>\n<p>在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。</p>\n<h1 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h1><p>我们的程序到目前为止只使用过静态内存或栈内存。</p>\n<ul>\n<li><p>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。</p>\n</li>\n<li><p>栈内存用来保存定义在函数内的非static对象。</p>\n</li>\n</ul>\n<p>分配在静态或栈内存中的对象由编译器自动创建和销毁。</p>\n<ul>\n<li><p>对于栈对象，仅在其定义的程序块运行时才存在。</p>\n</li>\n<li><p>static对象在使用之前分配，在程序结束时销毁。</p>\n</li>\n</ul>\n<p>除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象。</p>\n<p>动态对象的生存周期由程序来控制，当动态对象不再使用时，我们的代码必须显示地销毁它们。</p>\n<h2 id=\"动态内存与智能指针\"><a href=\"#动态内存与智能指针\" class=\"headerlink\" title=\"动态内存与智能指针\"></a>动态内存与智能指针</h2><p>C++中，动态内存的管理是通过一对运算符来完成的：</p>\n<ul>\n<li><p>new，在动态内存中为对象分配空间并返回一个指向该对象的指针。</p>\n</li>\n<li><p>delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>\n</li>\n</ul>\n<p>为了更容易（同时也更安全）地使用动态内存，新的标准提供了两种智能指针（smart pointer）类型来管理动态对象。</p>\n<p>智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针的区别在于管理底层指针的方式：</p>\n<ul>\n<li><p>shared_ptr允许多个指针指向同一个对象；</p>\n</li>\n<li><p>unique_ptr则“独占”所指向的对象。</p>\n</li>\n<li><p>标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。</p>\n</li>\n</ul>\n<p>这些类型定义在memory头文件中。</p>\n<h3 id=\"shared-ptr类\"><a href=\"#shared-ptr类\" class=\"headerlink\" title=\"shared_ptr类\"></a>shared_ptr类</h3><p>智能指针也是模板，当创建一个智能指针时，必须提供指向的类型：</p>\n<pre><code class=\"c++\">shared_ptr&lt;string&gt; p1; // shared_ptr, 可以指向string</code></pre>\n<p>默认初始化的智能指针中保存着一个空指针。</p>\n<p>解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：</p>\n<pre><code class=\"c++\">if (p1) *p1 = &quot;hi&quot;;</code></pre>\n<p><strong>make_shared函数</strong></p>\n<p>最安全的分配和使用动态内存的方法是调用标准库函数make_shared。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p>\n<pre><code class=\"c++\">// 指向一个值为42的int的shared_ptr\nshared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);\n\n// p6指向一个动态分配的空vector&lt;string&gt;\nauto p6 = make_shared&lt;vector&lt;string&gt;&gt;();</code></pre>\n<p>类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。</p>\n<p><strong>shared_ptr的拷贝和赋值</strong></p>\n<p>每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>\n<pre><code class=\"c++\">auto p = make_shared&lt;int&gt;(42); // p指向的对象只有p一个引用者\nauto q(p); // p和q指向相同的对象，此对象有两个引用者</code></pre>\n<p>可以认为每个shared_ptr都有一个关联的计数器，通常称其为<strong>引用计数</strong>(reference count)。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器就会递减。</p>\n<p>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</p>\n<p>!!!note<br>    到底是由一个计数器还是其他数据结构来记录有多少指针共享对象，完全由标准库的具体实现决定。关键是智能指针类能记录有多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象。</p>\n<p><strong>使用了动态生存期的资源的类</strong></p>\n<p>程序使用动态内存出于以下三种原因之一：</p>\n<ol>\n<li><p>程序不知道自己需要多少对象</p>\n</li>\n<li><p>程序不知道所需对象的准确类型</p>\n</li>\n<li><p>程序需要在多个对象间共享数据</p>\n</li>\n</ol>\n<p>容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因的例子。本章介绍出于第三种原因的例子。</p>\n<h3 id=\"直接管理内存\"><a href=\"#直接管理内存\" class=\"headerlink\" title=\"直接管理内存\"></a>直接管理内存</h3><p>C++提供了new运算符分配内存，delete运算符释放new分配的内存。</p>\n<p>相对于智能指针，使用这两个运算符管理内存非常容易出错。</p>\n<p><strong>使用new动态分配和初始化对象</strong></p>\n<p>在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：</p>\n<pre><code class=\"c++\">int *pi = new int; // pi指向一个动态分配的、未初始化的无名对象</code></pre>\n<p>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型将使用默认构造函数进行初始化。</p>\n<p>可以使用直接初始化方式来初始化一个动态分配的对象：</p>\n<pre><code class=\"c++\">int *pi = new int(1024);\n\nvector&lt;int&gt; *pv = new vector&lt;int&gt;{1, 2, 3};</code></pre>\n<p><strong>动态分配的const对象</strong></p>\n<p>用new分配const对象是合法的：</p>\n<pre><code class=\"c++\">const int *pci = new const int(1024);</code></pre>\n<p>类似其他任何const对象，一个动态分配的const对象必须进行初始化。</p>\n<p><strong>内存耗尽</strong></p>\n<p>一旦一个程序用光了它所有可用的内存，new表达式就会失败（并返回一个空指针）。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。</p>\n<p>我们可以改变使用new的方式来阻止它抛出异常：</p>\n<pre><code class=\"c++\">// 如果分配失败，new返回一个空指针\nint *p1 = new int; // 如果分配失败，new抛出std::bad_alloc\nint *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针</code></pre>\n<p><strong>释放动态内存</strong></p>\n<p>为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过delete表达式（delete expression）来将动态内存归还给系统。</p>\n<pre><code class=\"c++\">delete p; // p必须指向一个动态分配的对象或是一个空指针</code></pre>\n<p><strong>指针值和delete</strong><br>释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</p>\n<pre><code class=\"c++\">int i，*pil=&amp;i，*pi2=nullptr;\ndouble*pd = new double(33)，*pd2=pd;\ndelete i；//错误：i不是一个指针\ndelete pi1；//未定义；pi1指向一个局部变量\ndelete pd；//正确\ndelete pd2；//未定义：pd2指向的内存已经被释放了\ndelete pi2；//正确：释放一个空指针总是没有错误的</code></pre>\n<p><strong>动态对象的生存期直到被释放时为止</strong></p>\n<p>如12.1.1节（第402页）所述，由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个由内置指针管理的动态对象，直到被显式释放之前它都是存在的。</p>\n<p>返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担—调用者必须记得释放内存：</p>\n<pre><code class=\"c++\">//factory返回一个指针，指向一个动态分配的对象\nFoo* factory(T arg){\n    //视情况处理arg\n    return new Foo(arg);//调用者负责释放此内存\n}\n</code></pre>\n<pre><code>使用new和delete管理动态内存存在三个常见问题：\n1.忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。\n2.使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。\n3.同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。相对于查找和修正这些错误来说，制造出这些错误要简单得多。</code></pre><h3 id=\"shared-ptr和new结合使用\"><a href=\"#shared-ptr和new结合使用\" class=\"headerlink\" title=\"shared_ptr和new结合使用\"></a>shared_ptr和new结合使用</h3><p>如果不初始化一个智能指针，它就会被初始化为一个空指针。还可以用new返回的指针来初始化智能指针：</p>\n<pre><code class=\"c++\">shared_ptr&lt;int&gt; p2(new int(42)); // p2指向一个值为42的int</code></pre>\n<p>接受指针参数的智能指针构造函数是explicit的，因此必须使用直接初始化形式来初始化一个智能指针：</p>\n<pre><code class=\"c++\">shared_ptr&lt;int&gt; p1 = new int(1024); // 错误：必须使用直接初始化形式\nshared_ptr&lt;int&gt; p2(new int(1024));  // 正确：使用了直接初始化形式</code></pre>\n<p>p1的初始化隐式地要求编译器用一个new返回的int*来创建一个shared_ptr。由于我们不能进行内置指针到智能指针间的隐式转换，因此这条初始化语句是错误的。出于相同的原因，一个返回 shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：</p>\n<pre><code class=\"c++\">shared ptr&lt;int&gt;clone(int p){\nreturn new int(p)；//错误：隐式转换为shared ptr&lt;int&gt;\n}</code></pre>\n<p>我们必须将shared_ptr显式绑定到一个想要返回的指针上：</p>\n<pre><code class=\"c++\">shared ptr&lt;int&gt;clone(int p){\n//正确：显式地用int*创建 shared ptr&lt;int&gt;\nreturn shared_ptr&lt;int&gt;(new int(p))；\n}</code></pre>\n<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象（可以提供自己的操作来替代delete）。</p>\n<p>更多关于智能指针使用的讨论见p412。</p>\n<h3 id=\"智能指针和异常\"><a href=\"#智能指针和异常\" class=\"headerlink\" title=\"智能指针和异常\"></a>智能指针和异常</h3><p>程序需要确保在异常发生后资源能被正确地释放。一个简单的确保资源被释放的方法是使用智能指针：</p>\n<pre><code class=\"c++\">void f()\n{\n    shared_ptr&lt;int&gt; sp(new int(42)); // 分配一个对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n} // 函数结束时shared_ptr自动释放内存</code></pre>\n<p>无论是否发生了异常，局部对象都会被销毁，sp是指向这块内存的唯一指针，因此内存会被释放掉。</p>\n<p>如果使用了内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：</p>\n<pre><code class=\"c++\">void f()\n{\n    int *ip = new int(42); // 动态分配一个新对象\n    // 这段代码抛出一个异常，且在f中未被捕获\n    delete ip; // 在退出以前释放内存\n}</code></pre>\n<p>如果在new和delete之间发生了异常，且异常未在f中被捕获，则内存就永远不会被释放了。</p>\n<p><strong>使用我们自己的释放操作</strong></p>\n<p>这里给一个简单的定义删除器的例子，而具体的讨论见书本p416。</p>\n<pre><code class=\"c++\">auto deleter = [](int* p)\n{   \n    std::cout &lt;&lt; &quot;delete data: &quot; &lt;&lt; *p &lt;&lt; std::endl;\n    delete p;\n};  \n\nstd::shared_ptr&lt;int&gt; p(new int(42), deleter);</code></pre>\n<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：</p>\n<p>-. 不使用相同的内置指针值初始化（或reset）多个智能指针。<br>-. 不delete get（）返回的指针。<br>-. 不使用get（）初始化或reset另一个智能指针。<br>-. 如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。<br>-. 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（参见12.1.4节，第415页和12.1.5节，第419页）。</p>\n<h3 id=\"unique-ptr\"><a href=\"#unique-ptr\" class=\"headerlink\" title=\"unique_ptr\"></a>unique_ptr</h3><p>与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p>\n<p>与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。</p>\n<pre><code class=\"c++\">unique_ptr&lt;double&gt; p1; // 可以指向一个double的unique_ptr\nunique_ptr&lt;int&gt; p2(new int(42)); // p2指向一个值为42的int</code></pre>\n<p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。</p>\n<p>更多有关unique_ptr操作的讨论见p418。</p>\n<h3 id=\"weak-ptr\"><a href=\"#weak-ptr\" class=\"headerlink\" title=\"weak_ptr\"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指对象生存期的智能指针，它指向一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象还是会被释放。</p>\n<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：</p>\n<pre><code class=\"c++\">auto p = make_shared&lt;int&gt;(42);\nweak_ptr&lt;int&gt; wp(p); // wp若共享p；p的引用计数未改变</code></pre>\n<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。如果存在，lock返回一个指向共享对象的shared_ptr。否则返回一个空shared_ptr。</p>\n<pre><code class=\"c++\">if (shared_ptr&lt;int&gt; np = wp.lock()) { // 如果np不为空则条件成立\n    // 在if中，np与p共享对象\n}</code></pre>\n<h2 id=\"动态数组\"><a href=\"#动态数组\" class=\"headerlink\" title=\"动态数组\"></a>动态数组</h2><p>C++语言和标准库提供了两种一次分配一个对象数组的方法：</p>\n<ul>\n<li><p>一种new表达式语法，可以分配并初始化一个对象数组。</p>\n</li>\n<li><p>标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</p>\n</li>\n</ul>\n<p>!!!note<br>    大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</p>\n<h3 id=\"new和数组\"><a href=\"#new和数组\" class=\"headerlink\" title=\"new和数组\"></a>new和数组</h3><p>为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目：</p>\n<pre><code class=\"c++\">// 调用get_size确定分配多少个int\nint *pia = new int[get_size()]; // pia指向第一个int</code></pre>\n<p>方括号中的大小必须是整型，但不必是常量。</p>\n<p><strong>分配一个数组会得到一个元素类型的指针</strong></p>\n<p>当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。</p>\n<p>!!!note<br>    要记住我们所说的动态数组并不是数组类型，这是很重要的。</p>\n<p><strong>初始化动态分配对象的数组</strong></p>\n<p>默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号：</p>\n<pre><code class=\"c++\">int *pia = new int[10]; // 10个未初始化的int\nint *pia2 = new int[10](); // 10个值初始化为0的int</code></pre>\n<p>新标准中，我们还可以提供一个元素初始化器的花括号列表：</p>\n<pre><code class=\"c++\">// 10个int分别用列表中对应的初始化器初始化\nint *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};</code></pre>\n<p><strong>释放动态数组</strong></p>\n<p>为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对：</p>\n<pre><code class=\"c++\">delete p; // p必须指向一个动态分配的对象或为空\ndelete [] pa; // pa必须指向一个动态分配的数组或为空</code></pre>\n<p>数组的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。</p>\n<p><strong>智能指针和动态数组</strong></p>\n<p>标准库提供了一个可以管理new分配的数组的unique_ptr版本：</p>\n<pre><code class=\"c++\">// up指向一个包含10个未初始化int的数组\nunique_ptr&lt;int[]&gt; up(new int[10]);\nup.release(); // 自动用delete[]销毁其指针</code></pre>\n<blockquote>\n<p>my note: 这里似乎有错误，release方法据p418介绍，是放弃对指针的控制权，返回指针。并不销毁原来指向的对象。另一个事例见：<a href=\"http://zh.cppreference.com/w/cpp/memory/unique_ptr/release\" target=\"_blank\" rel=\"noopener\">http://zh.cppreference.com/w/cpp/memory/unique_ptr/release</a></p>\n</blockquote>\n<p>当unique_ptr销毁时，会自动销毁其指向的对象。</p>\n<h3 id=\"allocator类\"><a href=\"#allocator类\" class=\"headerlink\" title=\"allocator类\"></a>allocator类</h3><p>new和delete有一些灵活性上的局限：</p>\n<ul>\n<li><p>new将内存分配和对象构造组合在了一起。</p>\n</li>\n<li><p>delete将对象析构和内存释放组合在了一起。</p>\n</li>\n</ul>\n<p>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。</p>\n<p><strong>allocator类</strong></p>\n<p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它分配的内存是原始的、未构造的。</p>\n<p>allocator也是模板，为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定对象类型来确定恰当的内存大小和对齐位置：</p>\n<pre><code class=\"c++\">allocator&lt;string&gt; alloc; // 可以分配string的allocator对象\nauto const p = alloc.allocate(n); // 分配n个未初始化的string</code></pre>\n<p><strong>allocator分配未构造的内存</strong></p>\n<p>allocator分配的内存是未构造的（unconstructed）。我们按需要在此内存中构造对象。</p>\n<pre><code class=\"c++\">auto q = p; // q指向最后构造元素之后的位置\nalloc.construct(q++); // *q为空字符串\nalloc.construct(q++, &quot;hi&quot;); // *q为hi!</code></pre>\n<p>还未构造对象的情况下就使用原始内存是错误的。</p>\n<p>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。</p>\n<pre><code class=\"c++\">while (q != p)\n    alloc.destroy(--q); // 释放我们真正构造的string</code></pre>\n<p>一旦元素被销毁后，就可以重新用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：</p>\n<pre><code class=\"c++\">alloc.deallocate(p, n);</code></pre>\n<p>我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。</p>\n<p><strong>拷贝和填充未初始化内存的算法</strong></p>\n<p>标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。见p429。</p>\n<h1 id=\"拷贝控制\"><a href=\"#拷贝控制\" class=\"headerlink\" title=\"拷贝控制\"></a>拷贝控制</h1><p>一个类通过定义五种特殊的成员函数来控制拷贝、移动、复制、销毁这些操作，包括：<strong>拷贝构造函数、拷贝赋值函数、移动赋值函数、移动构造函数和析构函数。</strong></p>\n<h2 id=\"拷贝、赋值、销毁\"><a href=\"#拷贝、赋值、销毁\" class=\"headerlink\" title=\"拷贝、赋值、销毁\"></a>拷贝、赋值、销毁</h2><h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>拷贝构造函数的第一个参数是自身的应用，且额外参数都有默认值。</p>\n<p><code>拷贝构造函数的第一个参数必须是一个引用类型。</code></p>\n<pre><code class=\"c++\">class Foo{\npublic:\n    Foo();//默认构造函数\n    Foo(const Foo&amp;);//拷贝构造函数\n};</code></pre>\n<p><strong>拷贝构造函数通常不应该是explicit的。</strong></p>\n<h3 id=\"合成拷贝构造函数\"><a href=\"#合成拷贝构造函数\" class=\"headerlink\" title=\"合成拷贝构造函数\"></a>合成拷贝构造函数</h3><p>对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。</p>\n<pre><code class=\"c++\">class Sales_data{\npublic:\n    Sales_data(const Sales_data&amp;)//合成拷贝构造函数\nprivate:\n    string BookNo;\n    int units_sold = 0;\n    double revenue = 0.0;\n};\n//与Sales_data的合成的拷贝构造函数等价\nSales_data::Sales_data(const Sales_data &amp;orig):\n                                                BookNo(orig.BookNo),\n                                                units_sold(orig.units_sold),\n                                                revenue(orig.revenue)\n{}</code></pre>\n<p><strong>拷贝初始化</strong></p>\n<p>拷贝初始化通常使用拷贝构造函数完成（有时候为移动构造函数）。</p>\n<p>拷贝初始化不仅在我们用=定义变量时发生，在下列情况下也会发生：</p>\n<p>*. 将一个对象作为实参传递给一个非引用类型的形参</p>\n<p>*. 从一个返回类型为非引用类型的函数返回一个对象</p>\n<p>*. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员</p>\n<p><strong>参数和返回值</strong></p>\n<p>当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。</p>\n<p><strong>拷贝初始化的限制</strong></p>\n<pre><code class=\"c++\">vector&lt;int&gt; v1(10)//正确：直接初始化\nvector&lt;int&gt; v2=10;//错误，接受大小参数的构造函数是显式的\nvoid f(vector&lt;int&gt;);//f的参数进行拷贝初始化\nf(10);//错误；不能用一个显式的构造函数拷贝一个实参\nf(vector&lt;int&gt;(10));//正确，从一个int直接构造一个临时的vector</code></pre>\n<p><strong>编译器可以绕过构造函数</strong></p>\n<p>在拷贝初始化的过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。例如：</p>\n<pre><code class=\"c++\">string null_book=&quot;9-999-999999-9&quot;;//拷贝初始化\nstring null_book(&quot;9-999-999999-9&quot;);//编译器绕过了拷贝构造函数</code></pre>\n<h3 id=\"拷贝赋值运算符\"><a href=\"#拷贝赋值运算符\" class=\"headerlink\" title=\"拷贝赋值运算符\"></a>拷贝赋值运算符</h3><p><strong>重载赋值运算符</strong></p>\n<p>重载赋值运算符本质是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。</p>\n<pre><code class=\"c++\">class Foo{\npublic:\n    Foo&amp; operator=(const Foo&amp;);//赋值运算符\n//...\n}</code></pre>\n<p>为了与内置运算符保持一致性，赋值运算符通常返回一个指向其左侧运算对象的引用。</p>\n<p><strong>合成拷贝赋值运算符</strong></p>\n<p>如果一个类未定义自己的拷贝赋值运算符，编译器会为它合成一个。合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员。对于数组类型的成员，逐个赋值数组元素。</p>\n<pre><code class=\"c++\">Sales_data&amp;\nSales_data::operator=(const Sales_data &amp;rhs){\n    BookNo = rhs.BookNo;\n    units_sold = rhs.units_sold;\n    revenue = rhs.revenue;\n    return *this;\n}</code></pre>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他的工作，析构函数释放对象使用的资源，并销毁对象的非static数据成员。</p>\n<p>析构函数没有返回值，也不接受参数。</p>\n<p><strong>析构函数完成什么工作</strong></p>\n<p>在一个人构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序执行。</p>\n<p>通常，析构函数释放对象在生存期分配的所有资源。</p>\n<pre><code>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。</code></pre><p><strong>什么时候会调用析构函数</strong></p>\n<p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>\n<ol>\n<li><p>变量离开其作用域时被销毁</p>\n</li>\n<li><p>当一个对象被销毁时，其成员被销毁</p>\n</li>\n<li><p>容器被销毁时，其元素被销毁</p>\n</li>\n<li><p>对于动态分配的对象，当指向它的指针应用delete运算符时被销毁</p>\n</li>\n<li><p>对于临时对象，当创建它的完整表达式时被销毁</p>\n<p> 当一个指向对象的引用或者指针离开作用域时，析构函数不会执行。</p>\n</li>\n</ol>\n<p><strong>合成析构函数</strong></p>\n<p>当一个类未定义自己的析构函数时，编译器便会自动为它自动定义一个合成析构函数。</p>\n<h3 id=\"三-五法则\"><a href=\"#三-五法则\" class=\"headerlink\" title=\"三/五法则\"></a>三/五法则</h3><pre><code>如果一个函数需要自定义析构函数，几乎可以肯定他也需要自定义拷贝赋值运算符合拷贝构造函数。</code></pre><p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong></p>\n<h3 id=\"使用default\"><a href=\"#使用default\" class=\"headerlink\" title=\"使用default\"></a>使用default</h3><p>我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。</p>\n<h3 id=\"阻止拷贝\"><a href=\"#阻止拷贝\" class=\"headerlink\" title=\"阻止拷贝\"></a>阻止拷贝</h3><pre><code>大多数类应该定义拷贝构造函数、构造函数和拷贝赋值运算符，无论是显式地还是隐式的。</code></pre><p><strong>定义删除的函数</strong></p>\n<p>我们可以通过将拷贝构造函数和拷贝赋值函数定义为删除的函数来阻止拷贝。删除的函数是这样的函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：</p>\n<pre><code class=\"c++\">struct NoCopy{\nNoCopy()=default;\nNoCopy(const NoCopy&amp;)=delete;//阻止拷贝；\n}</code></pre>\n<p>还可以对任何函数指定=delete。</p>\n<p><strong>析构函数不能是删除的函数</strong></p>\n<p>如果析构函数被删除，就无法销毁此类对象。对于一个删除了析构函数的类型（或者其某个成员删除了析构函数），编译器将不允许定义该类型的变量或创建该类型的临时对象。</p>\n<p><strong>合成的拷贝控制成员可能是删除的</strong></p>\n<p>对于某些类来说，编译器会把一些合成的成员定义为删除的函数。其规则是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>\n<p><strong>private拷贝控制</strong></p>\n<p>在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。为了阻止友元和成员函数访问私有成员，就不定义这些成员。</p>\n<h2 id=\"拷贝控制和资源管理\"><a href=\"#拷贝控制和资源管理\" class=\"headerlink\" title=\"拷贝控制和资源管理\"></a>拷贝控制和资源管理</h2><p>通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>\n<p>为了定义这些成员，必须先确定类对象的拷贝语义。一般有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p>\n<p>类的行为像一个值，意味着它应该有自己的状态。当拷贝一个对象时，副本和原对象是完全独立的。改变副本不会影响原对象，反之亦然。</p>\n<p>类的行为像一个指针，意味着拷贝一个对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。</p>\n<h3 id=\"行为像值的类\"><a href=\"#行为像值的类\" class=\"headerlink\" title=\"行为像值的类\"></a>行为像值的类</h3><p>对于类管理的资源，每个对象都应该拥有一份自己的拷贝。</p>\n<p>为了实现类值的行为，HasPtr需要：</p>\n<ul>\n<li><p>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针</p>\n</li>\n<li><p>定义一个析构函数来释放string</p>\n</li>\n<li><p>定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string</p>\n</li>\n</ul>\n<p><strong>类值拷贝赋值运算符</strong></p>\n<p>一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧对象的现有成员就是安全的了。接着再将数据从临时对象拷贝到左侧运算对象的成员中。</p>\n<p>这样就可以正确进行自赋值操作。</p>\n<h3 id=\"定义行为像指针的类\"><a href=\"#定义行为像指针的类\" class=\"headerlink\" title=\"定义行为像指针的类\"></a>定义行为像指针的类</h3><p>这种情况下，HasPtr仍然需要通过析构函数来释放string。但只有当最后一个指向string的HasPtr对象销毁时，它才可以释放string。</p>\n<p>令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。shared_ptr类自己会记录有多少用户共享它所指向的对象，当没有用户使用对象时，shared_ptr类负责释放资源。</p>\n<p>但是有时候我们希望直接管理资源，这种情况下，可以使用<strong>引用计数（reference count）</strong>。</p>\n<p><strong>引用计数</strong></p>\n<p>引用计数的工作方式如下：</p>\n<ul>\n<li><p>除了初始化对象外，每个构造函数（除了拷贝构造函数）还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。计数器初始化为1。</p>\n</li>\n<li><p>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。</p>\n</li>\n<li><p>析构函数递减计数器，如果变为0，则析构函数释放状态。</p>\n</li>\n<li><p>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。</p>\n</li>\n</ul>\n<p>引用计数应该保存在动态内存中，这样才能保证共享引用计数。</p>\n<h2 id=\"交换操作\"><a href=\"#交换操作\" class=\"headerlink\" title=\"交换操作\"></a>交换操作</h2><p>管理资源的类通常还定义一个名为swap的函数。一些算法会在需要交换两个元素时调用swap。</p>\n<p>如果一个类定义了自己的swap，那么算法将使用类自定义的版本。否则算法将使用标准库定义的swap。标准库定义的版本可能像这样：</p>\n<pre><code class=\"c++\">HasPtr temp = v1;\nv1 = v2;\nv2 = temp;</code></pre>\n<p>但对于HasPtr这样管理外部资源的类，可以直接交换指针，而不是分配多一个副本。</p>\n<pre><code class=\"c++\">string *temp = v1.ps;\nv1.ps = v2.ps;\nv2.ps = temp;</code></pre>\n<p>swap函数的存在是为了优化代码。详细定义方法见书本。</p>\n<p><strong>在赋值运算符中使用swap</strong></p>\n<p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为<strong>拷贝并交换（copy and swap）</strong>的技术。</p>\n<pre><code class=\"c++\">HasPtr &amp;HasPtr::operator=(HasPtr rhs)\n{\n    swap(*this, rhs);\n    return *this;\n}</code></pre>\n<p>rhs是右侧运算对象的一个副本，它会在赋值运算符结束时被自动销毁。</p>\n<p>这种技术自动处理了自赋值的情况且天然就是异常安全的。</p>\n<h2 id=\"拷贝控制示例\"><a href=\"#拷贝控制示例\" class=\"headerlink\" title=\"拷贝控制示例\"></a>拷贝控制示例</h2><p>见习题练习13.33-13.38。</p>\n<h2 id=\"动态内存管理类\"><a href=\"#动态内存管理类\" class=\"headerlink\" title=\"动态内存管理类\"></a>动态内存管理类</h2><p>再看看！</p>\n<h2 id=\"对象移动\"><a href=\"#对象移动\" class=\"headerlink\" title=\"对象移动\"></a>对象移动</h2><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在很多情况下，对象拷贝后就立即销毁了，这种情况下，使用移动而非拷贝会大幅提升性能。</p>\n<p>使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（指针或IO缓冲）。因此，这些类的对象不能拷贝但可以移动。</p>\n<h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><p>为了支持移动操作，新标准引入了一种新的类型——<strong>右值引用（rvalue reference）</strong>。右值引用必须绑定到右值——一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源移动到另一个对象中。</p>\n<pre><code class=\"c++\">int i = 42;\nint &amp;r = i;    // 正确：r引用i\nint &amp;&amp;rr = i;  // 错误：不能将一个右值引用绑定到一个左值上\nconst int &amp;r3 = i*42;//正确：我们可以将一个const的引用绑定到一个右值上\nint &amp;&amp;r2 = i * 42; // 正确：将rr2绑定到乘法结果上</code></pre>\n<p><strong>左值持久，右值短暂</strong></p>\n<p>左值与右值的区别：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>\n<p>由于右值引用只能绑定到临时对象，我们得知：</p>\n<p>*. 所引用的对象将要被销毁</p>\n<p>*. 该对象没有其他用户</p>\n<p>这两个特性意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。</p>\n<p><strong>变量是左值</strong></p>\n<p>变量可以看作只有一个运算对象而没有运算符的表达式。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。</p>\n<p>因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上：</p>\n<pre><code class=\"c++\">int &amp;&amp;rr1 = 42;     // 正确：字面常量是右值\nint &amp;&amp;rr2 = rr1;    // 错误：表达式rr1是左值！</code></pre>\n<pre><code>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行，</code></pre><p><strong>标准库move函数</strong></p>\n<p>虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用。</p>\n<pre><code class=\"c++\">int &amp;&amp;rr3 = std::move(i); // OK</code></pre>\n<p>move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用move就意味着承诺：除了对i赋值或销毁它外，我们将不再使用它。</p>\n<pre><code>我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。\n使用move的代码应该是std::move而不是move。</code></pre><h3 id=\"移动构造函数和移动赋值运算符\"><a href=\"#移动构造函数和移动赋值运算符\" class=\"headerlink\" title=\"移动构造函数和移动赋值运算符\"></a>移动构造函数和移动赋值运算符</h3><p>移动的版本从给定对象“窃取”资源而不是拷贝资源。</p>\n<p>移动构造函数的第一个参数是该类型的一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。</p>\n<p>除了完成资源的移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。</p>\n<pre><code class=\"c++\">StrVec::StrVec(StrVec &amp;&amp;s) noexcpet // 移动构造函数不应抛出异常\n // 成员初始化器接管s中的资源\n : elements(s.elements), first_free(s.first_free), cap(s.cap)\n{\n    // 令s进入这样的状态——对其运行析构函数是安全的\n    s.elements = s.first_free = s.cap = nullptr;\n}</code></pre>\n<p><strong>移动操作、标准库容器和异常</strong></p>\n<p>移动操作通常不分配资源，因此通常不会抛出异常，我们应当将此事通知标准库。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。</p>\n<p>通知的方法是在构造函数中指明noexcept。</p>\n<pre><code class=\"c++\">class StrVec{\npublic:\n    StrVec(StrVec&amp;&amp; ) noexcept;//移动构造函数 \n};\nStrVec::StrVec(StrVec &amp;&amp;s) noexcept:/*成员初始化器*/\n{/*构造函数体*/}</code></pre>\n<p><strong>移动赋值运算符</strong></p>\n<p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：</p>\n<pre><code class=\"c++\">StrVec&amp; StrVec::operator=(StrVec &amp;&amp;rhs) noexcept\n{\n    // 直接检测自赋值\n    if (this != &amp;rhs) {\n        free();    // 释放已有资源\n        elements = rhs.elements; // 接管资源\n        first_free = rhs.first_free;\n        cap = rhs.cap;\n        // 将rhs置于可析构状态\n        rhs.elements = rhs.first_free = rhs.cap = nullptr;\n    }\n    return *this;\n}</code></pre>\n<p><strong>移后源对象必须可析构</strong></p>\n<p>从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。</p>\n<p>除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的，即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。但是移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。</p>\n<pre><code>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</code></pre><p><strong>合成的移动操作</strong></p>\n<p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</p>\n<p>如果类定义了一个移动构造函数或一个移动赋值运算符，则该类的拷贝版本会被定义为删除的。</p>\n<p><strong>移动右值，拷贝左值</strong></p>\n<p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。</p>\n<pre><code class=\"c++\">StrVec v1, v2;\nv1 = v2;                    // v2是左值，使用拷贝赋值\nStrVec getVec(istream&amp;);    // getVec返回一个右值\nv2 = getVec(cin);           // getVec(cin)是一个右值；使用移动赋值</code></pre>\n<p><strong>更新三/五法则</strong></p>\n<p>所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p>\n<h3 id=\"右值引用和成员函数\"><a href=\"#右值引用和成员函数\" class=\"headerlink\" title=\"右值引用和成员函数\"></a>右值引用和成员函数</h3><p>除了构造函数和赋值运算符之外，成员函数也可以提供拷贝和移动的版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。</p>\n<pre><code class=\"c++\">void push_back(const X&amp;);   // 拷贝：绑定到任意类型的X\nvoid push_back(X&amp;&amp;);        // 移动：只能绑定到类型X的可修改的右值</code></pre>\n<p><strong>右值和左值引用成员函数</strong></p>\n<p>我们可以强制左侧运算对象是一个左值。</p>\n<p>我们指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个<strong>引用限定符（reference qualifier）</strong>。</p>\n<pre><code class=\"c++\">class Foo {\npublic:\n    Foo &amp;operator=(const Foo&amp;) &amp;;   // 只能向可修改的左值赋值\n};</code></pre>\n<p>引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值。如果存在const限定符，引用限定符必须跟随在const限定符之后。</p>\n<p><strong>重载和引用函数</strong></p>\n<p>我们可以综合引用限定符和const来区分一个成员函数的重载版本。</p>\n<pre><code class=\"c++\">class Foo{\npublic:\n    Foo sorted() &amp;&amp;;//可用于可改变的右值\n    Foo sorted() const &amp;;//可用于任何类型的Foo\nprivate:\n    vector&lt;int&gt; data;\n};\n//本对象为右值，因此可以原址排序\nFoo Foo::sorted() &amp;&amp;\n{\n    sort(data.begin(),data.end());\n    return *this;\n}\n//本对象是一个左值或者一个const，哪种情况我们都不能对其进行原址排序\nFoo Foo::sorted() const &amp;{\n    Foo ret(*this);\n    sort(ret.data.begin(),ret.data.end());\n    return ret;\n}</code></pre>\n<pre><code>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</code></pre><h1 id=\"重载运算和类型转换\"><a href=\"#重载运算和类型转换\" class=\"headerlink\" title=\"重载运算和类型转换\"></a>重载运算和类型转换</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>重载运算符是具有特殊名字的函数：他们的名字由关键字operator和其后要定义的运算符号组成。重载运算符也包含返回类型，参数列表以及函数体。</p>\n<pre><code>当一个运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。</code></pre><p>对于一个运算符函数来是哦，它或者是类的成员，或者至少含有一个类型的参数：</p>\n<pre><code class=\"c++\">//错误，不能为int重定义内置的运算符\nint operator+(int,int);</code></pre>\n<p>不能被重载的运算符： .* :: . ? ：</p>\n<p><strong>直接调用一个重载的运算符函数</strong></p>\n<p>调用方法如下：</p>\n<pre><code class=\"c++\">//一个非成员运算符的等价调用\ndata1+data2;//普通的表达式\noperator+(data1,data2);//等价的函数调用\ndata1 += data2;//基于调用的表达式\ndata1.operator+=(data2);//对成员运算符函数的等价调用</code></pre>\n<p>将this绑定到data1的位置，将data2作为实参传入函数。</p>\n<p><strong>某些运算符不应该被重载</strong></p>\n<pre><code>通常情况下不应该重载逗号，取地址，逻辑与和逻辑或运算符。</code></pre><p><strong>使用与内置类型一致的含义</strong></p>\n<p><strong>选择作为成员或者非成员函数</strong></p>\n<p>有的运算符必须作为成员，另一些情况下，运算符作为非成员更好：</p>\n<ol>\n<li><p>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符必须作为成员；</p>\n</li>\n<li><p>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值略有不同；</p>\n</li>\n<li><p>递增、递减和解引用运算符，一般应该是成员；</p>\n</li>\n<li><p>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该时普通的非成员函数。</p>\n</li>\n</ol>\n<pre><code class=\"c++\">string s = &quot;world&quot;;\nstring t = s + &quot;!&quot;;//正确，我们能把一个const char*加到一个string中等价于s.operator+(&quot;!&quot;)\nstring u = &quot;Hi&quot; + s;//错误，等价于：&quot;Hi&quot;.operator+(s),hi的类型是const char* ，这是一种内置类型，没有成员函数</code></pre>\n<h2 id=\"输入和输出运算符\"><a href=\"#输入和输出运算符\" class=\"headerlink\" title=\"输入和输出运算符\"></a>输入和输出运算符</h2><h3 id=\"重载输出运算符-lt-lt\"><a href=\"#重载输出运算符-lt-lt\" class=\"headerlink\" title=\"重载输出运算符&lt;&lt;\"></a>重载输出运算符&lt;&lt;</h3><p>第一个形参通常是一个非常量的ostream对象的引用，之所以ostream是非常量是因为向流写入内容会改变其状态，而引用该形参是因为我们没法直接复制一个ostream对象。</p>\n<p>第二个形参通常是一个常量的引用，该常量是我们要输出的类类型。</p>\n<p>为了与其他输出运算符保持一致，operator&lt;&lt;通常返回它的ostream形参。例如：</p>\n<pre><code class=\"c++\">class Salas_data{\nfriend std::ostream&amp; operator&lt;&lt;(ostream&amp;, const Salas_data&amp;);\nfriend std::ostream&amp; operator&gt;&gt;(istream&amp;, const Salas_data&amp;);\n};</code></pre>\n<pre><code>通常，输出运算符不应该打印换行符，主要负责输出打印的对象而非格式。</code></pre><p><strong>输出输出运算符必须是非成员函数</strong></p>\n<h3 id=\"重载输入运算符-gt-gt\"><a href=\"#重载输入运算符-gt-gt\" class=\"headerlink\" title=\"重载输入运算符&gt;&gt;\"></a>重载输入运算符&gt;&gt;</h3><p>通常情况下，输入运算符的第一个实参为将要读取的流的引用，第二个形参为将要读入到的（非常量）对象的引用。该运算符会返回某个流的引用。</p>\n<pre><code>输入运算符必须处理输入失败的问题，而输出运算符不需要。</code></pre><h2 id=\"算术和关系运算符\"><a href=\"#算术和关系运算符\" class=\"headerlink\" title=\"算术和关系运算符\"></a>算术和关系运算符</h2><p>通常我们把算术和关系运算符作为非成员函数以允许对左侧和右侧的运算对象进行转换。形参都是常量的引用。</p>\n<pre><code class=\"c++\">Salas_data operator+(const Salas_data &amp;lhs,const Salas_data &amp;rhs){\n    Salas_data sum = lhs;\n    sum += rhs;\n    return sum;\n}</code></pre>\n<pre><code>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值运算符来实现。</code></pre><h3 id=\"相等运算符\"><a href=\"#相等运算符\" class=\"headerlink\" title=\"相等运算符\"></a>相等运算符</h3><pre><code class=\"c++\">bool operator==(const Sales_data &amp;lhs, const Sales_data &amp;rhs)\n{\n    return lhs.isbn() == rhs.isbn() &amp;&amp;\n           lhs.units_sold == rhs.units_sold &amp;&amp;\n           lhs.revenue == rhs.revenue;\n}\n\nbool operator!=(const Sales_data &amp;lhs, const Sales_data &amp;rhs)\n{\n    return !(lhs == rhs);\n}</code></pre>\n<h3 id=\"关系运算符-1\"><a href=\"#关系运算符-1\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>如果一个类不存在一种逻辑可靠的&lt;定义，这个类不定义&lt;运算符也许更好。</p>\n<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><p>之前介绍了拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。</p>\n<p>比如：</p>\n<pre><code class=\"c++\">vector&lt;string&gt; v;\nv = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};</code></pre>\n<pre><code class=\"c++\">class StrVec {\npublic:\n    StrVec&amp; operator=(std::initializer_list&lt;std::string&gt;)\n    {\n        // ...\n    }\n};</code></pre>\n<pre><code>赋值运算符必须为成员函数。</code></pre><h3 id=\"复合赋值运算符\"><a href=\"#复合赋值运算符\" class=\"headerlink\" title=\"复合赋值运算符\"></a>复合赋值运算符</h3><pre><code>赋值运算符必须为成员函数，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</code></pre><pre><code class=\"c++\">// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针\nSales_data&amp; Sales_data::operator+=(const Sales_data &amp;rhs)\n{\n    units_sold += rhs.units_sold;\n    revenue += rhs.revenue;\n    return *this;\n}</code></pre>\n<h3 id=\"下标运算符\"><a href=\"#下标运算符\" class=\"headerlink\" title=\"下标运算符\"></a>下标运算符</h3><p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。</p>\n<pre><code>下标运算符必须是成员函数。</code></pre><p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。最好同时定义下标运算符的常量版本和非常量版本，当用作于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。</p>\n<pre><code class=\"c++\">class StrVec {\npublic:\n    std::string&amp; operator[](std::size_t n) { return elements[n]; }\n\n    const std::string&amp; operator[](std::size_t n) const { return elements[n]; }\n\nprivate:\n    std::string *elements;    // 指向数组首元素的指针\n};</code></pre>\n<h2 id=\"递增递减运算符\"><a href=\"#递增递减运算符\" class=\"headerlink\" title=\"递增递减运算符\"></a>递增递减运算符</h2><p>在迭代器类中通常会实现递增运算符++和递减运算符–，这两种运算符使得类可以在元素的序列中前后移动。</p>\n<p>对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。</p>\n<pre><code class=\"c++\">class StrBlobPtr {\npublic:\n    StrBlobPtr&amp; operator++();        // 前置运算符\n    StrBlobPtr&amp; operator--();\n};</code></pre>\n<pre><code class=\"c++\">//前置版本：返回递增递减对象的引用\nStrBlobPtr&amp; StrBlobPtr::operator++(){\n//如果curr已经指向了容器的尾后位置，则无法递增它\n    check(curr, &quot;increment past end of StrBlobPtr &quot;)\n    ++curr;    //将curr在当前状态下向前移动一个元素\n    return *this;\n}\n\nStrBlobPtr&amp; StrBlobPtr::operator--(){\n    //如果curr是0，则继续递减它将产生一个无效下标\n    --curr;        //将curr在当前状态下向后移动一个元素\n    check(curr, &quot;decrement past begin of StrBlobPtr&quot;);\n    return *this;\n}</code></pre>\n<p><strong>区分前置和后置运算符</strong></p>\n<p>后置版本接受一个额外的（不被使用的）int类型的形参，这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</p>\n<pre><code class=\"c++\">class StrBlobPtr {\npublic:\n    StrBlobPtr operator++(int);        // 后置运算符\n    StrBlobPtr operator--(int);\n};</code></pre>\n<p>!!!note<br>    为了与内置版本保持一致，后置运算符应该返回对象的原值，返回的形式是一个值而非引用。</p>\n<pre><code class=\"c++\">//后置版本：递增递减对象的值但是返回原值\nStrBlobPtr StrBlobPtr::operator++(int){\n    //此处无须检查有效性，调用前置递增运算符时才需要检查\n    StrBlobPtr ret = *this;//记录当前的值\n    ++*this;//向前移动一个元素，前置++需要检查递增的有效性\n    return ret;//返回之前记录的状态\n}\n\nStrBlobPtr StrBlobPtr::operator--(int){\n    //此处无须检查有效性，调用前置递减运算符时才需要检查\n    StrBlobPtr ret = *this    //记录当前的值\n    --*this //向后移动一个元素，前置--需要检查递减的有效性\n    return ret;\n}</code></pre>\n<p><strong>显式的调用后置运算符</strong></p>\n<pre><code class=\"c++\">StrBlobPtr p(a1);//p指向a1中的vector\np.operator++(0);//调用后置版本的operator++\np.operator++();//调用前置版本的operator++</code></pre>\n<h2 id=\"成员访问运算符\"><a href=\"#成员访问运算符\" class=\"headerlink\" title=\"成员访问运算符\"></a>成员访问运算符</h2><p>在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符。</p>\n<pre><code class=\"c++\">class StrBlobPtr {\npublic:\n    std::string&amp; operator*() const;\n    {\n        auto p = check(curr,&quot;dereference past end&quot;);\n        return (*p)[curr];\n    }\n    std::string* operator-&gt;() const\n    {\n        // 将实际工作委托给解引用运算符\n        return &amp; this-&gt;operator*();\n    }\n};</code></pre>\n<p><strong>对箭头运算符返回值的限定</strong></p>\n<p>对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator-&gt;类的对象。根据point类型的不同，point-&gt;分别等价于：</p>\n<pre><code class=\"c++\">(*point).mem;        //point是一个内置的指针类型\npoint.operator()-&gt;mem;        //point是一个类对象</code></pre>\n<p>除此之外，代码都将发生错误。</p>\n<h2 id=\"函数调用运算符\"><a href=\"#函数调用运算符\" class=\"headerlink\" title=\"函数调用运算符\"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更灵活。</p>\n<pre><code class=\"c++\">struct absInt {\n    int operator()(int val) const {\n        return val &lt; 0 ? -val : val;\n    }\n};</code></pre>\n<p>这个类只定义了一种操作：函数调用运算符，它负责接受一个int类型的实参，然后返回该实参的绝对值。</p>\n<p>使用调用运算符的方式是令一个absInt对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：</p>\n<pre><code class=\"c++\">int i = -42;\nabsInt absObj;\nint ui = absObj(i);        // 将i传递给absObj.operator()</code></pre>\n<p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</p>\n<p>如果类定义了调用运算符，则该类的对象称作函数对象（function object）。因为可以调用这种对象，所以我们说这些对象的行为像函数一样。</p>\n<h3 id=\"lambda是函数对象\"><a href=\"#lambda是函数对象\" class=\"headerlink\" title=\"lambda是函数对象\"></a>lambda是函数对象</h3><p>当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符，默认情况下，它是一个const成员函数。</p>\n<p>当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象确实存在。因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。</p>\n<p>通过值捕获的变量被拷贝到lambda中。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</p>\n<h3 id=\"标准库定义的函数对象\"><a href=\"#标准库定义的函数对象\" class=\"headerlink\" title=\"标准库定义的函数对象\"></a>标准库定义的函数对象</h3><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+操作。</p>\n<p>这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，<code>plus&lt;string&gt;</code>令string的加法运算符作用于string对象。</p>\n<pre><code class=\"c++\">plus&lt;int&gt; intAdd;            // 可执行int加法的函数对象\nint sum = intAdd(10, 20);    // 使用intAdd::operator(int, int)求10和20的和</code></pre>\n<p><strong>在算法中使用标准库函数对象</strong></p>\n<p>表示运算符的函数对象类常用来替换算法中的默认运算符。比如，默认情况下排序算法使用operator&lt;将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个greater类型的对象。</p>\n<pre><code class=\"c++\">// 传入一个临时的函数对象用于执行两个string对象的&gt;比较运算\nsort(svec.begin(), svec.end(), greater&lt;string&gt;());</code></pre>\n<h3 id=\"可调用对象与function\"><a href=\"#可调用对象与function\" class=\"headerlink\" title=\"可调用对象与function\"></a>可调用对象与function</h3><p>C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。</p>\n<p>和其他对象一样，可调用对象也有类型。lambda有它自己唯一的未命名的类类型；函数及函数指针的类型由其返回值和实参类型决定。</p>\n<p>然而，两个不同类型的可调用对象却可能共享同一种调用形式（call signature）。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：</p>\n<pre><code class=\"c++\">int(int, int)</code></pre>\n<p><strong>标准库function函数</strong></p>\n<p>function是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，此额外信息是指该function类型能够表示的对象的调用形式：</p>\n<pre><code class=\"c++\">function&lt;int(int, int)&gt;</code></pre>\n<p>这里声明的function类型，表示接受两个int、返回一个int的可调用对象：</p>\n<pre><code class=\"c++\">function&lt;int(int, int)&gt; f1 = add;            // 函数指针\nfunction&lt;int(int, int)&gt; f2 = divide();        // 函数对象类的对象\nfunction&lt;int(int, int)&gt; f3 = [](int i, int j) { return i * j; };    // lambda\n\ncout &lt;&lt; f1(4, 2) &lt;&lt; endl;\ncout &lt;&lt; f2(4, 2) &lt;&lt; endl;\ncout &lt;&lt; f3(4, 2) &lt;&lt; endl;</code></pre>\n<h2 id=\"重载、类型转换与运算符\"><a href=\"#重载、类型转换与运算符\" class=\"headerlink\" title=\"重载、类型转换与运算符\"></a>重载、类型转换与运算符</h2><p>在263页中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。</p>\n<p>转换构造函数和类型转换运算符共同定义了<strong>类类型转换（class-type conversions）</strong>。</p>\n<h3 id=\"类型转换运算符\"><a href=\"#类型转换运算符\" class=\"headerlink\" title=\"类型转换运算符\"></a>类型转换运算符</h3><p><strong>类型转换运算符（conversion  operator）</strong>是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。其一般形式如下：</p>\n<pre><code class=\"c++\">operator type() const;</code></pre>\n<p>其中type表示某种类型。类型转换运算符可以面向任意类型（除了void之外）进行定义，只要该类型能作为函数的返回类型，因此我们不允许转换成数组或者函数类型，但允许转换成指针或者引用类型。</p>\n<pre><code>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，一般被定义成const成员。</code></pre><p><strong>定义含有类型转换运算符的类</strong></p>\n<p>举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：</p>\n<pre><code class=\"c++\">class SmallInt {\npublic:\n    SmallInt(int i = 0) : val(i)\n    {\n        if (i &lt; 0 || i &gt; 255)\n            throw std::out_of_range(&quot;Bad SmallInt value&quot;);\n    }\n\n    operator int() const { return val; }\nprivate:\n    std::size_t val;\n};</code></pre>\n<p>SmallInt类的构造函数将算数类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int：</p>\n<pre><code class=\"c++\">SmallInt si;\nsi = 4;            // 4 -&gt; SmallInt, 然后调用赋值运算符\nsi + 3;            // si -&gt; int，然后执行整数的加法</code></pre>\n<p><strong>类型转换运算符可能产生意外结果</strong></p>\n<p>在实践中，类很少提供类型转换运算符。但有一种例外：对于类来说，定义向bool的类型转换还是比较普遍的现象，但这会遇到一个问题：因为bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中（这不是期望的）。</p>\n<p><strong>显式的类型转换运算符</strong></p>\n<p>为了防止上述异常情况的发生，C++新标准引入了显式的类型转换运算符（explicit conversion operator）：</p>\n<pre><code class=\"c++\">class SmallInt {\npublic:\n    // 编译器不会自动执行这一类型转换\n    explicit operator int() const { return val; }\n};</code></pre>\n<p>编译器不会将一个显式的类型转换运算符用于隐式类型转换：</p>\n<pre><code class=\"c++\">SmallInt si = 3;            // 正确：SmallInt的构造函数不是显式的\nsi + 3;                        // 错误：此处需要隐式的类型转换，但类的运算符是显式的\nstatic_cast&lt;int&gt;(si) + 3;    // 正确：显式地请求类型转换</code></pre>\n<p>但，如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它。</p>\n<pre><code>向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的。</code></pre><h3 id=\"避免有二义性的类型转换\"><a href=\"#避免有二义性的类型转换\" class=\"headerlink\" title=\"避免有二义性的类型转换\"></a>避免有二义性的类型转换</h3><pre><code>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</code></pre><p><strong>实参匹配和相同的类型转换</strong></p>\n<pre><code>我们无法通过强制类型转换来解决二义性问题，因为强制类型转换也面临二义性问题。</code></pre><h3 id=\"函数匹配和重载运算符\"><a href=\"#函数匹配和重载运算符\" class=\"headerlink\" title=\"函数匹配和重载运算符\"></a>函数匹配和重载运算符</h3><h1 id=\"面向对象程序设计\"><a href=\"#面向对象程序设计\" class=\"headerlink\" title=\"面向对象程序设计\"></a>面向对象程序设计</h1><p>面向对象程序设计基于三个基本概念：数据抽象、继承、动态绑定。</p>\n<hr>\n<h2 id=\"OOP概述\"><a href=\"#OOP概述\" class=\"headerlink\" title=\"OOP概述\"></a>OOP概述</h2><p><strong>面向对象程序设计(object-oriented programming)</strong>的核心思想时数据抽象，继承和动态绑定。通过数据抽象我们可以将类的接口和实现分开，使用继承，我们可以定义相似的类型并对其相似关系建模；使用动态绑定，我们可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>\n<p><strong>继承</strong></p>\n<p>通过继承(inheritance)；联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类(base class)，其他类则间接或直接地从基类继承而来，这些继承而来的类称为派生类(derived class)。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>\n<pre><code class=\"c++\">class Quote{\npublic:\n    std::string isbn() const;\n    virtual double net_price(std::size_t n) const;\n};\n\nclass Bulk_Quote:public Quote{\npublic:\n    double net_price(std::size_t n) const override;\n};</code></pre>\n<p><strong>动态绑定</strong></p>\n<p>通过使用动态绑定(dynamic binding)，我们能用用一段代码分别处理Quote和Bulk_Quote的对象。</p>\n<pre><code class=\"c++\">//计算并打印销售给定数量的某种书籍所得的费用\ndouble print_total(ostream &amp;os,const Quote &amp;item,size_t n){\n    //根据传入item的形参的对象调用Quote::net_price()\n    //或者Bulk_Quote::net_price\n    double ret = item.net_price(n);\n    os&lt;&lt;&quot;ISBN: &quot;&lt;&lt;item.isbn()&lt;&lt; &quot;# sold: &quot;&lt;&lt;n&lt;&lt; &quot;total due &quot;&lt;&lt;ret&lt;&lt;endl;\n    return ret;\n}\n\n//basic的类型时Quote,bulk的类型是Bulk_Quote\n\nprint_total(cout,basic,20);//调用Quote::net_price()\n\nprint_total(cout,bulk,20);//调用Bulk_Quote::net_price()</code></pre>\n<pre><code>当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。</code></pre><h2 id=\"定义基类和派生类\"><a href=\"#定义基类和派生类\" class=\"headerlink\" title=\"定义基类和派生类\"></a>定义基类和派生类</h2><h3 id=\"定义基类\"><a href=\"#定义基类\" class=\"headerlink\" title=\"定义基类\"></a>定义基类</h3><pre><code class=\"c++\">class Quote{\npublic:\n    Quote() = default;\n    Quote(std::string &amp;book,double sales_price):bookNo(book),price(sales_price){}\n    std::string isbn() const {return bookNo;};\n    virtual double net_price(size_t n) const {return n*price;}\n    virtual ~Quote()\nprivate:\n    std::string bookNo;\nprotected:\n    double pricr = 0.0;\n};</code></pre>\n<pre><code>通常，基类都应该定义一个虚析构函数，即使该函数在不执行任何实际操作也是如此。</code></pre><p><strong>成员函数和继承</strong></p>\n<p>成员函数如果没有被定义为虚函数，则其解析过程在发生编译时而不是运行时。</p>\n<p>基类通过在其成员函数的声明语句之前加上关键词virtual使得该函数执行动态绑定。</p>\n<p><strong>访问控制和继承</strong></p>\n<p>派生类可以继承定义在基类的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。派生类可以访问公有成员，而不能访问私有成员。不过，如果基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的(protected)访问运算符说明这样的成员。</p>\n<h3 id=\"定义派生类\"><a href=\"#定义派生类\" class=\"headerlink\" title=\"定义派生类\"></a>定义派生类</h3><p>派生类必须使用类派生列表(class derivation list)明确指出它是从哪个基类继承而来的。</p>\n<p><strong>派生类中的虚函数</strong></p>\n<p>C++新标准允许派生类显式的注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键词后面，或者在引用函数的引用限定符后面添加一个关键词override。</p>\n<p><strong>派生类对象及派生类向基类的类型转换</strong></p>\n<p>因为在派生类对象中含有基类对应的组成部分，所以我们能够把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上。</p>\n<pre><code class=\"c++\">Quote item;        //基类对象\nBulk_Quote bulk;        //派生类对象\nQuote *p = &amp;item;        //p指向Quote对象\np = &amp;bulk;        //p指向bulk的Quote部分\nQuote &amp;r = bulk;        r绑定到bulk的Quote部分</code></pre>\n<p><strong>派生类构造函数</strong></p>\n<pre><code class=\"c++\">Bulk_Quote(const string &amp;book,double p,size_t qty,double disc):\n            Quote(book,p),min_qty(qty),discount(dis){}</code></pre>\n<pre><code>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</code></pre><p><strong>派生类使用基类的成员</strong></p>\n<p>派生类可以使用基类的公有和保护成员。</p>\n<p><strong>继承与静态成员</strong></p>\n<p>静态成员遵循通用的访问规则。</p>\n<p><strong>被用作基类的类</strong></p>\n<p>如果我们想将某个类作为基类，则该类必须已经定义而非仅仅声明：</p>\n<pre><code class=\"c++\">class Quote;        //声明但未定义；\n//错误：quote必须被定义\nclass Bulk_Quote:public Quote{...};</code></pre>\n<p><strong>防止继承的发生</strong></p>\n<p>在类名后加一个final可以防止继承的发生。</p>\n<pre><code class=\"c++\">class NoDerived final{};</code></pre>\n<h3 id=\"类型转换与继承\"><a href=\"#类型转换与继承\" class=\"headerlink\" title=\"类型转换与继承\"></a>类型转换与继承</h3><p>可以将基类的指针或者引用绑定到派生类的对象上有一层极为重要的含义：当使用基类的引用或指针时，实际上我们不知道该引用（指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>\n<p><strong>动态类型与静态类型</strong></p>\n<p>我们必须把一个变量或者表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或者表达式生成的类型；动态类型则是变量或者表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p>\n<p>例如：当print_total调用net_price时<code>double ret = item.net_price(n);</code></p>\n<p>我们知道item的静态类型是Quote&amp;，它的动态类型则依赖于item绑定的实参，动态类型直到运行时才可知。</p>\n<p><strong>不存在从基类向派生类的隐式类型转换……</strong></p>\n<p>因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类到派生类的自动类型转换。</p>\n<pre><code class=\"c++\">Quote base;\nBulk_Quote* bulkp = &amp;base;        //错误：不能将基类转换成派生类\nBulk_Quote&amp; bulkref = base;        //错误：不能将基类转换成派生类\nBulk_Quote bulk;\nQuote *itemp = &amp;bulk;        //正确：动态类型是Bulk_Quote\nBulk_Quote *bulkp = itemp;        //错误：不能将基类转换成派生类</code></pre>\n<p><strong>……在对象之间不存在类型转换</strong></p>\n<pre><code>当我们用一个派生类为一个基类对象赋值时，只有该派生类对象中的基类部分会被拷贝，移动和赋值，它的派生类部分会被忽略掉。</code></pre><h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>我们必须为每个虚函数提供定义。</p>\n<p><strong>对虚函数的调用可能在运行时才被解析</strong></p>\n<p>动态绑定只有当我们通过指针或者引用调用虚函数时才会发生。</p>\n<p><strong>派生类中的虚函数</strong></p>\n<p>一旦某个函数被声明为虚函数，则在所有的派生类中它都是虚函数。</p>\n<pre><code>基类中的虚函数在派生了中隐含地也是一个虚函数。\n当派生类覆盖某个虚函数时，该函数的形参必须与派生类的形参严格匹配。\n返回类型在返回的是类的指针或者引用时可不一样，但是要求从基类到派生类的类型转换是可访问的。</code></pre><p><strong>final和override说明符</strong></p>\n<p>final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。</p>\n<p><strong>虚函数和默认实参</strong></p>\n<pre><code>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</code></pre><p><strong>回避虚函数机制</strong></p>\n<p>在某些情况下，我们希望对虚函数的调用不要动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的：</p>\n<pre><code class=\"c++\">//强行调用基类中定义的函数版本而不管baseP的动态类型如何\ndouble undiscount = baseP-&gt;Quote::net_price(42);</code></pre>\n<h2 id=\"抽象基类\"><a href=\"#抽象基类\" class=\"headerlink\" title=\"抽象基类\"></a>抽象基类</h2><p><strong>纯虚函数</strong></p>\n<p>纯虚函数无需定义、我们在函数体的位置书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。</p>\n<pre><code class=\"c++\">double net_price(size_t) const =0;</code></pre>\n<p><strong>含有纯虚函数的类是抽象基类</strong></p>\n<p>抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能创建一个抽象基类的对象。因为Disc_quoto将net_price定义为纯虚函数，所以我们不能定义Disc_quote的对象。我们可以定义Disc_quote的派生类的对象。前提是这些类覆盖了net_price函数。</p>\n<pre><code>我们不能创建抽象基类的对象。</code></pre><p><strong>派生类构造函数只初始化它的直接基类</strong></p>\n<h2 id=\"访问控制与继承\"><a href=\"#访问控制与继承\" class=\"headerlink\" title=\"访问控制与继承\"></a>访问控制与继承</h2><p><strong>受保护的成员</strong></p>\n<p>protected说明符可以看做是public和private中和后的产物：</p>\n<ol>\n<li><p>和私有成员类似，受保护的成员对于类的用户来说是不可访问的</p>\n</li>\n<li><p>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的</p>\n</li>\n<li><p><strong>派生类的成员只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中受保护的成员没有任何访问特权</strong></p>\n</li>\n</ol>\n<pre><code class=\"c++\">class Base{\nprotected:\n    int prot_mem;\n};\n\nclass Sneaky:public Base{\n    friend void clobber(Sneaky&amp;);//能访问Sneaky::prot_mem\n    friend void clobber(Base&amp;);//不能访问Base::prot_mem\n    int j;\n};\n\n//正确，clobber能够访问Sneaky对象的private和protected成员\nvoid clobber(Snaaky &amp;s){s.j=s.prot_mem=0;}\n//错误;clobber不能访问Base的protected成员\nvoid clobber(base &amp;s){s.prot_mem=0;}</code></pre>\n<p><strong>公有，私有和受保护继承</strong></p>\n<p>某个类对其继承而来的成员的访问权限受到两个因素的影响：</p>\n<ol>\n<li><p>在基类中该成员的访问说明符</p>\n</li>\n<li><p>在派生类的派生列表中的访问说明符</p>\n</li>\n</ol>\n<p>派生类说明符的目的是控制派生类影虎对于基类成员的访问权限，还可以控制继承自派生类的新类的访问权限。</p>\n<p><strong>派生类向基类转换的可访问性</strong></p>\n<p>派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：</p>\n<ul>\n<li><p>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</p>\n</li>\n<li><p>不论以什么方式继承B，D的成员和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的。</p>\n</li>\n<li><p>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换；反之，如果D继承B的方式是私有的，则不能使用。</p>\n<p>  对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>\n</li>\n</ul>\n<p><strong>友元与继承</strong></p>\n<p>友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。</p>\n<p><strong>改变个别成员的可访问性</strong></p>\n<p>有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：</p>\n<pre><code class=\"c++\">class Base {\npublic:\n    std::size_t size() const { return n; }\nprotected:\n    std::size_t n;\n};\n\nclass Derived : private Base {\npublic:\n    // 令size成员保持public访问级别\n    using Base::size;\nprotected:\n    using Base::n;\n};</code></pre>\n<p>因为Derived使用了私有继承，所以继承而来的成员size和n默认情况下是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。</p>\n<p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中任何可访问成员标记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。</p>\n<pre><code>派生类只能为那些它可以访问的名字提供using声明。</code></pre><p><strong>默认的继承保护级别</strong></p>\n<p>默认情况下，使用class关键词定义的派生类是私有继承，而使用struct关键字定义的派生类为公有继承。</p>\n<h2 id=\"继承中的类作用域\"><a href=\"#继承中的类作用域\" class=\"headerlink\" title=\"继承中的类作用域\"></a>继承中的类作用域</h2><p>每个类定义自己的作用域，在这个作用域内我们定义类的成员。</p>\n<p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，所以派生类才能像使用自己的成员一样使用基类的成员。</p>\n<p><strong>在编译时进行名字查找</strong></p>\n<p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。</p>\n<p><strong>名字冲突和继承</strong></p>\n<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。</p>\n<pre><code>派生类将隐藏同名的基类成员。</code></pre><p><strong>通过作用域运算符来使用隐藏的成员</strong></p>\n<p>作用域运算符将覆盖掉原有的查找规则。</p>\n<pre><code>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</code></pre><p><strong>名字查找先去类型检查</strong></p>\n<pre><code class=\"c++\">struct Base{\n    Base():mem(0){};\n    int memfcn();\nprotected:\n    int mem;\n};\n\nstruct Derived:Base{\n    Derived(int i):mem(i){};\n    int memfcn(int);\n    int get_mem(){return mem;};\nprotected:\n    int mem;\n};\n\nDerived d;\nBase b;\nb.memfcn();        //调用Base::memfcn\nd.memfcn(10);        //调用Derived::memfcn\nd.memfcn();        //错误：参数列表为空的memfcn被隐藏了\nd.Base::memfcn();        //正确：调用Base::memfcn</code></pre>\n<p><strong>虚函数和作用域</strong></p>\n<p>加入基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数。</p>\n<p><strong>通过基类调用隐藏的虚函数</strong></p>\n<h2 id=\"构造函数与拷贝控制\"><a href=\"#构造函数与拷贝控制\" class=\"headerlink\" title=\"构造函数与拷贝控制\"></a>构造函数与拷贝控制</h2><p>和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。</p>\n<h3 id=\"虚析构函数\"><a href=\"#虚析构函数\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h3><p>当我们delete一个动态分配的对象的指针时，将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本。</p>\n<pre><code class=\"c++\">class Quote {\npublic:\n    // 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数\n    virtual ~Quote() = default;    // 动态绑定析构函数\n};</code></pre>\n<pre><code>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</code></pre><p>之前介绍的经验准则说，如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但这里基类的析构函数并不遵顼这个准则，它是一个重要的例外。</p>\n<p>虚析构函数还将阻止合成移动操作。</p>\n<h3 id=\"合成拷贝控制与继承\"><a href=\"#合成拷贝控制与继承\" class=\"headerlink\" title=\"合成拷贝控制与继承\"></a>合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁操作。此外，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如：</p>\n<ul>\n<li><p>合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。</p>\n</li>\n<li><p>Quote的默认构造函数将bookNo成员默认初始化为空子行串，同时便用类内例始值将price初始化为0。</p>\n</li>\n<li><p>Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化qty和discount。</p>\n</li>\n<li><p>Disc quote的构造函数完成后，继续执行Bu1k_quote的构造函数，但是它什么具体工作也不做。</p>\n</li>\n</ul>\n<p><strong>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</strong></p>\n<p><strong>派生类中删除的拷贝控制与基类的关系</strong></p>\n<p>某些定义为基类的方式也可能导致有的派生类成员成为删除的函数：</p>\n<p>-. 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问（参见15.5节，第543页），则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。</p>\n<p>-. 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。</p>\n<p>-. 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=defau1t请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</p>\n<p>例如：</p>\n<pre><code class=\"c++\">class B{\npublic:\n    B();\n    B(const B&amp;)=delete;\n};\n\nclass D:public B{\n    //没有声明任何构造函数\n};\n\nD d;        //正确，D的合成默认构造函数使用B的默认构造函数\nD d2(d);        //错误：D的合成拷贝构造函数是被删除的\nD d3(std::move(d));        //错误：隐式的使用D的被删除的拷贝构造函数</code></pre>\n<p><strong>移动操作和继承</strong></p>\n<p>因为基类缺少移动操作会阻止派生类拥有自己的移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。</p>\n<pre><code class=\"c++\">class Quote{\npublic:\n    Quote()=default;//对成员依次进行默认初始化\n    Quote(const Quote&amp;)=default;//对成员依次拷贝\n    Quote(Quote&amp;&amp;)=default;//对成员依次拷贝\n    Quote&amp; operator=(const Quote&amp;)=default;//拷贝赋值\n    Quote&amp; operator=(Quote&amp;&amp;)=default;//拷贝赋值\n    virtual ~Quote()=default;//析构函数\n}</code></pre>\n<h3 id=\"派生类的拷贝控制成员\"><a href=\"#派生类的拷贝控制成员\" class=\"headerlink\" title=\"派生类的拷贝控制成员\"></a>派生类的拷贝控制成员</h3><p>派生类的构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要移动和拷贝基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>\n<p>和构造函数及赋值运算符不同的是，析构函数只负责销毁自己分配的资源。</p>\n<pre><code>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</code></pre><p><strong>定义派生类的拷贝和移动构造函数</strong></p>\n<p>当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分：</p>\n<pre><code class=\"c++\">class Base{/* */};\nclass D:public Base{\npublic:\n    //默认情况下，基类的默认构造函数初始化对象的基类部分\n    //要想使用拷贝或移动构造函数，我们必须在构造函数初始列表中\n    //显式的调用该构造函数\n    D(const D&amp;):Base(d)        //拷贝基类成员\n            /*D的成员的初始值*/{ /* */}\n    D(D&amp;&amp; d):Base(std::move(d))        //移动基类成员\n            /*D的成员的初始值*/{ /* */}\n};</code></pre>\n<pre><code>在默认情况下，其基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝或者移动基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝构造函数。</code></pre><p><strong>派生类赋值运算符</strong></p>\n<p>派生类的赋值运算符也必须显式地为其基类部分赋值。</p>\n<pre><code class=\"c++\">//Base::operator=(const Base&amp;)不会被自动调用\nD &amp;D::operator=(const D &amp;rhs){\n    Base::operator=(rhs);//为基类部分赋值\n    //按照过去的方式为派生类的成员赋值\n    //酌情处理自赋值及释放已有资源等情况\n    return *this;\n}</code></pre>\n<p><strong>派生类析构函数</strong></p>\n<p>派生类析构函数只负责销毁由派生类自己分配的资源。</p>\n<p><strong>在构造函数和析构函数中调用虚函数</strong></p>\n<h3 id=\"继承的构造函数\"><a href=\"#继承的构造函数\" class=\"headerlink\" title=\"继承的构造函数\"></a>继承的构造函数</h3><p><strong>类不能继承默认、拷贝、移动构造函数</strong>，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>\n<p>在C++11新标准中，派生类能够重用其直接基类定义的构造函数。</p>\n<p>一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>\n<p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p>\n<pre><code class=\"c++\">class Bulk_quote : public Disc_quote {\npublic:\n    using Disc_quote::Disc_quote; // 继承Disc_quote的构造函数\n    double net_price(std::size_t) const;\n};</code></pre>\n<p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。当当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>\n<p>在Bulk_quote类中，继承的构造函数等价于：</p>\n<pre><code class=\"c++\">Bulk_quote(const std::string &amp;book, double price, std::size_t qty, double disc) :\n    Disc_quote(book, price, qty, disc) {}</code></pre>\n<p>如果派生类含有自己的数据成员，则这些成员将被默认初始化。</p>\n<p><strong>继承的构造函数的特点</strong></p>\n<p>一个构造函数的using声明不会改变该构造函数的访问级别。不能指定explicit和constexpr。</p>\n<h2 id=\"容器与继承\"><a href=\"#容器与继承\" class=\"headerlink\" title=\"容器与继承\"></a>容器与继承</h2><h1 id=\"模板和泛型编程\"><a href=\"#模板和泛型编程\" class=\"headerlink\" title=\"模板和泛型编程\"></a>模板和泛型编程</h1><h2 id=\"定义模板\"><a href=\"#定义模板\" class=\"headerlink\" title=\"定义模板\"></a>定义模板</h2><h3 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h3><p>一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板函数可以像这样：</p>\n<pre><code class=\"c++\">template&lt;typename T&gt;\nint compare(const T &amp;v1,const T &amp;v2){\n    return  v1 &gt; v2 ? 1 : -1;\n}</code></pre>\n<p>模板定义以一个关键词template开始，后跟一个模板参数列表，这是一个逗号分隔或多个模板参数的列表，用&lt; 和 &gt; 包围起来。</p>\n<pre><code>在模板定义中，模板参数列表不能为空。</code></pre><p><strong>实例化参数模板</strong></p>\n<p>‘’’c++<br>cout&lt;&lt;compare(1,0)&lt;&lt;endl;//T为int<br>‘’’</p>\n<p><strong>模板类型参数</strong></p>\n<p>类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或者类型转换。</p>\n<p><strong>非类型模板参数</strong></p>\n<p>一个非类型模板参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或者typename来指定非类型参数。</p>\n<pre><code>非类型模板参数的模板实参必须是常亮表达式。</code></pre><p><strong>inline和constexpr的函数模板</strong></p>\n<p>inline或者constexpr说明符放在参数列表之后，返回类型之前：</p>\n<pre><code class=\"c++\">template&lt;typename T&gt;\ninline T min(const T &amp;a,const T &amp;b)</code></pre>\n<p><strong>编写类型无关的代码</strong></p>\n<p>编写泛型代码的两个重要的原则：</p>\n<ol>\n<li><p>模板中的函数参数是const的引用；</p>\n</li>\n<li><p>函数体的条件判断仅使用&lt;比较运算。</p>\n</li>\n</ol>\n<p><strong>模板编译</strong></p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h1 id=\"标准库特殊设施\"><a href=\"#标准库特殊设施\" class=\"headerlink\" title=\"标准库特殊设施\"></a>标准库特殊设施</h1><h2 id=\"tuple类型\"><a href=\"#tuple类型\" class=\"headerlink\" title=\"tuple类型\"></a>tuple类型</h2><p>tuple是类似pair的模板。每个pair的成员类型都不相同，但是每个pair都恰好有两个成员。不同tuple类型的成员类型也不相同，但是每个tuple可以有任意数量的成员。每个确定的tuple类型的成员数目是固定的，但一个tuple类型的成员数目可以与另一个tuple类型不同。</p>\n<pre><code class=\"c++\">tuple支持的操作\ntuple&lt;T1,T2,...,Tn&gt; t;\ntuple&lt;T1,T2,...,Tn&gt; t(v1,v2,v3,v4,...,vn);\nmake_tuple(v1,v2,...,vn);\nt1==t2;\nt1 relop t2;\nget&lt;i&gt;(t);</code></pre>\n<h3 id=\"定义和初始化tuple\"><a href=\"#定义和初始化tuple\" class=\"headerlink\" title=\"定义和初始化tuple\"></a>定义和初始化tuple</h3><p>当我们定义一个tuple时，需要指出每个成员的类型：</p>\n<pre><code class=\"c++\">tuple&lt;size_t,size_t,size_t&gt; threeD;//三个成员都设置为0\ntuple&lt;string,vector&lt;double&gt;,int,list&lt;int&gt;) someVal(&quot;contents&quot;,{3.14,2.718},42,{0,1,2,3,4,5})</code></pre>\n<p><strong>访问tuple的成员</strong></p>\n<p>要访问一个tuple的成员，就要使用一个名为get的标准函数模板。</p>\n<pre><code class=\"c++\">auto book = get&lt;0&gt;(item);//返回item成员的第一个成员\nauto cnt = get&lt;1&gt;(item);//返回item成员的第二个成员</code></pre>\n<p>如果不知道一个tuple准确的类型细节信息，可以使用辅助类模板来查询tuple成员的类型和数量：</p>\n<pre><code class=\"c++\">typedef decltype(item) trans;//trans是item的类型\n//返回item类型对象中成员的数量\nsize_t sz = tuple_size&lt;trans&gt;::value;//返回3\n//cnt类型与item中第二个成员相同\ntuple_element&lt;1,trans&gt;::type cnt = get&lt;1&gt;(item);//cnt为int型</code></pre>\n<h3 id=\"使用tuple返回多个值\"><a href=\"#使用tuple返回多个值\" class=\"headerlink\" title=\"使用tuple返回多个值\"></a>使用tuple返回多个值</h3><h2 id=\"bitset类型\"><a href=\"#bitset类型\" class=\"headerlink\" title=\"bitset类型\"></a>bitset类型</h2><p>标准库定义了bitset类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset中。</p>\n<h3 id=\"定义和初始化bitset\"><a href=\"#定义和初始化bitset\" class=\"headerlink\" title=\"定义和初始化bitset\"></a>定义和初始化bitset</h3><p>bitset类是一个类模板，它类似array类，具有固定的大小。当我们定义一个bitset时，需要声明它包含多少个二进制位。</p>\n<pre><code class=\"c++\">bitset&lt;32&gt; bitvec(1U);    // 32位；低位为1，其他位为0</code></pre>\n<p>二进制位的位置是从0开始编号的，因此，bitvec包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位（low-order），编号到31结束的二进制位被称为高位（high-order）。</p>\n<p><strong>使用unsigned值初始化bitset</strong></p>\n<p>当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当作位模式来处理。bitset中的二进制位将是此模式的一个副本。如果bitset的大小大于unsigned long long的位数，则剩余高位被置为0。如果小于，则只使用给定值中的低位，超出bitset大小的高位被丢弃。</p>\n<p><strong>从一个string初始化bitset</strong></p>\n<p>我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符都直接表示位模式。当我们使用字符串表示数时，字符串中下标最小的字符对应高位：</p>\n<pre><code class=\"c++\">bitset&lt;32&gt; bitvec4(&quot;1100&quot;);    // 2、3两位为1，剩余两位为0</code></pre>\n<p>如果string包含的字符数比bitset少，则bitset的高位被置为0。</p>\n<pre><code>string的下标编号习惯于bitset恰好相反：string中下标最大的字符（最右）用来初始化bitset中的低位。</code></pre><h3 id=\"bitset操作\"><a href=\"#bitset操作\" class=\"headerlink\" title=\"bitset操作\"></a>bitset操作</h3><p>bitset操作定义了多种检测或设置一个或多个二进制位的方法。</p>\n<pre><code class=\"c++\">bitset&lt;32&gt; bitvec(1U);\nbool is_set = bitvec.any();            // true，因为有1位置位\nbool is_not_set = bitvec.none();    // false，因为有1位置位了\nbool all_set = bitvec.all();        // false，因为只有1位置位了\nsize_t onBits = bitvec.count();        // 返回1\nsize_t sz = bitvec.size();            // 返回32\nbitvec.flip();                        // 翻转bitvec中的所有位\nbitvec.reset();                        // 将所有位复位\nbitvec.set();                        // 将所有位置位\n\nbitvec.flip(0);                        // 翻转第一位\nbitvec.set(0);                        // 置位第一位\nbitvec.reset(i);                    // 复位第i位\nbitvec.test(0);                        // 返回false，因为第一位已复位\n\nbitvec[0] = 0;                        // 将第一位复位\nbitvec[31] = bitvec[0];                // 将最后一位设置为与第一位一样\n~bitvec[0];                            // 翻转第一位</code></pre>\n<p><strong>提取bitset的值</strong></p>\n<p>to_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式，只有当bitset的大小小于等于对应的大小时，我们才能使用这两个操作，否则将会抛出overflow_error异常。</p>\n<pre><code class=\"c++\">unsigned long ulong = bitvec3.to_ulong();\ncout &lt;&lt; &quot;ulong = &quot; &lt;&lt; ulong &lt;&lt; endl;</code></pre>\n<p><strong>bitset的IO运算符</strong></p>\n<p>输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的字符数达到对应bitset的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，读取过程才停止。随即用临时string对象来初始化bitset。如果读取的字符数小于bitset的大小，高位被置为0。</p>\n<pre><code class=\"c++\">bitset&lt;16&gt; bits;\ncin &gt;&gt; bits;        // 从cin读取最多16个0或1\ncout &lt;&lt; &quot;bits: &quot; &lt;&lt; bits &lt;&lt; endl;</code></pre>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>正则表达式是一种描述字符序列的方法，是一种及其强大的计算工具。它定义在头文件regex中，它包含多个组件：</p>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>regex</td>\n<td>表示有一个正则表达式的类</td>\n</tr>\n<tr>\n<td>regex_match</td>\n<td>将一个字符序列与一个正则表达式匹配</td>\n</tr>\n<tr>\n<td>regex_search</td>\n<td>寻找第一个与正则表达式匹配的子序列</td>\n</tr>\n<tr>\n<td>regex_replace</td>\n<td>使用给定格式替换一个正则表达式</td>\n</tr>\n<tr>\n<td>sregex_iterator</td>\n<td>迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串</td>\n</tr>\n<tr>\n<td>smatch</td>\n<td>容器类，保存在string中搜索的结果</td>\n</tr>\n<tr>\n<td>ssub_match</td>\n<td>string中匹配的子表达式的结果</td>\n</tr>\n</tbody></table>\n<p>regex类表示一个正则表达式。</p>\n<p>函数regex_match和regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个输入序列与表达式匹配，则regex_match返回true；如果输入一个序列中一个子串与表达式匹配，则regex_search返回true。</p>\n<h2 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h2><p>程序通常需要一个随机数源。在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。此函数生成均匀分布的伪随机整数，每个随机数的范围在0和一个系统相关的最大值（至少为32767）之间。</p>\n<p>rand函数有一些问题：即使不是大多数，也有很多程序员需要不同范围的随机数。一些应用需要随机浮点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题而试图转换rand生成的随机数的范围、类型或分布时，常常会引入非随机性。</p>\n<p>定义在头文件random中的随机数库通过一组协作的类来解决这些问题：随机数引擎（random-number engines）和随机数分布类（random-number distribution）。</p>\n<table>\n<thead>\n<tr>\n<th>组件</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>引擎</td>\n<td>类型，生成随机unsigned整数序列</td>\n</tr>\n<tr>\n<td>分布</td>\n<td>类型，使用引擎返回服从特定概率分布的随机数</td>\n</tr>\n</tbody></table>\n<p>!!!note<br>    C++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。</p>\n<h3 id=\"随机数引擎和分布\"><a href=\"#随机数引擎和分布\" class=\"headerlink\" title=\"随机数引擎和分布\"></a>随机数引擎和分布</h3><p>随机数引擎是函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。我们可以通过调用一个随机数引擎对象来生成原始随机数。</p>\n<pre><code class=\"c++\">default_random_engine e;\ncout &lt;&lt; e() &lt;&lt; endl;        // 生成一个随机无符号数</code></pre>\n<p>标准库定义了多个随机数引擎类，区别在于性能和随机质量不同。</p>\n<p><strong>分布类型和引擎</strong></p>\n<p>为了得到一个指定范围内的数，我们使用一个分布类型的对象：</p>\n<pre><code class=\"c++\">// 生成0到9之间（包含）均匀分布的随机数\nuniform_int_distribution&lt;unsigned&gt; u(0, 9);\ndefault_random_engine e;\ncout &lt;&lt; u(e) &lt;&lt; endl;</code></pre>\n<p>分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。</p>\n<pre><code>当我们说随机数发生器时，是指分布对象和引擎对象的组合。</code></pre><p><strong>引擎生成一个数值序列</strong></p>\n<p>随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来是随机的，但对于一个给定的发生器，每次运行程序它都会返回相同的数值序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p>\n<p><strong>设置随机数发生器种子</strong></p>\n<p>我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子（seed）来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。</p>\n<pre><code class=\"c++\">default_random_engine e1;        // 使用默认种子\ne1.seed(42);                    // 调用seed设置一个种子值\ndefault_random_engine e2(42);    // 使用给定的种子值</code></pre>\n<p>如果引擎种子相同，将生成相同的序列。</p>\n<p>选择一个好种子，是极其困难的，可能最常用的方法是调用系统函数time。它定义在头文件ctime中，它返回从一个特定时刻到当前经过了多少秒。</p>\n<pre><code class=\"c++\">default_random_engine e(time(0));    // 稍微随机些的种子</code></pre>\n<blockquote>\n<p>my note: 使用random_device引擎为另一个引擎创建一个种子也是一种方法。</p>\n</blockquote>\n<p>后续内容讨论了其他随机数的分布，比如：生成随机实数、生成非均匀分布随机数等。</p>\n<h2 id=\"IO库再探\"><a href=\"#IO库再探\" class=\"headerlink\" title=\"IO库再探\"></a>IO库再探</h2><h3 id=\"格式化输入与输出\"><a href=\"#格式化输入与输出\" class=\"headerlink\" title=\"格式化输入与输出\"></a>格式化输入与输出</h3><p>除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽度等。</p>\n<p>标准库定义了一组操纵符来修改流的格式状态。一个操纵符是一个函数或是一个对象，会影响流的状态。</p>\n<p>!!!warning<br>    当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效。</p>\n<p><strong>控制布尔值的格式</strong></p>\n<p>默认情况下，bool值打印为1或0，通过对流使用boolalpha操纵符来修改原有格式：</p>\n<pre><code class=\"c++\">cout &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; &quot; &quot; &lt;&lt; false &lt;&lt; endl; // 输出：true false</code></pre>\n<p>一旦向cout“写入”了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印true或false，为了取消格式的改变，noboolalpha：</p>\n<pre><code class=\"c++\">cout &lt;&lt; noboolalpha;</code></pre>\n<p><strong>指定整型值的进制</strong></p>\n<p>默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct、dec将其改为十六进制、八进制或是改回十进制。</p>\n<pre><code class=\"c++\">cout &lt;&lt; &quot;default: &quot; &lt;&lt; 20 &lt;&lt; endl;\ncout &lt;&lt; &quot;octal: &quot; &lt;&lt; oct &lt;&lt; 20 &lt;&lt; endl;\ncout &lt;&lt; &quot;hex: &quot; &lt;&lt; hex &lt;&lt; 20 &lt;&lt; endl;\ncout &lt;&lt; &quot;decimal: &quot; &lt;&lt; dec &lt;&lt; 20 &lt;&lt; endl; </code></pre>\n<p><strong>在输出中指出进制</strong></p>\n<p>当对流应用showbase操纵符时，会在输出结果中显示进制：</p>\n<ul>\n<li><p>前导0x表示十六进制。</p>\n</li>\n<li><p>前导0表示八进制。</p>\n</li>\n<li><p>无前导字符串表示十进制。</p>\n</li>\n</ul>\n<pre><code class=\"c++\">cout &lt;&lt; showbase;    // 打印整型值时显示进制\ncout &lt;&lt; &quot;default: &quot; &lt;&lt; 20 &lt;&lt; endl;\ncout &lt;&lt; &quot;octal: &quot; &lt;&lt; oct &lt;&lt; 20 &lt;&lt; endl;\ncout &lt;&lt; &quot;hex: &quot; &lt;&lt; hex &lt;&lt; 20 &lt;&lt; endl;\ncout &lt;&lt; &quot;decimal: &quot; &lt;&lt; dec &lt;&lt; 20 &lt;&lt; endl;\ncout &lt;&lt; noshowbase; // 恢复流状态 </code></pre>\n<p><strong>指定打印精度</strong></p>\n<p>setprecision操纵符接受一个参数，用来设置精度。它定义在头文件iomanip中。</p>\n<pre><code class=\"c++\">cout &lt;&lt; setprecision(3);\ncout &lt;&lt; sqrt(2.0) &lt;&lt; endl;    // 输出：1.41</code></pre>\n<p>更多操纵符见p669。</p>\n<h3 id=\"未格式化的输入-输出操作\"><a href=\"#未格式化的输入-输出操作\" class=\"headerlink\" title=\"未格式化的输入/输出操作\"></a>未格式化的输入/输出操作</h3><p>标准库提供了一组低层操作，支持未格式化IO（unformatted IO）。这组操作允许我们将一个流当作一个无解释的字节序列来处理。</p>\n<p><strong>单字节操作</strong></p>\n<p>有几个未格式化操作每次一个字节地处理流，它们会读取而不是忽略空白符。</p>\n<pre><code class=\"c++\">// 读写一个字符\nchar ch;\nwhile (cin.get(ch))\n    cout.put(ch);</code></pre>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>is.get(ch)</td>\n<td>从istream is读取下一个字节存入字符ch中。返回is</td>\n</tr>\n<tr>\n<td>os.put(ch)</td>\n<td>将字符ch输出到ostream os。返回os</td>\n</tr>\n<tr>\n<td>is.get()</td>\n<td>将is的下一个字节作为int返回</td>\n</tr>\n<tr>\n<td>is.putback(ch)</td>\n<td>将字符ch放回is。返回is</td>\n</tr>\n<tr>\n<td>is.unget()</td>\n<td>将is向后移动一个字节。返回is</td>\n</tr>\n<tr>\n<td>is.peek()</td>\n<td>将下一个字节作为int返回，但不从流中删除它</td>\n</tr>\n</tbody></table>\n<p>详细讨论见p673。</p>\n<p><strong>多字节操作</strong></p>\n<p>一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。</p>\n<p>书中未给出代码案例讲解，具体操作见p674。</p>\n<h3 id=\"流随机访问\"><a href=\"#流随机访问\" class=\"headerlink\" title=\"流随机访问\"></a>流随机访问</h3><p>标准库提供了一对函数，来定位（seek）到流中给定的位置，以及告诉（tell）我们当前的位置。</p>\n<p>在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问，因为这种操作对它们没有意义。对这些流调用seek和tell会导致运行时出错，将流置于一个无效状态。</p>\n<p><strong>seek和tell函数</strong></p>\n<p>为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。标准库实际上定义了两对seek和tell函数，差别在于名字的后缀是g还是p，g版本表示我们正在读取数据，而p版本表示我们正在写入数据。</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tellg() tellp()</td>\n<td>返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置</td>\n</tr>\n<tr>\n<td>seekg(pos) seekp(pos)</td>\n<td>在一个输入流或输出流中奖标记重定位到给定的绝对地址。pos通常是前一个tell返回的值</td>\n</tr>\n<tr>\n<td>seekp(off, from) seekg(off, from)</td>\n<td>在一个输入流或输出流中，奖标记定位到from之前或之后off个字符，from可以是：beg（流开始位置）, cur（流当前位置）, end（流结尾位置）</td>\n</tr>\n</tbody></table>\n<p>从逻辑上讲，我们只能对istream使用g版本，对ostream使用p版本。iostream则可以使用g版本又可以使用p版本。</p>\n"}],"PostAsset":[{"_id":"source/_posts/2019-PM-APPSO/yewu2.jpg","slug":"yewu2.jpg","post":"ck1awgxaj00072wvc0v9aouvh","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/yemian1.png","slug":"yemian1.png","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-music163/wangyiyun.png","slug":"wangyiyun.png","post":"ck1awgxb4000v2wvcp82wtyg3","modified":0,"renderable":0},{"_id":"source/_posts/2019-The-Elements-of-user-experience/User.jpg","slug":"User.jpg","post":"ck1awgxb5000x2wvc7szt2ilj","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-fix-connection-rest-by-port/shili.png","slug":"shili.png","post":"ck1awgxbh001k2wvchqbshbd7","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-APPSO/yewu.png","slug":"yewu.png","post":"ck1awgxaj00072wvc0v9aouvh","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-AppSo-origin/yewu1.jpg","slug":"yewu1.jpg","post":"ck1awgxav000g2wvcecp2qoy5","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-AppSo-origin/yewu2.jpg","slug":"yewu2.jpg","post":"ck1awgxav000g2wvcecp2qoy5","modified":0,"renderable":0},{"_id":"source/_posts/2019-NASM/BludgModel.jpg","slug":"BludgModel.jpg","post":"ck1awgxam00092wvclhz7z0t7","modified":0,"renderable":0},{"_id":"source/_posts/2019-NASM/TrilinearModel.jpg","slug":"TrilinearModel.jpg","post":"ck1awgxam00092wvclhz7z0t7","modified":0,"renderable":0},{"_id":"source/_posts/2019-NASM/bilinear.jpg","slug":"bilinear.jpg","post":"ck1awgxam00092wvclhz7z0t7","modified":0,"renderable":0},{"_id":"source/_posts/2019-NASM/linear.jpg","slug":"linear.jpg","post":"ck1awgxam00092wvclhz7z0t7","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-demand-analysis/kaifanandu.png","slug":"kaifanandu.png","post":"ck1awgxb0000n2wvc2vjd5yi5","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-demand-analysis/siweidaotu.png","slug":"siweidaotu.png","post":"ck1awgxb0000n2wvc2vjd5yi5","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-demand-analysis/sixiangxian.png","slug":"sixiangxian.png","post":"ck1awgxb0000n2wvc2vjd5yi5","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-demand-analysis/xuqiu.png","slug":"xuqiu.png","post":"ck1awgxb0000n2wvc2vjd5yi5","modified":0,"renderable":0},{"_id":"source/_posts/2019-Opensees/114b5d55abb9b8a74bb18b1bcb0a2dca.png","slug":"114b5d55abb9b8a74bb18b1bcb0a2dca.png","post":"ck1awgxar000b2wvcvus41ol0","modified":0,"renderable":0},{"_id":"source/_posts/2019-Opensees/3a04b2f3ba77e09e1d4a195a723210b2.png","slug":"3a04b2f3ba77e09e1d4a195a723210b2.png","post":"ck1awgxar000b2wvcvus41ol0","modified":0,"renderable":0},{"_id":"source/_posts/2019-Opensees/3a471a82ccc457c44eba5125317e883a.png","slug":"3a471a82ccc457c44eba5125317e883a.png","post":"ck1awgxar000b2wvcvus41ol0","modified":0,"renderable":0},{"_id":"source/_posts/2019-Opensees/3b1adcfc091178afbb2f106514eed312.png","slug":"3b1adcfc091178afbb2f106514eed312.png","post":"ck1awgxar000b2wvcvus41ol0","modified":0,"renderable":0},{"_id":"source/_posts/2019-Opensees/46afa9afcf5fa20bf42a6c9a6f73d79e.png","slug":"46afa9afcf5fa20bf42a6c9a6f73d79e.png","post":"ck1awgxar000b2wvcvus41ol0","modified":0,"renderable":0},{"_id":"source/_posts/2019-Opensees/df03b2f5e7ca2bcccbbfaa784be671c3.png","slug":"df03b2f5e7ca2bcccbbfaa784be671c3.png","post":"ck1awgxar000b2wvcvus41ol0","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-meiyou/gongnengjiegou.png","slug":"gongnengjiegou.png","post":"ck1awgxb2000q2wvc9jbho8za","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-meiyou/shiyong.png","slug":"shiyong.png","post":"ck1awgxb2000q2wvc9jbho8za","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-meiyou/shiyongliucheng.png","slug":"shiyongliucheng.png","post":"ck1awgxb2000q2wvc9jbho8za","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-meiyou/xingbie.png","slug":"xingbie.png","post":"ck1awgxb2000q2wvc9jbho8za","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-meiyou/xingbie2.png","slug":"xingbie2.png","post":"ck1awgxb2000q2wvc9jbho8za","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-meiyou/xingbie3.jpg","slug":"xingbie3.jpg","post":"ck1awgxb2000q2wvc9jbho8za","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/baokuan.jpg","slug":"baokuan.jpg","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/fenxi.png","slug":"fenxi.png","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/jiazhi.jpg","slug":"jiazhi.jpg","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/kuangjia.png","slug":"kuangjia.png","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/shouru.png","slug":"shouru.png","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/tuijian.png","slug":"tuijian.png","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/yemian2.png","slug":"yemian2.png","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/yemian3.jpg","slug":"yemian3.jpg","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/yemian4.png","slug":"yemian4.png","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-PM-dedao/yemian5.png","slug":"yemian5.png","post":"ck1awgxax000i2wvclz11nepm","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/NewSSH.png","slug":"NewSSH.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/RA.png","slug":"RA.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/SSH.png","slug":"SSH.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/chenggong.png","slug":"chenggong.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/chushihua.png","slug":"chushihua.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/gitxiazai.png","slug":"gitxiazai.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/hexo.png","slug":"hexo.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/newrepository.png","slug":"newrepository.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/npmshili.png","slug":"npmshili.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/setting.png","slug":"setting.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-how-to-build-your-Blog/xiazaishili.png","slug":"xiazaishili.png","post":"ck1awgxba00152wvcgxd5mrcz","modified":0,"renderable":0},{"_id":"source/_posts/2019-CProgramming/二维数组存储.jpg","slug":"二维数组存储.jpg","post":"ck1awgxdb002y2wvcicf1jiyv","modified":0,"renderable":0},{"_id":"source/_posts/2019-CProgramming/共享函数原型.png","slug":"共享函数原型.png","post":"ck1awgxdb002y2wvcicf1jiyv","modified":0,"renderable":0},{"_id":"source/_posts/2019-CProgramming/字符串存储.jpg","slug":"字符串存储.jpg","post":"ck1awgxdb002y2wvcicf1jiyv","modified":0,"renderable":0},{"_id":"source/_posts/2019-CProgramming/宏定义和类型定义.png","slug":"宏定义和类型定义.png","post":"ck1awgxdb002y2wvcicf1jiyv","modified":0,"renderable":0},{"_id":"source/_posts/2019-CProgramming/联合和结构的存储.jpg","slug":"联合和结构的存储.jpg","post":"ck1awgxdb002y2wvcicf1jiyv","modified":0,"renderable":0},{"_id":"source/_posts/2019-cPlusPlusproblemset/readme.jpg","slug":"readme.jpg","post":"ck1awgxek00332wvc0ojfxh0n","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck1awgxa900012wvcz0hrrhm3","category_id":"ck1awgxah00052wvcjzmzvm59","_id":"ck1awgxax000j2wvc2yuzw510"},{"post_id":"ck1awgxar000b2wvcvus41ol0","category_id":"ck1awgxah00052wvcjzmzvm59","_id":"ck1awgxb1000o2wvc92x8huwe"},{"post_id":"ck1awgxae00032wvcg1la6pz7","category_id":"ck1awgxas000c2wvc0fm8mgqs","_id":"ck1awgxb3000r2wvcoc7walfg"},{"post_id":"ck1awgxb0000n2wvc2vjd5yi5","category_id":"ck1awgxay000l2wvc1besn7v7","_id":"ck1awgxb6000y2wvc0j78bhic"},{"post_id":"ck1awgxaj00072wvc0v9aouvh","category_id":"ck1awgxay000l2wvc1besn7v7","_id":"ck1awgxb800132wvcsmptsu44"},{"post_id":"ck1awgxb2000q2wvc9jbho8za","category_id":"ck1awgxay000l2wvc1besn7v7","_id":"ck1awgxbb00162wvcrglwcaz7"},{"post_id":"ck1awgxb4000v2wvcp82wtyg3","category_id":"ck1awgxay000l2wvc1besn7v7","_id":"ck1awgxbd001a2wvcb69rohae"},{"post_id":"ck1awgxam00092wvclhz7z0t7","category_id":"ck1awgxb3000s2wvc98chr42v","_id":"ck1awgxbf001e2wvcfrhrmvru"},{"post_id":"ck1awgxb5000x2wvc7szt2ilj","category_id":"ck1awgxah00052wvcjzmzvm59","_id":"ck1awgxbg001h2wvcr538nogg"},{"post_id":"ck1awgxb700122wvcafu6cmvf","category_id":"ck1awgxah00052wvcjzmzvm59","_id":"ck1awgxbi001l2wvcbkt8hnk3"},{"post_id":"ck1awgxav000g2wvcecp2qoy5","category_id":"ck1awgxay000l2wvc1besn7v7","_id":"ck1awgxbj001n2wvcbvr5e7af"},{"post_id":"ck1awgxax000i2wvclz11nepm","category_id":"ck1awgxay000l2wvc1besn7v7","_id":"ck1awgxbl001r2wvcc07qjp7j"},{"post_id":"ck1awgxbe001d2wvcx8u5c814","category_id":"ck1awgxah00052wvcjzmzvm59","_id":"ck1awgxbm001t2wvc9cczehze"},{"post_id":"ck1awgxbg001g2wvcmstubsg3","category_id":"ck1awgxah00052wvcjzmzvm59","_id":"ck1awgxbo001x2wvcm5xd9ubh"},{"post_id":"ck1awgxbc00192wvcjxpdjbqw","category_id":"ck1awgxbf001f2wvc5bxy7lro","_id":"ck1awgxbp00202wvchb4brzm2"},{"post_id":"ck1awgxbj001m2wvcf5ikrnqt","category_id":"ck1awgxb3000s2wvc98chr42v","_id":"ck1awgxbr00242wvc221o2xvu"},{"post_id":"ck1awgxbl001s2wvcm9chwdhr","category_id":"ck1awgxah00052wvcjzmzvm59","_id":"ck1awgxbt00272wvcei439txy"},{"post_id":"ck1awgxbk001q2wvc7fs4i2nw","category_id":"ck1awgxbn001v2wvczzpjts04","_id":"ck1awgxbt00292wvcsp6ej3mh"},{"post_id":"ck1awgxbs00262wvcp9ufkraf","category_id":"ck1awgxbr00232wvcmeyo6fcu","_id":"ck1awgxbv002d2wvcxz384c0h"},{"post_id":"ck1awgxbn001w2wvco0lrbsb4","category_id":"ck1awgxbr00232wvcmeyo6fcu","_id":"ck1awgxbw002g2wvcpk1lpzfu"},{"post_id":"ck1awgxbp001z2wvca40x2b3k","category_id":"ck1awgxbu002a2wvccdno21u7","_id":"ck1awgxbw002i2wvcorhhxm89"},{"post_id":"ck1awgxbq00222wvc4hf4twat","category_id":"ck1awgxbr00232wvcmeyo6fcu","_id":"ck1awgxbx002l2wvcl4hsc8tz"},{"post_id":"ck1awgxdb002y2wvcicf1jiyv","category_id":"ck1awgxdc002z2wvcgtjtqsyu","_id":"ck1awgxde00322wvc5qsitcz0"},{"post_id":"ck1awgxek00332wvc0ojfxh0n","category_id":"ck1awgxeo00342wvcucdo055t","_id":"ck1awgxes00372wvce5kpj650"}],"PostTag":[{"post_id":"ck1awgxa900012wvcz0hrrhm3","tag_id":"ck1awgxai00062wvcbhkn1h60","_id":"ck1awgxau000f2wvcpkydk6w0"},{"post_id":"ck1awgxae00032wvcg1la6pz7","tag_id":"ck1awgxas000d2wvcferdg7d2","_id":"ck1awgxb1000p2wvcn8840dtq"},{"post_id":"ck1awgxb0000n2wvc2vjd5yi5","tag_id":"ck1awgxay000m2wvcn5uava4z","_id":"ck1awgxb4000u2wvco5a8qe0b"},{"post_id":"ck1awgxaj00072wvc0v9aouvh","tag_id":"ck1awgxay000m2wvcn5uava4z","_id":"ck1awgxb5000w2wvc7dydhacp"},{"post_id":"ck1awgxb2000q2wvc9jbho8za","tag_id":"ck1awgxay000m2wvcn5uava4z","_id":"ck1awgxb7000z2wvcjobstqs9"},{"post_id":"ck1awgxb4000v2wvcp82wtyg3","tag_id":"ck1awgxay000m2wvcn5uava4z","_id":"ck1awgxb900142wvc2bxfzib8"},{"post_id":"ck1awgxam00092wvclhz7z0t7","tag_id":"ck1awgxb4000t2wvckoyzbz5r","_id":"ck1awgxbb00172wvclg0neq9y"},{"post_id":"ck1awgxar000b2wvcvus41ol0","tag_id":"ck1awgxb700112wvc2fnbz6k7","_id":"ck1awgxbe001c2wvc1o6p4qsz"},{"post_id":"ck1awgxav000g2wvcecp2qoy5","tag_id":"ck1awgxay000m2wvcn5uava4z","_id":"ck1awgxbh001j2wvcxyr51bpv"},{"post_id":"ck1awgxax000i2wvclz11nepm","tag_id":"ck1awgxay000m2wvcn5uava4z","_id":"ck1awgxbk001p2wvcz7vtma7b"},{"post_id":"ck1awgxb5000x2wvc7szt2ilj","tag_id":"ck1awgxbk001o2wvcdwwuklwb","_id":"ck1awgxbo001y2wvcq42hfv2l"},{"post_id":"ck1awgxb700122wvcafu6cmvf","tag_id":"ck1awgxbn001u2wvcerfyliyw","_id":"ck1awgxbr00252wvc34e1g17f"},{"post_id":"ck1awgxbc00192wvcjxpdjbqw","tag_id":"ck1awgxbq00212wvc2bgyqeok","_id":"ck1awgxbu002b2wvci3su5nsw"},{"post_id":"ck1awgxbe001d2wvcx8u5c814","tag_id":"ck1awgxbn001u2wvcerfyliyw","_id":"ck1awgxbv002f2wvcc1qgabmh"},{"post_id":"ck1awgxbg001g2wvcmstubsg3","tag_id":"ck1awgxbn001u2wvcerfyliyw","_id":"ck1awgxbw002j2wvccqt4rlne"},{"post_id":"ck1awgxbj001m2wvcf5ikrnqt","tag_id":"ck1awgxbw002h2wvcdorlfyet","_id":"ck1awgxbx002m2wvc7mstf29i"},{"post_id":"ck1awgxbk001q2wvc7fs4i2nw","tag_id":"ck1awgxbx002k2wvczzc2nq9z","_id":"ck1awgxc0002o2wvcxam2jtb2"},{"post_id":"ck1awgxbl001s2wvcm9chwdhr","tag_id":"ck1awgxc0002n2wvcrbzmf1y7","_id":"ck1awgxc1002q2wvcvfvq8cm4"},{"post_id":"ck1awgxbn001w2wvco0lrbsb4","tag_id":"ck1awgxc1002p2wvcobedq59l","_id":"ck1awgxc2002s2wvc42mpx2rm"},{"post_id":"ck1awgxbp001z2wvca40x2b3k","tag_id":"ck1awgxc2002r2wvc54di7xfp","_id":"ck1awgxc2002u2wvcz36iifnf"},{"post_id":"ck1awgxbq00222wvc4hf4twat","tag_id":"ck1awgxc2002t2wvcsuox10nt","_id":"ck1awgxc3002w2wvct576q4zh"},{"post_id":"ck1awgxbs00262wvcp9ufkraf","tag_id":"ck1awgxc2002t2wvcsuox10nt","_id":"ck1awgxc3002x2wvciqc1h5ju"},{"post_id":"ck1awgxdb002y2wvcicf1jiyv","tag_id":"ck1awgxdd00302wvcjfvg9ez8","_id":"ck1awgxde00312wvc90czvyud"},{"post_id":"ck1awgxek00332wvc0ojfxh0n","tag_id":"ck1awgxeo00352wvchi4ag89m","_id":"ck1awgxer00362wvcfg27ummu"}],"Tag":[{"name":"PM 读书笔记","_id":"ck1awgxai00062wvcbhkn1h60"},{"name":"Glodon BIM","_id":"ck1awgxas000d2wvcferdg7d2"},{"name":"PM","_id":"ck1awgxay000m2wvcn5uava4z"},{"name":"软件 Matlab","_id":"ck1awgxb4000t2wvckoyzbz5r"},{"name":"读书笔记 Opensees","_id":"ck1awgxb700112wvc2fnbz6k7"},{"name":"读书笔记 PM","_id":"ck1awgxbk001o2wvcdwwuklwb"},{"name":"读书笔记","_id":"ck1awgxbn001u2wvcerfyliyw"},{"name":"Linux 批处理","_id":"ck1awgxbq00212wvc2bgyqeok"},{"name":"软件 技巧 Markdown Word","_id":"ck1awgxbw002h2wvcdorlfyet"},{"name":"自动检测图像 Matlab","_id":"ck1awgxbx002k2wvczzc2nq9z"},{"name":"读书笔记 运营","_id":"ck1awgxc0002n2wvcrbzmf1y7"},{"name":"面试 PM","_id":"ck1awgxc1002p2wvcobedq59l"},{"name":"python","_id":"ck1awgxc2002r2wvc54di7xfp"},{"name":"面试","_id":"ck1awgxc2002t2wvcsuox10nt"},{"name":"C语言","_id":"ck1awgxdd00302wvcjfvg9ez8"},{"name":"C++ 读书笔记","_id":"ck1awgxeo00352wvchi4ag89m"}]}}